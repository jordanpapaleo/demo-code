(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * @class Align
 * @constructor
 * @component
 * @param {LocalDispatch} node LocalDispatch to be retrieved from corresponding Render Node of the Align component
 */

function Align(node) {
    Position.call(this, node);

    var initial = node.getAlign();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

Align.prototype.toString = function toString() {
    return 'Align';
};

Align.prototype = Object.create(Position.prototype);
Align.prototype.constructor = Align;

Align.prototype.update = function update() {
    this._node.setAlign(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Align.prototype.onUpdate = Align.prototype.update;

module.exports = Align;

},{"./Position":7}],2:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * @class Camera
 * @constructor
 * @component
 * @param {RenderNode} RenderNode to which the instance of Camera will be a component of
 */
function Camera(node) {
    this._node = node;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;
    this._requestingUpdate = false;
    this._id = node.addComponent(this);
    this._viewTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._viewDirty = false;
    this._perspectiveDirty = false;
    this.setFlat();
}

Camera.FRUSTUM_PROJECTION = 0;
Camera.PINHOLE_PROJECTION = 1;
Camera.ORTHOGRAPHIC_PROJECTION = 2;

Camera.prototype.toString = function toString() {
    return 'Camera';
};

Camera.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        projectionType: this._projectionType,
        focalDepth: this._focalDepth,
        near: this._near,
        far: this._far
    };
};

Camera.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.set(state.projectionType, state.focalDepth, state.near, state.far);
        return true;
    }
    return false;
};

Camera.prototype.set = function set(type, depth, near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._projectionType = type;
    this._focalDepth = depth;
    this._near = near;
    this._far = far;
};

Camera.prototype.setDepth = function setDepth(depth) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.PINHOLE_PROJECTION;
    this._focalDepth = depth;
    this._near = 0;
    this._far = 0;

    return this;
};

Camera.prototype.setFrustum = function setFrustum(near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.FRUSTUM_PROJECTION;
    this._focalDepth = 0;
    this._near = near;
    this._far = far;

    return this;
};

Camera.prototype.setFlat = function setFlat() {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;

    return this;
};

Camera.prototype.onUpdate = function onUpdate() {
    this._requestingUpdate = false;

    var path = this._node.getLocation();

    this._node
        .sendDrawCommand('WITH')
        .sendDrawCommand(path);

    if (this._perspectiveDirty) {
        this._perspectiveDirty = false;

        switch (this._projectionType) {
            case Camera.FRUSTUM_PROJECTION:
                this._node.sendDrawCommand('FRUSTUM_PROJECTION');
                this._node.sendDrawCommand(this._near);
                this._node.sendDrawCommand(this._far);
                break;
            case Camera.PINHOLE_PROJECTION:
                this._node.sendDrawCommand('PINHOLE_PROJECTION');
                this._node.sendDrawCommand(this._focalDepth);
                break;
            case Camera.ORTHOGRAPHIC_PROJECTION:
                this._node.sendDrawCommand('ORTHOGRAPHIC_PROJECTION');
                break;
        }
    }

    if (this._viewDirty) {
        this._viewDirty = false;

        this._node.sendDrawCommand('CHANGE_VIEW_TRANSFORM');
        this._node.sendDrawCommand(this._viewTransform[0]);
        this._node.sendDrawCommand(this._viewTransform[1]);
        this._node.sendDrawCommand(this._viewTransform[2]);
        this._node.sendDrawCommand(this._viewTransform[3]);

        this._node.sendDrawCommand(this._viewTransform[4]);
        this._node.sendDrawCommand(this._viewTransform[5]);
        this._node.sendDrawCommand(this._viewTransform[6]);
        this._node.sendDrawCommand(this._viewTransform[7]);

        this._node.sendDrawCommand(this._viewTransform[8]);
        this._node.sendDrawCommand(this._viewTransform[9]);
        this._node.sendDrawCommand(this._viewTransform[10]);
        this._node.sendDrawCommand(this._viewTransform[11]);

        this._node.sendDrawCommand(this._viewTransform[12]);
        this._node.sendDrawCommand(this._viewTransform[13]);
        this._node.sendDrawCommand(this._viewTransform[14]);
        this._node.sendDrawCommand(this._viewTransform[15]);
    }
};


Camera.prototype.onTransformChange = function onTransformChange(transform) {
    var a = transform;
    this._viewDirty = true;

    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,

    det = 1/(b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

    this._viewTransform[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this._viewTransform[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this._viewTransform[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this._viewTransform[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this._viewTransform[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this._viewTransform[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this._viewTransform[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this._viewTransform[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this._viewTransform[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this._viewTransform[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this._viewTransform[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this._viewTransform[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this._viewTransform[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this._viewTransform[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this._viewTransform[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this._viewTransform[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
};

module.exports = Camera;

},{}],3:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var CallbackStore = require('../utilities/CallbackStore');
var Vec2 = require('../math/Vec2');

var VEC_REGISTER = new Vec2();

var gestures = {drag: true, tap: true, rotate: true, pinch: true};

/**
 * Component to manage gesture events. Will track 'pinch', 'rotate', 'tap', and 'drag' events, on an
 * as-requested basis.
 *
 * @class GestureHandler
 * @param {LocalDispatch} node The node with which to register the handler.
 * @param {Object[]} events An array of event objects specifying .event and .callback properties.
 */

function GestureHandler (node, events) {
    this.node = node;
    this.id = node.addComponent(this);

    this._events = new CallbackStore();

    this.last1 = new Vec2();
    this.last2 = new Vec2();

    this.delta1 = new Vec2();
    this.delta2 = new Vec2();

    this.velocity1 = new Vec2();
    this.velocity2 = new Vec2();

    this.dist = 0;
    this.diff12 = new Vec2();

    this.center = new Vec2();
    this.centerDelta = new Vec2();
    this.centerVelocity = new Vec2();

    this.pointer1 = {
        position: this.last1,
        delta: this.delta1,
        velocity: this.velocity1,
    };

    this.pointer2 = {
        position: this.last2,
        delta: this.delta2,
        velocity: this.velocity2,
    };

    this.event = {
        status: null,
        time: 0,
        pointers: [],
        center: this.center,
        centerDelta: this.centerDelta,
        centerVelocity: this.centerVelocity,
        points: 0,
        current: 0
    };

    this.trackedPointerIDs = [-1, -1];
    this.timeOfPointer = 0;
    this.multiTap = 0;

    this.mice = [];

    this.gestures = [];
    this.options = {};
    this.trackedGestures = {};

    var i;
    var len;

    if (events) {
        for (i = 0, len = events.length; i < len; i++) {
            this.on(events[i], events[i].callback);
        }
    }

    node.addUIEvent('touchstart');
    node.addUIEvent('mousedown');
    node.addUIEvent('touchmove');
    node.addUIEvent('mousemove');
    node.addUIEvent('touchend');
    node.addUIEvent('mouseup');
    node.addUIEvent('mouseleave');
}

GestureHandler.prototype.onReceive = function onReceive (ev, payload) {
    switch(ev) {
        case 'touchstart':
        case 'mousedown':
            _processPointerStart.call(this, payload);
            break;
        case 'touchmove':
        case 'mousemove':
            _processPointerMove.call(this, payload);
            break;
        case 'touchend':
        case 'mouseup':
            _processPointerEnd.call(this, payload);
            break;
        case 'mouseleave':
            _processMouseLeave.call(this, payload);
            break;
        default:
            break;
    }
};

GestureHandler.prototype.toString = function toString() {
    return 'GestureHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {Object|String} ev The event object or event name.
 * @param {Function} cb The callback.
 */
GestureHandler.prototype.on = function on(ev, cb) {
    var gesture = ev.event || ev;
    if (gestures[gesture]) {
        this.trackedGestures[gesture] = true;
        this.gestures.push(gesture);
        if (ev.event) this.options[gesture] = ev;
        this._events.on(gesture, cb);
    }
};

/**
 * Trigger gestures in the order they were requested, if they occured.
 *
 * @method triggerGestures
 */
GestureHandler.prototype.triggerGestures = function() {
    var payload = this.event;
    for (var i = 0, len = this.gestures.length; i < len; i++) {
        var gesture = this.gestures[i];
        switch (gesture) {
            case 'rotate':
            case 'pinch':
                if (payload.points === 2) this.trigger(gesture, payload);
                break;
            case 'tap':
                if (payload.status === 'start') {
                    if (this.options.tap) {
                        var pts = this.options.tap.points || 1;
                        if(this.multiTap >= pts && payload.points >= pts) this.trigger(gesture, payload);
                    }
                    else this.trigger(gesture, payload);
                }
                break;
            default:
                this.trigger(gesture, payload);
                break;
        }
    }
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
GestureHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

/**
 * Process up to the first two touch/mouse move events. Exit out if the first two points are already being tracked.
 *
 * @method _processPointerStart
 * @private
 * @param {Object} e The event object.
 */
function _processPointerStart(e) {
    var t;
    if (!e.targetTouches) {
        this.mice[0] = e;
        t = this.mice;
        e.identifier = 1;
    }
    else t = e.targetTouches;

    if (t[0] && t[1] && this.trackedPointerIDs[0] === t[0].identifier && this.trackedPointerIDs[1] === t[1].identifier) {
        return;
    }

    this.event.time = Date.now();

    var threshold;
    var id;

    if (this.trackedPointerIDs[0] !== t[0].identifier) {
        if (this.trackedGestures.tap) {
            threshold = (this.options.tap && this.options.tap.threshold) || 250;
            if (this.event.time - this.timeOfPointer < threshold) this.event.taps++;
            else this.event.taps = 1;
            this.timeOfPointer = this.event.time;
            this.multiTap = 1;
        }
        this.event.current = 1;
        this.event.points = 1;
        id = t[0].identifier;
        this.trackedPointerIDs[0] = id;

        this.last1.set(t[0].pageX, t[0].pageY);
        this.velocity1.clear();
        this.delta1.clear();
        this.event.pointers.push(this.pointer1);
    }
    if (t[1] && this.trackedPointerIDs[1] !== t[1].identifier) {
        if (this.trackedGestures.tap) {
            threshold = (this.options.tap && this.options.tap.threshold) || 250;
            if (this.event.time - this.timeOfPointer < threshold) this.multiTap = 2;
        }
        this.event.current = 2;
        this.event.points = 2;
        id = t[1].identifier;
        this.trackedPointerIDs[1] = id;

        this.last2.set(t[1].pageX, t[1].pageY);
        this.velocity2.clear();
        this.delta2.clear();

        Vec2.add(this.last1, this.last2, this.center).scale(0.5);
        this.centerDelta.clear();
        this.centerVelocity.clear();

        Vec2.subtract(this.last2, this.last1, this.diff12);
        this.dist = this.diff12.length();

        if (this.trackedGestures.pinch) {
            this.event.scale = this.event.scale || 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures.rotate) {
            this.event.rotation = this.event.rotation || 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
        this.event.pointers.push(this.pointer2);
    }

    this.event.status = 'start';
    if (this.event.points === 1) {
        this.center.copy(this.last1);
        this.centerDelta.clear();
        this.centerVelocity.clear();
        if (this.trackedGestures.pinch) {
            this.event.scale = 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures.rotate) {
            this.event.rotation = 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
    }
    this.triggerGestures();
}

/**
 * Process up to the first two touch/mouse move events.
 *
 * @method _processPointerMove
 * @private
 * @param {Object} e The event object.
 */
function _processPointerMove(e) {
    var t;
    if (!e.targetTouches) {
        if (!this.event.current) return;
        this.mice[0] = e;
        t = this.mice;
        e.identifier = 1;
    }
    else t = e.targetTouches;

    var time = Date.now();
    var dt = time - this.event.time;
    if (dt === 0) return;
    var invDt = 1000 / dt;
    this.event.time = time;

    this.event.current = 1;
    this.event.points = 1;
    if (this.trackedPointerIDs[0] === t[0].identifier) {
        VEC_REGISTER.set(t[0].pageX, t[0].pageY);
        Vec2.subtract(VEC_REGISTER, this.last1, this.delta1);
        Vec2.scale(this.delta1, invDt, this.velocity1);
        this.last1.copy(VEC_REGISTER);

    }
    if (t[1]) {
        this.event.current = 2;
        this.event.points = 2;
        VEC_REGISTER.set(t[1].pageX, t[1].pageY);
        Vec2.subtract(VEC_REGISTER, this.last2, this.delta2);
        Vec2.scale(this.delta2, invDt, this.velocity2);
        this.last2.copy(VEC_REGISTER);

        Vec2.add(this.last1, this.last2, VEC_REGISTER).scale(0.5);
        Vec2.subtract(VEC_REGISTER, this.center, this.centerDelta);
        Vec2.add(this.velocity1, this.velocity2, this.centerVelocity).scale(0.5);
        this.center.copy(VEC_REGISTER);

        Vec2.subtract(this.last2, this.last1, VEC_REGISTER);

        if (this.trackedGestures.rotate) {
            var dot = VEC_REGISTER.dot(this.diff12);
            var cross = VEC_REGISTER.cross(this.diff12);
            var theta = -Math.atan2(cross, dot);
            this.event.rotation += theta;
            this.event.rotationDelta = theta;
            this.event.rotationVelocity = theta * invDt;
        }

        var dist = VEC_REGISTER.length();
        var scale = dist / this.dist;
        this.diff12.copy(VEC_REGISTER);
        this.dist = dist;

        if (this.trackedGestures.pinch) {
            this.event.scale *= scale;
            scale -= 1.0;
            this.event.scaleDelta = scale;
            this.event.scaleVelocity = scale * invDt;
        }
    }

    this.event.status = 'move';
    if (this.event.points === 1) {
        this.center.copy(this.last1);
        this.centerDelta.copy(this.delta1);
        this.centerVelocity.copy(this.velocity1);
        if (this.trackedGestures.pinch) {
            this.event.scale = 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures.rotate) {
            this.event.rotation = 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
    }
    this.triggerGestures();
}

/**
 * Process up to the first two touch/mouse end events. Exit out if the two points being tracked are still active.
 *
 * @method _processPointerEnd
 * @private
 * @param {Object} e The event object.
 */
function _processPointerEnd(e) {
    var t;
    if (!e.targetTouches) {
        if (!this.event.current) return;
        this.mice.pop();
        t = this.mice;
    }
    else t = e.targetTouches;

    if (t[0] && t[1] && this.trackedPointerIDs[0] === t[0].identifier && this.trackedPointerIDs[1] === t[1].identifier) {
            return;
    }

    var id;

    this.event.status = 'end';
    if (!t[0]) {
        this.event.current = 0;
        this.trackedPointerIDs[0] = -1;
        this.trackedPointerIDs[1] = -1;
        this.triggerGestures();
        this.event.pointers.pop();
        this.event.pointers.pop();
        return;
    }
    else if(this.trackedPointerIDs[0] !== t[0].identifier) {
        this.trackedPointerIDs[0] = -1;
        id = t[0].identifier;
        this.trackedPointerIDs[0] = id;

        this.last1.set(t[0].pageX, t[0].pageY);
        this.velocity1.clear();
        this.delta1.clear();
    }
    if (!t[1]) {
        this.event.current = 1;
        this.trackedPointerIDs[1] = -1;
        this.triggerGestures();
        this.event.points = 1;
        this.event.pointers.pop();
    }
    else if (this.trackedPointerIDs[1] !== t[1].identifier) {
        this.trackedPointerIDs[1] = -1;
        this.event.points = 2;
        id = t[1].identifier;
        this.trackedPointerIDs[1] = id;

        this.last2.set(t[1].pageX, t[1].pageY);
        this.velocity2.clear();
        this.delta2.clear();

        Vec2.add(this.last1, this.last2, this.center).scale(0.5);
        this.centerDelta.clear();
        this.centerVelocity.clear();

        Vec2.subtract(this.last2, this.last1, this.diff12);
        this.dist = this.diff12.length();
    }
}

/**
 * Treats a mouseleave event as a gesture end.
 *
 * @method _processMouseLeave
 * @private
 */
function _processMouseLeave() {
    if (this.event.current) {
        this.event.status = 'end';
        this.event.current = 0;
        this.trackedPointerIDs[0] = -1;
        this.triggerGestures();
        this.event.pointers.pop();
    }
}

module.exports = GestureHandler;

},{"../math/Vec2":48,"../utilities/CallbackStore":90}],4:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * @class MountPoint
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the MountPoint component
 */
function MountPoint(node) {
    Position.call(this, node);

    var initial = node.getMountPoint();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

MountPoint.prototype.toString = function toString() {
    return 'MountPoint';
};

MountPoint.prototype = Object.create(Position.prototype);
MountPoint.prototype.constructor = MountPoint;

MountPoint.prototype.update = function update() {
    this._node.setMountPoint(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

MountPoint.prototype.onUpdate = MountPoint.prototype.update;

module.exports = MountPoint;

},{"./Position":7}],5:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');


/**
 * @class Opacity
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Opacity component
 */
function Opacity(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._value = new Transitionable(1);

    this._requestingUpdate = false;
}

Opacity.prototype.toString = function toString() {
    return 'Opacity';
};

/**
*
* Retrieves state of Opacity
*
* @method
* @return {Object} contains component key which holds the stringified constructor 
* and value key which contains the numeric value
*/
Opacity.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        value: this._value.get()
    };
};

/**
*
* Setter for Opacity state
*
* @method
* @param {Object} state contains component key, which holds stringified constructor, and a value key, which contains a numeric value used to set opacity if the constructor value matches
* @return {Boolean} true if set is successful, false otherwise
*/
Opacity.prototype.setValue = function setValue(value) {
    if (this.toString() === value.component) {
        this.set(value.value);
        return true;
    }
    return false;
};

/**
*
* Setter for Opacity with callback
*
* @method
* @param {Number} value value used to set Opacity
* @param {Object} options options hash
* @param {Function} callback to be called following Opacity set
* @chainable
*/
Opacity.prototype.set = function set(value, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._value.set(value, options, callback);
    return this;
};

/**
*
* Getter for Opacity
*
* @method
* @return {Number}
*/
Opacity.prototype.get = function get() {
    return this._value.get();
};

/**
*
* Stops Opacity transition
*
* @method
* @chainable
*/
Opacity.prototype.halt = function halt() {
    this._value.halt();
    return this;
};

Opacity.prototype.isActive = function isActive(){
    return this._value.isActive();
};

Opacity.prototype.update = function update () {
    this._node.setOpacity(this._value.get());
    if (this._value.isActive()) {
      this._node.requestUpdateOnNextTick(this._id);
    } else {
      this._requestingUpdate = false;
    }
};

Opacity.prototype.onUpdate = Opacity.prototype.update;

module.exports = Opacity;

},{"../transitions/Transitionable":88}],6:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * @class Origin
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Origin component
 */
function Origin(node) {
    Position.call(this, node);

    var initial = node.getOrigin();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

Origin.prototype.toString = function toString() {
    return 'Origin';
};

Origin.prototype = Object.create(Position.prototype);
Origin.prototype.constructor = Origin;

Origin.prototype.update = function update() {
    this._node.setOrigin(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Origin.prototype.onUpdate = Origin.prototype.update;

module.exports = Origin;

},{"./Position":7}],7:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');

/**
 * @class Position
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Position component
 */
function Position(node) {
    this._node = node;
    this._id = node.addComponent(this);
  
    this._requestingUpdate = false;
    
    var initialPosition = node.getPosition();

    this._x = new Transitionable(initialPosition[0]);
    this._y = new Transitionable(initialPosition[1]);
    this._z = new Transitionable(initialPosition[2]);
}

Position.prototype.toString = function toString() {
    return 'Position';
};

/**
*
* Gets object containing stringified constructor, x, y, z coordinates
*
* @method
* @return {Object}
*/
Position.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        x: this._x.get(),
        y: this._y.get(),
        z: this._z.get()
    };
};

/**
*
* Setter for position coordinates
*
* @method
* @param {Object} state Object -- component: stringified constructor, x: number, y: number, z: number
* @return {Boolean} true on success
*/
Position.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.set(state.x, state.y, state.z);
        return true;
    }
    return false;
};

/**
*
* Getter for X position
*
* @method
* @return {Number}
*/
Position.prototype.getX = function getX() {
    return this._x.get();
};

/**
*
* Getter for Y position
*
* @method
* @return {Number}
*/
Position.prototype.getY = function getY() {
    return this._y.get();
};

/**
*
* Getter for Z position
*
* @method
* @return {Number}
*/
Position.prototype.getZ = function getZ() {
    return this._z.get();
};

/**
*
* Getter for any active coordinates
*
* @method
* @return {Boolean}
*/
Position.prototype.isActive = function isActive() {
    return this._x.isActive() || this._y.isActive() || this._z.isActive();
};

Position.prototype._checkUpdate = function _checkUpdate() {
    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};


Position.prototype.update = function update () {
    this._node.setPosition(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

/** 
*
* If true, component is to be updated on next engine tick
*
* @method
*/
Position.prototype.onUpdate = Position.prototype.update;

/** 
*
* Setter for X position
*
* @method
* @param {Number} val used to set x coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting X
* @chainable
*/
Position.prototype.setX = function setX(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._x.set(val, options, callback);
    return this;
};

/** 
*
* Setter for Y position
*
* @method
* @param {Number} val used to set y coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting Y
* @chainable
*/
Position.prototype.setY = function setY(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._y.set(val, options, callback);
    return this;
};

/** 
*
* Setter for Z position
*
* @method
* @param {Number} val used to set z coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting Z
* @chainable
*/
Position.prototype.setZ = function setZ(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._z.set(val, options, callback);
    return this;
};


/**
*
* Setter for XYZ position with callback
*
* @method
* @param {Number} x used to set x coordinate
* @param {Number} y used to set y coordinate
* @param {Number} z used to set z coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting each coordinate
* @chainable
*/
Position.prototype.set = function set(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    if (x != null) this._x.set(x, options, xCallback);
    if (y != null) this._y.set(y, options, yCallback);
    if (z != null) this._z.set(z, options, zCallback);

    return this;
};

/**
*
* Stops transition of Position component
*
* @method
* @chainable
*/
Position.prototype.halt = function halt() {
    this._x.halt();
    this._y.halt();
    this._z.halt();
    return this;
};

module.exports = Position;

},{"../transitions/Transitionable":88}],8:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * @class Rotation
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Rotation component
 */
function Rotation(node) {
    Position.call(this, node);

    var initial = node.getRotation();

    var x = initial[0];
    var y = initial[1];
    var z = initial[2];
    var w = initial[3];

    var xx = x * x;
    var yy = y * y;
    var zz = z * z;

    var ty = 2 * (x * z + y * w);
    ty = ty < -1 ? -1 : ty > 1 ? 1 : ty;

    var rx = Math.atan2(2 * (x * w - y * z), 1 - 2 * (xx + yy));
    var ry = Math.asin(ty);
    var rz = Math.atan2(2 * (z * w - x * y), 1 - 2 * (yy + zz));

    this._x.set(rx);
    this._y.set(ry);
    this._z.set(rz);
}

Rotation.prototype.toString = function toString() {
    return 'Rotation';
};

Rotation.prototype = Object.create(Position.prototype);
Rotation.prototype.constructor = Rotation;

Rotation.prototype.update = function update() {
    this._node.setRotation(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Rotation.prototype.onUpdate = Rotation.prototype.update;

module.exports = Rotation;

},{"./Position":7}],9:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * @class Scale
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Scale component
 */
function Scale(node) {
    Position.call(this, node);
    this._x.set(1);
    this._y.set(1);
    this._z.set(1);
}

Scale.prototype.toString = function toString() {
    return 'Scale';
};

Scale.prototype = Object.create(Position.prototype);
Scale.prototype.constructor = Scale;

Scale.prototype.update = function update() {
    this._node.setScale(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Scale.prototype.onUpdate = Scale.prototype.update;

module.exports = Scale;

},{"./Position":7}],10:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');

/**
 * Size component used for managing the size of the underlying RenderContext.
 * Supports absolute and relative (proportional and differential) sizing.
 *
 * @class Size
 * @constructor
 * @component
 *
 * @param {LocalDispatch} node LocalDispatch to be retrieved from
 *                                 corresponding RenderNode of the Size
 *                                 component
 */
function Size(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._requestingUpdate = false;

    var initialProportionalSize = node.getProportionalSize();
    var initialDifferentialSize = node.getDifferentialSize();
    var initialAbsoluteSize = node.getAbsoluteSize();

    this._proportional = {
        x: new Transitionable(initialProportionalSize[0]),
        y: new Transitionable(initialProportionalSize[1]),
        z: new Transitionable(initialProportionalSize[2])
    };
    this._differential = {
        x: new Transitionable(initialDifferentialSize[0]),
        y: new Transitionable(initialDifferentialSize[1]),
        z: new Transitionable(initialDifferentialSize[2])
    };
    this._absolute = {
        x: new Transitionable(initialAbsoluteSize[0]),
        y: new Transitionable(initialAbsoluteSize[1]),
        z: new Transitionable(initialAbsoluteSize[2])
    };
}

Size.RELATIVE = 0;
Size.ABSOLUTE = 1;
Size.RENDER = 2;
Size.DEFAULT = Size.RELATIVE;

Size.prototype.setMode = function setMode(x, y, z) {
    this._node.setSizeMode(x, y, z);
    return this;
};

Size.prototype.toString = function toString() {
    return 'Size';
};

/**
 * @typedef absoluteSizeValue
 * @type {Object}
 * @property {String} type current type of sizing being applied ('absolute')
 * @property {String} component component name ('Size')
 * @property {number} x
 * @property {number} y
 * @property {number} z
 */

/**
 * @typedef relativeSizeValue
 * @type {Object}
 * @property {String} type current type of sizing being applied ('relative')
 * @property {String} component component name ('Size')
 * @property {Object} differential
 * @property {number} differential.x
 * @property {number} differential.y
 * @property {number} differential.z
 * @property {Object} proportional
 * @property {number} proportional.x
 * @property {number} proportional.y
 * @property {number} proportional.z
 */

/**
* Returns serialized state of the component.
*
* @method getValue
*
* @return {absoluteSizeValue|relativeSizeValue}
*/
Size.prototype.getValue = function getValue() {
    return {
        sizeMode: this._node.value.sizeMode,
        absolute: {
            x: this._absolute.x.get(),
            y: this._absolute.y.get(),
            z: this._absolute.z.get()
        },
        differential: {
            x: this._differential.x.get(),
            y: this._differential.y.get(),
            z: this._differential.z.get()
        },
        proportional: {
            x: this._proportional.x.get(),
            y: this._proportional.y.get(),
            z: this._proportional.z.get()
        }
    };
};

/**
* Updates state of component.
*
* @method setValue
*
* @param {absoluteSizeValue|relativeSizeValue} state state encoded in same
*                                                    format as state retrieved
*                                                    through `getValue`
* @return {Boolean}                                  boolean indicating
*                                                    whether the new state has
*                                                    been applied
*/
Size.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.setMode.apply(this, state.sizeMode);
        if (state.absolute) {
            this.setAbsolute(state.absolute.x, state.absolute.y, state.absolute.z);
        }
        if (state.differential) {
            this.setAbsolute(state.differential.x, state.differential.y, state.differential.z);
        }
        if (state.proportional) {
            this.setAbsolute(state.proportional.x, state.proportional.y, state.proportional.z);
        }
    }
    return false;
};

Size.prototype._isActive = function _isActive(type) {
    return type.x.isActive() || type.y.isActive() || type.z.isActive();
};

Size.prototype.isActive = function isActive(){
    return (
        this._isActive(this._absolute) ||
        this._isActive(this._proportional) ||
        this._isActive(this._differential)
    );
};

Size.prototype.onUpdate = function onUpdate() {
    var abs = this._absolute;
    this._node.setAbsoluteSize(
        abs.x.get(),
        abs.y.get(),
        abs.z.get()
    );
    var prop = this._proportional;
    var diff = this._differential;
    this._node.setProportionalSize(
        prop.x.get(),
        prop.y.get(),
        prop.z.get()
    );
    this._node.setDifferentialSize(
        diff.x.get(),
        diff.y.get(),
        diff.z.get()
    );

    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};


/**
* Applies absolute size.
*
* @method setAbsolute
* @chainable
*
* @param {Number} x used to set absolute size in x-direction (width)
* @param {Number} y used to set absolute size in y-direction (height)
* @param {Number} z used to set absolute size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setAbsolute = function setAbsolute(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var abs = this._absolute;
    if (x != null) {
        abs.x.set(x, options, xCallback);
    }
    if (y != null) {
        abs.y.set(y, options, yCallback);
    }
    if (z != null) {
        abs.z.set(z, options, zCallback);
    }
};

/**
* Applies proportional size.
*
* @method setProportional
* @chainable
*
* @param {Number} x used to set proportional size in x-direction (width)
* @param {Number} y used to set proportional size in y-direction (height)
* @param {Number} z used to set proportional size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setProportional = function setProportional(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var prop = this._proportional;
    if (x != null) {
        prop.x.set(x, options, xCallback);
    }
    if (y != null) {
        prop.y.set(y, options, yCallback);
    }
    if (z != null) {
        prop.z.set(z, options, zCallback);
    }
    return this;
};

/**
* Applies differential size to Size component.
*
* @method setDifferential
* @chainable
*
* @param {Number} x used to set differential size in x-direction (width)
* @param {Number} y used to set differential size in y-direction (height)
* @param {Number} z used to set differential size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
*/
Size.prototype.setDifferential = function setDifferential(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var diff = this._differential;
    if (x != null) {
        diff.x.set(x, options, xCallback);
    }
    if (y != null) {
        diff.y.set(y, options, yCallback);
    }
    if (z != null) {
        diff.z.set(z, options, zCallback);
    }
    return this;
};

/**
* Retrieves the computed size applied to the underlying RenderContext.
*
* @method get
*
* @return {Number[]} size three dimensional computed size
*/
Size.prototype.get = function get () {
    return this._node.getSize();
};

/**
 * Halts all currently active size transitions.
 *
 * @method halt
 * @chainable
 *
 * @return {Size} this
 */
Size.prototype.halt = function halt () {
    this._proportional.x.halt();
    this._proportional.y.halt();
    this._proportional.z.halt();
    this._differential.x.halt();
    this._differential.y.halt();
    this._differential.z.halt();
    this._absolute.x.halt();
    this._absolute.y.halt();
    this._absolute.z.halt();
    return this;
};

module.exports = Size;

},{"../transitions/Transitionable":88}],11:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');
var Quaternion = require('../math/Quaternion');

var Q_REGISTER = new Quaternion();
var Q2_REGISTER = new Quaternion();

function Vec3Transitionable(x, y, z, transform) {
    this._transform = transform;
    this._dirty = false;
    this.x = new Transitionable(x);
    this.y = new Transitionable(y);
    this.z = new Transitionable(z);
    this._values = {x: x, y: y, z: z};
}

Vec3Transitionable.prototype.get = function get() {
    this._values.x = this.x.get();
    this._values.y = this.y.get();
    this._values.z = this.z.get();
    return this._values;
};

Vec3Transitionable.prototype.set = function set(x, y, z, options, callback) {
    this.dirty();

    var cbX = null;
    var cbY = null;
    var cbZ = null;

    if (z != null) cbZ = callback;
    else if (y != null) cbY = callback;
    else if (x != null) cbX = callback;

    if (x != null) this.x.set(x, options, cbX);
    if (y != null) this.y.set(y, options, cbY);
    if (z != null) this.z.set(z, options, cbZ);

    return this;
};

Vec3Transitionable.prototype.isActive = function isActive() {
    return this.x.isActive() || this.y.isActive() || this.z.isActive();
};

Vec3Transitionable.prototype.pause = function pause() {
    this.x.pause();
    this.y.pause();
    this.z.pause();
    return this;
};

Vec3Transitionable.prototype.resume = function resume() {
    this.x.resume();
    this.y.resume();
    this.z.resume();
    return this;
};

Vec3Transitionable.prototype.halt = function halt() {
    this.x.halt();
    this.y.halt();
    this.z.halt();
    return this;
};

Vec3Transitionable.prototype.dirty = function dirty() {
    if (!this._transform._dirty) {
        this._transform._node.requestUpdate(this._transform._id);
        this._transform._dirty = true;
    }
    this._dirty = true;
    return this;
};

function QuatTransitionable(x, y, z, w, transform) {
    this._transform = transform;
    this._queue = [];
    this._front = 0;
    this._end = 0;
    this._dirty = false;
    this._t = new Transitionable(0);
    this._fromQ = new Quaternion(w, x, y, z);
    this._toQ = new Quaternion();
    this._q = new Quaternion(w, x, y, z);
}

QuatTransitionable.prototype.get = function get() {
    var t = this._t.get();
    var w, x, y, z;
    var queue = this._queue;
    while (t >= this._front + 1) {
        this._front++;
        w = queue.shift();
        x = queue.shift();
        y = queue.shift();
        z = queue.shift();
        this._q.set(w, x, y, z);
        this._fromQ.set(w, x, y, z);
        if (this._queue.length !== 0) this._toQ.set(queue[0], queue[1], queue[2], queue[3]);
    }
    if (this._queue.length !== 0) this._fromQ.slerp(this._toQ, t - this._front, this._q);
    return this._q;
};

QuatTransitionable.prototype.set = function set(x, y, z, w, options, callback) {
    if (!this._transform._dirty) {
        this._transform._node.requestUpdate(this._transform._id);
        this._transform._dirty = true;
    }
    this._dirty = true;
    if (this._queue.length === 0) this._toQ.set(w, x, y, z);
    this._queue.push(w, x, y, z);
    this._end++;
    this._t.set(this._end, options, callback);
    return this;
};

QuatTransitionable.prototype.isActive = function isActive() {
    return this._t.isActive();
};

QuatTransitionable.prototype.pause = function pause() {
    this._t.pause();
    return this;
};

QuatTransitionable.prototype.resume = function resume() {
    this._t.resume();
    return this;
};

QuatTransitionable.prototype.halt = function halt() {
    this._dirty = false;
    this._t.reset(0);
    this._queue.length = 0;
    this._front = 0;
    this._end = 0;
    return this;
};

function Transform(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this.origin = null;
    this.mountPoint = null;
    this.align = null;
    this.scale = null;
    this.position = null;
    this.rotation = null;

    this._dirty = false;
}

Transform.prototype.toString = function toString() {
    return 'Transform';
};

Transform.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        origin: this.origin && this.origin.get(),
        mountPoint: this.mountPoint && this.mountPoint.get(),
        align: this.align && this.align.get(),
        scale: this.scale && this.scale.get(),
        position: this.position && this.position.get(),
        rotation: this.rotation && this.rotation.get()
    };
};

Transform.prototype.setState = function setState(state) {
    if (this.toString() === state.component) {
        state.origin && this.setOrigin(state.origin.x, state.origin.y, state.origin.z);
        state.mountPoint && this.setMountPoint(state.mountPoint.x, state.mountPoint.y, state.mountPoint.z);
        state.align && this.setAlign(state.align.x, state.align.y, state.align.z);
        state.scale && this.setScale(state.scale.x, state.scale.y, state.scale.z);
        state.position && this.setPosition(state.position.x, state.position.y, state.position.z);
        state.rotation && this.setRotation(state.rotation.x, state.rotation.y, state.rotation.z, state.rotation.w);
        return true;
    }
    return false;
};

Transform.prototype.setOrigin = function setOrigin(x, y, z, options, callback) {
    if (!this.origin) {
        var v = this._node.getOrigin();
        this.origin = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.origin.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setMountPoint = function setMountPoint(x, y, z, options, callback) {
    if (!this.mountPoint) {
        var v = this._node.getMountPoint();
        this.mountPoint = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.mountPoint.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setAlign = function setAlign(x, y, z, options, callback) {
    if (!this.align) {
        var v = this._node.getAlign();
        this.align = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.align.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setScale = function setScale(x, y, z, options, callback) {
    if (!this.scale) {
        var v = this._node.getScale();
        this.scale = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.scale.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setPosition = function setPosition(x, y, z, options, callback) {
    if (!this.position) {
        var v = this._node.getPosition();
        this.position = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.position.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.translate = function translate(x, y, z, options, callback) {
    if (!this.position) {
        var v = this._node.getPosition();
        this.position = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    var p = this.position;
    var xq = p.x._queue;
    var yq = p.y._queue;
    var zq = p.z._queue;
    var xEnd = x == null ? null : x + (xq.length > 0 ? xq[xq.length - 4] : p.x._end);
    var yEnd = y == null ? null : y + (yq.length > 0 ? yq[yq.length - 4] : p.y._end);
    var zEnd = z == null ? null : z + (zq.length > 0 ? zq[zq.length - 4] : p.z._end);
    this.position.set(xEnd, yEnd, zEnd, options, callback);
    return this;
};

Transform.prototype.setRotation = function setRotation(x, y, z, w, options, callback) {
    if (!this.rotation) {
        var v = this._node.getRotation();
        this.rotation = new QuatTransitionable(v[0], v[1], v[2], v[3], this);
    }
    var q = Q_REGISTER;
    if (typeof w === 'number') {
        q.set(w, x, y, z);
    }
    else {
        q.fromEuler(x, y, z);
        callback = options;
        options = w;
    }
    this.rotation.set(q.x, q.y, q.z, q.w, options, callback);
    return this;
};

Transform.prototype.rotate = function rotate(x, y, z, w, options, callback) {
    if (!this.rotation) {
        var v = this._node.getRotation();
        this.rotation = new QuatTransitionable(v[0], v[1], v[2], v[3], this);
    }
    var queue = this.rotation._queue;
    var len = this.rotation._queue.length;
    var referenceQ;
    if (len !== 0) {
        referenceQ = Q2_REGISTER.set(queue[len - 4], queue[len - 3], queue[len - 2], queue[len - 1]);
    }
    else referenceQ = Q2_REGISTER.copy(this.rotation._q);

    var rotQ = Q_REGISTER;
    if (typeof w === 'number') {
        rotQ.set(w, x, y, z);
    }
    else {
        rotQ.fromEuler(x, y, z);
        callback = options;
        options = w;
    }

    var q = referenceQ.multiply(rotQ);
    this.rotation.set(q.x, q.y, q.z, q.w, options, callback);
    return this;
};

Transform.prototype.clean = function clean() {
    var node = this._node;
    var c;
    var isDirty = false;
    if ((c = this.origin) && c._dirty) {
        node.setOrigin(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.mountPoint) && c._dirty) {
        node.setMountPoint(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.align) && c._dirty) {
        node.setAlign(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.scale) && c._dirty) {
        node.setScale(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.position) && c._dirty) {
        node.setPosition(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.rotation) && c._dirty) {
        c.get();
        node.setRotation(c._q.x, c._q.y, c._q.z, c._q.w);
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if (isDirty) this._node.requestUpdateOnNextTick(this._id);
    else this._dirty = false;
};

Transform.prototype.onUpdate = Transform.prototype.clean;

module.exports = Transform;

},{"../math/Quaternion":47,"../transitions/Transitionable":88}],12:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var CallbackStore = require('../utilities/CallbackStore');

/**
 * Component to manage DOM events. When registering an event, the user may specify .methods and
 * .properties to preprocess the event object.
 *
 * @class UIEventHandler
 * @param {LocalDispatch} dispatch The dispatch with which to register the handler.
 * @param {Object[]} events An array of event objects specifying .event and .callback properties.
 */
function UIEventHandler (dispatch, events) {
    this.dispatch = dispatch;
    this._events = new CallbackStore();

    if (events) {
        for (var i = 0, len = events.length; i < len; i++) {
            this.on(events[i], events[i].callback);
        }
    }
}

UIEventHandler.prototype.toString = function toString() {
    return 'UIEventHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {Object|String} ev The event object or event name.
 * @param {Function} cb The callback.
 */
UIEventHandler.prototype.on = function on(ev, cb) {
    var renderables = this.dispatch.getRenderables();
    var eventName = ev.event || ev;
    var methods = ev.methods;
    var properties = ev.properties;
    for (var i = 0, len = renderables.length; i < len; i++) {
        if (renderables[i].on) renderables[i].on(eventName, methods, properties);
    }
    this._events.on(eventName, cb);
    this.dispatch.registerTargetedEvent(eventName, this.trigger.bind(this, eventName));
};

/**
 * Deregister a callback from an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
UIEventHandler.prototype.off = function off(ev, cb) {
    this._events.off(ev, cb);
    this.dispatch.deregisterGlobalEvent(ev, this.trigger.bind(this, ev));
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
UIEventHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

module.exports = UIEventHandler;

},{"../utilities/CallbackStore":90}],13:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Align: require('./Align'),
    Camera: require('./Camera'),
    GestureHandler: require('./GestureHandler'),
    MountPoint: require('./MountPoint'),
    Opacity: require('./Opacity'),
    Origin: require('./Origin'),
    Position: require('./Position'),
    Rotation: require('./Rotation'),
    Scale: require('./Scale'),
    Size: require('./Size'),
    Transform: require('./Transform'),
    UIEventHandler: require('./UIEventHandler')
};

},{"./Align":1,"./Camera":2,"./GestureHandler":3,"./MountPoint":4,"./Opacity":5,"./Origin":6,"./Position":7,"./Rotation":8,"./Scale":9,"./Size":10,"./Transform":11,"./UIEventHandler":12}],14:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Channels are being used for interacting with the UI Thread when running in
 * a Web Worker or with the ThreadManager/ Compostior when running in single
 * threaded mode (no Web Worker).
 *
 * @class Channel
 * @constructor
 */
function Channel() {
    if (typeof self !== 'undefined' && self.window !== self) {
        this._enterWorkerMode();
    }
}


/**
 * Called during construction. Subscribes for `message` event and routes all
 * future `sendMessage` messages to the Main Thread ("UI Thread").
 * 
 * Primarily used for testing.
 * 
 * @method  _enterWorkerMode
 * @private
 */ 
Channel.prototype._enterWorkerMode = function _enterWorkerMode() {
    this._workerMode = true;
    var _this = this;
    self.addEventListener('message', function onmessage(ev) {
        _this.onMessage(ev.data);
    });
};

/**
 * Meant to be overriden by `Famous`.
 *
 * @type {Function} Assigned method will be invoked for every received message.
 */
Channel.prototype.onMessage = null;

/**
 * Sends a message to the ThreadManager.
 *
 * @param  {Any}    message Arbitrary message object.
 */
Channel.prototype.sendMessage = function sendMessage (message) {
    if (this._workerMode) {
        self.postMessage(message);
    } else {
        this.onmessage(message);
    }
};

/**
 * Meant to be overriden by the ThreadManager when running in the UI Thread.
 * Used for preserving API compatibility with Web Workers.
 * When running in Web Worker mode, this property won't be mutated.
 *
 * @private
 * @type {Function}     Assigned method will be invoked for every message
 *                      posted by `famous-core`
 */
Channel.prototype.onmessage = null;

/**
 * Sends a message to the manager of this channel (the `Famous` singleton) by
 * invoking `onMessage`.
 * Used for preserving API compatibility with Web Workers.
 *
 * @private
 * @alias onMessage
 */
Channel.prototype.postMessage = function postMessage(message) {
    return this.onMessage(message);
};

module.exports = Channel;

},{}],15:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Equivalent of an Engine in the Worker Thread. Used to synchronize and manage
 * time across different Threads.
 *
 * @class  Clock
 * @constructor
 * @private
 */
function Clock () {
    this._time = 0;
    this._frame = 0;
    this._timerQueue = [];
    this._updatingIndex = 0;

    this._scale = 1;
    this._scaledTime = this._time;
}

/**
 * Sets the scale at which the clock time is passing.
 * Useful for slow-motion or fast-forward effects.
 * 
 * `1` means no time scaling ("realtime"),
 * `2` means the clock time is passing twice as fast,
 * `0.5` means the clock time is passing two times slower than the "actual"
 * time at which the Clock is being updated via `.step`.
 *
 * Initally the clock time is not being scaled (factor `1`).
 * 
 * @method  setScale
 * @chainable
 * 
 * @param {Number} scale    The scale at which the clock time is passing.
 */
Clock.prototype.setScale = function setScale (scale) {
    this._scale = scale;
    return this;
};

/**
 * @method  getScale
 * 
 * @return {Number} scale    The scale at which the clock time is passing.
 */
Clock.prototype.getScale = function getScale () {
    return this._scale;
};

/**
 * Updates the internal clock time.
 *
 * @method  step
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Clock}       this
 */
Clock.prototype.step = function step (time) {
    this._frame++;

    this._scaledTime = this._scaledTime + (time - this._time)*this._scale;
    this._time = time;

    for (var i = 0; i < this._timerQueue.length; i++) {
        if (this._timerQueue[i](this._scaledTime)) {
            this._timerQueue.splice(i, 1);
        }
    }
    return this;
};

/**
 * Returns the internal clock time.
 *
 * @method  now
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.now = function now () {
    return this._scaledTime;
};

/**
 * Returns the internal clock time.
 *
 * @method  getTime
 * @deprecated Use #now instead
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.getTime = Clock.prototype.now;

/**
 * Returns the number of frames elapsed so far.
 *
 * @method getFrame
 * 
 * @return {Number} frames
 */
Clock.prototype.getFrame = function getFrame () {
    return this._frame;
};

/**
 * Wraps a function to be invoked after a certain amount of time.
 * After a set duration has passed, it executes the function and
 * removes it as a listener to 'prerender'.
 *
 * @method setTimeout
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} delay milliseconds from now to execute the function
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setTimeout = function (callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            return true;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};


/**
 * Wraps a function to be invoked after a certain amount of time.
 *  After a set duration has passed, it executes the function and
 *  resets the execution time.
 *
 * @method setInterval
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} duration interval to execute function in milliseconds
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setInterval = function setInterval(callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            startedAt = time;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};

/**
 * Removes previously via `Clock#setTimeout` or `Clock#setInterval`
 * registered callback function
 *
 * @method clearTimer
 * @chainable
 * 
 * @param  {Function} callback  previously by `Clock#setTimeout` or
 *                              `Clock#setInterval` returned callback function
 * @return {Clock}              this
 */
Clock.prototype.clearTimer = function (timer) {
    var index = this._timerQueue.indexOf(timer);
    if (index !== -1) {
        this._timerQueue.splice(index, 1);
    }
    return this;
};

module.exports = Clock;


},{}],16:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

// TODO: Dispatch should be generalized so that it can work on any Node
// not just Contexts.

var Event = require('./Event');

/**
 * The Dispatch class is used to propogate events down the
 * scene graph.
 *
 * @param {Context} Context on which it operates
 */
function Dispatch (context) {

    if (!context) throw new Error('Dispatch needs to be instantiated on a node');
    
    this._context = context; // A reference to the context
                             // on which the dispatcher
                             // operates

    this._queue = []; // The queue is used for two purposes
                      // 1. It is used to list indicies in the
                      //    Nodes path which are then used to lookup
                      //    a node in the scene graph.
                      // 2. It is used to assist dispatching
                      //    such that it is possible to do a breadth first
                      //    traversal of the scene graph.
}

/**
 * lookupNode takes a path and returns the node at the location specified
 * by the path, if one exists. If not, it returns undefined.
 *
 * @param {String} The location of the node specified by its path
 * 
 * @return {Node | undefined} The node at the requested path
 */
Dispatch.prototype.lookupNode = function lookupNode (location) {
    if (!location) throw new Error('lookupNode must be called with a path');

    var path = this._queue;

    _splitTo(location, path);
    
    if (path[0] !== this._context.getSelector()) return void 0;

    var children = this._context.getChildren();
    var child;
    var i = 1;
    path[0] = this._context;

    while (i < path.length) {
        child = children[path[i]];
        path[i] = child;
        if (child) children = child.getChildren();
        else return void 0;
        i++;
    }

    return child;
};

/**
 * dispatch takes an event name and a payload and dispatches it to the
 * entire scene graph below the node that the dispatcher is on. The nodes
 * receive the events in a breadth first traversal, meaning that parents
 * have the opportunity to react to the event before children.
 *
 * @param {String} event name
 * @param {Any} payload
 */
Dispatch.prototype.dispatch = function dispatch (event, payload) {
    if (!event) throw new Error('dispatch requires an event name as it\'s first argument');

    var queue = this._queue;
    var item;
    var i;
    var len;
    var children;

    queue.length = 0;
    queue.push(this._context);

    while (queue.length) {
        item = queue.shift();
        if (item.onReceive) item.onReceive(event, payload);
        children = item.getChildren();
        for (i = 0, len = children.length ; i < len ; i++) queue.push(children[i]);
    }
};

/**
 * dispatchUIevent takes a path, an event name, and a payload and dispatches them in
 * a manner anologous to DOM bubbling. It first traverses down to the node specified at
 * the path. That node receives the event first, and then every ancestor receives the event
 * until the context.
 *
 * @param {String} the path of the node
 * @param {String} the event name
 * @param {Any} the payload
 */
Dispatch.prototype.dispatchUIEvent = function dispatchUIEvent (path, event, payload) {
    if (!path) throw new Error('dispatchUIEvent needs a valid path to dispatch to');
    if (!event) throw new Error('dispatchUIEvent needs an event name as its second argument');

    var queue = this._queue;
    var node;
    
    Event.call(payload);
    payload.node = this.lookupNode(path); // After this call, the path is loaded into the queue
                                          // (lookUp node doesn't clear the queue after the lookup)

    while (queue.length) {
        node = queue.pop(); // pop nodes off of the queue to move up the ancestor chain.
        if (node.onReceive) node.onReceive(event, payload);
        if (payload.propagationStopped) break;
    }
};

/**
 * _splitTo is a private method which takes a path and splits it at every '/'
 * pushing the result into the supplied array. This is a destructive change.
 *
 * @private
 * @param {String} the specified path
 * @param {Array} the array to which the result should be written
 */
function _splitTo (string, target) {
    target.length = 0; // clears the array first.
    var last = 0;

    for (var i = 0, len = string.length ; i < len ; i++) {
        if (string[i] === '/') {
            target.push(string.substring(last, i));
            last = i + 1;
        }
    }

    if (i - last > 0) target.push(string.substring(last, i));

    return target;
}

module.exports = Dispatch;


},{"./Event":17}],17:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The Event class adds the stopPropagation functionality
 * to the UIEvents within the scene graph.
 *
 * @constructor Event
 */
function Event () {
    this.propagationStopped = false;
    this.stopPropagation = stopPropagation;
}

/**
 * stopPropagation ends the bubbling of the event in the
 * scene graph.
 *
 * @method stopPropagation
 */
function stopPropagation () {
    this.propagationStopped = true;
}

module.exports = Event;


},{}],18:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Clock = require('./Clock');
var Scene = require('./Scene');
var Channel = require('./Channel');
var UIManager = require('../renderers/UIManager');
var Compositor = require('../renderers/Compositor');
var Engine = require('../engine/Engine');

var ENGINE_START = ['ENGINE', 'START'];
var ENGINE_STOP = ['ENGINE', 'STOP'];
var TIME_UPDATE = ['TIME', null];

/**
 * Famous has two responsibilities, one to act as the highest level
 * updater and another to send messages over to the renderers. It is
 * a singleton.
 */
function FamousEngine() {
    this._updateQueue = []; // The updateQueue is a place where nodes
                            // can place themselves in order to be
                            // updated on the frame.

    this._nextUpdateQueue = []; // the nextUpdateQueue is used to queue
                                // updates for the next tick.
                                // this prevents infinite loops where during
                                // an update a node continuously puts itself
                                // back in the update queue.

    this._scenes = {}; // a hash of all of the scenes's that the FamousEngine
                         // is responsible for.

    this._messages = TIME_UPDATE;   // a queue of all of the draw commands to
                                    // send to the the renderers this frame.

    this._inUpdate = false; // when the famous is updating this is true.
                            // all requests for updates will get put in the
                            // nextUpdateQueue

    this._clock = new Clock(); // a clock to keep track of time for the scene
                               // graph.

    this._channel = new Channel();
    this._channel.onMessage = this.handleMessage.bind(this);
}


/**
 * @method init
 * @chainable
 */
FamousEngine.prototype.init = function init(options) {
    this.compositor = options && options.compositor || new Compositor();
    this.engine = options && options.engine || new Engine();
    this.uiManager = new UIManager(this.getChannel(), this.compositor, this.engine);
    return this;
};

/**
 * @method setChannel
 * @chainable
 *
 * @param {Channel} channel     The channel to be used for communicating with
 *                              the `UIManager`/ `Compositor`.
 */
FamousEngine.prototype.setChannel = function setChannel(channel) {
    this._channel = channel;
    return this;
};

/**
 * @method getChannel
 *
 * @return {Channel} channel    The channel to be used for communicating with
 *                              the `UIManager`/ `Compositor`.
 */
FamousEngine.prototype.getChannel = function getChannel () {
    return this._channel;
};

/**
 * _update is the body of the update loop. The frame consists of
 * pulling in appending the nextUpdateQueue to the currentUpdate queue
 * then moving through the updateQueue and calling onUpdate with the current
 * time on all nodes. While _update is called _inUpdate is set to true and
 * all requests to be placed in the update queue will be forwarded to the
 * nextUpdateQueue.
 */
FamousEngine.prototype._update = function _update () {
    this._inUpdate = true;
    var time = this._clock.now();
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    this._messages[1] = time;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = queue.shift();
        if (item && item.onUpdate) item.onUpdate(time);
    }

    this._inUpdate = false;
};

/**
 * requestUpdates takes a class that has an onUpdate method and puts it
 * into the updateQueue to be updated at the next frame.
 * If FamousEngine is currently in an update, requestUpdate
 * passes its argument to requestUpdateOnNextTick.
 *
 * @param {Object} an object with an onUpdate method
 */
FamousEngine.prototype.requestUpdate = function requestUpdate (requester) {
    if (!requester)
        throw new Error(
            'requestUpdate must be called with a class to be updated'
        );

    if (this._inUpdate) this.requestUpdateOnNextTick(requester);
    else this._updateQueue.push(requester);
};

/**
 * requestUpdateOnNextTick is requests an update on the next frame.
 * If FamousEngine is not currently in an update than it is functionally equivalent
 * to requestUpdate. This method should be used to prevent infinite loops where
 * a class is updated on the frame but needs to be updated again next frame.
 *
 * @param {Object} an object with an onUpdate method
 */
FamousEngine.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
};

/**
 * postMessage sends a message queue into FamousEngine to be processed.
 * These messages will be interpreted and sent into the scene graph
 * as events if necessary.
 *
 * @param {Array} an array of commands.
 * @chainable
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleMessage = function handleMessage (messages) {
    if (!messages)
        throw new Error(
            'onMessage must be called with an array of messages'
        );

    var command;

    while (messages.length > 0) {
        command = messages.shift();
        switch (command) {
            case 'WITH':
                this.handleWith(messages);
                break;
            case 'FRAME':
                this.handleFrame(messages);
                break;
            default:
                throw new Error('received unknown command: ' + command);
        }
    }
    return this;
};

/**
 * handleWith is a method that takes an array of messages following the
 * WITH command. It'll then issue the next commands to the path specified
 * by the WITH command.
 *
 * @param {Array} array of messages.
 * @chainable
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleWith = function handleWith (messages) {
    var path = messages.shift();
    var command = messages.shift();

    switch (command) {
        case 'TRIGGER': // the TRIGGER command sends a UIEvent to the specified path
            var type = messages.shift();
            var ev = messages.shift();

            this.getContext(path).getDispatch().dispatchUIEvent(path, type, ev);
            break;
        default:
            throw new Error('received unknown command: ' + command);
    }
    return this;
};

/**
 * handleFrame is called when the renderers issue a FRAME command to
 * FamousEngine. FamousEngine will then step updating the scene graph to the current time.
 *
 * @param {Array} array of messages.
 * @chainable
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleFrame = function handleFrame (messages) {
    if (!messages) throw new Error('handleFrame must be called with an array of messages');
    if (!messages.length) throw new Error('FRAME must be sent with a time');

    this.step(messages.shift());
    return this;
};

/**
 * step updates the clock and the scene graph and then sends the draw commands
 * that accumulated in the update to the renderers.
 *
 * @param {Number} current engine time
 * @chainable
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.step = function step (time) {
    if (time == null) throw new Error('step must be called with a time');

    this._clock.step(time);
    this._update();

    if (this._messages.length) {
        this._channel.sendMessage(this._messages);
        this._messages.length = 2;
    }

    return this;
};

/**
 * returns the context of a particular path. The context is looked up by the selector
 * portion of the path and is listed from the start of the string to the first
 * '/'.
 *
 * @param {String} the path to look up the context for.
 *
 * @return {Context | Undefined} the context if found, else undefined.
 */
FamousEngine.prototype.getContext = function getContext (selector) {
    if (!selector) throw new Error('getContext must be called with a selector');

    var index = selector.indexOf('/');
    selector = index === -1 ? selector : selector.substring(0, index);

    return this._scenes[selector];
};

/**
 * returns the instance of clock within famous.
 *
 * @return {Clock} FamousEngine's clock
 */
FamousEngine.prototype.getClock = function getClock () {
    return this._clock;
};

/**
 * queues a message to be transfered to the renderers.
 *
 * @param {Any} Draw Command
 * @chainable
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.message = function message (command) {
    this._messages.push(command);
    return this;
};

/**
 * Creates a scene under which a scene graph could be built.
 *
 * @param {String} a dom selector for where the scene should be placed
 *
 * @return {Scene} a new instance of Scene.
 */
FamousEngine.prototype.createScene = function createScene (selector) {
    selector = selector || 'body';

    if (this._scenes[selector]) this._scenes[selector].dismount();
    this._scenes[selector] = new Scene(selector, this);
    return this._scenes[selector];
};

/**
 * Starts the engine running in the Main-Thread.
 * This effects **every** updateable managed by the Engine.
 *
 * @chainable
 */
FamousEngine.prototype.startEngine = function startEngine () {
    this._channel.sendMessage(ENGINE_START);
    return this;
};

/**
 * Stops the engine running in the Main-Thread.
 * This effects **every** updateable managed by the Engine.
 *
 * @chainable
 */
FamousEngine.prototype.stopEngine = function stopEngine () {
    this._channel.sendMessage(ENGINE_STOP);
    return this;
};

module.exports = new FamousEngine();

},{"../engine/Engine":42,"../renderers/Compositor":83,"../renderers/UIManager":85,"./Channel":14,"./Clock":15,"./Scene":20}],19:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

var Transform = require('./Transform');
var Size = require('./Size');

var TRANSFORM_PROCESSOR = new Transform();
var SIZE_PROCESSOR = new Size();

var IDENT = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];

var ONES = [1, 1, 1];
var QUAT = [0, 0, 0, 1];

/**
 * Nodes define hierarchy and geometrical transformations. They can be moved
 * (translated), scaled and rotated.
 *
 * A Node is either mounted or unmounted. Unmounted nodes are detached from the
 * scene graph. Unmounted nodes have no parent node, while each mounted node has
 * exactly one parent. Nodes have an arbitary number of children, which can be
 * dynamically added using @{@link addChild}.
 *
 * Each Nodes have an arbitrary number of `components`. Those components can
 * send `draw` commands to the renderer or mutate the node itself, in which case
 * they define behavior in the most explicit way. Components that send `draw`
 * commands aare considered `renderables`. From the node's perspective, there is
 * no distinction between nodes that send draw commands and nodes that define
 * behavior.
 *
 * Because of the fact that Nodes themself are very unopinioted (they don't
 * "render" to anything), they are often being subclassed in order to add e.g.
 * components at initialization to them. Because of this flexibility, they might
 * as well have been called `Entities`.
 *
 * @example
 * // create three detached (unmounted) nodes
 * var parent = new Node();
 * var child1 = new Node();
 * var child2 = new Node();
 *
 * // build an unmounted subtree (parent is still detached)
 * parent.addChild(child1);
 * parent.addChild(child2);
 *
 * // mount parent by adding it to the context
 * var context = Famous.createContext("body");
 * context.addChild(parent);
 *
 * @class Node
 * @constructor
 */
function Node () {
    this._calculatedValues = {
        transform: new Float32Array(IDENT),
        size: new Float32Array(3)
    };

    this._requestingUpdate = false;
    this._inUpdate = false;

    this._updateQueue = [];
    this._nextUpdateQueue = [];

    this._freedComponentIndicies = [];
    this._components = [];

    this._freedChildIndicies = [];
    this._children = [];

    this._parent = null;
    this._globalUpdater = null;

    this._lastEulerX = 0;
    this._lastEulerY = 0;
    this._lastEulerZ = 0;
    this._lastEuler = false;

    this.value = new Node.Spec();
}

Node.RELATIVE_SIZE = Size.RELATIVE;
Node.ABSOLUTE_SIZE = Size.ABSOLUTE;
Node.RENDER_SIZE = Size.RENDER;
Node.DEFAULT_SIZE = Size.DEFAULT;

/**
 * A Node spec holds the "data" associated with a Node.
 *
 * @property {String} location path to the node (e.g. "body/0/1")
 * @property {Object} showState
 * @property {Boolean} showState.mounted
 * @property {Boolean} showState.shown
 * @property {Number} showState.opacity
 * @property {Object} offsets
 * @property {Float32Array.<Number>} offsets.mountPoint
 * @property {Float32Array.<Number>} offsets.align
 * @property {Float32Array.<Number>} offsets.origin
 * @property {Object} vectors
 * @property {Float32Array.<Number>} vectors.position
 * @property {Float32Array.<Number>} vectors.rotation
 * @property {Float32Array.<Number>} vectors.scale
 * @property {Object} size
 * @property {Float32Array.<Number>} size.sizeMode
 * @property {Float32Array.<Number>} size.proportional
 * @property {Float32Array.<Number>} size.differential
 * @property {Float32Array.<Number>} size.absolute
 * @property {Float32Array.<Number>} size.render
 */
Node.Spec = function Spec () {
    this.location = null;
    this.showState = {
        mounted: false,
        shown: false,
        opacity: 1
    };
    this.offsets = {
        mountPoint: new Float32Array(3),
        align: new Float32Array(3),
        origin: new Float32Array(3)
    };
    this.vectors = {
        position: new Float32Array(3),
        rotation: new Float32Array(QUAT),
        scale: new Float32Array(ONES)
    };
    this.size = {
        sizeMode: new Float32Array([Size.RELATIVE, Size.RELATIVE, Size.RELATIVE]),
        proportional: new Float32Array(ONES),
        differential: new Float32Array(3),
        absolute: new Float32Array(3),
        render: new Float32Array(3)
    };
    this.UIEvents = [];
};

/**
 * Determine the node's location in the scene graph hierarchy.
 * A location of `body/0/1` can be interpreted as the following scene graph
 * hierarchy (ignoring siblings of ancestors and additional child nodes):
 *
 * `Context:body` -> `Node:0` -> `Node:1`, where `Node:1` is the node the
 * `getLocation` method has been invoked on.
 *
 * @method getLocation
 *
 * @return {String} location (path), e.g. `body/0/1`
 */
Node.prototype.getLocation = function getLocation () {
    return this.value.location;
};

/**
 * @alias getId
 */
Node.prototype.getId = Node.prototype.getLocation;

/**
 * Dispatches the event on the node by recursively traversing the scene graph
 * upwards.
 *
 * @method emit
 *
 * @param  {String} event   Event type.
 * @param  {Object} payload Event object to be dispatched.
 */
Node.prototype.emit = function emit (event, payload) {
    var p = this.getParent();
    // the context is its own ancestor
    while (p !== (p = p.getParent()));
    p.getDispatch().dispatch(event, payload);
    return this;
};

// THIS WILL BE DEPRICATED
Node.prototype.sendDrawCommand = function sendDrawCommand (message) {
    this._globalUpdater.message(message);
    return this;
};

/**
 * Recursively serializes the Node, including all previously added components.
 *
 * @method getValue
 *
 * @return {Object}     Serialized representation of the node, including
 *                      components.
 */
Node.prototype.getValue = function getValue () {
    var numberOfChildren = this._children.length;
    var numberOfComponents = this._components.length;
    var i = 0;

    var value = {
        location: this.value.location,
        spec: this.value,
        components: new Array(numberOfComponents),
        children: new Array(numberOfChildren)
    };

    for (; i < numberOfChildren ; i++)
        if (this._children[i] && this._children[i].getValue)
            value.children[i] = this._children[i].getValue();

    for (i = 0 ; i < numberOfComponents ; i++)
        if (this._components[i] && this._components[i].getValue)
            value.components[i] = this._components[i].getValue();

    return value;
};

/**
 * Similar to @{@link getValue}, but returns the actual "computed" value. E.g.
 * a proportional size of 0.5 might resolve into a "computed" size of 200px
 * (assuming the parent has a width of 400px).
 *
 * @method getComputedValue
 *
 * @return {Object}     Serialized representation of the node, including
 *                      children, excluding components.
 */
Node.prototype.getComputedValue = function getComputedValue () {
    var numberOfChildren = this._children.length;

    var value = {
        location: this.value.location,
        computedValues: this._calculatedValues,
        children: new Array(numberOfChildren)
    };

    for (var i = 0 ; i < numberOfChildren ; i++)
        value.children[i] = this._children[i].getComputedValue();

    return value;
};

/**
 * Retrieves all children of the current node.
 *
 * @method getChildren
 *
 * @return {Array.<Node>}   An array of children.
 */
Node.prototype.getChildren = function getChildren () {
    return this._children;
};

/**
 * Retrieves the parent of the current node. Unmounted nodes do not have a
 * parent node.
 *
 * @method getParent
 *
 * @return {Node}       Parent node.
 */
Node.prototype.getParent = function getParent () {
    return this._parent;
};

/**
 * Schedules the @{@link update} function of the node to be invoked on the next
 * frame (if no update during this frame has been scheduled already).
 * If the node is currently being updated (which means one of the requesters
 * invoked requestsUpdate while being updated itself), an update will be
 * scheduled on the next frame.
 *
 * @method requestUpdate
 *
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 */
Node.prototype.requestUpdate = function requestUpdate (requester) {
    if (this._inUpdate || !this.isMounted())
        return this.requestUpdateOnNextTick(requester);
    this._updateQueue.push(requester);
    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Schedules an update on the next tick. Similarily to @{@link requestUpdate},
 * `requestUpdateOnNextTick` schedules the node's `onUpdate` function to be
 * invoked on the frame after the next invocation on the node's onUpdate function.
 *
 * @method requestUpdateOnNextTick
 *
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 */
Node.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
    return this;
};

/**
 * If the context has been created using @{@link Famous.createContext}, the
 * @{@link Famous} singleton will be the global updater.
 *
 * @method getUpdater
 *
 * @return {Object} The global updater.
 */
Node.prototype.getUpdater = function getUpdater () {
    return this._globalUpdater;
};

/**
 * Checks if the node is mounted. Unmounted nodes are detached from the scene
 * graph.
 *
 * @method isMounted
 *
 * @return {Boolean}    Boolean indicating weather the node is mounted or not.
 */
Node.prototype.isMounted = function isMounted () {
    return this.value.showState.mounted;
};

/**
 * Checks if the node is visible ("shown").
 *
 * @method isShown
 *
 * @return {Boolean}    Boolean indicating weather the node is visible
 *                      ("shown") or not.
 */
Node.prototype.isShown = function isShown () {
    return this.value.showState.shown;
};

/**
 * Determines the node's relative opacity.
 * The opacity needs to be within [0, 1], where 0 indicates a completely
 * transparent, therefore invisible node, whereas an opacity of 1 means the
 * node is completely solid.
 *
 * @method getOpacity
 *
 * @return {Number}         Relative opacity of the node.
 */
Node.prototype.getOpacity = function getOpacity () {
    return this.value.showState.opacity;
};

/**
 * Determines the node's previously set mount point.
 *
 * @method getMountPoint
 *
 * @return {Float32Array}   An array representing the mount point.
 */
Node.prototype.getMountPoint = function getMountPoint () {
    return this.value.offsets.mountPoint;
};

/**
 * Determines the node's previously set align.
 *
 * @method getAlign
 *
 * @return {Float32Array}   An array representing the align.
 */
Node.prototype.getAlign = function getAlign () {
    return this.value.offsets.align;
};

/**
 * Determines the node's previously set origin.
 *
 * @method getOrigin
 *
 * @return {Float32Array}   An array representing the origin.
 */
Node.prototype.getOrigin = function getOrigin () {
    return this.value.offsets.origin;
};

/**
 * Determines the node's previously set position.
 *
 * @method getPosition
 *
 * @return {Float32Array}   An array representing the position.
 */
Node.prototype.getPosition = function getPosition () {
    return this.value.vectors.position;
};

Node.prototype.getRotation = function getRotation () {
    return this.value.vectors.rotation;
};

Node.prototype.getScale = function getScale () {
    return this.value.vectors.scale;
};

Node.prototype.getSizeMode = function getSizeMode () {
    return this.value.size.sizeMode;
};

Node.prototype.getProportionalSize = function getProportionalSize () {
    return this.value.size.proportional;
};

Node.prototype.getDifferentialSize = function getDifferentialSize () {
    return this.value.size.differential;
};

Node.prototype.getAbsoluteSize = function getAbsoluteSize () {
    return this.value.size.absolute;
};

Node.prototype.getRenderSize = function getRenderSize () {
    return this.value.size.render;
};

Node.prototype.getSize = function getSize () {
    return this._calculatedValues.size;
};

Node.prototype.getTransform = function getTransform () {
    return this._calculatedValues.transform;
};

Node.prototype.getUIEvents = function getUIEvents () {
    return this.value.UIEvents;
};

Node.prototype.addChild = function addChild (child) {
    var index = child ? this._children.indexOf(child) : -1;
    child = child ? child : new Node();

    if (index === -1) {
        index = this._freedChildIndicies.length ? this._freedChildIndicies.pop() : this._children.length;
        this._children[index] = child;

        if (this.isMounted() && child.onMount) {
            var myId = this.getId();
            var childId = myId + '/' + index;
            child.onMount(this, childId);
        }

    }

    return child;
};

Node.prototype.removeChild = function removeChild (child) {
    var index = this._children.indexOf(child);
    var added = index !== -1;
    if (added) {
        this._freedChildIndicies.push(index);

        this._children[index] = null;

        if (this.isMounted() && child.onDismount)
            child.onDismount();
    }
    return added;
};

/**
 * Each component can only be added once per node.
 *
 * @method addComponent
 *
 * @param {Object} component    An component to be added.
 * @return {Number} index       The index at which the component has been
 *                              registered. Indices aren't necessarily
 *                              consecutive.
 */
Node.prototype.addComponent = function addComponent (component) {
    var index = this._components.indexOf(component);
    if (index === -1) {
        index = this._freedComponentIndicies.length ? this._freedComponentIndicies.pop() : this._components.length;
        this._components[index] = component;

        if (this.isMounted() && component.onMount)
            component.onMount(this, index);

        if (this.isShown() && component.onShow)
            component.onShow();
    }

    return index;
};

/**
 * @method  getComponent
 *  
 * @param  {Number} index   Index at which the component has been regsitered
 *                          (using `Node#addComponent`).
 * @return {*}              The component registered at the passed in index (if
 *                          any).
 */ 
Node.prototype.getComponent = function getComponent (index) {
    return this._components[index];
};

/**
 * Removes a previously via @{@link addComponent} added component.
 *
 * @method removeComponent
 *
 * @param  {Object} component   An component that has previously been added
 *                              using @{@link addComponent}.
 */
Node.prototype.removeComponent = function removeComponent (component) {
    var index = this._components.indexOf(component);
    if (index !== -1) {
        this._freedComponentIndicies.push(index);
        if (this.isShown() && component.onHide)
            component.onHide();

        if (this.isMounted() && component.onDismount)
            component.onDismount();

        this._components[index] = null;
    }
    return component;
};

Node.prototype.addUIEvent = function addUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    var added = UIEvents.indexOf(eventName) !== -1;
    if (!added) {
        UIEvents.push(eventName);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component && component.onAddUIEvent) component.onAddUIEvent(eventName);
        }
    }
    return added;
};

Node.prototype._requestUpdate = function _requestUpdate (force) {
    if (force || (!this._requestingUpdate && this._globalUpdater)) {
        this._globalUpdater.requestUpdate(this);
        this._requestingUpdate = true;
    }
};

Node.prototype._vecOptionalSet = function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        if (!this._requestingUpdate) this._requestUpdate();
        return true;
    }
    return false;
};

Node.prototype.show = function show () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = true;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onShow) item.onShow();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentShow) item.onParentShow();
    }
    return this;
};

Node.prototype.hide = function hide () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = false;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onHide) item.onHide();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentHide) item.onParentHide();
    }
    return this;
};

Node.prototype.setAlign = function setAlign (x, y, z) {
    var vec3 = this.value.offsets.align;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    if (z != null) propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAlignChange) item.onAlignChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setMountPoint = function setMountPoint (x, y, z) {
    var vec3 = this.value.offsets.mountPoint;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    if (z != null) propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onMountPointChange) item.onMountPointChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOrigin = function setOrigin (x, y, z) {
    var vec3 = this.value.offsets.origin;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    if (z != null) propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOriginChange) item.onOriginChange(x, y, z);
        }
    }
    return this;
};


Node.prototype.setPosition = function setPosition (x, y, z) {
    var vec3 = this.value.vectors.position;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onPositionChange) item.onPositionChange(x, y, z);
        }
    }

    return this;
};

Node.prototype.setRotation = function setRotation (x, y, z, w) {
    var quat = this.value.vectors.rotation;
    var propogate = false;
    var qx, qy, qz, qw;

    if (w != null) {
        qx = x;
        qy = y;
        qz = z;
        qw = w;
        this._lastEulerX = null;
        this._lastEulerY = null;
        this._lastEulerZ = null;
        this._lastEuler = false;
    }
    else {
        if (x == null || y == null || z == null) {
            if (this._lastEuler) {
                x = x == null ? this._lastEulerX : x;
                y = y == null ? this._lastEulerY : y;
                z = z == null ? this._lastEulerZ : z;
            }
            else {
                var sp = -2 * (quat[1] * quat[2] - quat[3] * quat[0]);

                if (Math.abs(sp) > (1 - Number.MIN_VALUE)) {
                    y = y == null ? Math.PI * 0.5 * sp : y;
                    x = x == null ? Math.atan2(-quat[0] * quat[2] + quat[3] * quat[1], 0.5 - quat[1] * quat[1] - quat[2] * quat[2]) : x;
                    z = z == null ? 0 : z;
                }
                else {
                    y = y == null ? Math.asin(sp) : y;
                    x = x == null ? Math.atan2(quat[0] * quat[2] + quat[3] * quat[1], 0.5 - quat[0] * quat[0] - quat[1] * quat[1]) : x;
                    z = z == null ? Math.atan2(quat[0] * quat[1] + quat[3] * quat[2], 0.5 - quat[0] * quat[0] - quat[2] * quat[2]) : z;
                }
            }
        }

        var hx = x * 0.5;
        var hy = y * 0.5;
        var hz = z * 0.5;

        var sx = Math.sin(hx);
        var sy = Math.sin(hy);
        var sz = Math.sin(hz);
        var cx = Math.cos(hx);
        var cy = Math.cos(hy);
        var cz = Math.cos(hz);

        var sysz = sy * sz;
        var cysz = cy * sz;
        var sycz = sy * cz;
        var cycz = cy * cz;

        qx = sx * cycz + cx * sysz;
        qy = cx * sycz - sx * cysz;
        qz = cx * cysz + sx * sycz;
        qw = cx * cycz - sx * sysz;

        this._lastEuler = true;
        this._lastEulerX = x;
        this._lastEulerY = y;
        this._lastEulerZ = z;
    }

    propogate = this._vecOptionalSet(quat, 0, qx) || propogate;
    propogate = this._vecOptionalSet(quat, 1, qy) || propogate;
    propogate = this._vecOptionalSet(quat, 2, qz) || propogate;
    propogate = this._vecOptionalSet(quat, 3, qw) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = quat[0];
        y = quat[1];
        z = quat[2];
        w = quat[3];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onRotationChange) item.onRotationChange(x, y, z, w);
        }
    }
    return this;
};

Node.prototype.setScale = function setScale (x, y, z) {
    var vec3 = this.value.vectors.scale;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onScaleChange) item.onScaleChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOpacity = function setOpacity (val) {
    if (val !== this.value.showState.opacity) {
        this.value.showState.opacity = val;
        if (!this._requestingUpdate) this._requestUpdate();

        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOpacityChange) item.onOpacityChange(val);
        }
    }
    return this;
};

/**
 * Sets the size mode being used for determining the nodes final width, height
 * and depth.
 * Size modes are a way to define the way the node's size is being calculated.
 * Size modes are enums set on the @{@link Size} constructor (and aliased on
 * the Node).
 *
 * @example
 * node.setSizeMode(Node.RELATIVE_SIZE, Node.ABSOLUTE_SIZE, Node.ABSOLUTE_SIZE);
 * // Instead of null, any proporional height or depth can be passed in, since
 * // it would be ignored in any case.
 * node.setProportionalSize(0.5, null, null);
 * node.setAbsoluteSize(null, 100, 200);
 *
 * @method setSizeMode
 *
 * @param {SizeMode} x    The size mode being used for determining the size in
 *                        x direction ("width").
 * @param {SizeMode} y    The size mode being used for determining the size in
 *                        y direction ("height").
 * @param {SizeMode} z    The size mode being used for determining the size in
 *                        z direction ("depth").
 */
Node.prototype.setSizeMode = function setSizeMode (x, y, z) {
    var vec3 = this.value.size.sizeMode;
    var propogate = false;
    
    if (x != null) propogate = this._resolveSizeMode(vec3, 0, x) || propogate;
    if (y != null) propogate = this._resolveSizeMode(vec3, 1, y) || propogate;
    if (z != null) propogate = this._resolveSizeMode(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onSizeModeChange) item.onSizeModeChange(x, y, z);
        }
    }
    return this;
};

/**
 * A protected method that resolves string representations of size mode
 * to numeric values and applies them.
 *
 * @method _resolveSizeMode
 *
 * @return {Bool} whether or not the sizemode has been changed for this index.
 */
Node.prototype._resolveSizeMode = function _resolveSizeMode (vec, index, val) {
    if (val.constructor === String) {
        switch (val.toLowerCase()) {
            case 'relative':
            case 'default':
                return this._vecOptionalSet(vec, index, 0);
            case 'absolute':
                return this._vecOptionalSet(vec, index, 1);
            case 'render':
                return this._vecOptionalSet(vec, index, 2);
            default: throw new Error('unknown size mode: ' + val);
        }
    }
    else return this._vecOptionalSet(vec, index, val);
};

/**
 * A proportional size defines the node's dimensions relative to its parents
 * final size.
 * Proportional sizes need to be within the range of [0, 1].
 *
 * @method setProportionalSize
 *
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 */
Node.prototype.setProportionalSize = function setProportionalSize (x, y, z) {
    var vec3 = this.value.size.proportional;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onProportionalSizeChange) item.onProportionalSizeChange(x, y, z);
        }
    }
    return this;
};

/**
 * Differential sizing can be used to add or subtract an absolute size from a
 * otherwise proportionally sized node.
 * E.g. a differential width of `-10` and a proportional width of `0.5` is
 * being interpreted as setting the node's size to 50% of its parent's width
 * *minus* 10 pixels.
 *
 * @method setDifferentialSize
 *
 * @param {Number} x    x-Size to be added to the relatively sized node in
 *                      pixels ("width").
 * @param {Number} y    y-Size to be added to the relatively sized node in
 *                      pixels ("height").
 * @param {Number} z    z-Size to be added to the relatively sized node in
 *                      pixels ("depth").
 */
Node.prototype.setDifferentialSize = function setDifferentialSize (x, y, z) {
    var vec3 = this.value.size.differential;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onDifferentialSizeChange) item.onDifferentialSizeChange(x, y, z);
        }
    }
    return this;
};

/**
 * Sets the nodes size in pixels, independent of its parent.
 *
 * @method setAbsoluteSize
 *
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 */
Node.prototype.setAbsoluteSize = function setAbsoluteSize (x, y, z) {
    var vec3 = this.value.size.absolute;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAbsoluteSizeChange) item.onAbsoluteSizeChange(x, y, z);
        }
    }
    return this;
};

Node.prototype._transformChanged = function _transformChanged (transform) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onTransformChange) item.onTransformChange(transform);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentTransformChange) item.onParentTransformChange(transform);
    }
};

Node.prototype._sizeChanged = function _sizeChanged (size) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onSizeChange) item.onSizeChange(size);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentSizeChange) item.onParentSizeChange(size);
    }
};

// DEPRICATE
Node.prototype.getFrame = function getFrame () {
    return this._globalUpdater.getFrame();
};

/**
 * returns an array of the components currently attached to this
 * node.
 *
 * @method getComponents
 *
 * @return {Array} list of components.
 */
Node.prototype.getComponents = function getComponents () {
    return this._components;
};

/**
 * Enters the node's update phase while updating its own spec and updating its components.
 *
 * @method update
 *
 * @param  {Number} time    high-resolution timstamp, usually retrieved using
 *                          requestAnimationFrame
 */
Node.prototype.update = function update (time){
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = this._components[queue.shift()];
        if (item && item.onUpdate) item.onUpdate(time);
    }

    var mySize = this.getSize();
    var myTransform = this.getTransform();
    var parent = this.getParent();
    var parentSize = parent.getSize();
    var parentTransform = parent.getTransform();
    var sizeChanged = SIZE_PROCESSOR.fromSpecWithParent(parentSize, this, mySize);

    var transformChanged = TRANSFORM_PROCESSOR.fromSpecWithParent(parentTransform, this.value, mySize, parentSize, myTransform);
    if (transformChanged) this._transformChanged(myTransform);
    if (sizeChanged) this._sizeChanged(mySize);

    this._inUpdate = false;
    this._requestingUpdate = false;

    if (!this.isMounted()) {
        // last update
        this._parent = null;
        this.value.location = null;
        this._globalUpdater = null;
    }
    else if (this._nextUpdateQueue.length) {
        this._globalUpdater.requestUpdateOnNextTick(this);
        this._requestingUpdate = true;
    }
    return this;
};

/**
 * Mounts the node and therefore its subtree by setting it as a child of the
 * passed in parent.
 *
 * @method mount
 *
 * @param  {Node} parent    parent node
 * @param  {String} myId    path to node (e.g. `body/0/1`)
 */
Node.prototype.mount = function mount (parent, myId) {
    if (this.isMounted()) return;
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this._parent = parent;
    this._globalUpdater = parent.getUpdater();
    this.value.location = myId;
    this.value.showState.mounted = true;

    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onMount) item.onMount(this, i);
    }

    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onParentMount) item.onParentMount(this, myId, i);
    }

    if (this._requestingUpdate) this._requestUpdate(true);
    return this;
};

/**
 * Dismounts (detaches) the node from the scene graph by removing it as a
 * child of its parent.
 *
 * @method dismount
 */
Node.prototype.dismount = function dismount () {
    if (!this.isMounted()) return;
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this.value.showState.mounted = false;

    this._parent.removeChild(this);

    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onDismount) item.onDismount();
    }

    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onParentDismount) item.onParentDismount();
    }

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Function to be invoked by the parent as soon as the parent is
 * being mounted.
 *
 * @method onParentMount
 *
 * @param  {Node} parent        The parent node.
 * @param  {String} parentId    The parent id (path to parent).
 * @param  {Number} index       Id the node should be mounted to.
 */
Node.prototype.onParentMount = function onParentMount (parent, parentId, index) {
    return this.mount(parent, parentId + '/' + index);
};

/**
 * Function to be invoked by the parent as soon as the parent is being
 * unmounted.
 *
 * @method onParentDismount
 */
Node.prototype.onParentDismount = function onParentDismount () {
    return this.dismount();
};

/**
 * Method to be called in order to dispatch an event to the node and all its
 * components. Note that this doesn't recurse the subtree.
 *
 * @method receive
 *
 * @param  {String} type   The event type (e.g. "click").
 * @param  {Object} ev     The event payload object to be dispatched.
 */
Node.prototype.receive = function receive (type, ev) {
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;
    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onReceive) item.onReceive(type, ev);
    }
    return this;
};


Node.prototype._requestUpdateWithoutArgs = function _requestUpdateWithoutArgs () {
    if (!this._requestingUpdate) this._requestUpdate();
};

Node.prototype.onUpdate = Node.prototype.update;

Node.prototype.onParentShow = Node.prototype.show;

Node.prototype.onParentHide = Node.prototype.hide;

Node.prototype.onParentTransformChange = Node.prototype._requestUpdateWithoutArgs;

Node.prototype.onParentSizeChange = Node.prototype._requestUpdateWithoutArgs;

Node.prototype.onShow = Node.prototype.show;

Node.prototype.onHide = Node.prototype.hide;

Node.prototype.onMount = Node.prototype.mount;

Node.prototype.onDismount = Node.prototype.dismount;

Node.prototype.onReceive = Node.prototype.receive;

module.exports = Node;

},{"./Size":21,"./Transform":22}],20:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

var Dispatch = require('./Dispatch');
var Node = require('./Node');
var Size = require('./Size');

/**
 * Scene is the bottom of the scene graph. It is it's own
 * parent and provides the global updater to the scene graph.
 *
 * @class Scene
 * @constructor
 *
 * @param {String} selector a string which is a dom selector
 *                 signifying which dom element the context
 *                 should be set upon
 * @param {Famous} a class which conforms to Famous' interface
 *                 it needs to be able to send methods to
 *                 the renderers and update nodes in the scene graph
 */
function Scene (selector, updater) {
    if (!selector) throw new Error('Scene needs to be created with a DOM selector');
    if (!updater) throw new Error('Scene needs to be created with a class like Famous');

    Node.call(this);         // Scene inherits from node

    this._updater = updater; // The updater that will both
                             // send messages to the renderers
                             // and update dirty nodes 

    this._dispatch = new Dispatch(this); // instantiates a dispatcher
                                         // to send events to the scene
                                         // graph below this context
    
    this._selector = selector; // reference to the DOM selector
                               // that represents the elemnent
                               // in the dom that this context
                               // inhabits

    this.onMount(this, selector); // Mount the context to itself
                                  // (it is its own parent)
    
    this._updater                  // message a request for the dom
        .message('NEED_SIZE_FOR')  // size of the context so that
        .message(selector);        // the scene graph has a total size

    this.show(); // the context begins shown (it's already present in the dom)

}

// Scene inherits from node
Scene.prototype = Object.create(Node.prototype);
Scene.prototype.constructor = Scene;

/**
 * Scene getUpdater function returns the passed in updater
 *
 * @return {Famous} the updater for this Scene
 */
Scene.prototype.getUpdater = function getUpdater () {
    return this._updater;
};

/**
 * Returns the selector that the context was instantiated with
 *
 * @return {String} dom selector
 */
Scene.prototype.getSelector = function getSelector () {
    return this._selector;
};

/**
 * Returns the dispatcher of the context. Used to send events
 * to the nodes in the scene graph.
 *
 * @return {Dispatch} the Scene's Dispatch
 */
Scene.prototype.getDispatch = function getDispatch () {
    return this._dispatch;
};

/**
 * Receives an event. If the event is 'CONTEXT_RESIZE' it sets the size of the scene
 * graph to the payload, which must be an array of numbers of at least
 * length three representing the pixel size in 3 dimensions.
 *
 * @param {String} event
 * @param {*} payload
 */
Scene.prototype.onReceive = function onReceive (event, payload) {
    // TODO: In the future the dom element that the context is attached to
    // should have a representation as a component. It would be render sized
    // and the context would receive its size the same way that any render size
    // component receives its size.
    if (event === 'CONTEXT_RESIZE') {
        
        if (payload.length < 2) 
            throw new Error(
                    'CONTEXT_RESIZE\'s payload needs to be at least a pair' +
                    ' of pixel sizes'
            );

        this.setSizeMode(Size.ABSOLUTE, Size.ABSOLUTE, Size.ABSOLUTE);
        this.setAbsoluteSize(payload[0],
                             payload[1],
                             payload[2] ? payload[2] : 0);

    }
};

module.exports = Scene;


},{"./Dispatch":16,"./Node":19,"./Size":21}],21:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The Size class is responsible for processing Size from a node
 * @constructor {Size}
 */
function Size () {
    this._size = new Float32Array(3);
}

// an enumeration of the different types of size modes
Size.RELATIVE = 0;
Size.ABSOLUTE = 1;
Size.RENDER = 2;
Size.DEFAULT = Size.RELATIVE;

/**
 * fromSpecWithParent takes the parent node's size, the target nodes spec,
 * and a target array to write to. Using the node's size mode it calculates 
 * a final size for the node from the node's spec. Returns whether or not
 * the final size has changed from its last value.
 *
 * @param {Array} parent node's calculated size
 * @param {Node.Spec} the target node's spec
 * @param {Array} an array to write the result to
 *
 * @return {Boolean} true if the size of the node has changed.
 */
Size.prototype.fromSpecWithParent = function fromSpecWithParent (parentSize, node, target) {
    var spec = node.getValue().spec;
    var components = node.getComponents();
    var mode = spec.size.sizeMode;
    var prev;
    var changed = false;
    var len = components.length;
    var j;
    for (var i = 0 ; i < 3 ; i++) {
        switch (mode[i]) {
            case Size.RELATIVE:
                prev = target[i];
                target[i] = parentSize[i] * spec.size.proportional[i] + spec.size.differential[i];
                break;
            case Size.ABSOLUTE:
                prev = target[i];
                target[i] = spec.size.absolute[i];
                break;
            case Size.RENDER:
                var candidate;
                for (j = 0; j < len ; j++) {
                    if (components[j].getRenderSize) {
                        candidate = components[j].getRenderSize()[i];
                        prev = target[i];
                        target[i] = target[i] < candidate || target[i] === 0 ? candidate : target[i];
                    }
                }
                break;
        }
        changed = changed || prev !== target[i];
    }
    return changed;
};

module.exports = Size;

},{}],22:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The transform class is responsible for calculating the transform of a particular
 * node from the data on the node and its parent
 *
 * @constructor {Transform}
 */
function Transform () {
    this._matrix = new Float32Array(16);
}

/**
 * Returns the last calculated transform
 *
 * @return {Array} a transform
 */
Transform.prototype.get = function get () {
    return this._matrix;
};

/**
 * Uses the parent transform, the node's spec, the node's size, and the parent's size
 * to calculate a final transform for the node. Returns true if the transform has changed.
 *
 * @param {Array} the parent matrix
 * @param {Node.Spec} the target node's spec
 * @param {Array} the size of the node
 * @param {Array} the size of the parent
 * @param {Array} the target array to write the resulting transform to
 *
 * @return {Boolean} whether or not the transform changed
 */
Transform.prototype.fromSpecWithParent = function fromSpecWithParent (parentMatrix, spec, mySize, parentSize, target) {
    target = target ? target : this._matrix;

    // local cache of everything
    var t00         = target[0];
    var t01         = target[1];
    var t02         = target[2];
    var t10         = target[4];
    var t11         = target[5];
    var t12         = target[6];
    var t20         = target[8];
    var t21         = target[9];
    var t22         = target[10];
    var t30         = target[12];
    var t31         = target[13];
    var t32         = target[14];
    var p00         = parentMatrix[0];
    var p01         = parentMatrix[1];
    var p02         = parentMatrix[2];
    var p10         = parentMatrix[4];
    var p11         = parentMatrix[5];
    var p12         = parentMatrix[6];
    var p20         = parentMatrix[8];
    var p21         = parentMatrix[9];
    var p22         = parentMatrix[10];
    var p30         = parentMatrix[12];
    var p31         = parentMatrix[13];
    var p32         = parentMatrix[14];
    var posX        = spec.vectors.position[0];
    var posY        = spec.vectors.position[1];
    var posZ        = spec.vectors.position[2];
    var rotX        = spec.vectors.rotation[0];
    var rotY        = spec.vectors.rotation[1];
    var rotZ        = spec.vectors.rotation[2];
    var rotW        = spec.vectors.rotation[3];
    var scaleX      = spec.vectors.scale[0];
    var scaleY      = spec.vectors.scale[1];
    var scaleZ      = spec.vectors.scale[2];
    var alignX      = spec.offsets.align[0] * parentSize[0];
    var alignY      = spec.offsets.align[1] * parentSize[1];
    var alignZ      = spec.offsets.align[2] * parentSize[2];
    var mountPointX = spec.offsets.mountPoint[0] * mySize[0];
    var mountPointY = spec.offsets.mountPoint[1] * mySize[1];
    var mountPointZ = spec.offsets.mountPoint[2] * mySize[2];
    var originX     = spec.offsets.origin[0] * mySize[0];
    var originY     = spec.offsets.origin[1] * mySize[1];
    var originZ     = spec.offsets.origin[2] * mySize[2];

    var wx = rotW * rotX;
    var wy = rotW * rotY;
    var wz = rotW * rotZ;
    var xx = rotX * rotX;
    var yy = rotY * rotY;
    var zz = rotZ * rotZ;
    var xy = rotX * rotY;
    var xz = rotX * rotZ;
    var yz = rotY * rotZ;

    var rs0 = (1 - 2 * (yy + zz)) * scaleX;
    var rs1 = (2 * (xy + wz)) * scaleX;
    var rs2 = (2 * (xz - wy)) * scaleX;
    var rs3 = (2 * (xy - wz)) * scaleY;
    var rs4 = (1 - 2 * (xx + zz)) * scaleY;
    var rs5 = (2 * (yz + wx)) * scaleY;
    var rs6 = (2 * (xz + wy)) * scaleZ;
    var rs7 = (2 * (yz - wx)) * scaleZ;
    var rs8 = (1 - 2 * (xx + yy)) * scaleZ;

    var tx = alignX + posX - mountPointX + originX - (rs0 * originX + rs3 * originY + rs6 * originZ);
    var ty = alignY + posY - mountPointY + originY - (rs1 * originX + rs4 * originY + rs7 * originZ);
    var tz = alignZ + posZ - mountPointZ + originZ - (rs2 * originX + rs5 * originY + rs8 * originZ);

    target[0] = p00 * rs0 + p10 * rs1 + p20 * rs2;
    target[1] = p01 * rs0 + p11 * rs1 + p21 * rs2;
    target[2] = p02 * rs0 + p12 * rs1 + p22 * rs2;
    target[3] = 0;
    target[4] = p00 * rs3 + p10 * rs4 + p20 * rs5;
    target[5] = p01 * rs3 + p11 * rs4 + p21 * rs5;
    target[6] = p02 * rs3 + p12 * rs4 + p22 * rs5;
    target[7] = 0;
    target[8] = p00 * rs6 + p10 * rs7 + p20 * rs8;
    target[9] = p01 * rs6 + p11 * rs7 + p21 * rs8;
    target[10] = p02 * rs6 + p12 * rs7 + p22 * rs8;
    target[11] = 0;
    target[12] = p00 * tx + p10 * ty + p20 * tz + p30;
    target[13] = p01 * tx + p11 * ty + p21 * tz + p31;
    target[14] = p02 * tx + p12 * ty + p22 * tz + p32;
    target[15] = 1;

    return t00 !== target[0] ||
        t01 !== target[1] ||
        t02 !== target[2] ||
        t10 !== target[4] ||
        t11 !== target[5] ||
        t12 !== target[6] ||
        t20 !== target[8] ||
        t21 !== target[9] ||
        t22 !== target[10] ||
        t30 !== target[12] ||
        t31 !== target[13] ||
        t32 !== target[14];

};

module.exports = Transform;

},{}],23:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Clock: require('./Clock'),
    Event: require('./Event'),
    Scene: require('./Scene'),
    FamousEngine: require('./FamousEngine'),
    Dispatch: require('./Dispatch'),
    Node: require('./Node'),
    Size: require('./Size'),
    Transform: require('./Transform')
};

},{"./Clock":15,"./Dispatch":16,"./Event":17,"./FamousEngine":18,"./Node":19,"./Scene":20,"./Size":21,"./Transform":22}],24:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var CallbackStore = require('../utilities/CallbackStore');

var RENDER_SIZE = 2;

/**
 * A DOMElement is a renderable that can be added just like a "normal"
 * component to a node using `addComponent`.
 * Renderables send draw commands to the node they are attached to.
 * Those commands then get interpreted by the `DOMRenderer` in the Main thread
 * to build the actual DOM representation.
 *
 * @class DOMElement
 * @constructor
 *
 * @param {Node} node                   The entity to which the `DOMElement`
 *                                      renderable should be attached to.
 * @param {Object} options              Initial options used for instantiating
 *                                      the Node.
 * @param {Object} options.properties   CSS properties that should be added to
 *                                      the actual DOMElement on the initial draw.
 * @param {Object} options.attributes   Element attributes that should be added to
 *                                      the actual DOMElement.
 * @param {String} options.id           String to be applied as 'id' of the actual
 *                                      DOMElement.
 * @param {String} options.content      String to be applied as the content of the
 *                                      actual DOMElement.
 * @param {Boolean} options.cutout      Specifies the presence of a 'cutout' in the
 *                                      WebGL canvas over this element which allows
 *                                      for DOM and WebGL layering.  On by default.
 */
function DOMElement (node, options) {
    if (!node) throw new Error('DOMElement must be instantiated on a node');

    this._node = node;
    this._parent = null;
    this._children = [];

    this._requestingUpdate = false;
    this._renderSized = false;
    this._requestRenderSize = false;

    this._changeQueue = [];

    this._UIEvents = node.getUIEvents().slice(0);
    this._classes = [];
    this._requestingEventListeners = [];
    this._styles = {};

    this.setProperty('display', node.isShown() ? 'none' : 'block');
    this.onOpacityChange(node.getOpacity());

    for (var property in this.DEFAULT_PROPERTIES) {
        this.setProperty(property, this.DEFAULT_PROPERTIES[property]);
    }

    this._attributes = {};
    this._content = '';

    this._tagName = options && options.tagName ? options.tagName : 'div';
    this._id = node ? node.addComponent(this) : null;

    this._renderSize = [0, 0, 0];

    this._callbacks = new CallbackStore();


    if (!options) return;

    var i;
    var key;

    if (options.classes)
        for (i = 0; i < options.classes.length; i++)
            this.addClass(options.classes[i]);

    if (options.attributes)
        for (key in options.attributes)
            this.setAttribute(key, options.attributes[key]);

    if (options.properties)
        for (key in options.properties)
            this.setProperty(key, options.properties[key]);

    if (options.id) this.setId(options.id);
    if (options.content) this.setContent(options.content);
    if (options.cutout === false) this.setCutoutState(options.cutout);
}

/**
 * Serializes the state of the DOMElement. This method will be invoked by
 * @{@link Node#getValue} in order to serialize the node and possibly entire
 * scene graph hierarchies.
 *
 * @method getValue
 *
 * @return {Object}     serialized component.
 */
DOMElement.prototype.getValue = function getValue () {
    return {
        classes: this._classes,
        styles: this._styles,
        attributes: this._attributes,
        content: this._content,
        id: this._attributes.id,
        tagName: this._tagName
    };
};

/**
 * Method to be invoked by the node as soon as an update occurs. This allows
 * the DOMElement renderable to dynamically react to state changes on the Node.
 *
 * This flushes the internal draw command queue by sending individual commands
 * to the node using `sendDrawCommand`.
 *
 * @method onUpdate
 */
DOMElement.prototype.onUpdate = function onUpdate () {
    var node = this._node;
    var queue = this._changeQueue;
    var len = queue.length;

    if (len && node) {
        node.sendDrawCommand('WITH');
        node.sendDrawCommand(node.getLocation());

        while (len--) node.sendDrawCommand(queue.shift());
        if (this._requestRenderSize) {
            node.sendDrawCommand('DOM_RENDER_SIZE');
            node.sendDrawCommand(node.getLocation());
            this._requestRenderSize = false;
        }

    }

    this._requestingUpdate = false;
};

/**
 * Private method which sets the parent of the element in the DOM
 * hierarchy.
 *
 * @method _setParent
 * @protected
 *
 * @param {String} path of the parent
 */
DOMElement.prototype._setParent = function _setParent (path) {
    if (this._node) {
        var location = this._node.getLocation();
        if (location === path || location.indexOf(path) === -1)
            throw new Error('The given path isn\'t an ancestor');
        this._parent = path;
    } else throw new Error('_setParent called on an Element that isn\'t in the scene graph');
};

/**
 * Private method which adds a child of the element in the DOM
 * hierarchy.
 *
 * @method _addChild
 * @protected
 *
 * @param {String} path of the child
 */
DOMElement.prototype._addChild = function _addChild (path) {
    if (this._node) {
        var location = this._node.getLocation();
        if (path === location || path.indexOf(location) === -1)
            throw new Error('The given path isn\'t a descendent');
        if (this._children.indexOf(path) === -1) this._children.push(path);
        else throw new Error('The given path is already a child of this element');
    } else throw new Error('_addChild called on an Element that isn\'t in the scene graph');
};

/**
 * Private method which returns the path of the parent of this element
 *
 * @method _getParent
 * @protected
 */
DOMElement.prototype._getParent = function _getParent () {
    return this._parent;
};

/**
 * Private method which returns an array of paths of the children elements
 * of this element
 *
 * @method _getChildren
 * @protected
 */
DOMElement.prototype._getChildren = function _getChildren () {
    return this._children;
};

/**
 * Method to be invoked by the Node as soon as the node (or any of its
 * ancestors) is being mounted.
 *
 * @method onMount
 *
 * @param  {Node} node      Parent node to which the component should be added.
 * @param  {String} id      Path at which the component (or node) is being
 *                          attached. The path is being set on the actual
 *                          DOMElement as a `data-fa-path`-attribute.
 */
DOMElement.prototype.onMount = function onMount (node, id) {
    this._node = node;
    this._id = id;
    this._UIEvents = node.getUIEvents().slice(0);
    this.draw();
    this.setAttribute('data-fa-path', node.getLocation());
};

/**
 * Method to be invoked by the Node as soon as the node is being dismounted
 * either directly or by dismounting one of its ancestors).
 *
 * @method onDismount
 */
DOMElement.prototype.onDismount = function onDismount () {
    this.setProperty('display', 'none');
    this.setAttribute('data-fa-path', '');
    this._initialized = false;
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being shown.
 * This results into the DOMElement setting the `display` property to `block`
 * and therefore visually showing the corresponding DOMElement (again).
 *
 * @method onShow
 */
DOMElement.prototype.onShow = function onShow () {
    this.setProperty('display', 'block');
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being hidden.
 * This results into the DOMElement setting the `display` property to `none`
 * and therefore visually hiding the corresponding DOMElement (again).
 *
 * @method onHide
 */
DOMElement.prototype.onHide = function onHide () {
    this.setProperty('display', 'none');
};

/**
 * Enables or disables WebGL 'cutout' for this element, which affects
 * how the element is layered with WebGL objects in the scene.
 *
 * @method setCutoutState
 *
 * @param {Boolean} usesCutout  The presence of a WebGL 'cutout' for this element.
 */
DOMElement.prototype.setCutoutState = function setCutoutState (usesCutout) {
    this._changeQueue.push('GL_CUTOUT_STATE', usesCutout);

    if (this._initialized) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as the transform matrix associated
 * with the node changes.
 * The DOMElement will react to transform changes by sending `CHANGE_TRANSFORM`
 * commands to the `DOMRenderer`.
 *
 * @method onTransformChange
 *
 * @param  {Float32Array} transform     The final transform matrix.
 */
DOMElement.prototype.onTransformChange = function onTransformChange (transform) {
    this._changeQueue.push('CHANGE_TRANSFORM');
    for (var i = 0, len = transform.length ; i < len ; i++)
        this._changeQueue.push(transform[i]);

    this.onUpdate();
};

/**
 * Method to be invoked by the node as soon as its computed size changes.
 *
 * @method onSizeChange
 * @chainable
 *
 * @param  {Float32Array} size      Absolute, pixel size.
 * @return {DOMElement} this
 */
DOMElement.prototype.onSizeChange = function onSizeChange (size) {
    var sizeMode = this._node.getSizeMode();
    var sizedX = sizeMode[0] !== RENDER_SIZE;
    var sizedY = sizeMode[1] !== RENDER_SIZE;
    if (this._initialized)
        this._changeQueue.push('CHANGE_SIZE',
            sizedX ? size[0] : sizedX,
            sizedY ? size[1] : sizedY);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Method to be invoked by the node as soon as its opacity changes.
 *
 * @method onOpacityChange
 * @chainable
 *
 * @param  {Number} opacity      The new opacity, as a scalar from 0 to 1.
 * @return {DOMElement} this
 */
DOMElement.prototype.onOpacityChange = function onOpacityChange (opacity) {
    return this.setProperty('opacity', opacity);
};

/**
 * Method to be invoked by the node as soon as a new UIEvent is being added.
 * This results into an `ADD_EVENT_LISTENER` command being send.
 *
 * @param  {String} UIEvent     UIEvent to be subscribed to (e.g. `click`).
 */
DOMElement.prototype.onAddUIEvent = function onAddUIEvent (UIEvent) {
    if (this._UIEvents.indexOf(UIEvent) === -1) {
        this._subscribe(UIEvent);
        this._UIEvents.push(UIEvent);
    } else if (this._inDraw) {
        this._subscribe(UIEvent);
    }
    return this;
};

/**
 * Appends an `ADD_EVENT_LISTENER` command to the command queue.
 *
 * @param  {String} UIEvent Event type (e.g. `click`)
 */
DOMElement.prototype._subscribe = function _subscribe (UIEvent) {
    if (this._initialized) {
        this._changeQueue.push('SUBSCRIBE', UIEvent, true);
    }
    if (!this._requestingUpdate) {
        this._requestUpdate();
    }
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as the underlying size mode
 * changes. This results into the size being fetched from the node in
 * order to update the actual, rendered size.
 *
 * @method onSizeModeChange
 */
DOMElement.prototype.onSizeModeChange = function onSizeModeChange (x, y, z) {
    if (x === RENDER_SIZE || y === RENDER_SIZE || z === RENDER_SIZE) {
        this._renderSized = true;
        this._requestRenderSize = true;
    }
    this.onSizeChange(this._node.getSize());
};


DOMElement.prototype.getRenderSize = function getRenderSize () {
    return this._renderSize;
};

DOMElement.prototype._requestUpdate = function _requestUpdate () {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

/**
 * Initializes the DOMElement by sending the `INIT_DOM` command. This creates
 * or reallocates a new Element in the actual DOM hierarchy.
 *
 * @method init
 */
DOMElement.prototype.init = function init () {
    this._changeQueue.push('INIT_DOM', this._tagName);
    this._initialized = true;
    this.onTransformChange(this._node.getTransform());
    this.onSizeChange(this._node.getSize());
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Sets the id attribute of the DOMElement.
 *
 * @method setId
 * @chainable
 *
 * @param {String} id   New id to be set.
 */
DOMElement.prototype.setId = function setId (id) {
    this.setAttribute('id', id);
    return this;
};

/**
 * Adds a new class to the internal class list of the underlying Element in the
 * DOM.
 *
 * @method addClass
 * @chainable
 *
 * @param {String} value    New class name to be added.
 * @return {DOMElement} this
 */
DOMElement.prototype.addClass = function addClass (value) {
    if (this._classes.indexOf(value) < 0) {
        if (this._initialized) this._changeQueue.push('ADD_CLASS', value);
        this._classes.push(value);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
        return this;
    }

    if (this._inDraw) {
        if (this._initialized) this._changeQueue.push('ADD_CLASS', value);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Removes a class from the DOMElement's classList.
 *
 * @method removeClass
 *
 * @param  {String} value       Class name to be removed.
 * @return {DOMElement} this
 */
DOMElement.prototype.removeClass = function removeClass (value) {
    var index = this._classes.indexOf(value);

    if (index < 0) return this;

    this._changeQueue.push('REMOVE_CLASS', value);

    this._classes.splice(index, 1);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};


/**
 * Checks if the DOMElement has the passed in class.
 *
 * @method  hasClass
 *
 * @param  {String} value   The class name.
 * @return {Boolean}        Boolean value indicating whether the passed in class
 *                          name is in the DOMElement's class list.
 */
DOMElement.prototype.hasClass = function hasClass (value) {
    return this._classes.indexOf(value) !== -1;
};

/**
 * Sets an attribute of the DOMElement.
 *
 * @method setAttribute
 *
 * @param {String} name     Attribute key (e.g. `src`)
 * @param {String} value    Attribute value (e.g. `http://famo.us`)
 */
DOMElement.prototype.setAttribute = function setAttribute (name, value) {
    if (this._attributes[name] !== value || this._inDraw) {
        this._attributes[name] = value;
        if (this._initialized) this._changeQueue.push('CHANGE_ATTRIBUTE', name, value);
        if (!this._requestUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Sets a CSS property.
 *
 * @method setProperty
 * @chainable
 *
 * @param {String} name  Name of the CSS rule (e.g. `background-color`).
 * @param {String} value Value of CSS property (e.g. `red`).
 * @return {DOMElement} this
 */
DOMElement.prototype.setProperty = function setProperty (name, value) {
    if (this._styles[name] !== value || this._inDraw) {
        this._styles[name] = value;
        if (this._initialized) this._changeQueue.push('CHANGE_PROPERTY', name, value);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
    }
    return this;
};

/**
 * Sets the content of the DOMElement. This is using `innerHTML`, escaping user
 * generated content is therefore essential for security purposes.
 *
 * @method setContent
 *
 * @param {String} content     Content to be set using `.innerHTML = ...`
 */
DOMElement.prototype.setContent = function setContent (content) {
    if (this._content !== content || this._inDraw) {
        this._content = content;
        if (this._initialized) this._changeQueue.push('CHANGE_CONTENT', content);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
    }
    return this;
};

/**
 * Subscribes to a DOMElement using.
 *
 * @method on
 *
 * @param  {String} event       The event type (e.g. `click`).
 * @param  {Function} listener  Handler function for the specified event type
 *                              in which the payload event object will be
 *                              passed into.
 */
DOMElement.prototype.on = function on (event, listener) {
    return this._callbacks.on(event, listener);
};

/**
 * Function to be invoked by the Node whenever an UIEvent is being received.
 * There are two different ways to subscribe for those events:
 *
 * 1. By overriding the onReceive method (and possibly using `switch` in order
 *     to differentiate between the different event types).
 * 2. By using @{@link DOMElement#on} and using the built-in
 *     @{@linkCallbackStore}.
 *
 * @method onReceive
 *
 * @param  {String} event   Event type (e.g. `click`).
 * @param  {Object} payload Event object.
 */
DOMElement.prototype.onReceive = function onReceive (event, payload) {
    if (event === 'resize') {
        this._renderSize[0] = payload.val[0];
        this._renderSize[1] = payload.val[1];
        if (!this._requestingUpdate) this._requestUpdate();
    }
    this._callbacks.trigger(event, payload);
};

/**
 * The draw function is being used in order to allow mutating the DOMElement
 * before actually mounting the corresponding node.
 *
 * @method draw
 * @private
 */
DOMElement.prototype.draw = function draw () {
    var key;
    var i;
    var len;

    this._inDraw = true;

    this.init();

    for (i = 0, len = this._classes.length ; i < len ; i++)
        this.addClass(this._classes[i]);

    if (this._content) this.setContent(this._content);

    for (key in this._styles)
        if (this._styles[key])
            this.setProperty(key, this._styles[key]);

    for (key in this._attributes)
        if (this._attributes[key])
            this.setAttribute(key, this._attributes[key]);

    for (i = 0, len = this._UIEvents.length ; i < len ; i++)
        this.onAddUIEvent(this._UIEvents[i]);

    this._inDraw = false;
};

DOMElement.prototype.DEFAULT_PROPERTIES = {
    'position': 'absolute',
    '-webkit-transform-origin': '0% 0%',
    'transform-origin': '0% 0%',
    '-webkit-backface-visibility': 'visible',
    'backface-visibility': 'visible',
    '-webkit-transform-style': 'preserve-3d',
    'transform-style': 'preserve-3d',
    '-webkit-tap-highlight-color': 'transparent',
    'pointer-events': 'auto',
    'z-index': '1',
    'box-sizing': 'border-box',
    '-moz-box-sizing': 'border-box',
    '-webkit-box-sizing': 'border-box'
};

module.exports = DOMElement;

},{"../utilities/CallbackStore":90}],25:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    DOMElement: require('./DOMElement')
};

},{"./DOMElement":24}],26:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var ElementCache = require('./ElementCache');
var math = require('./Math');
var vendorPrefix = require('../utilities/vendorPrefix');
var eventMap = require('./events/EventMap');

var TRANSFORM = null;

/**
 * DOMRenderer is a class responsible for adding elements
 * to the DOM and writing to those elements.
 * There is a DOMRenderer per context, represented as an
 * element and a selector. It is instantiated in the
 * context class.
 *
 * @class DOMRenderer
 *
 * @param {HTMLElement} an element.
 * @param {String} the selector of the element.
 * @param {Compositor}
 */
function DOMRenderer (element, selector, compositor) {
    TRANSFORM = TRANSFORM || vendorPrefix('transform');
    this._compositor = compositor; // a reference to the compositor

    this._target = null; // a register for holding the current
                         // element that the Renderer is operating
                         // upon

    this._parent = null; // a register for holding the parent
                         // of the target

    this._path = null; // a register for holding the path of the target
                       // this register must be set first, and then
                       // children, target, and parent are all looked
                       // up from that.

    this._children = []; // a register for holding the children of the
                         // current target.

    this._root = new ElementCache(element, selector); // the root
                                                      // of the dom tree that this
                                                      // renderer is responsible
                                                      // for

    this._boundTriggerEvent = this._triggerEvent.bind(this);

    this._selector = selector;

    this._elements = {};

    this._elements[selector] = this._root;

    this.perspectiveTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._VPtransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

    this._size = [null, null];
}


/**
 * Attaches an EventListener to the element associated with the passed in path.
 * Prevents the default browser action on all subsequent events if
 * `preventDefault` is truthy.
 * All incoming events will be forwarded to the compositor by invoking the
 * `sendEvent` method.
 * Delegates events if possible by attaching the event listener to the context.
 *
 * @method  subscribe
 *
 * @param  {String} path            Path uniquely describing the location of the
 *                                  element in the scene graph.
 * @param  {String} type            DOM event type (e.g. click, mouseover).
 * @param  {Boolean} preventDefault Whether or not the default browser action
 *                                  should be prevented.
 */ 
DOMRenderer.prototype.subscribe = function subscribe(type, preventDefault) {
    // TODO preventDefault should be a separate command
    this._assertTargetLoaded();
    
    this._target.preventDefault[type] = preventDefault;
    this._target.subscribe[type] = true;
    
    if (
        !this._target.listeners[type] && !this._root.listeners[type]
    ) {
        var target = eventMap[type][1] ? this._root : this._target;
        target.listeners[type] = this._boundTriggerEvent;
        target.element.addEventListener(type, this._boundTriggerEvent);
    }
};

/**
 * Function to be added using `addEventListener` to the corresponding
 * DOMElement.
 *
 * @method  _triggerEvent
 * @private
 *
 * @param  {Event} ev  DOM Event payload.
 */
DOMRenderer.prototype._triggerEvent = function _triggerEvent(ev) {
    // Use ev.path, which is an array of Elements (polyfilled if needed).
    var evPath = ev.path ? ev.path : _getPath(ev);
    // First element in the path is the element on which the event has actually
    // been emitted.
    for (var i = 0; i < evPath.length; i++) {
        // Skip nodes that don't have a dataset property or data-fa-path
        // attribute.
        if (!evPath[i].dataset) continue;
        var path = evPath[i].dataset.faPath;
        if (!path) continue;
        
        // Stop further event propogation and path traversal as soon as the
        // first ElementCache subscribing for the emitted event has been found.
        if (this._elements[path].subscribe[ev.type]) {
            ev.stopPropagation();

            // Optionally preventDefault. This needs forther consideration and
            // should be optional. Eventually this should be a separate command/
            // method.
            if (this._elements[path].preventDefault[ev.type]) {
                ev.preventDefault();
            }

            var NormalizedEventConstructor = eventMap[ev.type][0];

            // Finally send the event to the Worker Thread through the
            // compositor.
            this._compositor.sendEvent(path, ev.type, new NormalizedEventConstructor(ev));

            break;
        }
    }
};


/**
 * getSizeOf gets the dom size of a particular famo.us element
 *
 * @method getSizeOf
 * @param {String} path
 *
 * @return {Array} a vec3 of the offset size of the dom element
 */
DOMRenderer.prototype.getSizeOf = function getSizeOf (path) {
    var element = this._elements[path];
    if (!element) return;

    var res = {val: element.size};
    this._compositor.sendEvent(path, 'resize', res);
    return res;
};

function _getPath (ev) {
    // TODO move into _triggerEvent, avoid object allocation
    var path = [];
    var node = ev.target;
    while (node !== document.body) {
        path.push(node);
        node = node.parentNode;
    }
    return path;
}


/**
 * Determines the size of the context by querying the DOM for `offsetWidth` and
 * `offsetHeight`.
 *
 * @method  getSize
 *
 * @return {Array}  Offset size.
 */
DOMRenderer.prototype.getSize = function getSize () {
    this._size[0] = this._root.element.offsetWidth;
    this._size[1] = this._root.element.offsetHeight;
    return this._size;
};

DOMRenderer.prototype._getSize = DOMRenderer.prototype.getSize;


/**
 * Executes the retrieved draw commands. Draw commands only refer to the
 * cross-browser normalized `transform` property.
 *
 * @method  draw
 *
 * @param  {type} renderState description
 * @return {type}             description
 */
DOMRenderer.prototype.draw = function draw (renderState) {
    if (renderState.perspectiveDirty) {
        this.perspectiveDirty = true;

        this.perspectiveTransform[0] = renderState.perspectiveTransform[0];
        this.perspectiveTransform[1] = renderState.perspectiveTransform[1];
        this.perspectiveTransform[2] = renderState.perspectiveTransform[2];
        this.perspectiveTransform[3] = renderState.perspectiveTransform[3];

        this.perspectiveTransform[4] = renderState.perspectiveTransform[4];
        this.perspectiveTransform[5] = renderState.perspectiveTransform[5];
        this.perspectiveTransform[6] = renderState.perspectiveTransform[6];
        this.perspectiveTransform[7] = renderState.perspectiveTransform[7];

        this.perspectiveTransform[8] = renderState.perspectiveTransform[8];
        this.perspectiveTransform[9] = renderState.perspectiveTransform[9];
        this.perspectiveTransform[10] = renderState.perspectiveTransform[10];
        this.perspectiveTransform[11] = renderState.perspectiveTransform[11];

        this.perspectiveTransform[12] = renderState.perspectiveTransform[12];
        this.perspectiveTransform[13] = renderState.perspectiveTransform[13];
        this.perspectiveTransform[14] = renderState.perspectiveTransform[14];
        this.perspectiveTransform[15] = renderState.perspectiveTransform[15];
    }

    if (renderState.viewDirty || renderState.perspectiveDirty) {
        math.multiply(this._VPtransform, this.perspectiveTransform, renderState.viewTransform);
        this._root.element.style[TRANSFORM] = this._stringifyMatrix(this._VPtransform);
    }
};


/**
 * Internal helper function used for ensuring that a path is currently loaded.
 *
 * @method  _asserPathLoaded
 * @private
 *
 * @throws  Throws an error if no path is loaded.
 */
DOMRenderer.prototype._assertPathLoaded = function _asserPathLoaded () {
    if (!this._path) throw new Error('path not loaded');
};

/**
 * Internal helper function used for ensuring that a parent is currently loaded.
 *
 * @method  _asserPathLoaded
 * @private
 *
 * @throws  Throws an error if no parent is loaded.
 */
DOMRenderer.prototype._assertParentLoaded = function _assertParentLoaded () {
    if (!this._parent) throw new Error('parent not loaded');
};

/**
 * Internal helper function used for ensuring that children are currently
 * loaded.
 *
 * @method  _asserPathLoaded
 * @private
 *
 * @throws  Throws an error if no chilren are loaded.
 */
DOMRenderer.prototype._assertChildrenLoaded = function _assertChildrenLoaded () {
    if (!this._children) throw new Error('children not loaded');
};

/**
 * Internal helper function used for ensuring that a target is currently loaded.
 *
 * @method  _assertTargetLoaded
 *
 * @throws  Throws an error if no target is currently loaded.
 */
DOMRenderer.prototype._assertTargetLoaded = function _assertTargetLoaded () {
    if (!this._target) throw new Error('No target loaded');
};

/**
 * Finds and sets the parent of the currently loaded element (path).
 *
 * @method  findParent
 * @private
 *
 * @return {ElementCache}   Parent element.
 */
DOMRenderer.prototype.findParent = function findParent () {
    this._assertPathLoaded();

    var path = this._path;
    var parent;

    while (!parent && path.length) {
        path = path.substring(0, path.lastIndexOf('/'));
        parent = this._elements[path];
    }
    this._parent = parent;
    return parent;
};


/**
 * Finds all children of the currently loaded element.
 *
 * @method findChildren
 * @private
 *
 * @param  {Array} [array]  Output-Array used for writing to (subsequently
 *                          appending children).
 * @return {Array}          Result
 */
DOMRenderer.prototype.findChildren = function findChildren (array) {
    // TODO Optimize me.
    this._assertPathLoaded();

    var path = this._path + '/';
    var keys = Object.keys(this._elements);
    var i = 0;
    var len;
    array = array ? array : this._children;

    this._children.length = 0;

    while (i < keys.length) {
        if (keys[i].indexOf(path) === -1 || keys[i] === path) keys.splice(i, 1);
        else i++;
    }
    var currentPath;
    var j = 0;
    for (i = 0 ; i < keys.length ; i++) {
        currentPath = keys[i];
        for (j = 0 ; j < keys.length ; j++) {
            if (i !== j && keys[j].indexOf(currentPath) !== -1) {
                keys.splice(j, 1);
                i--;
            }
        }
    }
    for (i = 0, len = keys.length ; i < len ; i++)
        array[i] = this._elements[keys[i]];

    return array;
};


/**
 * Used for determining the target loaded under the current path.
 *
 * @method  findTarget
 *
 * @return {ElementCache|undefined}     Element loaded under defined path.
 */
DOMRenderer.prototype.findTarget = function findTarget () {
    this._target = this._elements[this._path];
    return this._target;
};


/**
 * Loads the passed in path.
 *
 * @method  loadPath
 *
 * @param  {String} path    Path to be loaded.
 * @return {String}         Loaded path
 */
DOMRenderer.prototype.loadPath = function loadPath (path) {
    this._path = path;
    return this._path;
};


/**
 * Inserts a DOMElement at the currently loaded path, assuming no target is
 * loaded. Only one DOMElement can be associated with each path.
 *
 * @method  insertEl
 *
 * @param  {String} tagName     Tag name (capitalization will be normalized).
 */
DOMRenderer.prototype.insertEl = function insertEl (tagName) {
    if (!this._target ||
         this._target.element.tagName.toLowerCase() === tagName.toLowerCase()) {

        this.findParent();
        this.findChildren();

        this._assertParentLoaded();
        this._assertChildrenLoaded();

        if (this._target) this._parent.element.removeChild(this._target.element);

        this._target = new ElementCache(document.createElement(tagName), this._path);
        this._parent.element.appendChild(this._target.element);
        this._elements[this._path] = this._target;

        for (var i = 0, len = this._children.length ; i < len ; i++) {
            this._target.element.appendChild(this._children[i].element);
        }
    }
};


/**
 * Sets a property on the currently loaded target.
 *
 * @method  setProperty
 *
 * @param  {String} name    Property name (e.g. background, color, font)
 * @param  {String} value   Proprty value (e.g. black, 20px)
 */
DOMRenderer.prototype.setProperty = function setProperty (name, value) {
    this._assertTargetLoaded();
    this._target.element.style[name] = value;
};


/**
 * Sets the size of the currently loaded target.
 * Removes any explicit sizing constraints when passed in `false`
 * ("true-sizing").
 *
 * @method  setSize
 *
 * @param  {Number|false} width   Width to be set.
 * @param  {Number|false} height  Height to be set.
 */
DOMRenderer.prototype.setSize = function setSize (width, height) {
    this._assertTargetLoaded();
    
    this.setWidth(width);
    this.setHeight(height);
};

DOMRenderer.prototype.setWidth = function setWidth(width) {
    this._assertTargetLoaded();
    
    var contentWrapper = this._target.content;
    
    if (width === false) {
        this._target.explicitWidth = true;
        if (contentWrapper) contentWrapper.style.width = '';
        width = contentWrapper ? contentWrapper.offsetWidth : 0;
        this._target.element.style.width = width + 'px';
    } else {
        this._target.explicitWidth = false;
        if (contentWrapper) contentWrapper.style.width = width + 'px';
        this._target.element.style.width = width + 'px';
    }
    
    this._target.size[0] = width;
};

DOMRenderer.prototype.setHeight = function setHeight(height) {
    this._assertTargetLoaded();
    
    var contentWrapper = this._target.content;
    
    if (height === false) {
        this._target.explicitHeight = true;
        if (contentWrapper) contentWrapper.style.height = '';
        height = contentWrapper ? contentWrapper.offsetHeight : 0;
        this._target.element.style.height = height + 'px';
    } else {
        this._target.explicitHeight = false;
        if (contentWrapper) contentWrapper.style.height = height + 'px';
        this._target.element.style.height = height + 'px';
    }
    
    this._target.size[1] = height;
};

/**
 * Sets an attribute on the currently loaded target.
 *
 * @method  setAttribute
 *
 * @param  {String} name    Attribute name (e.g. href)
 * @param  {String} value   Attribute value (e.g. http://famo.us)
 */
DOMRenderer.prototype.setAttribute = function setAttribute (name, value) {
    this._assertTargetLoaded();
    this._target.element.setAttribute(name, value);
};

/**
 * Sets the `innerHTML` content of the currently loaded target.
 *
 * @method  setContent
 *
 * @param  {String} content     Content to be set as `innerHTML`.
 */
DOMRenderer.prototype.setContent = function setContent (content) {
    this._assertTargetLoaded();
    this.findChildren();
    
    if (!this._target.content) {
        this._target.content = document.createElement('div');
        this._target.content.style.position = 'absolute';
        this._target.element.insertBefore(
            this._target.content,
            this._target.element.firstChild
        );
    }
    this._target.content.innerHTML = content;
    
    this.setSize(
        this._target.explicitWidth ? false : this._target.size[0],
        this._target.explicitHeight ? false : this._target.size[1]
    );
};


/**
 * Sets the passed in transform matrix (world space). Inverts the parent's world
 * transform.
 *
 * @method  setMatrix
 *
 * @param  {Float32Array} [transform]   World transform.
 */
DOMRenderer.prototype.setMatrix = function setMatrix (transform) {
    // TODO Don't multiply matrics in the first place.
    this._assertTargetLoaded();
    this.findParent();
    var worldTransform = this._target.worldTransform;
    var changed = false;

    var i;
    var len;

    if (transform)
        for (i = 0, len = 16 ; i < len ; i++) {
            changed = changed ? changed : worldTransform[i] === transform[i];
            worldTransform[i] = transform[i];
        }
    else changed = true;

    if (changed) {
        math.invert(this._target.invertedParent, this._parent.worldTransform);
        math.multiply(this._target.finalTransform, this._target.invertedParent, worldTransform);

        // TODO: this is a temporary fix for draw commands
        // coming in out of order
        var children = this.findChildren([]);
        var previousPath = this._path;
        var previousTarget = this._target;
        for (i = 0, len = children.length ; i < len ; i++) {
            this._target = children[i];
            this._path = this._target.path;
            this.setMatrix();
        }
        this._path = previousPath;
        this._target = previousTarget;
    }

    this._target.element.style[TRANSFORM] = this._stringifyMatrix(this._target.finalTransform);
};


/**
 * Adds a class to the classList associated with the currently loaded target.
 *
 * @method  addClass
 *
 * @param  {String} domClass    Class name to be added to the current target.
 */
DOMRenderer.prototype.addClass = function addClass (domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.add(domClass);
};


/**
 * Removes a class from the classList associated with the currently loaded
 * target.
 *
 * @method  removeClass
 *
 * @param  {String} domClass    Class name to be removed from currently loaded
 *                              target.
 */
DOMRenderer.prototype.removeClass = function removeClass (domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.remove(domClass);
};


/**
 * Stringifies the passed in matrix for setting the `transform` property.
 *
 * @method  _stringifyMatrix
 * @private
 *
 * @param  {Array} m    Matrix as an array or array-like object.
 * @return {String}     Stringified matrix as `matrix3d`-property.
 */
DOMRenderer.prototype._stringifyMatrix = function _stringifyMatrix(m) {
    var r = 'matrix3d(';

    r += (m[0] < 0.000001 && m[0] > -0.000001) ? '0,' : m[0] + ',';
    r += (m[1] < 0.000001 && m[1] > -0.000001) ? '0,' : m[1] + ',';
    r += (m[2] < 0.000001 && m[2] > -0.000001) ? '0,' : m[2] + ',';
    r += (m[3] < 0.000001 && m[3] > -0.000001) ? '0,' : m[3] + ',';
    r += (m[4] < 0.000001 && m[4] > -0.000001) ? '0,' : m[4] + ',';
    r += (m[5] < 0.000001 && m[5] > -0.000001) ? '0,' : m[5] + ',';
    r += (m[6] < 0.000001 && m[6] > -0.000001) ? '0,' : m[6] + ',';
    r += (m[7] < 0.000001 && m[7] > -0.000001) ? '0,' : m[7] + ',';
    r += (m[8] < 0.000001 && m[8] > -0.000001) ? '0,' : m[8] + ',';
    r += (m[9] < 0.000001 && m[9] > -0.000001) ? '0,' : m[9] + ',';
    r += (m[10] < 0.000001 && m[10] > -0.000001) ? '0,' : m[10] + ',';
    r += (m[11] < 0.000001 && m[11] > -0.000001) ? '0,' : m[11] + ',';
    r += (m[12] < 0.000001 && m[12] > -0.000001) ? '0,' : m[12] + ',';
    r += (m[13] < 0.000001 && m[13] > -0.000001) ? '0,' : m[13] + ',';
    r += (m[14] < 0.000001 && m[14] > -0.000001) ? '0,' : m[14] + ',';

    r += m[15] + ')';
    return r;
};

module.exports = DOMRenderer;

},{"../utilities/vendorPrefix":100,"./ElementCache":27,"./Math":28,"./events/EventMap":31}],27:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Transform identity matrix.
 */ 
var ident = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];

/**
 * ElementCache is being used for keeping track of an element's DOM Element,
 * path, world transform, inverted parent, final transform (as being used for
 * setting the actual `transform`-property) and post render size (final size as
 * being rendered to the DOM).
 * 
 * @class   ElementCache
 *  
 * @param  {Element} element    DOMElement
 * @param  {String} path        Path used for uniquely identifying the location
 *                              in the scene graph.
 */ 
function ElementCache (element, path) {
    this.element = element;
    this.path = path;
    this.content = null;
    this.size = new Int16Array(3);
    this.explicitHeight = false;
    this.explicitWidth = false;
    this.worldTransform = new Float32Array(ident);
    this.invertedParent = new Float32Array(ident);
    this.finalTransform = new Float32Array(ident);
    this.postRenderSize = new Float32Array(2);
    this.listeners = {};
    this.preventDefault = {};
    this.subscribe = {};
}

module.exports = ElementCache;

},{}],28:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

function invert (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
}

function multiply (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3],
        b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7],
        b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11],
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    var changed = false;
    var out0, out1, out2, out3;

    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[0] ||
                        out1 === out[1] ||
                        out2 === out[2] ||
                        out3 === out[3];

    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;

    b0 = b4; b1 = b5; b2 = b6; b3 = b7;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[4] ||
                        out1 === out[5] ||
                        out2 === out[6] ||
                        out3 === out[7];

    out[4] = out0;
    out[5] = out1;
    out[6] = out2;
    out[7] = out3;

    b0 = b8; b1 = b9; b2 = b10; b3 = b11;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[8] ||
                        out1 === out[9] ||
                        out2 === out[10] ||
                        out3 === out[11];

    out[8] = out0;
    out[9] = out1;
    out[10] = out2;
    out[11] = out3;

    b0 = b12; b1 = b13; b2 = b14; b3 = b15;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[12] ||
                        out1 === out[13] ||
                        out2 === out[14] ||
                        out3 === out[15];

    out[12] = out0;
    out[13] = out1;
    out[14] = out2;
    out[15] = out3;

    return out;
}

module.exports = {
    multiply: multiply,
    invert: invert
};

},{}],29:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

function CompositionEvent(ev) {
    // [Constructor(DOMString typeArg, optional CompositionEventInit compositionEventInitDict)]
    // interface CompositionEvent : UIEvent {
    //     readonly    attribute DOMString data;
    // };

    UIEvent.call(this, ev);
    this.data = ev.data;
}

CompositionEvent.prototype = Object.create(UIEvent.prototype);
CompositionEvent.prototype.constructor = CompositionEvent;

CompositionEvent.prototype.toString = function toString () {
    return 'CompositionEvent';
};

module.exports = CompositionEvent;

},{"./UIEvent":37}],30:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

function Event(ev) {
    // [Constructor(DOMString type, optional EventInit eventInitDict),
    //  Exposed=Window,Worker]
    // interface Event {
    //   readonly attribute DOMString type;
    //   readonly attribute EventTarget? target;
    //   readonly attribute EventTarget? currentTarget;

    //   const unsigned short NONE = 0;
    //   const unsigned short CAPTURING_PHASE = 1;
    //   const unsigned short AT_TARGET = 2;
    //   const unsigned short BUBBLING_PHASE = 3;
    //   readonly attribute unsigned short eventPhase;

    //   void stopPropagation();
    //   void stopImmediatePropagation();

    //   readonly attribute boolean bubbles;
    //   readonly attribute boolean cancelable;
    //   void preventDefault();
    //   readonly attribute boolean defaultPrevented;

    //   [Unforgeable] readonly attribute boolean isTrusted;
    //   readonly attribute DOMTimeStamp timeStamp;

    //   void initEvent(DOMString type, boolean bubbles, boolean cancelable);
    // };

    this.type = ev.type;
    this.defaultPrevented = ev.defaultPrevented;
    this.timeStamp = ev.timeStamp;
}

Event.prototype.toString = function toString () {
    return 'Event';
};

module.exports = Event;

},{}],31:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

 /*jshint -W079 */

'use strict';

var CompositionEvent = require('./CompositionEvent');
var Event = require('./Event');
var FocusEvent = require('./FocusEvent');
var InputEvent = require('./InputEvent');
var KeyboardEvent = require('./KeyboardEvent');
var MouseEvent = require('./MouseEvent');
var TouchEvent = require('./TouchEvent');
var UIEvent = require('./UIEvent');
var WheelEvent = require('./WheelEvent');

var EventMap = {
    // UI Events (http://www.w3.org/TR/uievents/)
    abort                          : [Event, false],
    beforeinput                    : [InputEvent, true],
    blur                           : [FocusEvent, false],
    click                          : [MouseEvent, true],
    compositionend                 : [CompositionEvent, true],
    compositionstart               : [CompositionEvent, true],
    compositionupdate              : [CompositionEvent, true],
    dblclick                       : [MouseEvent, true],
    focus                          : [FocusEvent, false],
    focusin                        : [FocusEvent, true],
    focusout                       : [FocusEvent, true],
    input                          : [InputEvent, true],
    keydown                        : [KeyboardEvent, true],
    keyup                          : [KeyboardEvent, true],
    load                           : [Event, false],
    mousedown                      : [MouseEvent, true],
    mouseenter                     : [MouseEvent, false],
    mouseleave                     : [MouseEvent, false],

    // bubbles, but will be triggered very frequently
    mousemove                      : [MouseEvent, false],

    mouseout                       : [MouseEvent, true],
    mouseover                      : [MouseEvent, true],
    mouseup                        : [MouseEvent, true],
    resize                         : [UIEvent, false],

    // might bubble
    scroll                         : [UIEvent, false],
    
    select                         : [Event, true],
    unload                         : [Event, false],
    wheel                          : [WheelEvent, true],

    // Touch Events Extension (http://www.w3.org/TR/touch-events-extensions/)
    touchcancel                    : [TouchEvent, true],
    touchend                       : [TouchEvent, true],
    touchmove                      : [TouchEvent, true],
    touchstart                     : [TouchEvent, true]
};

module.exports = EventMap;

},{"./CompositionEvent":29,"./Event":30,"./FocusEvent":32,"./InputEvent":33,"./KeyboardEvent":34,"./MouseEvent":35,"./TouchEvent":36,"./UIEvent":37,"./WheelEvent":38}],32:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

function FocusEvent(ev) {
    // [Constructor(DOMString typeArg, optional FocusEventInit focusEventInitDict)]
    // interface FocusEvent : UIEvent {
    //     readonly    attribute EventTarget? relatedTarget;
    // };

    UIEvent.call(this, ev);
}

FocusEvent.prototype = Object.create(UIEvent.prototype);
FocusEvent.prototype.constructor = FocusEvent;

FocusEvent.prototype.toString = function toString () {
    return 'FocusEvent';
};

module.exports = FocusEvent;

},{"./UIEvent":37}],33:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

function InputEvent(ev) {
    // [Constructor(DOMString typeArg, optional InputEventInit inputEventInitDict)]
    // interface InputEvent : UIEvent {
    //     readonly    attribute DOMString inputType;
    //     readonly    attribute DOMString data;
    //     readonly    attribute boolean   isComposing;
    //     readonly    attribute Range     targetRange;
    // };

    UIEvent.call(this, ev);
    this.inputType = ev.inputType;
    this.data = ev.data;
    this.isComposing = ev.isComposing;
    this.targetRange = ev.targetRange;
}

InputEvent.prototype = Object.create(UIEvent.prototype);
InputEvent.prototype.constructor = InputEvent;

InputEvent.prototype.toString = function toString () {
    return 'InputEvent';
};

module.exports = InputEvent;

},{"./UIEvent":37}],34:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

function KeyboardEvent(ev) {
    // [Constructor(DOMString typeArg, optional KeyboardEventInit keyboardEventInitDict)]
    // interface KeyboardEvent : UIEvent {
    //     // KeyLocationCode
    //     const unsigned long DOM_KEY_LOCATION_STANDARD = 0x00;
    //     const unsigned long DOM_KEY_LOCATION_LEFT = 0x01;
    //     const unsigned long DOM_KEY_LOCATION_RIGHT = 0x02;
    //     const unsigned long DOM_KEY_LOCATION_NUMPAD = 0x03;
    //     readonly    attribute DOMString     key;
    //     readonly    attribute DOMString     code;
    //     readonly    attribute unsigned long location;
    //     readonly    attribute boolean       ctrlKey;
    //     readonly    attribute boolean       shiftKey;
    //     readonly    attribute boolean       altKey;
    //     readonly    attribute boolean       metaKey;
    //     readonly    attribute boolean       repeat;
    //     readonly    attribute boolean       isComposing;
    //     boolean getModifierState (DOMString keyArg);
    // };
    
    UIEvent.call(this, ev);
    this.DOM_KEY_LOCATION_STANDARD = 0x00;
    this.DOM_KEY_LOCATION_LEFT = 0x01;
    this.DOM_KEY_LOCATION_RIGHT = 0x02;
    this.DOM_KEY_LOCATION_NUMPAD = 0x03;
    this.key = ev.key;
    this.code = ev.code;
    this.location = ev.location;
    this.ctrlKey = ev.ctrlKey;
    this.shiftKey = ev.shiftKey;
    this.altKey = ev.altKey;
    this.metaKey = ev.metaKey;
    this.repeat = ev.repeat;
    this.isComposing = ev.isComposing;
    this.keyArg = ev.keyArg;
}

KeyboardEvent.prototype = Object.create(UIEvent.prototype);
KeyboardEvent.prototype.constructor = KeyboardEvent;

KeyboardEvent.prototype.toString = function toString () {
    return 'KeyboardEvent';
};

module.exports = KeyboardEvent;

},{"./UIEvent":37}],35:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 
/*jshint -W079 */

'use strict';

var UIEvent = require('./UIEvent');

function MouseEvent(ev) {
    // [Constructor(DOMString typeArg, optional MouseEventInit mouseEventInitDict)]
    // interface MouseEvent : UIEvent {
    //     readonly    attribute long           screenX;
    //     readonly    attribute long           screenY;
    //     readonly    attribute long           clientX;
    //     readonly    attribute long           clientY;
    //     readonly    attribute boolean        ctrlKey;
    //     readonly    attribute boolean        shiftKey;
    //     readonly    attribute boolean        altKey;
    //     readonly    attribute boolean        metaKey;
    //     readonly    attribute short          button;
    //     readonly    attribute EventTarget?   relatedTarget;
    //     // Introduced in this specification
    //     readonly    attribute unsigned short buttons;
    //     boolean getModifierState (DOMString keyArg);
    // };

    UIEvent.call(this, ev);
    this.screenX = ev.screenX;
    this.screenY = ev.screenY;
    this.clientX = ev.clientX;
    this.clientY = ev.clientY;
    this.ctrlKey = ev.ctrlKey;
    this.shiftKey = ev.shiftKey;
    this.altKey = ev.altKey;
    this.metaKey = ev.metaKey;
    this.button = ev.button;
    this.buttons = ev.buttons;

    this.pageX = ev.pageX;
    this.pageY = ev.pageY;
    this.x = ev.x;
    this.y = ev.y;
    this.offsetX = ev.offsetX;
    this.offsetY = ev.offsetY;
}

MouseEvent.prototype = Object.create(UIEvent.prototype);
MouseEvent.prototype.constructor = MouseEvent;

MouseEvent.prototype.toString = function toString () {
    return 'MouseEvent';
};

module.exports = MouseEvent;

},{"./UIEvent":37}],36:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

var EMPTY_ARRAY = [];

function Touch(touch) {
    // interface Touch {
    //     readonly    attribute long        identifier;
    //     readonly    attribute EventTarget target;
    //     readonly    attribute double      screenX;
    //     readonly    attribute double      screenY;
    //     readonly    attribute double      clientX;
    //     readonly    attribute double      clientY;
    //     readonly    attribute double      pageX;
    //     readonly    attribute double      pageY;
    // };
    
    this.identifier = touch.identifier;
    this.screenX = touch.screenX;
    this.screenY = touch.screenY;
    this.clientX = touch.clientX;
    this.clientY = touch.clientY;
    this.pageX = touch.pageX;
    this.pageY = touch.pageY;
}

function cloneTouchList(touchList) {
    if (!touchList) return EMPTY_ARRAY;
    // interface TouchList {
    //     readonly    attribute unsigned long length;
    //     getter Touch? item (unsigned long index);
    // };
    
    var touchListArray = [];
    for (var i = 0; i < touchList.length; i++) {
        touchListArray[i] = new Touch(touchList[i]);
    }
    return touchListArray;
}

function TouchEvent(ev) {
    // interface TouchEvent : UIEvent {
    //     readonly    attribute TouchList touches;
    //     readonly    attribute TouchList targetTouches;
    //     readonly    attribute TouchList changedTouches;
    //     readonly    attribute boolean   altKey;
    //     readonly    attribute boolean   metaKey;
    //     readonly    attribute boolean   ctrlKey;
    //     readonly    attribute boolean   shiftKey;
    // };
    UIEvent.call(this, ev);
    this.touches = cloneTouchList(ev.touches);
    this.targetTouches = cloneTouchList(ev.targetTouches);
    this.changedTouches = cloneTouchList(ev.changedTouches);
    this.altKey = ev.altKey;
    this.metaKey = ev.metaKey;
    this.ctrlKey = ev.ctrlKey;
    this.shiftKey = ev.shiftKey;
}

TouchEvent.prototype = Object.create(UIEvent.prototype);
TouchEvent.prototype.constructor = TouchEvent;

TouchEvent.prototype.toString = function toString () {
    return 'TouchEvent';
};

module.exports = TouchEvent;

},{"./UIEvent":37}],37:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 
/*jshint -W079 */

'use strict';

var Event = require('./Event');

function UIEvent(ev) {
    // [Constructor(DOMString type, optional UIEventInit eventInitDict)]
    // interface UIEvent : Event {
    //     readonly    attribute Window? view;
    //     readonly    attribute long    detail;
    // };

    Event.call(this, ev);
    this.detail = ev.detail;
}

UIEvent.prototype = Object.create(Event.prototype);
UIEvent.prototype.constructor = UIEvent;

UIEvent.prototype.toString = function toString () {
    return 'UIEvent';
};

module.exports = UIEvent;

},{"./Event":30}],38:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

var MouseEvent = require('./MouseEvent');

function WheelEvent(ev) {
    // [Constructor(DOMString typeArg, optional WheelEventInit wheelEventInitDict)]
    // interface WheelEvent : MouseEvent {
    //     // DeltaModeCode
    //     const unsigned long DOM_DELTA_PIXEL = 0x00;
    //     const unsigned long DOM_DELTA_LINE = 0x01;
    //     const unsigned long DOM_DELTA_PAGE = 0x02;
    //     readonly    attribute double        deltaX;
    //     readonly    attribute double        deltaY;
    //     readonly    attribute double        deltaZ;
    //     readonly    attribute unsigned long deltaMode;
    // };

    MouseEvent.call(this, ev);
    this.DOM_DELTA_PIXEL = 0x00;
    this.DOM_DELTA_LINE = 0x01;
    this.DOM_DELTA_PAGE = 0x02;
    this.deltaX = ev.deltaX;
    this.deltaY = ev.deltaY;
    this.deltaZ = ev.deltaZ;
    this.deltaMode = ev.deltaMode;
}

WheelEvent.prototype = Object.create(MouseEvent.prototype);
WheelEvent.prototype.constructor = WheelEvent;

WheelEvent.prototype.toString = function toString () {
    return 'WheelEvent';
};

module.exports = WheelEvent;

},{"./MouseEvent":35}],39:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    CompositionEvent: require('./CompositionEvent'),
    Event: require('./Event'),
    EventMap: require('./EventMap'),
    FocusEvent: require('./FocusEvent'),
    InputEvent: require('./InputEvent'),
    KeyboardEvent: require('./KeyboardEvent'),
    MouseEvent: require('./MouseEvent'),
    TouchEvent: require('./TouchEvent'),
    UIEvent: require('./UIEvent'),
    WheelEvent: require('./WheelEvent')
};


},{"./CompositionEvent":29,"./Event":30,"./EventMap":31,"./FocusEvent":32,"./InputEvent":33,"./KeyboardEvent":34,"./MouseEvent":35,"./TouchEvent":36,"./UIEvent":37,"./WheelEvent":38}],40:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    DOMRenderer: require('./DOMRenderer'),
    ElementCache: require('./ElementCache'),
    Events: require('./events'),
    Math: require('./Math')
};

},{"./DOMRenderer":26,"./ElementCache":27,"./Math":28,"./events":39}],41:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var now = require('./now');

/**
 * Engine class used for updating objects on a frame-by-frame. Synchronizes the
 * `update` method invocations to the refresh rate of the screen.
 * Does not normalize the high resolution timestamp when being consecutively
 * started and stopped.
 * 
 * @class ContainerEngine
 * @constructor
 */
function ContainerEngine() {
    this._updates = [];
    this._stoppedAt = now();
    this._sleep = 0;

    this.start();

    var _this = this;
    window.addEventListener('message', function(ev) {
        _this._onWindowMessage(ev);
    });
}

ContainerEngine.prototype._onWindowMessage = function _onWindowMessage(ev) {
    if (
        this._running &&
        ev.data.constructor === Array &&
        ev.data[0] === 'FRAME'
    ) {
        this.step(ev.data[1] - this._sleep);
    }
};

/**
 * Starts the ContainerEngine.
 *
 * @method start
 * @chainable
 * 
 * @return {ContainerEngine} this
 */
ContainerEngine.prototype.start = function start() {
    this._running = true;
    this._sleep += now() - this._stoppedAt;
    return this;
};

/**
 * Stops the ContainerEngine.
 *
 * @method stop
 * @chainable
 * 
 * @return {ContainerEngine} this
 */
ContainerEngine.prototype.stop = function stop() {
    this._running = false;
    this._stoppedAt = now();
    return this;
};

/**
 * Determines whether the ContainerEngine is currently running or not.
 *
 * @method isRunning
 * 
 * @return {Boolean}    boolean value indicating whether the ContainerEngine is
 *                      currently running or not
 */
ContainerEngine.prototype.isRunning = function isRunning() {
    return this._running;
};

/**
 * Updates all registered objects.
 *
 * @method step
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {ContainerEngine}      this
 */
ContainerEngine.prototype.step = function step (time) {
    for (var i = 0, len = this._updates.length ; i < len ; i++) {
        this._updates[i].update(time);
    }
    return this;
};

/**
 * Registeres an updateable object which `update` method should be invoked on
 * every paint, starting on the next paint (assuming the ContainerEngine is running).
 *
 * @method update
 * @chainable
 * 
 * @param  {Object} updateable          object to be updated
 * @param  {Function} updateable.update update function to be called on the
 *                                      registered object
 * @return {ContainerEngine}                     this
 */
ContainerEngine.prototype.update = function update(updateable) {
    if (this._updates.indexOf(updateable) === -1) {
        this._updates.push(updateable);
    }
    return this;
};

/**
 * Deregisters an updateable object previously registered using `update` to be
 * no longer updated.
 *
 * @method noLongerUpdate
 * @chainable
 * 
 * @param  {Object} updateable          updateable object previously
 *                                      registered using `update`
 * @return {ContainerEngine}                     this
 */
ContainerEngine.prototype.noLongerUpdate = function noLongerUpdate(updateable) {
    var index = this._updates.indexOf(updateable);
    if (index > -1) {
        this._updates.splice(index, 1);
    }
    return this;
};

module.exports = ContainerEngine;

},{"./now":44}],42:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var polyfills = require('../polyfills');
var rAF = polyfills.requestAnimationFrame;
var cAF = polyfills.cancelAnimationFrame;

/**
 * Boolean constant indicating whether the Engine has access to the document.
 * The document is being used in order to subscribe for visibilitychange events
 * used for normalizing the Engine time when e.g. when switching tabs.
 * 
 * @constant
 * @type {Boolean}
 */ 
var DOCUMENT_ACCESS = typeof document !== 'undefined';

if (DOCUMENT_ACCESS) {
    var VENDOR_HIDDEN, VENDOR_VISIBILITY_CHANGE;

    // Opera 12.10 and Firefox 18 and later support
    if (typeof document.hidden !== 'undefined') {
        VENDOR_HIDDEN = 'hidden';
        VENDOR_VISIBILITY_CHANGE = 'visibilitychange';
    }
    else if (typeof document.mozHidden !== 'undefined') {
        VENDOR_HIDDEN = 'mozHidden';
        VENDOR_VISIBILITY_CHANGE = 'mozvisibilitychange';
    }
    else if (typeof document.msHidden !== 'undefined') {
        VENDOR_HIDDEN = 'msHidden';
        VENDOR_VISIBILITY_CHANGE = 'msvisibilitychange';
    }
    else if (typeof document.webkitHidden !== 'undefined') {
        VENDOR_HIDDEN = 'webkitHidden';
        VENDOR_VISIBILITY_CHANGE = 'webkitvisibilitychange';
    }
}

/**
 * Engine class used for updating objects on a frame-by-frame. Synchronizes the
 * `update` method invocations to the refresh rate of the screen. Manages
 * the `requestAnimationFrame`-loop by normalizing the passed in timestamp
 * when switching tabs.
 * 
 * @class Engine
 * @constructor
 */
function Engine() {
    var _this = this;
    
    // References to objects to be updated on next frame.
    this._updates = [];
    
    this._looper = function(time) {
        _this.loop(time);
    };
    this._time = 0;
    this._stoppedAt = 0;
    this._sleep = 0;
    
    // Indicates whether the engine should be restarted when the tab/ window is
    // being focused again (visibility change).
    this._startOnVisibilityChange = true;
    
    // requestId as returned by requestAnimationFrame function;
    this._rAF = null;
    
    this._sleepDiff = true;
    
    // The engine is being started on instantiation.
    // TODO(alexanderGugel)
    this.start();

    // The Engine supports running in a non-browser environment (e.g. Worker).
    if (DOCUMENT_ACCESS) {
        document.addEventListener(VENDOR_VISIBILITY_CHANGE, function() {
            _this._onVisibilityChange();
        });
    }
}

Engine.prototype._onVisibilityChange = function _onVisibilityChange() {
    if (document[VENDOR_HIDDEN]) {
        this._onUnfocus();
    }
    else {
        this._onFocus();
    }
};

/**
 * Internal helper function to be invoked as soon as the window/ tab is being
 * focused after a visibiltiy change.
 * 
 * @method  _onFocus
 * @private
 */ 
Engine.prototype._onFocus = function _onFocus() {
    if (this._startOnVisibilityChange) {
        this._start();
    }
};

/**
 * Internal helper function to be invoked as soon as the window/ tab is being
 * unfocused (hidden) after a visibiltiy change.
 * 
 * @method  _onFocus
 * @private
 */ 
Engine.prototype._onUnfocus = function _onUnfocus() {
    this._stop();
};

/**
 * Starts the Engine. When switching to a differnt tab/ window (changing the
 * visibiltiy), the engine will be retarted when switching back to a visible
 * state.
 *
 * @method start
 * @chainable
 * 
 * @return {Engine} this
 */
Engine.prototype.start = function start() {
    if (!this._running) {
        this._startOnVisibilityChange = true;
        this._start();
    }
    return this;
};

/**
 * Internal version of {@link Engine#start}, not affecting behavior on visibilty
 * change.
 * 
 * @method  _start
 * @private
 */ 
Engine.prototype._start = function _start() {
    this._running = true;
    this._sleepDiff = true;
    this._rAF = rAF(this._looper);
};

/**
 * Stops the Engine.
 *
 * @method stop
 * @chainable
 * 
 * @return {Engine} this
 */
Engine.prototype.stop = function stop() {
    if (this._running) {
        this._startOnVisibilityChange = false;
        this._stop();
    }
    return this;
};

/**
 * Internal version of {@link Engine#stop}, not affecting behavior on visibilty
 * change.
 * 
 * @method  _stop
 * @private
 */ 
Engine.prototype._stop = function _stop() {
    this._running = false;
    this._stoppedAt = this._time;

    // Bug in old versions of Fx. Explicitly cancel.
    cAF(this._rAF);
};

/**
 * Determines whether the Engine is currently running or not.
 *
 * @method isRunning
 * 
 * @return {Boolean}    boolean value indicating whether the Engine is
 *                      currently running or not
 */
Engine.prototype.isRunning = function isRunning() {
    return this._running;
};

/**
 * Updates all registered objects.
 *
 * @method step
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Engine}      this
 */
Engine.prototype.step = function step (time) {
    this._time = time;
    if (this._sleepDiff) {
        this._sleep += time - this._stoppedAt;
        this._sleepDiff = false;
    }
    
    // The same timetamp will be emitted immediately before and after visibility
    // change.
    var normalizedTime = time - this._sleep;
    for (var i = 0, len = this._updates.length ; i < len ; i++) {
        this._updates[i].update(normalizedTime);
    }
    return this;
};

/**
 * Method being called by `requestAnimationFrame` on every paint. Indirectly
 * recursive by scheduling a future invocation of itself on the next paint.
 *
 * @method loop
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Engine}      this
 */
Engine.prototype.loop = function loop(time) {
    this.step(time);
    this._rAF = rAF(this._looper);
    return this;
};

/**
 * Registeres an updateable object which `update` method should be invoked on
 * every paint, starting on the next paint (assuming the Engine is running).
 *
 * @method update
 * @chainable
 * 
 * @param  {Object} updateable          object to be updated
 * @param  {Function} updateable.update update function to be called on the
 *                                      registered object
 * @return {Engine}                     this
 */
Engine.prototype.update = function update(updateable) {
    if (this._updates.indexOf(updateable) === -1) {
        this._updates.push(updateable);
    }
    return this;
};

/**
 * Deregisters an updateable object previously registered using `update` to be
 * no longer updated.
 *
 * @method noLongerUpdate
 * @chainable
 * 
 * @param  {Object} updateable          updateable object previously
 *                                      registered using `update`
 * @return {Engine}                     this
 */
Engine.prototype.noLongerUpdate = function noLongerUpdate(updateable) {
    var index = this._updates.indexOf(updateable);
    if (index > -1) {
        this._updates.splice(index, 1);
    }
    return this;
};

module.exports = Engine;

},{"../polyfills":82}],43:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Engine: require('./Engine'),
    ContainerEngine: require('./ContainerEngine'),
    now: require('./now')
};

},{"./ContainerEngine":41,"./Engine":42,"./now":44}],44:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
'use strict';

var now = typeof performance !== 'undefined' ? function() {
    return performance.now();
} : Date.now;

module.exports = now;

},{}],45:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

module.exports = {
    components: require('./components'),
    core: require('./core'),
    engine: require('./engine'),
    domRenderables: require('./dom-renderables'),
    domRenderers: require('./dom-renderers'),
    math: require('./math'),
    physics: require('./physics'),
    renderers: require('./renderers'),
    transitions: require('./transitions'),
    utilities: require('./utilities'),
    webglRenderables: require('./webgl-renderables'),
    webglRenderers: require('./webgl-renderers'),
    webglGeometries: require('./webgl-geometries'),
    webglMaterials: require('./webgl-materials'),
    webglShaders: require('./webgl-shaders'),
    polyfills: require('./polyfills')
};

},{"./components":13,"./core":23,"./dom-renderables":25,"./dom-renderers":40,"./engine":43,"./math":50,"./physics":80,"./polyfills":82,"./renderers":86,"./transitions":89,"./utilities":96,"./webgl-geometries":105,"./webgl-materials":119,"./webgl-renderables":121,"./webgl-renderers":134,"./webgl-shaders":136}],46:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * A 3x3 numerical matrix, represented as an array.
 *
 * @class Mat33
 * @constructor
 *
 * @param {Number[]} values
 */
function Mat33(values) {
    this.values = values || [1,0,0,0,1,0,0,0,1];
}

/**
 * Return the values in the Mat33 as an array.
 *
 * @method get
 * @return {Number[]} matrix values as array of rows.
 */
Mat33.prototype.get = function get() {
    return this.values;
};

/**
 * Set the values of the current Mat33.
 *
 * @method set
 * @param {Number[]} values Array of nine numbers to set in the Mat33.
 * @chainable
 */
Mat33.prototype.set = function set(values) {
    this.values = values;
    return this;
};

/**
 * Copy the values of the input Mat33.
 *
 * @method copy
 * @param {Mat33} matrix The Mat33 to copy.
 * @chainable
 */
Mat33.prototype.copy = function copy(matrix) {
    var A = this.values;
    var B = matrix.values;

    A[0] = B[0];
    A[1] = B[1];
    A[2] = B[2];
    A[3] = B[3];
    A[4] = B[4];
    A[5] = B[5];
    A[6] = B[6];
    A[7] = B[7];
    A[8] = B[8];

    return this;
};

/**
 * Take this Mat33 as A, input vector V as a column vector, and return Mat33 product (A)(V).
 *
 * @method vectorMultiply
 * @param {Vec3} v Vector to rotate.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The input vector after multiplication.
 */
Mat33.prototype.vectorMultiply = function vectorMultiply(v, output) {
    var M = this.values;
    var v0 = v.x;
    var v1 = v.y;
    var v2 = v.z;

    output.x = M[0]*v0 + M[1]*v1 + M[2]*v2;
    output.y = M[3]*v0 + M[4]*v1 + M[5]*v2;
    output.z = M[6]*v0 + M[7]*v1 + M[8]*v2;

    return output;
};

/**
 * Multiply the provided Mat33 with the current Mat33.  Result is (this) * (matrix).
 *
 * @method multiply
 * @param {Mat33} matrix Input Mat33 to multiply on the right.
 * @chainable
 */
Mat33.prototype.multiply = function multiply(matrix) {
    var A = this.values;
    var B = matrix.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    A[0] = A0*B0 + A1*B3 + A2*B6;
    A[1] = A0*B1 + A1*B4 + A2*B7;
    A[2] = A0*B2 + A1*B5 + A2*B8;
    A[3] = A3*B0 + A4*B3 + A5*B6;
    A[4] = A3*B1 + A4*B4 + A5*B7;
    A[5] = A3*B2 + A4*B5 + A5*B8;
    A[6] = A6*B0 + A7*B3 + A8*B6;
    A[7] = A6*B1 + A7*B4 + A8*B7;
    A[8] = A6*B2 + A7*B5 + A8*B8;

    return this;
};

/**
 * Transposes the Mat33.
 *
 * @method transpose
 * @chainable
 */
Mat33.prototype.transpose = function transpose() {
    var M = this.values;

    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];

    M[1] = M3;
    M[2] = M6;
    M[3] = M1;
    M[5] = M7;
    M[6] = M2;
    M[7] = M5;

    return this;
};

/**
 * The determinant of the Mat33.
 *
 * @method getDeterminant
 * @return {Number} The determinant.
 */
Mat33.prototype.getDeterminant = function getDeterminant() {
    var M = this.values;

    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M[0]*(M4*M8 - M5*M7) -
              M[1]*(M3*M8 - M5*M6) +
              M[2]*(M3*M7 - M4*M6);

    return det;
};

/**
 * The inverse of the Mat33.
 *
 * @method inverse
 * @chainable
 */
Mat33.prototype.inverse = function inverse() {
    var M = this.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M0*(M4*M8 - M5*M7) -
              M1*(M3*M8 - M5*M6) +
              M2*(M3*M7 - M4*M6);

    if (Math.abs(det) < 1e-40) return null;

    det = 1 / det;

    M[0] = (M4*M8 - M5*M7) * det;
    M[3] = (-M3*M8 + M5*M6) * det;
    M[6] = (M3*M7 - M4*M6) * det;
    M[1] = (-M1*M8 + M2*M7) * det;
    M[4] = (M0*M8 - M2*M6) * det;
    M[7] = (-M0*M7 + M1*M6) * det;
    M[2] = (M1*M5 - M2*M4) * det;
    M[5] = (-M0*M5 + M2*M3) * det;
    M[8] = (M0*M4 - M1*M3) * det;

    return this;
};

/**
 * Clones the input Mat33.
 *
 * @method clone
 * @param {Mat33} m Mat33 to clone.
 * @return {Mat33} New copy of the original Mat33.
 */
Mat33.clone = function clone(m) {
    return new Mat33(m.values.slice());
};

/**
 * The inverse of the Mat33.
 *
 * @method inverse
 * @param {Mat33} matrix Mat33 to invert.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The Mat33 after the invert.
 */
Mat33.inverse = function inverse(matrix, output) {
    var M = matrix.values;
    var result = output.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M0*(M4*M8 - M5*M7) -
              M1*(M3*M8 - M5*M6) +
              M2*(M3*M7 - M4*M6);

    if (Math.abs(det) < 1e-40) return null;

    det = 1 / det;

    result[0] = (M4*M8 - M5*M7) * det;
    result[3] = (-M3*M8 + M5*M6) * det;
    result[6] = (M3*M7 - M4*M6) * det;
    result[1] = (-M1*M8 + M2*M7) * det;
    result[4] = (M0*M8 - M2*M6) * det;
    result[7] = (-M0*M7 + M1*M6) * det;
    result[2] = (M1*M5 - M2*M4) * det;
    result[5] = (-M0*M5 + M2*M3) * det;
    result[8] = (M0*M4 - M1*M3) * det;

    return output;
};

/**
 * Transposes the Mat33.
 *
 * @method transpose
 * @param {Mat33} matrix Mat33 to transpose.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The Mat33 after the transpose.
 */
Mat33.transpose = function transpose(matrix, output) {
    var M = matrix.values;
    var result = output.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    result[0] = M0;
    result[1] = M3;
    result[2] = M6;
    result[3] = M1;
    result[4] = M4;
    result[5] = M7;
    result[6] = M2;
    result[7] = M5;
    result[8] = M8;

    return output;
};

/**
 * Add the provided Mat33's.
 *
 * @method add
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The result of the addition.
 */
Mat33.add = function add(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0 + B0;
    result[1] = A1 + B1;
    result[2] = A2 + B2;
    result[3] = A3 + B3;
    result[4] = A4 + B4;
    result[5] = A5 + B5;
    result[6] = A6 + B6;
    result[7] = A7 + B7;
    result[8] = A8 + B8;

    return output;
};

/**
 * Subtract the provided Mat33's.
 *
 * @method subtract
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The result of the subtraction.
 */
Mat33.subtract = function subtract(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0 - B0;
    result[1] = A1 - B1;
    result[2] = A2 - B2;
    result[3] = A3 - B3;
    result[4] = A4 - B4;
    result[5] = A5 - B5;
    result[6] = A6 - B6;
    result[7] = A7 - B7;
    result[8] = A8 - B8;

    return output;
};
/**
 * Multiply the provided Mat33 M2 with this Mat33.  Result is (this) * (M2).
 *
 * @method multiply
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} the result of the multiplication.
 */
Mat33.multiply = function multiply(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0*B0 + A1*B3 + A2*B6;
    result[1] = A0*B1 + A1*B4 + A2*B7;
    result[2] = A0*B2 + A1*B5 + A2*B8;
    result[3] = A3*B0 + A4*B3 + A5*B6;
    result[4] = A3*B1 + A4*B4 + A5*B7;
    result[5] = A3*B2 + A4*B5 + A5*B8;
    result[6] = A6*B0 + A7*B3 + A8*B6;
    result[7] = A6*B1 + A7*B4 + A8*B7;
    result[8] = A6*B2 + A7*B5 + A8*B8;

    return output;
};

module.exports = Mat33;

},{}],47:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var sin = Math.sin;
var cos = Math.cos;
var asin = Math.asin;
var acos = Math.acos;
var atan2 = Math.atan2;
var sqrt = Math.sqrt;

/**
 * A vector-like object used to represent rotations. If theta is the angle of
 * rotation, and (x', y', z') is a normalized vector representing the axis of
 * rotation, then w = cos(theta/2), x = sin(theta/2)*x', y = sin(theta/2)*y',
 * and z = sin(theta/2)*z'.
 *
 * @class Quaternion
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
function Quaternion(w, x, y, z) {
    this.w = w || 1;
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
}

/**
 * Multiply the current Quaternion by input Quaternion q.
 * Left-handed multiplication.
 *
 * @method multiply
 * @param {Quaternion} q The Quaternion to multiply by on the right.
 */
Quaternion.prototype.multiply = function multiply(q) {
    var x1 = this.x;
    var y1 = this.y;
    var z1 = this.z;
    var w1 = this.w;
    var x2 = q.x;
    var y2 = q.y;
    var z2 = q.z;
    var w2 = q.w || 0;

    this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    this.x = x1 * w2 + x2 * w1 + y2 * z1 - y1 * z2;
    this.y = y1 * w2 + y2 * w1 + x1 * z2 - x2 * z1;
    this.z = z1 * w2 + z2 * w1 + x2 * y1 - x1 * y2;
    return this;
};

/**
 * Multiply the current Quaternion by input Quaternion q on the left, i.e. q * this.
 * Left-handed multiplication.
 *
 * @method leftMultiply
 * @param {Quaternion} q The Quaternion to multiply by on the left.
 */
Quaternion.prototype.leftMultiply = function leftMultiply(q) {
    var x1 = q.x;
    var y1 = q.y;
    var z1 = q.z;
    var w1 = q.w || 0;
    var x2 = this.x;
    var y2 = this.y;
    var z2 = this.z;
    var w2 = this.w;

    this.w = w1*w2 - x1*x2 - y1*y2 - z1*z2;
    this.x = x1*w2 + x2*w1 + y2*z1 - y1*z2;
    this.y = y1*w2 + y2*w1 + x1*z2 - x2*z1;
    this.z = z1*w2 + z2*w1 + x2*y1 - x1*y2;
    return this;
};

/**
 * Apply the current Quaternion to input Vec3 v, according to
 * v' = ~q * v * q.
 *
 * @method rotateVector
 * @param {Vec3} v The reference Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The rotated version of the Vec3.
 */
Quaternion.prototype.rotateVector = function rotateVector(v, output) {
    var cw = this.w;
    var cx = -this.x;
    var cy = -this.y;
    var cz = -this.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    output.x = tx * w + x * tw + y * tz - ty * z;
    output.y = ty * w + y * tw + tx * z - x * tz;
    output.z = tz * w + z * tw + x * ty - tx * y;
    return output;
};

/**
 * Invert the current Quaternion.
 *
 * @method invert
 * @chainable
 */
Quaternion.prototype.invert = function invert() {
    this.w = -this.w;
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
};

/**
 * Conjugate the current Quaternion.
 *
 * @method conjugate
 * @chainable
 */
Quaternion.prototype.conjugate = function conjugate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
};

/**
 * Compute the length (norm) of the current Quaternion.
 *
 * @method length
 * @return {Number}
 */
Quaternion.prototype.length = function length() {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;
    return sqrt(w * w + x * x + y * y + z * z);
};

/**
 * Alter the current Quaternion to be of unit length;
 *
 * @method normalize
 * @chainable
 */
Quaternion.prototype.normalize = function normalize() {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var length = sqrt(w * w + x * x + y * y + z * z);
    if (length === 0) return;
    length = 1 / length;
    this.w *= length;
    this.x *= length;
    this.y *= length;
    this.z *= length;
    return this;
};

/**
 * Set the w, x, y, z components of the current Quaternion.
 *
 * @method set
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 * @chainable
 */
Quaternion.prototype.set = function set(w, x ,y, z) {
    if (w != null) this.w = w;
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    if (z != null) this.z = z;
    return this;
};

/**
 * Copy input Quaternion q onto the current Quaternion.
 *
 * @method copy
 * @param {Quaternion} q The reference Quaternion.
 * @chainable
 */
Quaternion.prototype.copy = function copy(q) {
    this.w = q.w;
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    return this;
};

/**
 * Reset the current Quaternion.
 *
 * @method clear
 * @chainable
 */
Quaternion.prototype.clear = function clear() {
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
    return this;
};

/**
 * The dot product. Can be used to determine the cosine of the angle between
 * the two rotations, assuming both Quaternions are of unit length.
 *
 * @method dot
 * @param {Quaternion} q The other Quaternion.
 * @return {Number}
 */
Quaternion.prototype.dot = function dot(q) {
    return this.w * q.w + this.x * q.x + this.y * q.y + this.z * q.z;
};

/**
 * Spherical linear interpolation.
 *
 * @method slerp
 * @param {Quaternion} q The final orientation.
 * @param {Number} t The tween parameter.
 * @param {Vec3} output Vec3 in which to put the result.
 * @return {Quaternion}
 */
Quaternion.prototype.slerp = function slerp(q, t, output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qw = q.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;

    var omega;
    var cosomega;
    var sinomega;
    var scaleFrom;
    var scaleTo;

    cosomega = w * qw + x * qx + y * qy + z * qz;
    if ((1.0 - cosomega) > 1e-5) {
        omega = acos(cosomega);
        sinomega = sin(omega);
        scaleFrom = sin((1.0 - t) * omega) / sinomega;
        scaleTo = sin(t * omega) / sinomega;
    }
    else {
        scaleFrom = 1.0 - t;
        scaleTo = t;
    }

    output.w = w * scaleFrom + qw * scaleTo;
    output.x = x * scaleFrom + qx * scaleTo;
    output.y = y * scaleFrom + qy * scaleTo;
    output.z = z * scaleFrom + qz * scaleTo;

    return output;
};

/**
 * Get the Mat33 matrix corresponding to the current Quaternion.
 *
 * @method toMatrix
 * @return {Transform}
 */
Quaternion.prototype.toMatrix = function toMatrix(output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var xx = x*x;
    var yy = y*y;
    var zz = z*z;
    var xy = x*y;
    var xz = x*z;
    var yz = y*z;

    return output.set([
        1 - 2 * (yy + zz), 2 * (xy - w*z), 2 * (xz + w*y),
        2 * (xy + w*z), 1 - 2 * (xx + zz), 2 * (yz - w*x),
        2 * (xz - w*y), 2 * (yz + w*x), 1 - 2 * (xx + yy)
    ]);
};

/**
 * The rotation angles about the x, y, and z axes corresponding to the
 * current Quaternion, when applied in the ZYX order.
 *
 * @method toEuler
 * @param {Vec3} output Vec3 in which to put the result.
 * @return {Vec3}
 */

Quaternion.prototype.toEuler = function toEuler(output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var xx = x * x;
    var yy = y * y;
    var zz = z * z;

    var ty = 2 * (x * z + y * w);
    ty = ty < -1 ? -1 : ty > 1 ? 1 : ty;

    output.x = atan2(2 * (x * w - y * z), 1 - 2 * (xx + yy));
    output.y = asin(ty);
    output.z = atan2(2 * (z * w - x * y), 1 - 2 * (yy + zz));

    return output;
};

/**
 * The Quaternion corresponding to the Euler angles x, y, and z,
 * applied in the ZYX order.
 *
 * @method fromEuler
 * @param {Number} x The angle of rotation about the x axis.
 * @param {Number} y The angle of rotation about the y axis.
 * @param {Number} z The angle of rotation about the z axis.
 * @param {Quaternion} output Quaternion in which to put the result.
 * @return {Quaternion} The equivalent Quaternion.
 */
Quaternion.prototype.fromEuler = function fromEuler(x, y, z) {
    var hx = x * 0.5;
    var hy = y * 0.5;
    var hz = z * 0.5;

    var sx = sin(hx);
    var sy = sin(hy);
    var sz = sin(hz);
    var cx = cos(hx);
    var cy = cos(hy);
    var cz = cos(hz);

    this.w = cx * cy * cz - sx * sy * sz;
    this.x = sx * cy * cz + cx * sy * sz;
    this.y = cx * sy * cz - sx * cy * sz;
    this.z = cx * cy * sz + sx * sy * cz;

    return this;
};

/**
 * Alter the current Quaternion to reflect a rotation of input angle about
 * input axis v.
 *
 * @method makeFromAngleAndAxis
 * @param {Number} angle The angle of rotation.
 * @param {Vec3} v The axis of rotation.
 * @chainable
 */
Quaternion.prototype.fromAngleAxis = function fromAngleAxis(angle, x, y, z) {
    var len = sqrt(x * x + y * y + z * z);
    if (len === 0) {
        this.w = 1;
        this.x = this.y = this.z = 0;
    }
    else {
        len = 1 / len;
        var halfTheta = angle * 0.5;
        var s = sin(halfTheta);
        this.w = cos(halfTheta);
        this.x = s * x * len;
        this.y = s * y * len;
        this.z = s * z * len;
    }
    return this;
};

/**
 * Multiply the input Quaternions.
 * Left-handed coordinate system multiplication.
 *
 * @method multiply
 * @param {Quaternion} q1 The left Quaternion.
 * @param {Quaternion} q2 The right Quaternion.
 * @param {Quaternion} output Quaternion in which to place the result.
 * @return {Quaternion} The product of multiplication.
 */
Quaternion.multiply = function multiply(q1, q2, output) {
    var w1 = q1.w || 0;
    var x1 = q1.x;
    var y1 = q1.y;
    var z1 = q1.z;

    var w2 = q2.w || 0;
    var x2 = q2.x;
    var y2 = q2.y;
    var z2 = q2.z;

    output.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    output.x = x1 * w2 + x2 * w1 + y2 * z1 - y1 * z2;
    output.y = y1 * w2 + y2 * w1 + x1 * z2 - x2 * z1;
    output.z = z1 * w2 + z2 * w1 + x2 * y1 - x1 * y2;
    return output;
};

/**
 * Normalize the input quaternion.
 *
 * @method normalize
 * @return {Quaternion} The normalized quaternion.
 */
Quaternion.normalize = function normalize(q, output) {
    var w = q.w;
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var length = sqrt(w * w + x * x + y * y + z * z);
    if (length === 0) return;
    length = 1 / length;
    output.w *= length;
    output.x *= length;
    output.y *= length;
    output.z *= length;
    return output;
};

/**
 * The conjugate of the input Quaternion.
 *
 * @method conjugate
 * @param {Quaternion} q The reference Quaternion.
 * @param {Quaternion} output Quaternion in which to place the result.
 * @return {Quaternion} The conjugate Quaternion.
 */
Quaternion.conjugate = function conjugate(q, output) {
    output.w = q.w;
    output.x = -q.x;
    output.y = -q.y;
    output.z = -q.z;
    return output;
};

/**
 * Clone the input Quaternion.
 *
 * @method clone
 * @param {Quaternion} q the reference Quaternion.
 * @return {Quaternion} The cloned Quaternion.
 */
Quaternion.clone = function clone(q) {
    return new Quaternion(q.w, q.x, q.y, q.z);
};

/**
 * The dot product of the two input Quaternions.
 *
 * @method dotProduct
 * @param {Quaternion} q1 The left Quaternion.
 * @param {Quaternion} q2 The right Quaternion.
 * @return {Number} The dot product of the two Quaternions.
 */
Quaternion.dot = function dot(q1, q2) {
    return q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z;
};

module.exports = Quaternion;

},{}],48:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var sin = Math.sin;
var cos = Math.cos;
var sqrt = Math.sqrt;

/**
 * A two-dimensional vector.
 *
 * @class Vec2
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 */
var Vec2 = function(x, y){
    if (x instanceof Array || x instanceof Float32Array) {
        this.x = x[0] || 0;
        this.y = x[1] || 0;
    }
    else {
        this.x = x || 0;
        this.y = y || 0;
    }
};

/**
 * Set the components of the current Vec2.
 *
 * @method set
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @chainable
 */
Vec2.prototype.set = function set(x, y) {
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    return this;
};

/**
 * Add the input v to the current Vec2.
 *
 * @method add
 * @param {Vec2} v The Vec2 to add.
 * @chainable
 */
Vec2.prototype.add = function add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
};

/**
 * Subtract the input v from the current Vec2.
 *
 * @method subtract
 * @param {Vec2} v The Vec2 to subtract.
 * @chainable
 */
Vec2.prototype.subtract = function subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
};

/**
 * Scale the current Vec2 by a scalar or Vec2.
 *
 * @method scale
 * @param {Number|Vec2} s The Number or vec2 by which to scale.
 * @chainable
 */
Vec2.prototype.scale = function scale(s) {
    if (s instanceof Vec2) {
        this.x *= s.x;
        this.y *= s.y;
    } else {
        this.x *= s;
        this.y *= s;
    }
    return this;
};

/**
 * Rotate the Vec2 counter-clockwise by theta about the z-axis.
 *
 * @method rotate
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec2.prototype.rotate = function(theta) {
    var x = this.x;
    var y = this.y;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = x * cosTheta - y * sinTheta;
    this.y = x * sinTheta + y * cosTheta;

    return this;
};

/**
 * The dot product of of the current Vec2 with the input Vec2.
 *
 * @method dot
 * @param {Number} v The other Vec2.
 * @chainable
 */
Vec2.prototype.dot = function(v) {
    return this.x * v.x + this.y * v.y;
};

/**
 * The cross product of of the current Vec2 with the input Vec2.
 *
 * @method cross
 * @param {Number} v The other Vec2.
 * @chainable
 */
Vec2.prototype.cross = function(v) {
    return this.x * v.y - this.y * v.x;
};

/**
 * Preserve the magnitude but invert the orientation of the current Vec2.
 *
 * @method invert
 * @chainable
 */
Vec2.prototype.invert = function invert() {
    this.x *= -1;
    this.y *= -1;
    return this;
};

/**
 * Apply a function component-wise to the current Vec2.
 *
 * @method map
 * @param {Function} fn Function to apply.
 * @chainable
 */
Vec2.prototype.map = function map(fn) {
    this.x = fn(this.x);
    this.y = fn(this.y);
    return this;
};

/**
 * The magnitude of the current Vec2.
 *
 * @method length
 * @return {Number}
 */
Vec2.prototype.length = function length() {
    var x = this.x;
    var y = this.y;

    return sqrt(x * x + y * y);
};

/**
 * Copy the input onto the current Vec2.
 *
 * @method copy
 * @param {Vec2} v Vec2 to copy.
 * @chainable
 */
Vec2.prototype.copy = function copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
};

/**
 * Reset the current Vec2.
 *
 * @method clear
 * @chainable
 */
Vec2.prototype.clear = function clear() {
    this.x = 0;
    this.y = 0;
    return this;
};

/**
 * Check whether the magnitude of the current Vec2 is exactly 0.
 *
 * @method isZero
 * @return {Boolean}
 */
Vec2.prototype.isZero = function isZero() {
    if (this.x !== 0 || this.y !== 0) return false;
    else return true;
};

/**
 * The array form of the current Vec2.
 *
 * @method toArray
 * @return {Number[]}
 */
Vec2.prototype.toArray = function toArray() {
    return [this.x, this.y];
};

/**
 * Normalize the input Vec2.
 *
 * @method normalize
 * @param {Vec2} v The reference Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The normalize Vec2.
 */
Vec2.normalize = function normalize(v, output) {
    var x = v.x;
    var y = v.y;

    var length = sqrt(x * x + y * y) || 1;
    length = 1 / length;
    output.x = v.x * length;
    output.y = v.y * length;

    return output;
};

/**
 * Clone the input Vec2.
 *
 * @method clone
 * @param {Vec2} v The Vec2 to clone.
 * @return {Vec2} The cloned Vec2.
 */
Vec2.clone = function clone(v) {
    return new Vec2(v.x, v.y);
};

/**
 * Add the input Vec2's.
 *
 * @method add
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the addition.
 */
Vec2.add = function add(v1, v2, output) {
    output.x = v1.x + v2.x;
    output.y = v1.y + v2.y;

    return output;
};

/**
 * Subtract the second Vec2 from the first.
 *
 * @method subtract
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the subtraction.
 */
Vec2.subtract = function subtract(v1, v2, output) {
    output.x = v1.x - v2.x;
    output.y = v1.y - v2.y;
    return output;
};

/**
 * Scale the input Vec2.
 *
 * @method scale
 * @param {Vec2} v The reference Vec2.
 * @param {Number} s Number to scale by.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the scaling.
 */
Vec2.scale = function scale(v, s, output) {
    output.x = v.x * s;
    output.y = v.y * s;
    return output;
};

/**
 * The dot product of the input Vec2's.
 *
 * @method dot
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @return {Number} The dot product.
 */
Vec2.dot = function dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
};

/**
 * The cross product of the input Vec2's.
 *
 * @method cross
 * @param {Number} v The left Vec2.
 * @param {Number} v The right Vec2.
 * @return {Number} The z-component of the cross product.
 */
Vec2.cross = function(v1,v2) {
    return v1.x * v2.y - v1.y * v2.x;
};

module.exports = Vec2;

},{}],49:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var sin = Math.sin;
var cos = Math.cos;
var sqrt = Math.sqrt;

/**
 * A three-dimensional vector.
 *
 * @class Vec3
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
var Vec3 = function(x ,y, z){
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
};

/**
 * Set the components of the current Vec3.
 *
 * @method set
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 * @chainable
 */
Vec3.prototype.set = function set(x, y, z) {
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    if (z != null) this.z = z;

    return this;
};

/**
 * Add the input v to the current Vec3.
 *
 * @method add
 * @param {Vec3} v The Vec3 to add.
 * @chainable
 */
Vec3.prototype.add = function add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;
};

/**
 * Subtract the input v from the current Vec3.
 *
 * @method subtract
 * @param {Vec3} v The Vec3 to subtract.
 * @chainable
 */
Vec3.prototype.subtract = function subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the x axis.
 *
 * @method rotateX
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateX = function rotateX(theta) {
    var y = this.y;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.y = y * cosTheta - z * sinTheta;
    this.z = y * sinTheta + z * cosTheta;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the y axis.
 *
 * @method rotateY
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateY = function rotateY(theta) {
    var x = this.x;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = z * sinTheta + x * cosTheta;
    this.z = z * cosTheta - x * sinTheta;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the z axis.
 *
 * @method rotateZ
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateZ = function rotateZ(theta) {
    var x = this.x;
    var y = this.y;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = x * cosTheta - y * sinTheta;
    this.y = x * sinTheta + y * cosTheta;

    return this;
};

/**
 * The dot product of the current Vec3 with input Vec3 v.
 *
 * @method dot
 * @param {Vec3} v The other Vec3.
 * @return {Number}
 */
Vec3.prototype.dot = function dot(v) {
    return this.x*v.x + this.y*v.y + this.z*v.z;
};

/**
 * The dot product of the current Vec3 with input Vec3 v.
 * Stores the result in the current Vec3.
 *
 * @method cross
 * @param {Vec3} v The other Vec3.
 * @chainable
 */
Vec3.prototype.cross = function cross(v) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    this.x = y * vz - z * vy;
    this.y = z * vx - x * vz;
    this.z = x * vy - y * vx;
    return this;
};

/**
 * Scale the current Vec3 by a scalar.
 *
 * @method scale
 * @param {Number} s The Number by which to scale.
 * @chainable
 */
Vec3.prototype.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;

    return this;
};

/**
 * Preserve the magnitude but invert the orientation of the current Vec3.
 *
 * @method invert
 * @chainable
 */
Vec3.prototype.invert = function invert() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;

    return this;
};

/**
 * Apply a function component-wise to the current Vec3.
 *
 * @method map
 * @param {Function} fn Function to apply.
 * @chainable
 */
Vec3.prototype.map = function map(fn) {
    this.x = fn(this.x);
    this.y = fn(this.y);
    this.z = fn(this.z);

    return this;
};

/**
 * The magnitude of the current Vec3.
 *
 * @method length
 * @return {Number}
 */
Vec3.prototype.length = function length() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return sqrt(x * x + y * y + z * z);
};

/**
 * The magnitude squared of the current Vec3.
 *
 * @method length
 * @return {Number}
 */
Vec3.prototype.lengthSq = function lengthSq() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return x * x + y * y + z * z;
};

/**
 * Copy the input onto the current Vec3.
 *
 * @method copy
 * @param {Vec3} v Vec3 to copy.
 * @chainable
 */
Vec3.prototype.copy = function copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
};

/**
 * Reset the current Vec3.
 *
 * @method clear
 * @chainable
 */
Vec3.prototype.clear = function clear() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    return this;
};

/**
 * Check whether the magnitude of the current Vec3 is exactly 0.
 *
 * @method isZero
 * @return {Boolean}
 */
Vec3.prototype.isZero = function isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
};

/**
 * The array form of the current Vec3.
 *
 * @method toArray
 * @return {Number[]}
 */
Vec3.prototype.toArray = function toArray() {
    return [this.x, this.y, this.z];
};

/**
 * Preserve the orientation but change the length of the current Vec3 to 1.
 *
 * @method normalize
 * @chainable
 */
Vec3.prototype.normalize = function normalize() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var len = sqrt(x * x + y * y + z * z) || 1;
    len = 1 / len;

    this.x *= len;
    this.y *= len;
    this.z *= len;
    return this;
};

/**
 * Apply the rotation corresponding to the input (unit) Quaternion
 * to the current Vec3.
 *
 * @method applyRotation
 * @param {Quaternion} q Unit Quaternion representing the rotation to apply.
 * @chainable
 */
Vec3.prototype.applyRotation = function applyRotation(q) {
    var cw = q.w;
    var cx = -q.x;
    var cy = -q.y;
    var cz = -q.z;

    var vx = this.x;
    var vy = this.y;
    var vz = this.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    this.x = tx * w + x * tw + y * tz - ty * z;
    this.y = ty * w + y * tw + tx * z - x * tz;
    this.z = tz * w + z * tw + x * ty - tx * y;
    return this;
};

/**
 * Apply the input Mat33 the the current Vec3.
 *
 * @method applyMatrix
 * @param {Mat33} matrix Mat33 to apply.
 * @chainable
 */
Vec3.prototype.applyMatrix = function applyMatrix(matrix) {
    var M = matrix.get();

    var x = this.x;
    var y = this.y;
    var z = this.z;

    this.x = M[0]*x + M[1]*y + M[2]*z;
    this.y = M[3]*x + M[4]*y + M[5]*z;
    this.z = M[6]*x + M[7]*y + M[8]*z;
    return this;
};

/**
 * Normalize the input Vec3.
 *
 * @method normalize
 * @param {Vec3} v The reference Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The normalize Vec3.
 */
Vec3.normalize = function normalize(v, output) {
    var x = v.x;
    var y = v.y;
    var z = v.z;

    var length = sqrt(x * x + y * y + z * z) || 1;
    length = 1 / length;

    output.x = x * length;
    output.y = y * length;
    output.z = z * length;
    return output;
};

/**
 * Apply a rotation to the input Vec3.
 *
 * @method applyRotation
 * @param {Vec3} v The reference Vec3.
 * @param {Quaternion} q Unit Quaternion representing the rotation to apply.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The rotated version of the input Vec3.
 */
Vec3.applyRotation = function applyRotation(v, q, output) {
    var cw = q.w;
    var cx = -q.x;
    var cy = -q.y;
    var cz = -q.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    output.x = tx * w + x * tw + y * tz - ty * z;
    output.y = ty * w + y * tw + tx * z - x * tz;
    output.z = tz * w + z * tw + x * ty - tx * y;
    return output;
};

/**
 * Clone the input Vec3.
 *
 * @method clone
 * @param {Vec3} v The Vec3 to clone.
 * @return {Vec3} The cloned Vec3.
 */
Vec3.clone = function clone(v) {
    return new Vec3(v.x, v.y, v.z);
};

/**
 * Add the input Vec3's.
 *
 * @method add
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the addition.
 */
Vec3.add = function add(v1, v2, output) {
    output.x = v1.x + v2.x;
    output.y = v1.y + v2.y;
    output.z = v1.z + v2.z;
    return output;
};

/**
 * Subtract the second Vec3 from the first.
 *
 * @method subtract
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the subtraction.
 */
Vec3.subtract = function subtract(v1, v2, output) {
    output.x = v1.x - v2.x;
    output.y = v1.y - v2.y;
    output.z = v1.z - v2.z;
    return output;
};

/**
 * Scale the input Vec3.
 *
 * @method scale
 * @param {Vec3} v The reference Vec3.
 * @param {Number} s Number to scale by.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the scaling.
 */
Vec3.scale = function scale(v, s, output) {
    output.x = v.x * s;
    output.y = v.y * s;
    output.z = v.z * s;
    return output;
};

/**
 * The dot product of the input Vec3's.
 *
 * @method dotProduct
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @return {Number} The dot product.
 */
Vec3.dot = function dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
};

/**
 * The (right-handed) cross product of the input Vec3's.
 * v1 x v2.
 *
 * @method crossProduct
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3}
 */
Vec3.cross = function cross(v1, v2, output) {
    var x1 = v1.x;
    var y1 = v1.y;
    var z1 = v1.z;
    var x2 = v2.x;
    var y2 = v2.y;
    var z2 = v2.z;

    output.x = y1 * z2 - z1 * y2;
    output.y = z1 * x2 - x1 * z2;
    output.z = x1 * y2 - y1 * x2;
    return output;
};

/**
 * The projection of v1 onto v2.
 *
 * @method project
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3}
 */
Vec3.project = function project(v1, v2, output) {
    var x1 = v1.x;
    var y1 = v1.y;
    var z1 = v1.z;
    var x2 = v2.x;
    var y2 = v2.y;
    var z2 = v2.z;

    var scale = x1 * x2 + y1 * y2 + z1 * z2;
    scale /= x2 * x2 + y2 * y2 + z2 * z2;

    output.x = x2 * scale;
    output.y = y2 * scale;
    output.z = z2 * scale;

    return output;
};

module.exports = Vec3;

},{}],50:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

module.exports = {
    Mat33: require('./Mat33'),
    Quaternion: require('./Quaternion'),
    Vec2: require('./Vec2'),
    Vec3: require('./Vec3')
};


},{"./Mat33":46,"./Quaternion":47,"./Vec2":48,"./Vec3":49}],51:[function(require,module,exports){
module.exports = noop

function noop() {
  throw new Error(
      'You should bundle your code ' +
      'using `glslify` as a transform.'
  )
}

},{}],52:[function(require,module,exports){
module.exports = programify

function programify(vertex, fragment, uniforms, attributes) {
  return {
    vertex: vertex, 
    fragment: fragment,
    uniforms: uniforms, 
    attributes: attributes
  };
}

},{}],53:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Vec3 = require('../math/Vec3');
var Mat33 = require('../math/Mat33');

var ObjectManager = require('../utilities/ObjectManager');
ObjectManager.register('DynamicGeometry', DynamicGeometry);
ObjectManager.register('DynamicGeometryFeature', DynamicGeometryFeature);
var OMRequestDynamicGeometryFeature = ObjectManager.requestDynamicGeometryFeature;
var OMFreeDynamicGeometryFeature = ObjectManager.freeDynamicGeometryFeature;

var TRIPLE_REGISTER = new Vec3();

/**
 * The so called triple product. Used to find a vector perpendicular to (v2 - v1) in the direction of v3.
 * (v1 x v2) x v3.
 *
 * @method tripleProduct
 * @private
 * @param {Vec3} v1 The first Vec3.
 * @param {Vec3} v2 The second Vec3.
 * @param {Vec3} v3 The third Vec3.
 * @return {Vec3} The result of the triple product.
 */
function tripleProduct(v1, v2, v3) {
    var v = TRIPLE_REGISTER;

    Vec3.cross(v1, v2, v);
    Vec3.cross(v, v3, v);

    return v;
}

/**
 * Of a set of vertices, retrieves the vertex furthest in the given direction.
 *
 * @method _hullSupport
 * @private
 * @param {Vec3[]} vertices The reference set of Vec3's.
 * @param {Vec3} direction The direction to compare against.
 * @return {Object} The vertex and its index in the vertex array.
 */
function _hullSupport(vertices, direction) {
    var furthest;
    var max = -Infinity;
    var dot;
    var vertex;
    var index;
    for (var i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        dot = Vec3.dot(vertex, direction);
        if (dot > max) {
            furthest = vertex;
            max = dot;
            index = i;
        }
    }

    return {
        vertex: furthest,
        index: index
    };
}

var VEC_REGISTER = new Vec3();
var POINTCHECK_REGISTER = new Vec3();
var AO_REGISTER = new Vec3();
var AB_REGISTER = new Vec3();
var AC_REGISTER = new Vec3();
var AD_REGISTER = new Vec3();
var BC_REGISTER = new Vec3();
var BD_REGISTER = new Vec3();

/**
 * Used internally to represent polyhedral facet information.
 *
 * @class DynamicGeometryFeature
 * @param {Number} distance The distance of the feature from the origin.
 * @param {Vec3} normal The Vec3 orthogonal to the feature, pointing out of the geometry.
 * @param {Number[]} vertexIndices The indices of the vertices which compose the feature.
 */
function DynamicGeometryFeature(distance, normal, vertexIndices) {
    this.distance = distance;
    this.normal = normal;
    this.vertexIndices = vertexIndices;
}

/**
 * Used by ObjectManager to reset objects.
 *
 * @method reset
 * @param {Array} args Argument array analogous to that used in instantiation.
 * @chainable
 */
DynamicGeometryFeature.prototype.reset = function(distance, normal, vertexIndices) {
    this.distance = distance;
    this.normal = normal;
    this.vertexIndices = vertexIndices;

    return this;
};

/**
 * Abstract object representing a growing polyhedron. Used in ConvexHull and in GJK+EPA collision detection.
 *
 * @class DynamicGeometry
 */
function DynamicGeometry() {
    this.vertices = [];
    this.numVertices = 0;
    this.features = [];
    this.numFeatures = 0;
    this.lastVertexIndex = 0;

    this._IDPool = {
        vertices: [],
        features: []
    };
}

/**
 * Used by ObjectManager to reset objects.
 *
 * @method reset
 * @param {Array} args Argument array analogous to that used in instantiation.
 * @chainable
 */
DynamicGeometry.prototype.reset = function reset() {
    this.vertices = [];
    this.numVertices = 0;
    this.features = [];
    this.numFeatures = 0;
    this.lastVertexIndex = 0;

    this._IDPool = {
        vertices: [],
        features: []
    };

    return this;
};

/**
 * Add a vertex to the polyhedron.
 *
 * @method addVertex
 * @param {Object} vertexObj Object returned by the support function.
 */
DynamicGeometry.prototype.addVertex = function(vertexObj) {
    var index = this._IDPool.vertices.length ? this._IDPool.vertices.pop() : this.vertices.length;
    this.vertices[index] = vertexObj;
    this.lastVertexIndex = index;
    this.numVertices++;
};

/**
 * Remove a vertex and push its location in the vertex array to the IDPool for later use.
 *
 * @method removeVertex
 * @param {Number} index Index of the vertex to remove.
 */
DynamicGeometry.prototype.removeVertex = function(index) {
    var vertex = this.vertices[index];
    this.vertices[index] = null;
    this._IDPool.vertices.push(index);
    this.numVertices--;

    return vertex;
};

/**
 * Add a feature (facet) to the polyhedron. Used internally in the reshaping process.
 *
 * @method addFeature
 * @param {Number} distance The distance of the feature from the origin.
 * @param {Vec3} normal The facet normal.
 * @param {Number[]} vertexIndices The indices of the vertices which compose the feature.
 */
DynamicGeometry.prototype.addFeature = function(distance, normal, vertexIndices) {
    var index = this._IDPool.features.length ? this._IDPool.features.pop() : this.features.length;
    this.features[index] = OMRequestDynamicGeometryFeature().reset(distance, normal, vertexIndices);
    this.numFeatures++;
};

/**
 * Remove a feature and push its location in the feature array to the IDPool for later use.
 *
 * @method removeFeature
 * @param {Number} index Index of the feature to remove.
 */
DynamicGeometry.prototype.removeFeature = function(index) {
    var feature = this.features[index];
    this.features[index] = null;
    this._IDPool.features.push(index);
    this.numFeatures--;

    OMFreeDynamicGeometryFeature(feature);
};

/**
 * Retrieve the last vertex object added to the geometry.
 *
 * @method getLastVertex
 * @return {Object}
 */
DynamicGeometry.prototype.getLastVertex = function() {
    return this.vertices[this.lastVertexIndex];
};

/**
 * Of the closest face to the origin, returns the normal vector pointed away from the origin.
 *
 * @method getFeatureClosestToOrigin
 * @return {Object}
 */
DynamicGeometry.prototype.getFeatureClosestToOrigin = function() {
    var min = Infinity;
    var closest = null;
    var features = this.features;
    for (var i = 0, len = features.length; i < len; i++) {
        var feature = features[i];
        if (!feature) continue;
        if (feature.distance < min) {
            min = feature.distance;
            closest = feature;
        }
    }
    return closest;
};

/**
 * Adds edge if not already on the frontier, removes if the edge or its reverse are on the frontier.
 * Used when reshaping DynamicGeometry's.
 *
 * @method _validateEdge
 * @private
 * @param {Object[]} vertices Vec3 reference array.
 * @param {Number[][]} frontier Current edges potentially separating the features to remove from the persistant shape.
 * @param {Number} start The index of the starting Vec3 on the edge.
 * @param {Number} end The index of the culminating Vec3.
 */
function _validateEdge(vertices, frontier, start, end) {
    var e0 = vertices[start].vertex;
    var e1 = vertices[end].vertex;
    for (var i = 0, len = frontier.length; i < len; i++) {
        var edge = frontier[i];
        if (!edge) continue;
        var v0 = vertices[edge[0]].vertex;
        var v1 = vertices[edge[1]].vertex;
        if ((e0 === v0 && (e1 === v1)) || (e0 === v1 && (e1 === v0))) {
            frontier[i] = null;
            return;
        }
    }
    frontier.push([start, end]);
}

/**
 * Based on the last (exterior) point added to the polyhedron, removes features as necessary and redetermines
 * its (convex) shape to include the new point by adding triangle features. Uses referencePoint, a point on the shape's
 * interior, to ensure feature normals point outward, else takes referencePoint to be the origin.
 *
 * @method reshape
 * @param {Vec3} referencePoint Point known to be in the interior, used to orient feature normals.
 */
DynamicGeometry.prototype.reshape = function(referencePoint) {
    var vertices = this.vertices;
    var point = this.getLastVertex().vertex;
    var features = this.features;
    var vertexOnFeature;
    var featureVertices;

    var i, j, len;

    // The removal of features creates a hole in the polyhedron -- frontierEdges maintains the edges
    // of this hole, each of which will form one edge of a new feature to be created
    var frontierEdges = [];

    for (i = 0, len = features.length; i < len; i++) {
        if (!features[i]) continue;
        featureVertices = features[i].vertexIndices;
        vertexOnFeature = vertices[featureVertices[0]].vertex;
        // If point is 'above' the feature, remove that feature, and check to add its edges to the frontier.
        if (Vec3.dot(features[i].normal, Vec3.subtract(point, vertexOnFeature, POINTCHECK_REGISTER)) > -0.001) {
            _validateEdge(vertices, frontierEdges, featureVertices[0], featureVertices[1]);
            _validateEdge(vertices, frontierEdges, featureVertices[1], featureVertices[2]);
            _validateEdge(vertices, frontierEdges, featureVertices[2], featureVertices[0]);
            this.removeFeature(i);
        }
    }

    var A = point;
    var a = this.lastVertexIndex;
    for (j = 0, len = frontierEdges.length; j < len; j++) {
        if (!frontierEdges[j]) continue;
        var b = frontierEdges[j][0];
        var c = frontierEdges[j][1];
        var B = vertices[b].vertex;
        var C = vertices[c].vertex;

        var AB = Vec3.subtract(B, A, AB_REGISTER);
        var AC = Vec3.subtract(C, A, AC_REGISTER);
        var ABC = Vec3.cross(AB, AC, new Vec3());
        ABC.normalize();

        if (!referencePoint) {
            var distance = Vec3.dot(ABC, A);
            if (distance < 0) {
                ABC.invert();
                distance *= -1;
            }
            this.addFeature(distance, ABC, [a, b, c]);
        }
        else {
            var reference = Vec3.subtract(referencePoint, A, VEC_REGISTER);
            if (Vec3.dot(ABC, reference) > -0.001) ABC.invert();
            this.addFeature(null, ABC, [a, b, c]);
        }
    }
};

/**
 * Checks if the Simplex instance contains the origin, returns true or false.
 * If false, removes a point and, as a side effect, changes input direction to be both
 * orthogonal to the current working simplex and point toward the origin.
 * Calls callback on the removed point.
 *
 * @method simplexContainsOrigin
 * @param {Vec3} direction Vector used to store the new search direction.
 * @param {Function} callback Function invoked with the removed vertex, used e.g. to free the vertex object
 * in the object manager.
 * @return {Boolean} The result of the containment check.
 */
DynamicGeometry.prototype.simplexContainsOrigin = function(direction, callback) {
    var numVertices = this.vertices.length;

    var a = this.lastVertexIndex;
    var b = a - 1;
    var c = a - 2;
    var d = a - 3;

    b = b < 0 ? b + numVertices : b;
    c = c < 0 ? c + numVertices : c;
    d = d < 0 ? d + numVertices : d;

    var A = this.vertices[a].vertex;
    var B = this.vertices[b].vertex;
    var C = this.vertices[c].vertex;
    var D = this.vertices[d].vertex;

    var AO = Vec3.scale(A, -1, AO_REGISTER);
    var AB = Vec3.subtract(B, A, AB_REGISTER);
    var AC, AD, BC, BD;
    var ABC, ACD, ABD, BCD;
    var distanceABC, distanceACD, distanceABD, distanceBCD;

    var vertexToRemove;

    if (numVertices === 4) {
        // Tetrahedron
        AC = Vec3.subtract(C, A, AC_REGISTER);
        AD = Vec3.subtract(D, A, AD_REGISTER);

        ABC = Vec3.cross(AB, AC, new Vec3());
        ACD = Vec3.cross(AC, AD, new Vec3());
        ABD = Vec3.cross(AB, AD, new Vec3());
        ABC.normalize();
        ACD.normalize();
        ABD.normalize();
        if (Vec3.dot(ABC, AD) > 0) ABC.invert();
        if (Vec3.dot(ACD, AB) > 0) ACD.invert();
        if (Vec3.dot(ABD, AC) > 0) ABD.invert();
        // Don't need to check BCD because we would have just checked that in the previous iteration
        // -- we added A to the BCD triangle because A was in the direction of the origin.

        distanceABC = Vec3.dot(ABC, AO);
        distanceACD = Vec3.dot(ACD, AO);
        distanceABD = Vec3.dot(ABD, AO);

        // Norms point away from origin -> origin is inside tetrahedron
        if (distanceABC < 0.001 && distanceABD < 0.001 && distanceACD < 0.001) {
            BC = Vec3.subtract(C, B, BC_REGISTER);
            BD = Vec3.subtract(D, B, BD_REGISTER);
            BCD = Vec3.cross(BC, BD, new Vec3());
            BCD.normalize();
            if (Vec3.dot(BCD, AB) <= 0) BCD.invert();
            distanceBCD = -1 * Vec3.dot(BCD,B);
            // Prep features for EPA
            this.addFeature(-distanceABC, ABC, [a,b,c]);
            this.addFeature(-distanceACD, ACD, [a,c,d]);
            this.addFeature(-distanceABD, ABD, [a,d,b]);
            this.addFeature(-distanceBCD, BCD, [b,c,d]);
            return true;
        }
        else if (distanceABC >= 0.001) {
            vertexToRemove = this.removeVertex(d);
            direction.copy(ABC);
        }
        else if (distanceACD >= 0.001) {
            vertexToRemove = this.removeVertex(b);
            direction.copy(ACD);
        }
        else {
            vertexToRemove = this.removeVertex(c);
            direction.copy(ABD);
        }
    }
    else if (numVertices === 3) {
        // Triangle
        AC = Vec3.subtract(C, A, AC_REGISTER);
        Vec3.cross(AB, AC, direction);
        if (Vec3.dot(direction, AO) <= 0) direction.invert();
    }
    else {
        // Line
        direction.copy(tripleProduct(AB, AO, AB));
    }
    if (vertexToRemove && callback) callback(vertexToRemove);
    return false;
};

/**
 * Given an array of Vec3's, computes the convex hull. Used in constructing bodies in the physics system and to
 * create custom GL meshes.
 *
 * @class ConvexHull
 * @constructor
 * @param {Vec3[]} vertices Cloud of vertices of which the enclosing convex hull is desired.
 * @param {Number} [iterations = 1e3] Maximum number of vertices to compose the convex hull.
 */
function ConvexHull(vertices, iterations) {
    iterations = iterations || 1e3;
    var hull = _computeConvexHull(vertices, iterations);

    var i, len;

    var indices = [];
    for (i = 0, len = hull.features.length; i < len; i++) {
        var f = hull.features[i];
        if (f) indices.push(f.vertexIndices);
    }

    var polyhedralProperties = _computePolyhedralProperties(hull.vertices, indices);
    var centroid = polyhedralProperties.centroid;

    var worldVertices = [];
    for (i = 0, len = hull.vertices.length; i < len; i++) {
        worldVertices.push(Vec3.subtract(hull.vertices[i].vertex, centroid, new Vec3()));
    }

    var normals = [];
    for (i = 0, len = worldVertices.length; i < len; i++) {
        normals.push(Vec3.normalize(worldVertices[i], new Vec3()));
    }

    var graph = {};
    var _neighborMatrix = {};
    for (i = 0; i < indices.length; i++) {
        var a = indices[i][0];
        var b = indices[i][1];
        var c = indices[i][2];

        _neighborMatrix[a] = _neighborMatrix[a] || {};
        _neighborMatrix[b] = _neighborMatrix[b] || {};
        _neighborMatrix[c] = _neighborMatrix[c] || {};

        graph[a] = graph[a] || [];
        graph[b] = graph[b] || [];
        graph[c] = graph[c] || [];

        if (!_neighborMatrix[a][b]) {
            _neighborMatrix[a][b] = 1;
            graph[a].push(b);
        }
        if (!_neighborMatrix[a][c]) {
            _neighborMatrix[a][c] = 1;
            graph[a].push(c);
        }
        if (!_neighborMatrix[b][a]) {
            _neighborMatrix[b][a] = 1;
            graph[b].push(a);
        }
        if (!_neighborMatrix[b][c]) {
            _neighborMatrix[b][c] = 1;
            graph[b].push(c);
        }
        if (!_neighborMatrix[c][a]) {
            _neighborMatrix[c][a] = 1;
            graph[c].push(a);
        }
        if (!_neighborMatrix[c][b]) {
            _neighborMatrix[c][b] = 1;
            graph[c].push(b);
        }
    }

    this.indices = indices;
    this.vertices = worldVertices;
    this.normals = normals;
    this.polyhedralProperties = polyhedralProperties;
    this.graph = graph;
}

/**
 * Performs the actual computation of the convex hull.
 *
 * @method _computeConvexHull
 * @private
 * @param {Vec3[]} vertices Cloud of vertices of which the enclosing convex hull is desired.
 * @param {Number} maxIterations Maximum number of vertices to compose the convex hull.
 * @return {DynamicGeometry} The computed hull.
 */
function _computeConvexHull(vertices, maxIterations) {
    var hull = new DynamicGeometry();

    hull.addVertex(_hullSupport(vertices, new Vec3(1, 0, 0)));
    hull.addVertex(_hullSupport(vertices, new Vec3(-1, 0, 0)));
    var A = hull.vertices[0].vertex;
    var B = hull.vertices[1].vertex;
    var AB = Vec3.subtract(B, A, AB_REGISTER);

    var dot;
    var vertex;
    var furthest;
    var index;
    var i, len;

    var max = -Infinity;
    for (i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        if (vertex === A || vertex === B) continue;
        var AV = Vec3.subtract(vertex, A, VEC_REGISTER);
        dot = Vec3.dot(AV, tripleProduct(AB, AV, AB));
        dot = dot < 0 ? dot * -1 : dot;
        if (dot > max) {
            max = dot;
            furthest = vertex;
            index = i;
        }
    }
    hull.addVertex({
        vertex: furthest,
        index: index
    });

    var C = furthest;
    var AC = Vec3.subtract(C, A, AC_REGISTER);
    var ABC = Vec3.cross(AB, AC, new Vec3());
    ABC.normalize();

    max = -Infinity;
    for (i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        if (vertex === A || vertex === B || vertex === C) continue;
        dot = Vec3.dot(Vec3.subtract(vertex, A, VEC_REGISTER), ABC);
        dot = dot < 0 ? dot * -1 : dot;
        if (dot > max) {
            max = dot;
            furthest = vertex;
            index = i;
        }
    }
    hull.addVertex({
        vertex: furthest,
        index: index
    });

    var D = furthest;
    var AD = Vec3.subtract(D, A, AD_REGISTER);
    var BC = Vec3.subtract(C, B, BC_REGISTER);
    var BD = Vec3.subtract(D, B, BD_REGISTER);

    var ACD = Vec3.cross(AC, AD, new Vec3());
    var ABD = Vec3.cross(AB, AD, new Vec3());
    var BCD = Vec3.cross(BC, BD, new Vec3());
    ACD.normalize();
    ABD.normalize();
    BCD.normalize();
    if (Vec3.dot(ABC, AD) > 0) ABC.invert();
    if (Vec3.dot(ACD, AB) > 0) ACD.invert();
    if (Vec3.dot(ABD, AC) > 0) ABD.invert();
    if (Vec3.dot(BCD, AB) < 0) BCD.invert();

    var a = 0;
    var b = 1;
    var c = 2;
    var d = 3;

    hull.addFeature(null, ABC, [a, b, c]);
    hull.addFeature(null, ACD, [a, c, d]);
    hull.addFeature(null, ABD, [a, b, d]);
    hull.addFeature(null, BCD, [b, c, d]);

    var assigned = {};
    for (i = 0, len = hull.vertices.length; i < len; i++) {
       assigned[hull.vertices[i].index] = true;
    }

    var cx = A.x + B.x + C.x + D.x;
    var cy = A.y + B.y + C.y + D.y;
    var cz = A.z + B.z + C.z + D.z;
    var referencePoint = new Vec3(cx, cy, cz);
    referencePoint.scale(0.25);

    var features = hull.features;
    var iteration = 0;
    while (iteration++ < maxIterations) {
        var currentFeature = null;
        for (i = 0, len = features.length; i < len; i++) {
            if (!features[i] || features[i].done) continue;
            currentFeature = features[i];
            furthest = null;
            index = null;
            A = hull.vertices[currentFeature.vertexIndices[0]].vertex;
            var s = _hullSupport(vertices, currentFeature.normal);
            furthest = s.vertex;
            index = s.index;
            var dist = Vec3.dot(Vec3.subtract(furthest, A, VEC_REGISTER), currentFeature.normal);

            if (dist < 0.001 || assigned[index]) {
                currentFeature.done = true;
                continue;
            }

            assigned[index] = true;
            hull.addVertex(s);
            hull.reshape(referencePoint);
        }
            // No feature has points 'above' it -> finished
        if (currentFeature === null) break;
    }

    return hull;
}

/**
 * Helper function used in _computePolyhedralProperties.
 * Sets f0 - f2 and g0 - g2 depending on w0 - w2.
 *
 * @method _subexpressions
 * @private
 * @param {Number} w0 Reference x coordinate.
 * @param {Number} w1 Reference y coordinate.
 * @param {Number} w2 Reference z coordinate.
 * @param {Number[]} f One of two output registers to contain the result of the calculation.
 * @param {Number[]} g One of two output registers to contain the result of the calculation.
 */
function _subexpressions(w0, w1, w2, f, g) {
    var t0 = w0 + w1;
    f[0] = t0 + w2;
    var t1 = w0 * w0;
    var t2 = t1 + w1 * t0;
    f[1] = t2 + w2 * f[0];
    f[2] = w0 * t1 + w1 * t2 + w2 * f[1];
    g[0] = f[1] + w0 * (f[0] + w0);
    g[1] = f[1] + w1 * (f[0] + w1);
    g[2] = f[1] + w2 * (f[0] + w2);
}

/**
 * Determines various properties of the volume.
 *
 * @method _computePolyhedralProperties
 * @private
 * @param {Vec3[]} vertices The vertices of the polyhedron.
 * @param {Number[][]} indices Array of arrays of indices of vertices composing the triangular features of the polyhedron,
 * one array for each feature.
 * @return {Object} Object holding the calculated span, volume, center, and euler tensor.
 */
function _computePolyhedralProperties(vertices, indices) {
    // Order: 1, x, y, z, x^2, y^2, z^2, xy, yz, zx
    var integrals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var fx = [];
    var fy = [];
    var fz = [];
    var gx = [];
    var gy = [];
    var gz = [];

    var i, len;

    for (i = 0, len = indices.length; i < len; i++) {
        var A = vertices[indices[i][0]].vertex;
        var B = vertices[indices[i][1]].vertex;
        var C = vertices[indices[i][2]].vertex;
        var AB = Vec3.subtract(B, A, AB_REGISTER);
        var AC = Vec3.subtract(C, A, AC_REGISTER);
        var ABC = AB.cross(AC);
        if (Vec3.dot(A, ABC) < 0) ABC.invert();

        var d0 = ABC.x;
        var d1 = ABC.y;
        var d2 = ABC.z;

        var x0 = A.x;
        var y0 = A.y;
        var z0 = A.z;
        var x1 = B.x;
        var y1 = B.y;
        var z1 = B.z;
        var x2 = C.x;
        var y2 = C.y;
        var z2 = C.z;

        _subexpressions(x0, x1, x2, fx, gx);
        _subexpressions(y0, y1, y2, fy, gy);
        _subexpressions(z0, z1, z2, fz, gz);

        integrals[0] += d0 * fx[0];
        integrals[1] += d0 * fx[1];
        integrals[2] += d1 * fy[1];
        integrals[3] += d2 * fz[1];
        integrals[4] += d0 * fx[2];
        integrals[5] += d1 * fy[2];
        integrals[6] += d2 * fz[2];
        integrals[7] += d0 * (y0 * gx[0] + y1 * gx[1] + y2 * gx[2]);
        integrals[8] += d1 * (z0 * gy[0] + z1 * gy[1] + z2 * gy[2]);
        integrals[9] += d2 * (x0 * gz[0] + x1 * gz[1] + x2 * gz[2]);
    }

    integrals[0] /= 6;
    integrals[1] /= 24;
    integrals[2] /= 24;
    integrals[3] /= 24;
    integrals[4] /= 60;
    integrals[5] /= 60;
    integrals[6] /= 60;
    integrals[7] /= 120;
    integrals[8] /= 120;
    integrals[9] /= 120;

    var minX = Infinity, maxX = -Infinity;
    var minY = Infinity, maxY = -Infinity;
    var minZ = Infinity, maxZ = -Infinity;

    for (i = 0, len = vertices.length; i < len; i++) {
        var vertex = vertices[i].vertex;
        if (vertex.x < minX) minX = vertex.x;
        if (vertex.x > maxX) maxX = vertex.x;
        if (vertex.y < minY) minY = vertex.y;
        if (vertex.y > maxY) maxY = vertex.y;
        if (vertex.z < minZ) minZ = vertex.z;
        if (vertex.z > maxZ) maxZ = vertex.z;
    }

    var size = [maxX - minX, maxY - minY, maxZ - minZ];
    var volume = integrals[0];
    var centroid = new Vec3(integrals[1], integrals[2], integrals[3]);
    centroid.scale(1 / volume);

    var eulerTensor = new Mat33([
                                  integrals[4], integrals[7], integrals[9],
                                  integrals[7], integrals[5], integrals[8],
                                  integrals[9], integrals[8], integrals[6]
                                 ]);

    return {
        size: size,
        volume: volume,
        centroid: centroid,
        eulerTensor: eulerTensor
    };
}

module.exports = {
    DynamicGeometry: DynamicGeometry,
    ConvexHull: ConvexHull
};

},{"../math/Mat33":46,"../math/Vec3":49,"../utilities/ObjectManager":93}],54:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Particle = require('./bodies/Particle');
var Constraint = require('./constraints/Constraint');
var Force = require('./forces/Force');

var CallbackStore = require('../utilities/CallbackStore');

var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');

var VEC_REGISTER = new Vec3();
var QUAT_REGISTER = new Quaternion();
var DELTA_REGISTER = new Vec3();

/**
 * Singleton PhysicsEngine object.
 * Manages bodies, forces, constraints.
 *
 * @class PhysicsEngine
 * @param {Object} options A hash of configurable options.
 */
function PhysicsEngine(options) {
    this.events = new CallbackStore();

    options = options || {};
    /** @prop bodies The bodies currently active in the engine. */
    this.bodies = [];
    /** @prop forces The forces currently active in the engine. */
    this.forces = [];
    /** @prop constraints The constraints currently active in the engine. */
    this.constraints = [];

    /** @prop step The time between frames in the engine. */
    this.step = options.step || 1000/60;
    /** @prop iterations The number of times each constraint is solved per frame. */
    this.iterations = options.iterations || 10;
    /** @prop _indexPool Pools of indicies to track holes in the arrays. */
    this._indexPools = {
        bodies: [],
        forces: [],
        constraints: []
    };

    this._entityMaps = {
        bodies: {},
        forces: {},
        constraints: {}
    };

    this.speed = options.speed || 1.0;
    this.time = 0;
    this.delta = 0;

    this.origin = options.origin || new Vec3();
    this.orientation = options.orientation ? options.orientation.normalize() :  new Quaternion();

    this.frameDependent = options.frameDependent || false;

    this.transformBuffers = {
        position: [0, 0, 0],
        rotation: [0, 0, 0, 1]
    };
}

/**
 * Listen for a specific event.
 *
 * @method on
 * @param {String} key
 * @param {Function} callback
 * @chainable
 */
PhysicsEngine.prototype.on = function on(key, callback) {
    this.events.on(key, callback);
    return this;
};

/**
 * Stop listening for a specific event.
 *
 * @method on
 * @param {String} key
 * @param {Function} callback
 * @chainable
 */
PhysicsEngine.prototype.off = function off(key, callback) {
    this.events.off(key, callback);
    return this;
};

/**
 * Trigger an event.
 *
 * @method on
 * @param {String} key
 * @param {Object} payload
 * @chainable
 */
PhysicsEngine.prototype.trigger = function trigger(key, payload) {
    this.events.trigger(key, payload);
    return this;
};

/**
 * Set the origin of the world.
 *
 * @method setOrigin
 * @chainable
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
PhysicsEngine.prototype.setOrigin = function setOrigin(x, y, z) {
    this.origin.set(x, y, z);
    return this;
};

/**
 * Set the orientation of the world.
 *
 * @method setOrientation
 * @chainable
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
PhysicsEngine.prototype.setOrientation = function setOrientation(w, x, y, z) {
    this.orientation.set(w, x, y, z).normalize();
    return this;
};

/**
 * Private helper method to store an element in a library array.
 *
 * @method _addElement
 * @private
 * @param {Object} element The body, force, or constraint to add.
 * @param {String} key Where to store the element.
 */
function _addElement(context, element, key) {
    var map = context._entityMaps[key];
    if (map[element._ID] == null) {
        var library = context[key];
        var indexPool = context._indexPools[key];
        if (indexPool.length) map[element._ID] = indexPool.pop();
        else map[element._ID] = library.length;
        library[map[element._ID]] = element;
    }
}

/**
 * Private helper method to remove an element from a library array.
 *
 * @method _removeElement
 * @private
 * @param {Object} element The body, force, or constraint to remove.
 * @param {String} key Where to store the element.
 */
function _removeElement(context, element, key) {
    var map = context._entityMaps[key];
    var index = map[element._ID];
    if (index != null) {
        context._indexPools[key].push(index);
        context[key][index] = null;
        map[element._ID] = null;
    }
}

/**
 * Add a group of bodies, force, or constraints to the engine.
 *
 * @method add
 * @chainable
 */
PhysicsEngine.prototype.add = function add() {
    for (var j = 0, lenj = arguments.length; j < lenj; j++) {
        var entity = arguments[j];
        if (entity instanceof Array) {
            for (var i = 0, len = entity.length; i < len; i++) {
                var e = entity[i];
                this.add(e);
            }
        } else {
            if (entity instanceof Particle) this.addBody(entity);
            else if (entity instanceof Constraint) this.addConstraint(entity);
            else if (entity instanceof Force) this.addForce(entity);
        }
    }
    return this;
};

/**
 * Remove a group of bodies, force, or constraints from the engine.
 *
 * @method remove
 * @chainable
 */
PhysicsEngine.prototype.remove = function remove() {
    for (var j = 0, lenj = arguments.length; j < lenj; j++) {
        var entity = arguments[j];
        if (entity instanceof Array) {
            for (var i = 0, len = entity.length; i < len; i++) {
                var e = entity[i];
                this.add(e);
            }
        } else {
            if (entity instanceof Particle) this.removeBody(entity);
            else if (entity instanceof Constraint) this.removeConstraint(entity);
            else if (entity instanceof Force) this.removeForce(entity);
        }
    }
    return this;
};

/**
 * Begin tracking a body.
 *
 * @method addBody
 * @param {Particle} body The body to track.
 */
PhysicsEngine.prototype.addBody = function addBody(body) {
    _addElement(this, body, 'bodies');
};

/**
 * Begin tracking a force.
 *
 * @method addForce
 * @param {Force} force The force to track.
 */
PhysicsEngine.prototype.addForce = function addForce(force) {
    _addElement(this, force, 'forces');
};

/**
 * Begin tracking a constraint.
 *
 * @method addConstraint
 * @param {Constraint} constraint The constraint to track.
 */
PhysicsEngine.prototype.addConstraint = function addConstraint(constraint) {
    _addElement(this, constraint, 'constraints');
};

/**
 * Stop tracking a body.
 *
 * @method removeBody
 * @param {Particle} body The body to stop tracking.
 */
PhysicsEngine.prototype.removeBody = function removeBody(body) {
    _removeElement(this, body, 'bodies');
};

/**
 * Stop tracking a force.
 *
 * @method removeForce
 * @param {Force} force The force to stop tracking.
 */
PhysicsEngine.prototype.removeForce = function removeForce(force) {
    _removeElement(this, force, 'forces');
};

/**
 * Stop tracking a constraint.
 *
 * @method removeConstraint
 * @param {Constraint} constraint The constraint to stop tracking.
 */
PhysicsEngine.prototype.removeConstraint = function removeConstraint(constraint) {
    _removeElement(this, constraint, 'constraints');
};

/**
 * Update the physics system to reflect the changes since the last frame. Steps forward in increments of
 * PhysicsEngine.step.
 *
 * @method update
 * @param {Number} time
 */
PhysicsEngine.prototype.update = function update(time) {
    if (this.time === 0) this.time = time;

    var bodies = this.bodies;
    var forces = this.forces;
    var constraints = this.constraints;

    var frameDependent = this.frameDependent;
    var step = this.step;
    var dt = step * 0.001;
    var speed = this.speed;

    var delta = this.delta;
    delta += (time - this.time) * speed;
    this.time = time;

    var i, len;
    var force, body, constraint;

    while(delta > step) {
        this.events.trigger('prestep', time);

        // Update Forces on particles
        for (i = 0, len = forces.length; i < len; i++) {
            force = forces[i];
            if (force === null) continue;
            force.update(time, dt);
        }

        // Tentatively update velocities
        for (i = 0, len = bodies.length; i < len; i++) {
            body = bodies[i];
            if (body === null) continue;
            _integrateVelocity(body, dt);
        }

        // Prep constraints for solver
        for (i = 0, len = constraints.length; i < len; i++) {
            constraint = constraints[i];
            if (constraint === null) continue;
            constraint.update(time, dt);
        }

        // Iteratively resolve constraints
        for (var j = 0, numIterations = this.iterations; j < numIterations; j++) {
            for (i = 0, len = constraints.length; i < len; i++) {
                constraint = constraints[i];
                if (constraint === null) continue;
                constraint.resolve(time, dt);
            }
        }

        // Increment positions and orientations
        for (i = 0, len = bodies.length; i < len; i++) {
            body = bodies[i];
            if (body === null) continue;
            _integratePose(body, dt);
        }

        this.events.trigger('poststep', time);

        if (frameDependent) delta = 0;
        else delta -= step;
    }

    this.delta = delta;
};

/**
 * Get the transform equivalent to the Particle's position and orientation.
 *
 * @method getTransform
 * @return {Object} Position and rotation of the boy, taking into account
 * the origin and orientation of the world.
 */
PhysicsEngine.prototype.getTransform = function getTransform(body) {
    var o = this.origin;
    var oq = this.orientation;
    var transform = this.transformBuffers;

    var p = body.position;
    var q = body.orientation;
    var rot = q;
    var loc = p;

    if (oq.w !== 1) {
        rot = Quaternion.multiply(q, oq, QUAT_REGISTER);
        loc = oq.rotateVector(p, VEC_REGISTER);
    }

    transform.position[0] = o.x+loc.x;
    transform.position[1] = o.y+loc.y;
    transform.position[2] = o.z+loc.z;

    transform.rotation[0] = rot.x;
    transform.rotation[1] = rot.y;
    transform.rotation[2] = rot.z;
    transform.rotation[3] = rot.w;

    return transform;
};

/**
 * Update the Particle momenta based off of current incident force and torque.
 *
 * @method _integrateVelocity
 * @private
 * @param {Particle} body
 * @param {Number} dt delta time
 */
function _integrateVelocity(body, dt) {
    body.momentum.add(Vec3.scale(body.force, dt, DELTA_REGISTER));
    body.angularMomentum.add(Vec3.scale(body.torque, dt, DELTA_REGISTER));
    Vec3.scale(body.momentum, body.inverseMass, body.velocity);
    body.inverseInertia.vectorMultiply(body.angularMomentum, body.angularVelocity);
    body.force.clear();
    body.torque.clear();
}

/**
 * Update the Particle position and orientation based off current translational and angular velocities.
 *
 * @method _integratePose
 * @private
 * @param {Particle} body
 * @param dt {Number} delta time
 */
function _integratePose(body, dt) {
    if (body.restrictions !== 0) {
        var restrictions = body.restrictions;
        var x = null;
        var y = null;
        var z = null;
        var ax = null;
        var ay = null;
        var az = null;

        if (restrictions & 32) x = 0;
        if (restrictions & 16) y = 0;
        if (restrictions & 8) z = 0;
        if (restrictions & 4) ax = 0;
        if (restrictions & 2) ay = 0;
        if (restrictions & 1) az = 0;

        if (x !== null || y !== null || z !== null) body.setVelocity(x,y,z);
        if (ax !== null || ay !== null || az !== null) body.setAngularVelocity(ax, ay, az);
    }

    body.position.add(Vec3.scale(body.velocity, dt, DELTA_REGISTER));

    var w = body.angularVelocity;
    var q = body.orientation;
    var wx = w.x;
    var wy = w.y;
    var wz = w.z;

    var qw = q.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;

    var hdt = dt * 0.5;
    q.w += (-wx * qx - wy * qy - wz * qz) * hdt;
    q.x += (wx * qw + wy * qz - wz * qy) * hdt;
    q.y += (wy * qw + wz * qx - wx * qz) * hdt;
    q.z += (wz * qw + wx * qy - wy * qx) * hdt;

    q.normalize();

    body.updateInertia();
}

module.exports = PhysicsEngine;

},{"../math/Quaternion":47,"../math/Vec3":49,"../utilities/CallbackStore":90,"./bodies/Particle":57,"./constraints/Constraint":63,"./forces/Force":74}],55:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Vec3 = require('../../math/Vec3');
var ConvexBodyFactory = require('./ConvexBodyFactory');

var _Box = ConvexBodyFactory([
            // Order: back-left,back-right,front-left,front-right
            // Top half
            new Vec3(-100, -100, -100),
            new Vec3(100, -100, -100),
            new Vec3(-100, -100, 100),
            new Vec3(100, -100, 100),
            // Bottom half
            new Vec3(-100, 100, -100),
            new Vec3(100, 100, -100),
            new Vec3(-100, 100, 100),
            new Vec3(100, 100, 100),
        ]);

/**
 * @class Box
 * @extends Particle
 * @param {Object} options
 */
function Box(options) {
    _Box.call(this, options);
    this.normals = [
        // Order: top, right, front
        new Vec3(0, 1, 0),
        new Vec3(1, 0, 0),
        new Vec3(0, 0, 1)
    ];

    this.type = 1 << 1;
}

Box.prototype = Object.create(_Box.prototype);
Box.prototype.constructor = Box;

module.exports = Box;

},{"../../math/Vec3":49,"./ConvexBodyFactory":56}],56:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Particle = require('./Particle');
var Mat33 = require('../../math/Mat33');
var Vec3 = require('../../math/Vec3');
var Geometry = require('../Geometry');
var ConvexHull = Geometry.ConvexHull;

var TEMP_REGISTER = new Vec3();

/**
 * Returns a constructor for a physical body reflecting the shape defined by input ConvexHull or Vec3 array.
 *
 * @method ConvexBodyFactory
 * @param {ConvexHull | Vec3[]} hull
 * @return {Function} The constructor.
 */
function ConvexBodyFactory(hull) {
    if (!(hull instanceof ConvexHull)) {
        if (!(hull instanceof Array)) throw new Error('ConvexBodyFactory requires a ConvexHull object or an array of Vec3\'s as input.');
        else hull = new ConvexHull(hull);
    }

    /**
     * The body class with inertia and vertices inferred from the input ConvexHull or Vec3 array.
     *
     * @class ConvexBody
     * @param {Object} options The options hash.
     */
    function ConvexBody(options) {
        Particle.call(this, options);

        var originalSize = hull.polyhedralProperties.size;
        var size = options.size || originalSize;

        var scaleX = size[0] / originalSize[0];
        var scaleY = size[1] / originalSize[1];
        var scaleZ = size[2] / originalSize[2];

        this._scale = [scaleX, scaleY, scaleZ];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        this.hull = hull;

        this.vertices = [];
        for (var i = 0, len = hull.vertices.length; i < len; i++) {
            this.vertices.push(T.vectorMultiply(hull.vertices[i], new Vec3()));
        }

        _computeInertiaProperties.call(this, T);
        this.inverseInertia.copy(this.localInverseInertia);
        this.updateInertia();

        var w = options.angularVelocity;
        if (w) this.setAngularVelocity(w.x, w.y, w.z);
    }

    ConvexBody.prototype = Object.create(Particle.prototype);
    ConvexBody.prototype.constructor = ConvexBody;

    /**
     * Set the size and recalculate
     *
     * @method setSize
     * @chainable
     * @param {Number} x The x span.
     * @param {Number} y The y span.
     * @param {Number} z The z span.
     */
    ConvexBody.prototype.setSize = function setSize(x,y,z) {
        var originalSize = hull.polyhedralProperties.size;

        this.size[0] = x;
        this.size[1] = y;
        this.size[2] = z;

        var scaleX = x / originalSize[0];
        var scaleY = y / originalSize[1];
        var scaleZ = z / originalSize[2];

        this._scale = [scaleX, scaleY, scaleZ];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        var vertices = this.vertices;
        for (var i = 0, len = hull.vertices.length; i < len; i++) {
            T.vectorMultiply(hull.vertices[i], vertices[i]);
        }

        return this;
    };

    /**
     * Update the local inertia and inverse inertia to reflect the current size.
     *
     * @method updateLocalInertia
     * @chainable
     */
    ConvexBody.prototype.updateLocalInertia = function updateInertia() {
        var scaleX = this._scale[0];
        var scaleY = this._scale[1];
        var scaleZ = this._scale[2];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        _computeInertiaProperties.call(this, T);

        return this;
    };

    /**
     * Retrieve the vertex furthest in a direction. Used internally for collision detection.
     *
     * @method support
     * @return {Vec3} The furthest vertex.
     */
    ConvexBody.prototype.support = function support(direction) {
        var vertices = this.vertices;
        var vertex, dot, furthest;
        var max = -Infinity;
        for (var i = 0, len = vertices.length; i < len; i++) {
            vertex = vertices[i];
            dot = Vec3.dot(vertex,direction);
            if (dot > max) {
                furthest = vertex;
                max = dot;
            }
        }
        return furthest;
    };

    /**
     * Update vertices to reflect current orientation.
     *
     * @method updateShape
     * @chainable
     */
    ConvexBody.prototype.updateShape = function updateShape() {
        var vertices = this.vertices;
        var q = this.orientation;
        var modelVertices = this.hull.vertices;

        var scaleX = this._scale[0];
        var scaleY = this._scale[1];
        var scaleZ = this._scale[2];

        var t = TEMP_REGISTER;
        for (var i = 0, len = vertices.length; i < len; i++) {
            t.copy(modelVertices[i]);
            t.x *= scaleX;
            t.y *= scaleY;
            t.z *= scaleZ;
            Vec3.applyRotation(t, q, vertices[i]);
        }

        return this;
    };

    return ConvexBody;
}

/**
 * Determines mass and inertia tensor based off the density, size, and facet information of the polyhedron.
 *
 * @method _computeInertiaProperties
 * @private
 * @param {Mat33} T The matrix transforming the intial set of vertices to a set reflecting the body size.
 */
function _computeInertiaProperties(T) {
    var polyhedralProperties = this.hull.polyhedralProperties;
    var T_values = T.get();
    var detT = T_values[0] * T_values[4] * T_values[8];

    var E_o = polyhedralProperties.eulerTensor;

    var E = new Mat33();
    Mat33.multiply(T, E_o, E);
    Mat33.multiply(E, T, E);
    var E_values = E.get();

    var Exx = E_values[0];
    var Eyy = E_values[4];
    var Ezz = E_values[8];
    var Exy = E_values[1];
    var Eyz = E_values[7];
    var Exz = E_values[2];

    var newVolume = polyhedralProperties.volume * detT;
    var mass = this.mass;
    var density = mass / newVolume;

    var Ixx = Eyy + Ezz;
    var Iyy = Exx + Ezz;
    var Izz = Exx + Eyy;
    var Ixy = -Exy;
    var Iyz = -Eyz;
    var Ixz = -Exz;

    var centroid = polyhedralProperties.centroid;

    Ixx -= newVolume * (centroid.y * centroid.y + centroid.z * centroid.z);
    Iyy -= newVolume * (centroid.z * centroid.z + centroid.x * centroid.x);
    Izz -= newVolume * (centroid.x * centroid.x + centroid.y * centroid.y);
    Ixy += newVolume * centroid.x * centroid.y;
    Iyz += newVolume * centroid.y * centroid.z;
    Ixz += newVolume * centroid.z * centroid.x;

    Ixx *= density * detT;
    Iyy *= density * detT;
    Izz *= density * detT;
    Ixy *= density * detT;
    Iyz *= density * detT;
    Ixz *= density * detT;

    var inertia = [
        Ixx, Ixy, Ixz,
        Ixy, Iyy, Iyz,
        Ixz, Iyz, Izz
    ];

    this.localInertia.set(inertia);
    Mat33.inverse(this.localInertia, this.localInverseInertia);
}

module.exports = ConvexBodyFactory;

},{"../../math/Mat33":46,"../../math/Vec3":49,"../Geometry":53,"./Particle":57}],57:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Vec3 = require('../../math/Vec3');
var Quaternion = require('../../math/Quaternion');
var Mat33 = require('../../math/Mat33');

var CallbackStore = require('../../utilities/CallbackStore');

var ZERO_VECTOR = new Vec3();

var MAT1_REGISTER = new Mat33();

var _ID = 0;
/**
 * Fundamental physical body. Maintains translational and angular momentum, position and orientation, and other properties
 * such as size and coefficients of restitution and friction used in collision response.
 *
 * @class Particle
 * @extends Particle
 * @param {Object} options sets the initial state of the Particle
 * @constructor
 */
function Particle(options) {
    this.events = new CallbackStore();

    options = options || {};

    this.position = options.position || new Vec3();
    this.orientation = options.orientation || new Quaternion();

    this.velocity = new Vec3();
    this.momentum = new Vec3();
    this.angularVelocity = new Vec3();
    this.angularMomentum = new Vec3();

    this.mass = options.mass || 1;
    this.inverseMass = 1 / this.mass;

    this.force = new Vec3();
    this.torque = new Vec3();

    this.restitution = options.restitution != null ? options.restitution : 0.4;
    this.friction = options.friction != null ? options.friction : 0.2;

    this.inverseInertia = new Mat33([0,0,0,0,0,0,0,0,0]);

    this.localInertia = new Mat33([0,0,0,0,0,0,0,0,0]);
    this.localInverseInertia = new Mat33([0,0,0,0,0,0,0,0,0]);

    this.size = options.size || [0, 0, 0];

    var v = options.velocity;
    if (v) this.setVelocity(v.x, v.y, v.z);

    this.restrictions = 0;
    this.setRestrictions.apply(this, options.restrictions || []);

    this.collisionMask = options.collisionMask || 1;
    this.collisionGroup = options.collisionGroup || 1;

    this.type = 1 << 0;

    this._ID = _ID++;
}

/**
 * Listen for a specific event.
 *
 * @method on
 * @param {String} key
 * @param {Function} callback
 * @chainable
 */
Particle.prototype.on = function on(key, callback) {
    this.events.on(key, callback);
    return this;
};

/**
 * Stop listening for a specific event.
 *
 * @method on
 * @param {String} key
 * @param {Function} callback
 * @chainable
 */
Particle.prototype.off = function off(key, callback) {
    this.events.off(key, callback);
    return this;
};

/**
 * Trigger an event.
 *
 * @method on
 * @param {String} key
 * @param {Object} payload
 * @chainable
 */
Particle.prototype.trigger = function trigger(key, payload) {
    this.events.trigger(key, payload);
    return this;
};

/**
 * Getter for the restriction bitmask. Converts the restrictions to their string representation.
 *
 * @method getRestrictions
 * @return {String[]} restrictions
 */
Particle.prototype.getRestrictions = function getRestrictions() {
    var linear = '';
    var angular = '';
    var restrictions = this.restrictions;
    if (restrictions & 32) linear += 'x';
    if (restrictions & 16) linear += 'y';
    if (restrictions & 8) linear += 'z';
    if (restrictions & 4) angular += 'x';
    if (restrictions & 2) angular += 'y';
    if (restrictions & 1) angular += 'z';

    return [linear, angular];
};

/**
 * Setter for the particle restriction bitmask.
 *
 * @method setRestrictions
 * @param {String} transRestrictions
 * @param {String} rotRestrictions
 * @chainable
 */
Particle.prototype.setRestrictions = function setRestrictions(transRestrictions, rotRestrictions) {
    transRestrictions = transRestrictions || '';
    rotRestrictions = rotRestrictions || '';
    this.restrictions = 0;
    if (transRestrictions.indexOf('x') > -1) this.restrictions |= 32;
    if (transRestrictions.indexOf('y') > -1) this.restrictions |= 16;
    if (transRestrictions.indexOf('z') > -1) this.restrictions |= 8;
    if (rotRestrictions.indexOf('x') > -1) this.restrictions |= 4;
    if (rotRestrictions.indexOf('y') > -1) this.restrictions |= 2;
    if (rotRestrictions.indexOf('z') > -1) this.restrictions |= 1;
    return this;
};

/**
 * Getter for mass
 *
 * @method getMass
 * @return {Number} mass
 */
Particle.prototype.getMass = function getMass() {
    return this.mass;
};

/**
 * Set the mass of the Particle.  Can be used to change the mass several times
 *
 * @method setMass
 * @param {Number} mass
 * @chainable
 */
Particle.prototype.setMass = function setMass(mass) {
    this.mass = mass;
    this.inverseMass = 1 / mass;
    return this;
};

/**
 * Getter for inverse mass
 *
 * @method getInverseMass
 * @return {Number} inverse mass
 */
Particle.prototype.getInverseMass = function() {
    return this.inverseMass;
};

/**
 * Resets the inertia tensor and its inverse to reflect the current shape.
 *
 * @method updateLocalInertia
 * @chainable
 * @param {Mat33} Mat33
 */
Particle.prototype.updateLocalInertia = function updateLocalInertia() {
    this.localInertia.set([0,0,0,0,0,0,0,0,0]);
    this.localInverseInertia.set([0,0,0,0,0,0,0,0,0]);
    return this;
};

/**
 * Updates the world inverse inertia tensor.
 *
 * @method updateInertia
 * @chainable
 */
Particle.prototype.updateInertia = function updateInertia() {
    var localInvI = this.localInverseInertia;
    var q = this.orientation;
    if (localInvI[0] === localInvI[4] && localInvI[4] === localInvI[8]) return;
    if (q.w === 1) return;
    var R = q.toMatrix(MAT1_REGISTER);
    Mat33.multiply(R, this.inverseInertia, this.inverseInertia);
    Mat33.multiply(this.localInverseInertia, R.transpose(), this.inverseInertia);
    return this;
};

/**
 * Getter for position
 *
 * @method getPosition
 * @return {Vec3} position
 */
Particle.prototype.getPosition = function getPosition() {
    return this.position;
};

/**
 * Setter for position
 *
 * @method setPosition
 * @param {Number} x the x coordinate for position
 * @param {Number} y the y coordinate for position
 * @param {Number} z the z coordinate for position
 * @return {Particle} this
 * @chainable
 */
Particle.prototype.setPosition = function setPosition(x, y, z) {
    this.position.set(x, y, z);
    return this;
};

/**
 * Getter for velocity
 *
 * @method getVelocity
 * @return {Vec3} velocity
 */
Particle.prototype.getVelocity = function getVelocity() {
    return this.velocity;
};

/**
 * Setter for velocity
 *
 * @method setvelocity
 * @param {Number} x the x coordinate for velocity
 * @param {Number} y the y coordinate for velocity
 * @param {Number} z the z coordinate for velocity
 * @chainable
 */
Particle.prototype.setVelocity = function setVelocity(x, y, z) {
    this.velocity.set(x, y, z);
    Vec3.scale(this.velocity, this.mass, this.momentum);
    return this;
};

/**
 * Getter for momenutm
 *
 * @method getMomentum
 * @return {Vec3} momentum
 */
Particle.prototype.getMomentum = function getMomentum() {
    return this.momentum;
};

/**
 * Setter for momentum
 *
 * @method setMomentum
 * @param {Number} x the x coordinate for momentum
 * @param {Number} y the y coordinate for momentum
 * @param {Number} z the z coordinate for momentum
 * @chainable
 */
Particle.prototype.setMomentum = function setMomentum(x, y, z) {
    this.momentum.set(x, y, z);
    Vec3.scale(this.momentum, this.inverseMass, this.velocity);
    return this;
};

/**
 * Getter for orientation
 *
 * @method getOrientation
 * @return {Quaternion} orientation
 */
Particle.prototype.getOrientation = function getOrientation() {
    return this.orientation;
};

/**
 * Setter for orientation
 *
 * @method setOrientation
 * @param {Number} w
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @chainable
 */
Particle.prototype.setOrientation = function setOrientation(w,x,y,z) {
    this.orientation.set(w,x,y,z).normalize();
    this.updateInertia();
    return this;
};

/**
 * Getter for angular velocity
 *
 * @method getAngularVelocity
 * @return {Vec3} angularVelocity
 */
Particle.prototype.getAngularVelocity = function getAngularVelocity() {
    return this.angularVelocity;
};

/**
 * Setter for angular velocity
 *
 * @method setAngularVelocity
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Particle.prototype.setAngularVelocity = function setAngularVelocity(x,y,z) {
    this.angularVelocity.set(x,y,z);
    var I = Mat33.inverse(this.inverseInertia, MAT1_REGISTER);
    if (I) I.vectorMultiply(this.angularVelocity, this.angularMomentum);
    else this.angularMomentum.clear();
    return this;
};

/**
 * Getter for angular momentum
 *
 * @method getAngularMomentum
 * @return {Vec3} angular momentum
 */
Particle.prototype.getAngularMomentum = function getAngularMomentum() {
    return this.angularMomentum;
};

/**
 * Setter for angular momentum
 *
 * @method setAngularMomentum
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Particle.prototype.setAngularMomentum = function setAngularMomentum(x,y,z) {
    this.angularMomentum.set(x,y,z);
    this.inverseInertia.vectorMultiply(this.angularMomentum, this.angularVelocity);
    return this;
};

/**
 * Getter for the force on the Particle
 *
 * @method getForce
 * @return {Vec3} force
 */
Particle.prototype.getForce = function getForce() {
    return this.force;
};

/**
 * Setter for the force on the Particle
 *
 * @method setForce
 * @param {Vec3} v the new Force
 * @chainable
 */
Particle.prototype.setForce = function setForce(x, y, z) {
    this.force.set(x, y, z);
    return this;
};

/**
 * Getter for torque.
 *
 * @method getTorque
 */
Particle.prototype.getTorque = function getTorque() {
    return this.torque;
};

/**
 * Setter for torque.
 *
 * @method setTorque
 * @param {Vec3} v
 * @chainable
 */
Particle.prototype.setTorque = function setTorque(x, y, z) {
    this.torque.set(x, y, z);
    return this;
};

/**
 * Extends Particle.applyForce with an optional argument
 * to apply the force at an off-centered location, resulting in a torque.
 *
 * @method applyForce
 * @param force {Vec3} force
 * @param {Vec3} location off-center location on the Particle (optional)
 */
Particle.prototype.applyForce = function applyForce(force) {
    this.force.add(force);
    return this;
};

/**
 * Applied a torque force to a Particle, inducing a rotation.
 *
 * @method applyTorque
 * @param torque {Vec3} torque
 */
Particle.prototype.applyTorque = function applyTorque(torque) {
    this.torque.add(torque);
    return this;
};

/**
 * Applies an impulse to momentum and updates velocity.
 *
 * @method applyImpulse
 * @param {Vec3} impulse
 */
Particle.prototype.applyImpulse = function applyImpulse(impulse) {
    this.momentum.add(impulse);
    Vec3.scale(this.momentum, this.inverseMass, this.velocity);
    return this;
};

/**
 * Applies an angular impulse to angular momentum and updates angular velocity.
 *
 * @method applyAngularImpulse
 * @param {Vec3} angularImpulse
 */
Particle.prototype.applyAngularImpulse = function applyAngularImpulse(angularImpulse) {
    this.angularMomentum.add(angularImpulse);
    this.inverseInertia.vectorMultiply(this.angularMomentum, this.angularVelocity);
    return this;
};

/**
 * Used in collision detection. The support function should accept a Vec3 direction
 * and return the point on the body's shape furthest in that direction. For point particles,
 * this returns the zero vector.
 *
 * @method support
 * @return {Vec3}
 */
Particle.prototype.support = function support() {
    return ZERO_VECTOR;
};

/**
 * Update the body's shape to reflect current orientation. Called in Collision.
 * Noop for point particles.
 *
 * @method updateShape
 */
Particle.prototype.updateShape = function updateShape() {};

module.exports = Particle;

},{"../../math/Mat33":46,"../../math/Quaternion":47,"../../math/Vec3":49,"../../utilities/CallbackStore":90}],58:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Particle = require('./Particle');
var Vec3 = require('../../math/Vec3');

var SUPPORT_REGISTER = new Vec3();

/**
 * Spherical Rigid body
 *
 * @class Sphere
 * @extends Particle
 * @param {Object} options
 */
function Sphere(options) {
    Particle.call(this, options);
    var r  = options.radius || 1;
    this.radius = r;
    this.size = [2*r, 2*r, 2*r];
    this.updateLocalInertia();
    this.inverseInertia.copy(this.localInverseInertia);

    var w = options.angularVelocity;
    if (w) this.setAngularVelocity(w.x, w.y, w.z);

    this.type = 1 << 2;
}

Sphere.prototype = Object.create(Particle.prototype);
Sphere.prototype.constructor = Sphere;

/**
 * Getter for radius.
 *
 * @method getRadius
 * @return {Number} radius
 */
Sphere.prototype.getRadius = function getRadius() {
    return this.radius;
};

/**
 * Setter for radius.
 *
 * @method setRadius
 * @param {Number} radius The intended radius of the sphere.
 * @chainable
 */
Sphere.prototype.setRadius = function setRadius(radius) {
    this.radius = radius;
    this.size = [2*this.radius, 2*this.radius, 2*this.radius];
    return this;
};

/**
 * Infers the inertia tensor.
 *
 * @override
 * @method updateInertia
 */
Sphere.prototype.updateLocalInertia = function updateInertia() {
    var m = this.mass;
    var r = this.radius;

    var mrr = m * r * r;

    this.localInertia.set([
        0.4 * mrr, 0, 0,
        0, 0.4 * mrr, 0,
        0, 0, 0.4 * mrr
    ]);

    this.localInverseInertia.set([
        2.5 / mrr, 0, 0,
        0, 2.5 / mrr, 0,
        0, 0, 2.5 / mrr
    ]);
};

/**
 * Returns the point on the sphere furthest in a given direction.
 *
 * @method support
 * @param {Vec3} direction
 * @param {Vec3}
 */
Sphere.prototype.support = function support(direction) {
    return Vec3.scale(direction, this.radius, SUPPORT_REGISTER);
};

/**
 * @exports Sphere
 * @module Sphere
 */
module.exports = Sphere;

},{"../../math/Vec3":49,"./Particle":57}],59:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Particle = require('./Particle');
var Vec3 = require('../../math/Vec3');

/**
 * @enum directions
 */
Wall.DOWN = 0;
Wall.UP = 1;
Wall.LEFT = 2;
Wall.RIGHT = 3;
Wall.FORWARD = 4;
Wall.BACKWARD = 5;

/**
 * An axis-aligned boundary. Will not respond to forces or impulses.
 *
 * @class Wall
 * @extends Particle
 * @param {Object} options
 */
function Wall(options) {
    Particle.call(this, options);

    var n = this.normal = new Vec3();

    var d = this.direction = options.direction;
    switch (d) {
        case Wall.DOWN:
            n.set(0, 1, 0);
            break;
        case Wall.UP:
            n.set(0, -1, 0);
            break;
        case Wall.LEFT:
            n.set(-1, 0, 0);
            break;
        case Wall.RIGHT:
            n.set(1, 0, 0);
            break;
        case Wall.FORWARD:
            n.set(0, 0, -1);
            break;
        case Wall.BACKWARD:
            n.set(0, 0, 1);
            break;
        default:
            break;
    }

    this.invNormal = Vec3.clone(n, new Vec3()).invert();

    this.mass = Infinity;
    this.inverseMass = 0;

    this.type = 1 << 3;
}

Wall.prototype = Object.create(Particle.prototype);
Wall.prototype.constructor = Wall;

module.exports = Wall;

},{"../../math/Vec3":49,"./Particle":57}],60:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('../../math/Vec3');
var Mat33 = require('../../math/Mat33');

var DELTA_REGISTER = new Vec3();

/**
 *  A constraint that keeps a physics body a given direction away from a given
 *  anchor, or another attached body.
 *
 *  @class Angle
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Angle(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.effectiveInertia = new Mat33();
    this.angularImpulse = new Vec3();
    this.error = 0;
}

Angle.prototype = Object.create(Constraint.prototype);
Angle.prototype.constructor = Angle;

/**
 * Initialize the Angle. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Angle.prototype.init = function() {
    this.cosAngle = this.cosAngle || this.a.orientation.dot(this.b.orientation);
};

/**
 * Warmstart the constraint and prepare calculations used in .resolve.
 *
 * @method update
 */
Angle.prototype.update = function update() {
    var a = this.a;
    var b = this.b;

    var q1 = a.orientation;
    var q2 = b.orientation;

    var cosTheta = q1.dot(q2);
    var diff = 2*(cosTheta - this.cosAngle);

    this.error = diff;

    var angularImpulse = this.angularImpulse;
    b.applyAngularImpulse(angularImpulse);
    a.applyAngularImpulse(angularImpulse.invert());

    Mat33.add(a.inverseInertia, b.inverseInertia, this.effectiveInertia);
    this.effectiveInertia.inverse();

    angularImpulse.clear();
};

/**
 * Adds an angular impulse to a physics body's angular velocity.
 *
 * @method resolve
 */
Angle.prototype.resolve = function update() {
    var a = this.a;
    var b = this.b;

    var diffW = DELTA_REGISTER;

    var w1 = a.angularVelocity;
    var w2 = b.angularVelocity;

    Vec3.subtract(w1, w2, diffW);
    diffW.scale(1 + this.error);

    var angularImpulse = diffW.applyMatrix(this.effectiveInertia);

    b.applyAngularImpulse(angularImpulse);
    a.applyAngularImpulse(angularImpulse.invert());
    angularImpulse.invert();
    this.angularImpulse.add(angularImpulse);
};

module.exports = Angle;

},{"../../math/Mat33":46,"../../math/Vec3":49,"./Constraint":63}],61:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('../../math/Vec3');
var Mat33 = require('../../math/Mat33');
var Quaternion = require('../../math/Quaternion');

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();

/**
 *  A constraint that maintains positions and orientations with respect to a specific anchor point.
 *
 *  @class BallAndSocket
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Options} options An object of configurable options.
 */
function BallAndSocket(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();
    this.error = new Vec3();
    this.effMassMatrix = new Mat33();
}

BallAndSocket.prototype = Object.create(Constraint.prototype);
BallAndSocket.prototype.constructor = BallAndSocket;

/**
 * Initialize the BallAndSocket. Sets defaults if a property was not already set.
 *
 * @method init
 */
BallAndSocket.prototype.init = function() {
    var w = this.anchor;

    var a = this.a;
    var b = this.b;

    var q1t = Quaternion.conjugate(a.orientation, new Quaternion());
    var q2t = Quaternion.conjugate(b.orientation, new Quaternion());

    this.rA = Vec3.subtract(w, a.position, new Vec3());
    this.rB = Vec3.subtract(w, b.position, new Vec3());

    this.bodyRA = q1t.rotateVector(this.rA, new Vec3());
    this.bodyRB = q2t.rotateVector(this.rB, new Vec3());
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
BallAndSocket.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var rA = a.orientation.rotateVector(this.bodyRA, this.rA);
    var rB = b.orientation.rotateVector(this.bodyRB, this.rB);

    var xRA = new Mat33([0,rA.z,-rA.y,-rA.z,0,rA.x,rA.y,-rA.x,0]);
    var xRB = new Mat33([0,rB.z,-rB.y,-rB.z,0,rB.x,rB.y,-rB.x,0]);

    var RIaRt = Mat33.multiply(xRA, a.inverseInertia, new Mat33()).multiply(xRA.transpose());
    var RIbRt = Mat33.multiply(xRB, b.inverseInertia, new Mat33()).multiply(xRB.transpose());

    var invEffInertia = Mat33.add(RIaRt, RIbRt, RIaRt);

    var worldA = Vec3.add(a.position, this.rA, this.anchor);
    var worldB = Vec3.add(b.position, this.rB, VEC2_REGISTER);

    Vec3.subtract(worldB, worldA, this.error);
    this.error.scale(0.2/dt);

    var imA = a.inverseMass;
    var imB = b.inverseMass;

    var invEffMass = new Mat33([imA + imB,0,0,0,imA + imB,0,0,0,imA + imB]);

    Mat33.add(invEffInertia, invEffMass, this.effMassMatrix);
    this.effMassMatrix.inverse();

    var impulse = this.impulse;
    var angImpulseA = this.angImpulseA;
    var angImpulseB = this.angImpulseB;

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
BallAndSocket.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var rA = this.rA;
    var rB = this.rB;

    var v1 = Vec3.add(a.velocity, Vec3.cross(a.angularVelocity, rA, WxR_REGISTER), VB1_REGISTER);
    var v2 = Vec3.add(b.velocity, Vec3.cross(b.angularVelocity, rB, WxR_REGISTER), VB2_REGISTER);

    var impulse = v1.subtract(v2).subtract(this.error).applyMatrix(this.effMassMatrix);
    var angImpulseB = Vec3.cross(rB, impulse, VEC1_REGISTER);
    var angImpulseA = Vec3.cross(rA, impulse, VEC2_REGISTER).invert();

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);
    impulse.invert();

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = BallAndSocket;

},{"../../math/Mat33":46,"../../math/Quaternion":47,"../../math/Vec3":49,"./Constraint":63}],62:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Vec3 = require('../../math/Vec3');
var Constraint = require('./Constraint');

var SweepAndPrune = require('./collision/SweepAndPrune');
var BruteForce = require('./collision/BruteForce');
var ConvexCollision = require('./collision/ConvexCollisionDetection');
var GJK = ConvexCollision.GJK;
var EPA = ConvexCollision.EPA;
var ContactManifoldTable = require('./collision/ContactManifold');

var ObjectManager = require('../../utilities/ObjectManager');
ObjectManager.register('CollisionData', CollisionData);
var OMRequestCollisionData = ObjectManager.requestCollisionData;

var VEC_REGISTER = new Vec3();

/**
 * Helper function to clamp a value to a given range.
 *
 * @method clamp
 * @private
 * @param {Number} value
 * @param {Number} lower
 * @param {Number} upper
 * @return {Number}
 */
function clamp(value, lower, upper) {
    return value < lower ? lower : value > upper ? upper : value;
}

/**
 * Object maintaining various figures of a collision. Registered in ObjectManager.
 *
 * @class CollisionData
 * @param {Number} penetration
 * @param {Vec3} normal
 * @param {Vec3} worldContactA
 * @param {Vec3} worldContactB
 * @param {Vec3} localContactA
 * @param {Vec3} localContactB
 */
function CollisionData(penetration, normal, worldContactA, worldContactB, localContactA, localContactB) {
    this.penetration = penetration;
    this.normal = normal;
    this.worldContactA = worldContactA;
    this.worldContactB = worldContactB;
    this.localContactA = localContactA;
    this.localContactB = localContactB;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
CollisionData.prototype.reset = function reset(penetration, normal, worldContactA, worldContactB, localContactA, localContactB) {
    this.penetration = penetration;
    this.normal = normal;
    this.worldContactA = worldContactA;
    this.worldContactB = worldContactB;
    this.localContactA = localContactA;
    this.localContactB = localContactB;

    return this;
};

/**
 * Ridid body Elastic Collision
 *
 * @class Collision
 * @extends Constraint
 * @param {Object} options
 */
function Collision(targets, options) {
    this.targets = [];
    if (targets) this.targets = this.targets.concat(targets);

    Constraint.call(this, options);
}

Collision.prototype = Object.create(Constraint.prototype);
Collision.prototype.constructor = Collision;

/**
 * Initialize the Collision tracker. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Collision.prototype.init = function() {
    if (this.broadPhase) {
        if (this.broadPhase instanceof Function) this.broadPhase = new this.broadPhase(this.targets);
    }
    else this.broadPhase = new SweepAndPrune(this.targets);
    this.contactManifoldTable = this.contactManifoldTable || new ContactManifoldTable();
};

/**
 * Collison detection. Updates the existing contact manifolds, runs the broadphase, and performs narrowphase
 * collision detection. Warm starts the contacts based on the results of the previous physics frame
 * and prepares necesssary calculations for the resolution.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
 Collision.prototype.update = function update(time, dt) {
    this.contactManifoldTable.update(dt);
    if (this.targets.length === 0) return;
    var i, len;
    for (i = 0, len = this.targets.length; i < len; i++) {
        this.targets[i].updateShape();
    }
    var potentialCollisions = this.broadPhase.update();
    var pair;
    for (i = 0, len = potentialCollisions.length; i < len; i++) {
        (pair = potentialCollisions[i]) && this.applyNarrowPhase(pair);
    }
    this.contactManifoldTable.prepContacts(dt);
};

/**
 * Apply impulses to resolve all Contact constraints.
 *
 * @method resolve
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Collision.prototype.resolve = function resolve(time, dt) {
    this.contactManifoldTable.resolveManifolds(dt);
};

/**
 * Add a target or targets to the collision system.
 *
 * @method addTarget
 * @param {Particle}
 */
Collision.prototype.addTarget = function addTarget(target) {
    this.targets.push(target);
    this.broadPhase.add(target);
};

/**
 * Remove a target or targets from the collision system.
 *
 * @method addTarget
 * @param {Particle}
 */
Collision.prototype.removeTarget = function removeTarget(target) {
    var index = this.targets.indexOf(target);
    if (index < 0) return;
    this.targets.splice(index, 1);
    this.broadPhase.remove(target);
};


var CONVEX = 1 << 0;
var BOX = 1 << 1;
var SPHERE = 1 << 2;
var WALL = 1 << 3;

var CONVEX_CONVEX = CONVEX | CONVEX;
var BOX_BOX = BOX | BOX;
var BOX_CONVEX = BOX | CONVEX;
var SPHERE_SPHERE = SPHERE | SPHERE;
var BOX_SPHERE = BOX | SPHERE;
var CONVEX_SPHERE = CONVEX | SPHERE;
var CONVEX_WALL = CONVEX | WALL;
var BOX_WALL = BOX | WALL;
var SPHERE_WALL = SPHERE | WALL;

var dispatch = {};
dispatch[CONVEX_CONVEX] = convexIntersectConvex;
dispatch[BOX_BOX] = convexIntersectConvex;
dispatch[BOX_CONVEX] = convexIntersectConvex;
dispatch[CONVEX_SPHERE] = convexIntersectConvex;
dispatch[SPHERE_SPHERE] = sphereIntersectSphere;
dispatch[BOX_SPHERE] = boxIntersectSphere;
dispatch[CONVEX_WALL] = convexIntersectWall;
dispatch[BOX_WALL] = convexIntersectWall;
dispatch[SPHERE_WALL] = convexIntersectWall;

/**
 * Narrowphase collision detection,
 * registers the Contact constraints for colliding bodies.
 *
 * Will detect the type of bodies in the collision.
 *
 * @method applyNarrowPhase
 * @param {Particle[]} targets
 */
Collision.prototype.applyNarrowPhase = function applyNarrowPhase(targets) {
    for (var i = 0, len = targets.length; i < len; i++) {
        for (var j = i + 1; j < len; j++) {
            var  a = targets[i];
            var b = targets[j];

            if ((a.collisionMask & b.collisionGroup && a.collisionGroup & b.collisionMask) === 0) continue;

            var collisionType = a.type | b.type;

            dispatch[collisionType] && dispatch[collisionType](this, a, b);
        }
    }
};

/**
 * Detects sphere-sphere collisions and registers the Contact.
 *
 * @private
 * @method sphereIntersectSphere
 * @param {Object} context
 * @param {Sphere} sphere1
 * @param {Sphere} sphere2
 */
function sphereIntersectSphere(context, sphere1, sphere2) {
    var p1 = sphere1.position;
    var p2 = sphere2.position;
    var relativePosition = Vec3.subtract(p2, p1, new Vec3());
    var distance = relativePosition.length();
    var sumRadii = sphere1.radius + sphere2.radius;
    var n = relativePosition.scale(1/distance);

    var overlap = sumRadii - distance;

    // Distance check
    if (overlap < 0) return;

    var rSphere1 = Vec3.scale(n, sphere1.radius, new Vec3());
    var rSphere2 = Vec3.scale(n, -sphere2.radius, new Vec3());

    var wSphere1 = Vec3.add(p1, rSphere1, new Vec3());
    var wSphere2 = Vec3.add(p2, rSphere2, new Vec3());

    var collisionData = OMRequestCollisionData().reset(overlap, n, wSphere1, wSphere2, rSphere1, rSphere2);

    context.contactManifoldTable.registerContact(sphere1, sphere2, collisionData);
}

/**
* Detects box-sphere collisions and registers the Contact.
*
* @param {Object} context
* @param {Box} box
* @param {Sphere} sphere
*/
function boxIntersectSphere(context, box, sphere) {
    if (box.type === SPHERE) {
        var temp = sphere;
        sphere = box;
        box = temp;
    }

    var pb = box.position;
    var ps = sphere.position;
    var relativePosition = Vec3.subtract(ps, pb, VEC_REGISTER);

    var q = box.orientation;

    var r = sphere.radius;

    var bsize = box.size;
    var halfWidth = bsize[0]*0.5;
    var halfHeight = bsize[1]*0.5;
    var halfDepth = bsize[2]*0.5;

    // x, y, z
    var bnormals = box.normals;
    var n1 = q.rotateVector(bnormals[1], new Vec3());
    var n2 = q.rotateVector(bnormals[0], new Vec3());
    var n3 = q.rotateVector(bnormals[2], new Vec3());

    // Find the point on the cube closest to the center of the sphere
    var closestPoint = new Vec3();
    closestPoint.x = clamp(Vec3.dot(relativePosition,n1), -halfWidth, halfWidth);
    closestPoint.y = clamp(Vec3.dot(relativePosition,n2), -halfHeight, halfHeight);
    closestPoint.z = clamp(Vec3.dot(relativePosition,n3), -halfDepth, halfDepth);
    // The vector found is relative to the center of the unrotated box -- rotate it
    // to find the point w.r.t. to current orientation
    closestPoint.applyRotation(q);

    // The impact point in world space
    var impactPoint = Vec3.add(pb, closestPoint, new Vec3());
    var sphereToImpact = Vec3.subtract(impactPoint, ps, impactPoint);
    var distanceToSphere = sphereToImpact.length();

    // If impact point is not closer to the sphere's center than its radius -> no collision
    var overlap = r - distanceToSphere;
    if (overlap < 0) return;

    var n = Vec3.scale(sphereToImpact, -1 / distanceToSphere, new Vec3());
    var rBox = closestPoint;
    var rSphere = sphereToImpact;

    var wBox = Vec3.add(pb, rBox, new Vec3());
    var wSphere = Vec3.add(ps, rSphere, new Vec3());

    var collisionData = OMRequestCollisionData().reset(overlap, n, wBox, wSphere, rBox, rSphere);

    context.contactManifoldTable.registerContact(box, sphere, collisionData);
}

/**
* Detects convex-convex collisions and registers the Contact. Uses GJK to determine overlap and then
* EPA to determine the actual collision data.
*
* @param {Object} context
* @param {ConvexBody} convex1
* @param {ConvexBody} convex2
*/
function convexIntersectConvex(context, convex1, convex2) {
    var glkSimplex = GJK(convex1, convex2);

    // No simplex -> no collision
    if (!glkSimplex) return;

    var collisionData = EPA(convex1, convex2, glkSimplex);
    if (collisionData !== null) context.contactManifoldTable.registerContact(convex1, convex2, collisionData);
}

/**
* Detects convex-wall collisions and registers the Contact.
*
* @param {Object} context
* @param {ConvexBody} convex
* @param {ConvexBody} wall
*/
function convexIntersectWall(context, convex, wall) {
    if (convex.type === WALL) {
        var temp = wall;
        wall = convex;
        convex = temp;
    }

    var convexPos = convex.position;
    var wallPos = wall.position;

    var n = wall.normal;
    var invN = wall.invNormal;

    var rConvex = convex.support(invN);
    var wConvex = Vec3.add(convexPos, rConvex, new Vec3());

    var diff = Vec3.subtract(wConvex, wallPos, VEC_REGISTER);

    var penetration = Vec3.dot(diff, invN);

    if (penetration < 0) return;

    var wWall = Vec3.scale(n, penetration, new Vec3()).add(wConvex);
    var rWall = Vec3.subtract(wWall, wall.position, new Vec3());

    var collisionData = OMRequestCollisionData().reset(penetration, invN, wConvex, wWall, rConvex, rWall);

    context.contactManifoldTable.registerContact(convex, wall, collisionData);
}

Collision.SweepAndPrune = SweepAndPrune;
Collision.BruteForce = BruteForce.BruteForce;
Collision.BruteForceAABB = BruteForce.BruteForceAABB;

module.exports = Collision;

},{"../../math/Vec3":49,"../../utilities/ObjectManager":93,"./Constraint":63,"./collision/BruteForce":69,"./collision/ContactManifold":70,"./collision/ConvexCollisionDetection":71,"./collision/SweepAndPrune":72}],63:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var _ID = 0;
/**
 * Base Constraint class to be used in the Physics
 * Subclass this class to implement a constraint
 *
 * @virtual
 * @class Constraint
 */
function Constraint(options) {
    options = options || {};
    this.setOptions(options);

    this._ID = _ID++;
}

/**
 * Decorates the Constraint with the options object.
 *
 * @method setOptions
 * @param {Object} Options
 */
Constraint.prototype.setOptions = function setOptions(options) {
    for (var key in options) this[key] = options[key];
    this.init(options);
};

/**
 * Method invoked upon instantiation and the setting of options.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Constraint.prototype.init = function init(options) {};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Constraint.prototype.update = function update(time, dt) {};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Constraint.prototype.resolve = function resolve(time, dt) {};

module.exports = Constraint;

},{}],64:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('../../math/Vec3');

var IMPULSE_REGISTER = new Vec3();
var NORMAL_REGISTER = new Vec3();

/** @const */
var EPSILSON = 1e-7;
/** @const */
var PI = Math.PI;


/**
 *  A constraint that keeps a physics body on a given implicit curve.
 *
 *  @class Curve
 *  @constructor
 *  @extends Constraint
 */
function Curve(targets, options) {
    if (targets) {
        if (targets instanceof Array) this.targets = targets;
        else this.targets = [targets];
    }
    else this.targets = [];

    Constraint.call(this, options);

    this.impulses = {};
    this.normals = {};
    this.velocityBiases = {};
    this.divisors = {};
}

Curve.prototype = Object.create(Constraint.prototype);
Curve.prototype.constructor = Curve;

/**
 * Initialize the Curve. Sets defaults if a property was not already set.
 *
 * @method init
 */
Curve.prototype.init = function() {
    this.equation1 = this.equation1 || function() {
        return 0;
    };
    this.equation2 = this.equation2 || function(x, y, z) {
        return z;
    };
    this.period = this.period || 1;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Warmstart the constraint and prepare calculations used in the .resolve step.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Curve.prototype.update = function update(time, dt) {
    var targets = this.targets;

    var normals = this.normals;
    var velocityBiases = this.velocityBiases;
    var divisors = this.divisors;
    var impulses = this.impulses;

    var impulse = IMPULSE_REGISTER;
    var n = NORMAL_REGISTER;

    var f = this.equation1;
    var g = this.equation2;

    var _c = this.damping;
    var _k = this.stiffness;

    for (var i = 0, len = targets.length; i < len; i++) {
        var body = targets[i];
        var ID = body._ID;
        if (body.immune) continue;

        var p = body.position;
        var m = body.mass;

        var gamma;
        var beta;

        if (this.period === 0) {
            gamma = 0;
            beta = 1;
        } else {
            var c = _c * m;
            var k = _k * m;

            gamma = 1 / (dt*(c + dt*k));
            beta  = dt*k / (c + dt*k);
        }

        var x = p.x;
        var y = p.y;
        var z = p.z;

        var f0 = f(x, y, z);
        var dfx = (f(x + EPSILSON, y, z) - f0) / EPSILSON;
        var dfy = (f(x, y + EPSILSON, z) - f0) / EPSILSON;
        var dfz = (f(x, y, z + EPSILSON) - f0) / EPSILSON;

        var g0 = g(x, y, z);
        var dgx = (g(x + EPSILSON, y, z) - g0) / EPSILSON;
        var dgy = (g(x, y + EPSILSON, z) - g0) / EPSILSON;
        var dgz = (g(x, y, z + EPSILSON) - g0) / EPSILSON;

        n.set(dfx + dgx, dfy + dgy, dfz + dgz);
        n.normalize();

        var baumgarte = beta * (f0 + g0) / dt;
        var divisor = gamma + 1 / m;

        var lambda = impulses[ID] || 0;
        Vec3.scale(n, lambda, impulse);
        body.applyImpulse(impulse);

        normals[ID] = normals[ID] || new Vec3();
        normals[ID].copy(n);
        velocityBiases[ID] = baumgarte;
        divisors[ID] = divisor;
        impulses[ID] = 0;
    }
};

/**
 * Adds a curve impulse to a physics body.
 *
 * @method resolve
 */
Curve.prototype.resolve = function resolve() {
    var targets = this.targets;

    var normals = this.normals;
    var velocityBiases = this.velocityBiases;
    var divisors = this.divisors;
    var impulses = this.impulses;

    var impulse = IMPULSE_REGISTER;

    for (var i = 0, len = targets.length; i < len; i++) {
        var body = targets[i];
        var ID = body._ID;
        if (body.immune) continue;

        var v = body.velocity;
        var n = normals[ID];

        var lambda = -(Vec3.dot(n, v) + velocityBiases[ID]) / divisors[ID];

        Vec3.scale(n, lambda, impulse);
        body.applyImpulse(impulse);


        impulses[ID] += lambda;
    }
};

module.exports = Curve;
},{"../../math/Vec3":49,"./Constraint":63}],65:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('../../math/Vec3');

var NORMAL_REGISTER = new Vec3();
var IMPULSE_REGISTER = new Vec3();
var V_REGISTER = new Vec3();
var P_REGISTER = new Vec3();
var DIRECTION_REGISTER = new Vec3();

/** @const */
var PI = Math.PI;

/**
 *  A constraint that maintains the direction of one body from another.
 *
 *  @class Direction
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Direction(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = 0;
    this.distance = 0;
    this.normal = new Vec3();
    this.velocityBias = 0;
    this.divisor = 0;
}

Direction.prototype = Object.create(Constraint.prototype);
Direction.prototype.constructor = Direction;

/**
 * Initialize the Direction. Sets defaults if a property was not already set.
 *
 * @method init
 */
Direction.prototype.init = function() {
    this.direction = this.direction || Vec3.subtract(this.b.position, this.a.position, new Vec3());
    this.direction.normalize();
    this.minLength = this.minLength || 0;
    this.period = this.period || 0.2;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Warmstart the constraint and prepare calculations used in .resolve.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Direction.prototype.update = function update(time, dt) {
    var a = this.a;
    var b = this.b;

    var n = NORMAL_REGISTER;
    var diffP = P_REGISTER;
    var impulse = IMPULSE_REGISTER;
    var directionVector = DIRECTION_REGISTER;

    var p1 = a.position;
    var w1 = a.inverseMass;

    var p2 = b.position;
    var w2 = b.inverseMass;

    var direction = this.direction;

    Vec3.subtract(p2, p1, diffP);
    Vec3.scale(direction, Vec3.dot(direction, diffP), directionVector);
    var goal = directionVector.add(p1);

    Vec3.subtract(p2, goal, n);
    var dist = n.length();
    n.normalize();

    var invEffectiveMass = w1 + w2;
    var effectiveMass = 1 / invEffectiveMass;
    var gamma;
    var beta;

    if (this.period === 0) {
        gamma = 0;
        beta  = 1;
    }
    else {
        var c = this.damping * effectiveMass;
        var k = this.stiffness * effectiveMass;

        gamma = 1 / (dt*(c + dt*k));
        beta  = dt*k / (c + dt*k);
    }

    var baumgarte = beta * dist / dt;
    var divisor = gamma + invEffectiveMass;

    var lambda = this.impulse;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.normal.copy(n);
    this.distance = dist;
    this.velocityBias = baumgarte;
    this.divisor = divisor;
    this.impulse = 0;
};

/**
 * Adds an impulse to a physics body's velocity due to the constraint
 *
 * @method resolve
 */
Direction.prototype.resolve = function update() {
    var a = this.a;
    var b = this.b;

    var impulse  = IMPULSE_REGISTER;
    var diffV = V_REGISTER;

    var minLength = this.minLength;

    var dist = this.distance;
    if (Math.abs(dist) < minLength) return;

    var v1 = a.velocity;
    var v2 = b.velocity;
    var n = this.normal;

    Vec3.subtract(v2, v1, diffV);

    var lambda = -(Vec3.dot(n, diffV) + this.velocityBias) / this.divisor;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.impulse += lambda;
};

module.exports = Direction;

},{"../../math/Vec3":49,"./Constraint":63}],66:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('../../math/Vec3');

var NORMAL_REGISTER = new Vec3();
var IMPULSE_REGISTER = new Vec3();
var V_REGISTER = new Vec3();
var P_REGISTER = new Vec3();

/** @const */
var PI = Math.PI;

/**
 *  A constraint that keeps two bodies within a certain distance.
 *
 *  @class Distance
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Distance(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = 0;
    this.distance = 0;
    this.normal = new Vec3();
    this.velocityBias = 0;
    this.divisor = 0;
}

Distance.prototype = Object.create(Constraint.prototype);
Distance.prototype.constructor = Distance;

/**
 * Initialize the Distance. Sets defaults if a property was not already set.
 *
 * @method init
 */
Distance.prototype.init = function() {
    this.length = this.length || Vec3.subtract(this.b.position, this.a.position, P_REGISTER).length();
    this.minLength = this.minLength || 0;
    this.period = this.period || 0.2;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Distance.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var n = NORMAL_REGISTER;
    var diffP = P_REGISTER;
    var impulse = IMPULSE_REGISTER;

    var length = this.length;

    var p1 = a.position;
    var w1 = a.inverseMass;

    var p2 = b.position;
    var w2 = b.inverseMass;

    Vec3.subtract(p2, p1, diffP);

    var separation = diffP.length();

    Vec3.scale(diffP, 1 / separation, n);

    var dist = separation - length;

    var invEffectiveMass = w1 + w2;
    var effectiveMass = 1 / invEffectiveMass;
    var gamma;
    var beta;

    if (this.period === 0) {
        gamma = 0;
        beta  = 1;
    }
    else {
        var c = this.damping * effectiveMass;
        var k = this.stiffness * effectiveMass;

        gamma = 1 / (dt*(c + dt*k));
        beta  = dt*k / (c + dt*k);
    }

    var baumgarte = beta * dist / dt;
    var divisor = gamma + invEffectiveMass;

    var lambda = this.impulse;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.normal.copy(n);
    this.distance = dist;
    this.velocityBias = baumgarte;
    this.divisor = divisor;
    this.impulse = 0;
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Distance.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var impulse = IMPULSE_REGISTER;
    var diffV = V_REGISTER;

    var minLength = this.minLength;

    var dist = this.distance;
    if (Math.abs(dist) < minLength) return;

    var v1 = a.getVelocity();
    var v2 = b.getVelocity();

    var n = this.normal;

    Vec3.subtract(v2, v1, diffV);
    var lambda = -(Vec3.dot(n, diffV) + this.velocityBias) / this.divisor;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.impulse += lambda;
};

module.exports = Distance;

},{"../../math/Vec3":49,"./Constraint":63}],67:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('../../math/Vec3');
var Mat33 = require('../../math/Mat33');
var Quaternion = require('../../math/Quaternion');

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VEC3_REGISTER = new Vec3();
var VEC4_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();
var DELTA_REGISTER = new Vec3();

/**
 *  A constraint that confines two bodies to the plane defined by the axis of the hinge.
 *
 *  @class Hinge
 *  @extends Constraint
 *  @param {Options} [options] An object of configurable options.
 *
 */
function Hinge(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();
    this.error = new Vec3();
    this.errorRot = [0,0];
    this.effMassMatrix = new Mat33();
    this.effMassMatrixRot = [];
}

Hinge.prototype = Object.create(Constraint.prototype);
Hinge.prototype.constructor = Hinge;

/**
 * Initialize the Hinge. Sets defaults if a property was not already set.
 *
 * @method init
 */
Hinge.prototype.init = function() {
    var w = this.anchor;

    var u = this.axis.normalize();

    var a = this.a;
    var b = this.b;

    var q1t = Quaternion.conjugate(a.orientation, new Quaternion());
    var q2t = Quaternion.conjugate(b.orientation, new Quaternion());

    this.rA = Vec3.subtract(w, a.position, new Vec3());
    this.rB = Vec3.subtract(w, b.position, new Vec3());

    this.bodyRA = q1t.rotateVector(this.rA, new Vec3());
    this.bodyRB = q2t.rotateVector(this.rB, new Vec3());

    this.axisA = Vec3.clone(u);
    this.axisB = Vec3.clone(u);

    this.axisBTangent1 = new Vec3();
    this.axisBTangent2 = new Vec3();

    this.t1xA = new Vec3();
    this.t2xA = new Vec3();

    this.bodyAxisA = q1t.rotateVector(u, new Vec3());
    this.bodyAxisB = q2t.rotateVector(u, new Vec3());
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Hinge.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var axisA = a.orientation.rotateVector(this.bodyAxisA, this.axisA);
    var axisB = b.orientation.rotateVector(this.bodyAxisB, this.axisB);
    this.axis.copy(axisB);

    var n = axisB;
    var t1 = this.axisBTangent1;
    var t2 = this.axisBTangent2;

    if (n.x >= 0.57735) {
        t1.set(n.y, -n.x, 0);
    }
    else {
        t1.set(0, n.z, -n.y);
    }
    t1.normalize();
    Vec3.cross(n, t1, t2);

    var t1xA = Vec3.cross(t1, axisA, this.t1xA);
    var t2xA = Vec3.cross(t2, axisA, this.t2xA);

    var rA = a.orientation.rotateVector(this.bodyRA, this.rA);
    var rB = b.orientation.rotateVector(this.bodyRB, this.rB);

    var xRA = new Mat33([0,rA.z,-rA.y,-rA.z,0,rA.x,rA.y,-rA.x,0]);
    var xRB = new Mat33([0,rB.z,-rB.y,-rB.z,0,rB.x,rB.y,-rB.x,0]);

    var RIaRt = Mat33.multiply(xRA, a.inverseInertia, new Mat33()).multiply(xRA.transpose());
    var RIbRt = Mat33.multiply(xRB, b.inverseInertia, new Mat33()).multiply(xRB.transpose());

    var invEffInertia = Mat33.add(RIaRt, RIbRt, RIaRt);

    var worldA = Vec3.add(a.position, this.rA, this.anchor);
    var worldB = Vec3.add(b.position, this.rB, VEC1_REGISTER);

    var invDt = 1/dt;
    Vec3.subtract(worldB, worldA, this.error);
    this.error.scale(0.2*invDt);

    var imA = a.inverseMass;
    var imB = b.inverseMass;

    var invEffMass = new Mat33([imA + imB,0,0,0,imA + imB,0,0,0,imA + imB]);

    Mat33.add(invEffInertia, invEffMass, this.effMassMatrix);
    this.effMassMatrix.inverse();

    var invIAt1xA = a.inverseInertia.vectorMultiply(t1xA, VEC1_REGISTER);
    var invIAt2xA = a.inverseInertia.vectorMultiply(t2xA, VEC2_REGISTER);
    var invIBt1xA = b.inverseInertia.vectorMultiply(t1xA, VEC3_REGISTER);
    var invIBt2xA = b.inverseInertia.vectorMultiply(t2xA, VEC4_REGISTER);

    var a11 = Vec3.dot(t1xA, invIAt1xA) + Vec3.dot(t1xA, invIBt1xA);
    var a12 = Vec3.dot(t1xA, invIAt2xA) + Vec3.dot(t1xA, invIBt2xA);
    var a21 = Vec3.dot(t2xA, invIAt1xA) + Vec3.dot(t2xA, invIBt1xA);
    var a22 = Vec3.dot(t2xA, invIAt2xA) + Vec3.dot(t2xA, invIBt2xA);

    var det = 1 / (a11*a22 - a12*a21);

    this.effMassMatrixRot[0] = a22 * det;
    this.effMassMatrixRot[1] = -a21 * det;
    this.effMassMatrixRot[2] = -a12 * det;
    this.effMassMatrixRot[3] = a11 * det;

    this.errorRot[0] = Vec3.dot(axisA, t1) * 0.2*invDt;
    this.errorRot[1] = Vec3.dot(axisA, t2) * 0.2*invDt;

    var impulse = this.impulse.scale(0.5);
    var angImpulseA = this.angImpulseA.scale(0.5);
    var angImpulseB = this.angImpulseB.scale(0.5);

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Hinge.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var rA = this.rA;
    var rB = this.rB;

    var t1xA = this.t1xA;
    var t2xA = this.t2xA;

    var w1 = a.angularVelocity;
    var w2 = b.angularVelocity;

    var v1 = Vec3.add(a.velocity, Vec3.cross(w1, rA, WxR_REGISTER), VB1_REGISTER);
    var v2 = Vec3.add(b.velocity, Vec3.cross(w2, rB, WxR_REGISTER), VB2_REGISTER);

    var impulse = v1.subtract(v2).subtract(this.error).applyMatrix(this.effMassMatrix);

    var diffW = Vec3.subtract(w2, w1, DELTA_REGISTER);

    var errorRot = this.errorRot;
    var jv1 = Vec3.dot(t1xA, diffW) + errorRot[0];
    var jv2 = Vec3.dot(t2xA, diffW) + errorRot[1];

    var K = this.effMassMatrixRot;

    var l1 = -(K[0]*jv1 + K[1]*jv2);
    var l2 = -(K[2]*jv1 + K[3]*jv2);

    var angImpulse = Vec3.scale(t1xA, l1, VEC2_REGISTER).add(Vec3.scale(t2xA, l2, VEC3_REGISTER));

    var angImpulseB = Vec3.cross(rB, impulse, VEC1_REGISTER).add(angImpulse);
    var angImpulseA = Vec3.cross(rA, impulse, VEC4_REGISTER).invert().subtract(angImpulse);

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);
    impulse.invert();

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = Hinge;

},{"../../math/Mat33":46,"../../math/Quaternion":47,"../../math/Vec3":49,"./Constraint":63}],68:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Axis-aligned bounding box. Used in collision broadphases.
 *
 * @class AABB
 */
function AABB(body) {
    this._body = body;
    this._ID = body._ID;
    this.position = null;
    this.vertices = {
        x: [],
        y: [],
        z: []
    };
    this.update();
}

var SPHERE = 1 << 2;
var WALL = 1 << 3;

var DOWN = 0;
var UP = 1;
var LEFT = 2;
var RIGHT = 3;
var FORWARD = 4;
var BACKWARD = 5;

/**
 * Update the bounds to reflect the current orientation and position of the parent Body.
 *
 * @method update
 */
AABB.prototype.update = function() {
    var body = this._body;
    var pos = this.position = body.position;

    var minX = Infinity, maxX = -Infinity;
    var minY = Infinity, maxY = -Infinity;
    var minZ = Infinity, maxZ = -Infinity;

    var type = body.type;
    if (type === SPHERE) {
        maxX = maxY = maxZ = body.radius;
        minX = minY = minZ = -body.radius;
    }
    else if (type === WALL) {
        var d = body.direction;
        maxX = maxY = maxZ = 1e6;
        minX = minY = minZ = -1e6;
        switch (d) {
            case DOWN:
                maxY = 25;
                minY = -1e3;
                break;
            case UP:
                maxY = 1e3;
                minY = -25;
                break;
            case LEFT:
                maxX = 25;
                minX = -1e3;
                break;
            case RIGHT:
                maxX = 1e3;
                minX = -25;
                break;
            case FORWARD:
                maxZ = 25;
                minZ = -1e3;
                break;
            case BACKWARD:
                maxZ = 1e3;
                minZ = -25;
                break;
            default:
                break;
       }
    }
    else if (body.vertices) {
        // ConvexBody
        var bodyVertices = body.vertices;
        for (var i = 0, len = bodyVertices.length; i < len; i++) {
            var vertex = bodyVertices[i];
            if (vertex.x < minX) minX = vertex.x;
            if (vertex.x > maxX) maxX = vertex.x;
            if (vertex.y < minY) minY = vertex.y;
            if (vertex.y > maxY) maxY = vertex.y;
            if (vertex.z < minZ) minZ = vertex.z;
            if (vertex.z > maxZ) maxZ = vertex.z;
        }
    } else {
        // Particle
        maxX = maxY = maxZ = 25;
        minX = minY = minZ = -25;
    }
    var vertices = this.vertices;
    vertices.x[0] = minX + pos.x;
    vertices.x[1] = maxX + pos.x;
    vertices.y[0] = minY + pos.y;
    vertices.y[1] = maxY + pos.y;
    vertices.z[0] = minZ + pos.z;
    vertices.z[1] = maxZ + pos.z;
};

/**
 * Check for overlap between two AABB's.
 *
 * @method checkOverlap
 * @param {AABB} aabb1
 * @param {AABB} aabb2
 */
AABB.checkOverlap = function(aabb1, aabb2) {
    var vertices1 = aabb1.vertices;
    var vertices2 = aabb2.vertices;

    var x10 = vertices1.x[0];
    var x11 = vertices1.x[1];
    var x20 = vertices2.x[0];
    var x21 = vertices2.x[1];
    if ((x20 <= x10 && x10 <= x21) || (x10 <= x20 && x20 <= x11)) {
        var y10 = vertices1.y[0];
        var y11 = vertices1.y[1];
        var y20 = vertices2.y[0];
        var y21 = vertices2.y[1];
        if ((y20 <= y10 && y10 <= y21) || (y10 <= y20 && y20 <= y11)) {
            var z10 = vertices1.z[0];
            var z11 = vertices1.z[1];
            var z20 = vertices2.z[0];
            var z21 = vertices2.z[1];
            if ((z20 <= z10 && z10 <= z21) || (z10 <= z20 && z20 <= z11)) {
                return true;
            }
        }
    }
    return false;
};

AABB.vertexThreshold = 100;

module.exports = AABB;

},{}],69:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var AABB = require('./AABB');

/**
 * O(n^2) comparisons with an AABB check for a midphase. Likely to be more performant
 * that the BruteForce when the bodies have many vertices. Only feasible for a small number of bodies.
 *
 * @class BruteForAABB
 * @param {Particles[]} targets
 * @param {Object} options
 */
function BruteForceAABB(targets) {
    this._volumes = [];
    this._entityRegistry = {};
    for (var i = 0; i < targets.length; i++) {
        this.add(targets[i]);
    }
}

/**
 * Start tracking a Particle.
 *
 * @method add
 * @param {Particle} body
 */
BruteForceAABB.prototype.add = function add(body) {
    var boundingVolume = new AABB(body);

    this._entityRegistry[body._ID] = body;
    this._volumes.push(boundingVolume);
};

/**
 * Return an array of possible collision pairs, culled by an AABB intersection test.
 *
 * @method update
 * @return {Particle[][]}
 */
BruteForceAABB.prototype.update = function update() {
    var _volumes = this._volumes;
    var _entityRegistry = this._entityRegistry;

    for (var k = 0, len = _volumes.length; k < len; k++) {
        _volumes[k].update();
    }

    var result = [];
    for (var i = 0, numTargets = _volumes.length; i < numTargets; i++) {
        for (var j = i + 1; j < numTargets; j++) {
            if (AABB.checkOverlap(_volumes[i], _volumes[j])) {
                result.push([_entityRegistry[i], _entityRegistry[j]]);
            }
        }
    }
    return result;
};

/**
 * The most simple yet computationally intensive broad-phase. Immediately passes its targets to the narrow-phase,
 * resulting in an O(n^2) process. Only feasible for a relatively small number of bodies.
 *
 * @class BruteForce
 * @param {Particle[]} targets
 */
function BruteForce(targets) {
    this.targets = targets;
}

/**
 * Start tracking a Particle.
 *
 * @method add
 * @param {Particle} body
 */
BruteForce.prototype.add = function add(body) {
    this.targets.push(body);
};

/**
 * Immediately returns an array of possible collisions.
 *
 * @method update
 * @return {Particle[][]}
 */
BruteForce.prototype.update = function update() {
    return [this.targets];
};

module.exports.BruteForceAABB = BruteForceAABB;
module.exports.BruteForce = BruteForce;

},{"./AABB":68}],70:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Vec3 = require('../../../math/Vec3');
var ObjectManager = require('../../../utilities/ObjectManager');

ObjectManager.register('Manifold', Manifold);
ObjectManager.register('Contact', Contact);
var OMRequestManifold = ObjectManager.requestManifold;
var OMRequestContact = ObjectManager.requestContact;
var OMFreeManifold = ObjectManager.freeManifold;
var OMFreeContact = ObjectManager.freeContact;

/**
 * Helper function to clamp a value to a given range.
 *
 * @method clamp
 * @param {Number} value
 * @param {Number} lower
 * @param {Number} upper
 * @return {Number}
 * @private
 */
function clamp(value, lower, upper) {
    return value < lower ? lower : value > upper ? upper : value;
}

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();
var R1_REGISTER = new Vec3();
var R2_REGISTER = new Vec3();
var NORMALIMPULSE_REGISTER = new Vec3();
var TANGENTIMPULSE1_REGISTER = new Vec3();
var TANGENTIMPULSE2_REGISTER = new Vec3();
var WA_REGISTER = new Vec3();
var WB_REGISTER = new Vec3();
var PENETRATING_REGISTER = new Vec3();
var DRIFTA_REGISTER = new Vec3();
var DRIFTB_REGISTER = new Vec3();

/**
 * Table maintaining and managing current contact manifolds.
 *
 * @class ContactManifoldTable
 */
function ContactManifoldTable() {
    this.manifolds = [];
    this.collisionMatrix = {};
    this._IDPool = [];
}

/**
 * Create a new contact manifold. Tracked by the collisionMatrix according to
 * its low-high ordered ID pair.
 *
 * @method addManifold
 * @param {Number} lowId
 * @param {Number} highID
 * @param {Particle} bodyA
 * @param {Particle} bodyB
 * @return {ContactManifold}
 */
ContactManifoldTable.prototype.addManifold = function addManifold(lowID, highID, bodyA, bodyB) {
    var collisionMatrix = this.collisionMatrix;
    collisionMatrix[lowID] = collisionMatrix[lowID] || {};

    var index = this._IDPool.length ? this._IDPool.pop() : this.manifolds.length;
    this.collisionMatrix[lowID][highID] = index;
    var manifold = OMRequestManifold().reset(lowID, highID, bodyA, bodyB);
    this.manifolds[index] = manifold;

    return manifold;
};

/**
 * Remove a manifold and free it for later reuse.
 *
 * @method removeManifold
 * @param {ContactManifold} manifold
 * @param {Number} index
 */
ContactManifoldTable.prototype.removeManifold = function removeManifold(manifold, index) {
    var collisionMatrix = this.collisionMatrix;

    this.manifolds[index] = null;
    collisionMatrix[manifold.lowID][manifold.highID] = null;
    this._IDPool.push(index);

    OMFreeManifold(manifold);
};

/**
 * Update each of the manifolds, removing those that no longer contain contact points.
 *
 * @method update
 * @param {Number} dt
 */
ContactManifoldTable.prototype.update = function update(dt) {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        var persists = manifold.update(dt);
        if (!persists) {
            this.removeManifold(manifold, i);
            manifold.bodyA.events.trigger('collision:end', manifold);
            manifold.bodyB.events.trigger('collision:end', manifold);
        }
    }
};

/**
 * Warm start all Contacts, and perform precalculations needed in the iterative solver.
 *
 * @method prepContacts
 * @param {Number} dt
 */
ContactManifoldTable.prototype.prepContacts = function prepContacts(dt) {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        var contacts = manifold.contacts;
        for (var j = 0, lenj = contacts.length; j < lenj; j++) {
            var contact = contacts[j];
            if (!contact) continue;
            contact.update(dt);
        }
    }
};

/**
 * Resolve all contact manifolds.
 *
 * @method resolveManifolds
 */
ContactManifoldTable.prototype.resolveManifolds = function resolveManifolds() {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        manifold.resolveContacts();
    }
};

/**
 * Create a new Contact, also creating a new Manifold if one does not already exist for that pair.
 *
 * @method registerContact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
ContactManifoldTable.prototype.registerContact = function registerContact(bodyA, bodyB, collisionData) {
    var lowID;
    var highID;

    if (bodyA._ID < bodyB._ID) {
        lowID = bodyA._ID;
        highID = bodyB._ID;
    } else {
        lowID = bodyB._ID;
        highID = bodyA._ID;
    }

    var manifolds = this.manifolds;
    var collisionMatrix = this.collisionMatrix;
    var manifold;
    if (!collisionMatrix[lowID] || collisionMatrix[lowID][highID] == null) {
        manifold = this.addManifold(lowID, highID, bodyA, bodyB);
        manifold.addContact(bodyA, bodyB, collisionData);
        bodyA.events.trigger('collision:start', manifold);
        bodyB.events.trigger('collision:start', manifold);
    } else {
        manifold = manifolds[ collisionMatrix[lowID][highID] ];
        manifold.contains(collisionData);
        manifold.addContact(bodyA, bodyB, collisionData);
    }
};

var THRESHOLD = 10;

/**
 * Class to keep track of Contact points.
 * @class manifold
 * @param {Number} lowId
 * @param {Number} highId
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function Manifold(lowID, highID, bodyA, bodyB) {
    this.lowID = lowID;
    this.highID = highID;

    this.contacts = [];
    this.numContacts = 0;

    this.bodyA = bodyA;
    this.bodyB = bodyB;

    this.lru = 0;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
Manifold.prototype.reset = function reset(lowID, highID, bodyA, bodyB) {
    this.lowID = lowID;
    this.highID = highID;

    this.contacts = [];
    this.numContacts = 0;

    this.bodyA = bodyA;
    this.bodyB = bodyB;

    this.lru = 0;

    return this;
};

/**
 * Create a new Contact point and add it to the Manifold.
 *
 * @method addContact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
Manifold.prototype.addContact = function addContact(bodyA, bodyB, collisionData) {
    var index = this.lru;
    if (this.contacts[index]) this.removeContact(this.contacts[index], index);
    this.contacts[index] = OMRequestContact().reset(bodyA, bodyB, collisionData);
    this.lru = (this.lru + 1) % 4;
    this.numContacts++;
};

/**
 * Remove and free a Contact for later reuse.
 *
 * @method removeContact
 * @param {Contact} contact
 * @param {Number} index
 */
Manifold.prototype.removeContact = function removeContact(contact, index) {
    this.contacts[index] = null;
    this.numContacts--;

    ObjectManager.freeCollisionData(contact.data);
    contact.data = null;
    OMFreeContact(contact);
};

/**
 * Check if a Contact already exists for the collision data within a certain tolerance.
 * If found, remove the Contact.
 *
 * @method contains
 * @param {CollisionData} collisionData
 * @return {Boolean}
 */
Manifold.prototype.contains = function contains(collisionData) {
    var wA = collisionData.worldContactA;
    var wB = collisionData.worldContactB;

    var contacts = this.contacts;
    for (var i = 0, len = contacts.length; i < len; i++) {
        var contact = contacts[i];
        if (!contact) continue;
        var data = contact.data;
        var distA = Vec3.subtract(data.worldContactA, wA, DRIFTA_REGISTER).length();
        var distB = Vec3.subtract(data.worldContactB, wB, DRIFTB_REGISTER).length();

        if (distA < THRESHOLD || distB < THRESHOLD) {
            this.removeContact(contact, i);
            return true;
        }
    }

    return false;
};

/**
 * Remove Contacts the local points of which have drifted above a certain tolerance.
 * Return true or false to indicate that the Manifold still contains at least one Contact.
 *
 * @method update
 * @return {Boolean} whether or not the manifold persists
 */
Manifold.prototype.update = function update() {
    var contacts = this.contacts;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var posA = bodyA.position;
    var posB = bodyB.position;

    for (var i = 0, len = contacts.length; i < len; i++) {
        var contact = contacts[i];
        if (!contact) continue;
        var data = contact.data;
        var n = data.normal;
        var rA = data.localContactA;
        var rB = data.localContactB;

        var cached_wA = data.worldContactA;
        var cached_wB = data.worldContactB;

        var wA = Vec3.add(posA, rA, WA_REGISTER);
        var wB = Vec3.add(posB, rB, WB_REGISTER);

        var notPenetrating = Vec3.dot(Vec3.subtract(wB, wA, PENETRATING_REGISTER), n) > 0;

        var driftA = Vec3.subtract(cached_wA, wA, DRIFTA_REGISTER);
        var driftB = Vec3.subtract(cached_wB, wB, DRIFTB_REGISTER);


        if (driftA.length() >= THRESHOLD || driftB.length() >= THRESHOLD || notPenetrating) {
            this.removeContact(contact, i);
        }
    }

    if (this.numContacts) return true;
    else return false;
};

/**
 * Resolve all contacts.
 *
 * @method resolveContacts
 */
Manifold.prototype.resolveContacts = function resolveContacts() {
    var contacts = this.contacts;
    for (var i = 0, len = contacts.length; i < len; i++) {
        if (!contacts[i]) continue;
        contacts[i].resolve();
    }
};

/**
 * Class to maintain collision data between two bodies.
 * The end of the resolve chain, and where the actual impulses are applied.
 *
 * @class Contact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
function Contact(bodyA, bodyB, collisionData) {
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.data = collisionData;

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();

    if (collisionData) this.init();
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
Contact.prototype.reset = function reset(bodyA, bodyB, collisionData) {
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.data = collisionData;

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    this.impulse.clear();
    this.angImpulseA.clear();
    this.angImpulseB.clear();

    this.init();

    return this;
};

/**
 * Initialization method called on instantiantion or reset of the Contact. Performs
 * precalculations that will not change over the life of the Contact.
 *
 * @method init
 */
Contact.prototype.init = function init() {
    var data = this.data;
    var n = data.normal;
    var t1 = new Vec3();
    if (n.x >= 0.57735) {
        t1.set(n.y, -n.x, 0);
    } else {
        t1.set(0, n.z, -n.y);
    }
    t1.normalize();
    var t2 = Vec3.cross(n, t1, new Vec3());

    this.tangent1 = t1;
    this.tangent2 = t2;

    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var invEffectiveMass = bodyA.inverseMass + bodyB.inverseMass;

    var r1n = Vec3.cross(rBodyA, n, R1_REGISTER);
    var r2n = Vec3.cross(rBodyB, n, R2_REGISTER);
    this.effNormalMass = 1 / (invEffectiveMass +
        Vec3.dot(r1n, bodyA.inverseInertia.vectorMultiply(r1n, VEC1_REGISTER)) +
        Vec3.dot(r2n, bodyB.inverseInertia.vectorMultiply(r2n, VEC1_REGISTER)));

    var r1t1 = Vec3.cross(rBodyA, t1, R1_REGISTER);
    var r2t1 = Vec3.cross(rBodyB, t1, R2_REGISTER);
    this.effTangentialMass1 = 1 / (invEffectiveMass +
        Vec3.dot(r1t1, bodyA.inverseInertia.vectorMultiply(r1t1, VEC1_REGISTER)) +
         Vec3.dot(r2t1, bodyB.inverseInertia.vectorMultiply(r2t1, VEC1_REGISTER)));

    var r1t2 = Vec3.cross(rBodyA, t2, R1_REGISTER);
    var r2t2 = Vec3.cross(rBodyB, t2, R2_REGISTER);
    this.effTangentialMass2 = 1 / (invEffectiveMass +
        Vec3.dot(r1t2, bodyA.inverseInertia.vectorMultiply(r1t2, VEC1_REGISTER)) +
         Vec3.dot(r2t2, bodyB.inverseInertia.vectorMultiply(r2t2, VEC1_REGISTER)));

    this.restitution = Math.min(bodyA.restitution, bodyB.restitution);
    this.friction = bodyA.friction * bodyB.friction;
};

/**
 * Warm start the Contact, prepare for the iterative solver, and reset impulses.
 *
 * @method update
 * @param {Number} dt
 */
Contact.prototype.update = function update(dt) {
    var data = this.data;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var n = data.normal;

    var vb1 = Vec3.add(bodyA.velocity, Vec3.cross(bodyA.angularVelocity, rBodyA, WxR_REGISTER), VB1_REGISTER);
    var vb2 = Vec3.add(bodyB.velocity, Vec3.cross(bodyB.angularVelocity, rBodyB, WxR_REGISTER), VB2_REGISTER);
    var relativeVelocity = vb2.subtract(vb1);
    var contactSpeed = Vec3.dot(relativeVelocity, n);

    var beta = 0.15;
    var slop = 1.5;
    var velocityTolerance = 20.0;

    var restitution = Math.abs(contactSpeed) < velocityTolerance ? 0.0 : this.restitution;
    this.velocityBias = -beta * Math.max(data.penetration - slop, 0.0) / dt;
    this.velocityBias += restitution * contactSpeed;

    var impulse = this.impulse.scale(0.25);
    var angImpulseA = this.angImpulseA.scale(0.25);
    var angImpulseB = this.angImpulseB.scale(0.25);

    bodyB.applyImpulse(impulse);
    bodyB.applyAngularImpulse(angImpulseB);
    impulse.invert();
    bodyA.applyImpulse(impulse);
    bodyA.applyAngularImpulse(angImpulseA);

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the contact and simulate friction.
 *
 * @method resolve
 */
Contact.prototype.resolve = function resolve() {
    var data = this.data;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var n = data.normal;
    var t1 = this.tangent1;
    var t2 = this.tangent2;

    var vb1 = Vec3.add(bodyA.velocity, Vec3.cross(bodyA.angularVelocity, rBodyA, WxR_REGISTER), VB1_REGISTER);
    var vb2 = Vec3.add(bodyB.velocity, Vec3.cross(bodyB.angularVelocity, rBodyB, WxR_REGISTER), VB2_REGISTER);
    var relativeVelocity = vb2.subtract(vb1);

    var normalLambda = -(Vec3.dot(relativeVelocity, n) + this.velocityBias) * this.effNormalMass;
    var newNormalImpulse = Math.max(this.normalImpulse + normalLambda, 0);
    normalLambda = newNormalImpulse - this.normalImpulse;

    var maxFriction = this.friction * newNormalImpulse;

    var tangentLambda1 = -Vec3.dot(relativeVelocity, t1) * this.effTangentialMass1;
    var newTangentImpulse1 = clamp(this.tangentImpulse1 + tangentLambda1, -maxFriction, maxFriction);
    tangentLambda1 = newTangentImpulse1 - this.tangentImpulse1;

    var tangentLambda2 = -Vec3.dot(relativeVelocity, t2) * this.effTangentialMass2;
    var newTangentImpulse2 = clamp(this.tangentImpulse2 + tangentLambda2, -maxFriction, maxFriction);
    tangentLambda2 = newTangentImpulse2 - this.tangentImpulse2;

    var impulse = Vec3.scale(n, normalLambda, NORMALIMPULSE_REGISTER);
    var tangentImpulse1 = Vec3.scale(t1, tangentLambda1, TANGENTIMPULSE1_REGISTER);
    var tangentImpulse2 = Vec3.scale(t2, tangentLambda2, TANGENTIMPULSE2_REGISTER);

    impulse.add(tangentImpulse1).add(tangentImpulse2);

    var angImpulseB = Vec3.cross(rBodyB, impulse, VEC1_REGISTER);
    var angImpulseA = Vec3.cross(rBodyA, impulse, VEC2_REGISTER).invert();

    bodyB.applyImpulse(impulse);
    bodyB.applyAngularImpulse(angImpulseB);
    impulse.invert();
    bodyA.applyImpulse(impulse);
    bodyA.applyAngularImpulse(angImpulseA);

    this.normalImpulse = newNormalImpulse;
    this.tangentImpulse1 = newTangentImpulse1;
    this.tangentImpulse2 = newTangentImpulse2;

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = ContactManifoldTable;

},{"../../../math/Vec3":49,"../../../utilities/ObjectManager":93}],71:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Vec3 = require('../../../math/Vec3');
var ObjectManager = require('../../../utilities/ObjectManager');

ObjectManager.register('GJK_EPASupportPoint', GJK_EPASupportPoint);
var OMRequestGJK_EPASupportPoint = ObjectManager.requestGJK_EPASupportPoint;
var OMRequestDynamicGeometry = ObjectManager.requestDynamicGeometry;
var OMFreeGJK_EPASupportPoint = ObjectManager.freeGJK_EPASupportPoint;
var OMFreeDynamicGeometry = ObjectManager.freeDynamicGeometry;
var OMFreeDynamicGeometryFeature = ObjectManager.freeDynamicGeometryFeature;

var P_REGISTER = new Vec3();
var V0_REGISTER = new Vec3();
var V1_REGISTER = new Vec3();
var V2_REGISTER = new Vec3();

var DIRECTION_REGISTER = new Vec3();
var INVDIRECTION_REGISTER = new Vec3();

/**
 * Support point to be added to the DynamicGeometry. The point in Minkowski space as well as the
 * original pair.
 *
 * @class GJK_EPASupportPoint
 * @param {Vec3} vertex
 * @param {Vec3} worldVertexA
 * @param {Vec3} worldVertexAB
 */
function GJK_EPASupportPoint(vertex, worldVertexA, worldVertexB) {
    this.vertex = vertex;
    this.worldVertexA = worldVertexA;
    this.worldVertexB = worldVertexB;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
GJK_EPASupportPoint.prototype.reset = function reset(vertex, worldVertexA, worldVertexB) {
    this.vertex = vertex;
    this.worldVertexA = worldVertexA;
    this.worldVertexB = worldVertexB;

    return this;
};

/**
 * Free the DynamicGeomtetry and associate vertices and features for later reuse.
 *
 * @method freeGJK_EPADynamicGeometry
 * @param {DynamicGeometry} geometry
 */
function freeGJK_EPADynamicGeometry(geometry) {
    var vertices = geometry.vertices;
    var i;
    i = vertices.length;
    while (i--) {
        var v = vertices.pop();
        if (v !== null) OMFreeGJK_EPASupportPoint(v);
    }
    geometry.numVertices = 0;
    var features = geometry.features;
    i = features.length;
    while (i--) {
        var f = features.pop();
        if (f !== null) OMFreeDynamicGeometryFeature(f);
    }
    geometry.numFeatures = 0;
    OMFreeDynamicGeometry(geometry);
}

/**
 * Find the point in Minkowski space furthest in a given direction for two convex Bodies.
 *
 * @method minkowskiSupport
 * @param {Body} body1
 * @param {Body} body2
 * @param {Vec3} direction
 * @return {GJK_EPASupportPoint}
 */
function minkowskiSupport(body1, body2, direction) {
    var inverseDirection = Vec3.scale(direction, -1, INVDIRECTION_REGISTER);

    var w1 = Vec3.add(body1.support(direction), body1.position, new Vec3());
    var w2 = Vec3.add(body2.support(inverseDirection), body2.position, new Vec3());

    // The vertex in Minkowski space as well as the original pair in world space
    return OMRequestGJK_EPASupportPoint().reset(Vec3.subtract(w1, w2, new Vec3()), w1, w2);
}

/**
 * Gilbert-Johnson-Keerthi collision detection. Returns a DynamicGeometry simplex if the bodies are found
 * to have collided or false for no collsion.
 *
 * @method GJK
 * param {Body} body1
 * param {Body} body2
 * @return {DynamicGeometry | Boolean}
 */
function GJK(body1, body2) {
    var support = minkowskiSupport;
    // Use p2 - p1 to seed the initial choice of direction
    var direction = Vec3.subtract(body2.position, body1.position, DIRECTION_REGISTER).normalize();
    var simplex = OMRequestDynamicGeometry();
    simplex.addVertex(support(body1, body2, direction));
    direction.invert();

    var i = 0;
    var maxIterations = 1e3;
    while(i++ < maxIterations) {
        if (direction.x === 0 && direction.y === 0 && direction.z === 0) break;
        simplex.addVertex(support(body1, body2, direction));
        if (Vec3.dot(simplex.getLastVertex().vertex, direction) < 0) break;
        // If simplex contains origin, return for use in EPA
        if (simplex.simplexContainsOrigin(direction, OMFreeGJK_EPASupportPoint)) return simplex;
    }
    freeGJK_EPADynamicGeometry(simplex);
    return false;
}

/**
 * Expanding Polytope Algorithm--penetration depth, collision normal, and contact points.
 * Returns a CollisonData object.
 *
 * @method EPA
 * @param {Body} body1
 * @param {Body} body2
 * @param {DynamicGeometry} polytope
 * @return {CollisionData}
 */
function EPA(body1, body2, polytope) {
    var support = minkowskiSupport;
    var depthEstimate = Infinity;

    var i = 0;
    var maxIterations = 1e3;
    while(i++ < maxIterations) {
        var closest = polytope.getFeatureClosestToOrigin();
        if (closest === null) return null;
        var direction = closest.normal;
        var point = support(body1, body2, direction);
        depthEstimate = Math.min(depthEstimate, Vec3.dot(point.vertex, direction));
        if (depthEstimate - closest.distance <= 0.01) {
            var supportA = polytope.vertices[closest.vertexIndices[0]];
            var supportB = polytope.vertices[closest.vertexIndices[1]];
            var supportC = polytope.vertices[closest.vertexIndices[2]];

            var A = supportA.vertex;
            var B = supportB.vertex;
            var C = supportC.vertex;
            var P = Vec3.scale(direction, closest.distance, P_REGISTER);

            var V0 = Vec3.subtract(B, A, V0_REGISTER);
            var V1 = Vec3.subtract(C, A, V1_REGISTER);
            var V2 = Vec3.subtract(P, A, V2_REGISTER);

            var d00 = Vec3.dot(V0, V0);
            var d01 = Vec3.dot(V0, V1);
            var d11 = Vec3.dot(V1, V1);
            var d20 = Vec3.dot(V2, V0);
            var d21 = Vec3.dot(V2, V1);
            var denom = d00*d11 - d01*d01;

            var v = (d11*d20 - d01*d21) / denom;
            var w = (d00*d21 - d01*d20) / denom;
            var u = 1.0 - v - w;

            var body1Contact =      supportA.worldVertexA.scale(u)
                               .add(supportB.worldVertexA.scale(v))
                               .add(supportC.worldVertexA.scale(w));

            var body2Contact =      supportA.worldVertexB.scale(u)
                               .add(supportB.worldVertexB.scale(v))
                               .add(supportC.worldVertexB.scale(w));

            var localBody1Contact = Vec3.subtract(body1Contact, body1.position, new Vec3());
            var localBody2Contact = Vec3.subtract(body2Contact, body2.position, new Vec3());

            freeGJK_EPADynamicGeometry(polytope);
            OMFreeGJK_EPASupportPoint(point);

            return ObjectManager.requestCollisionData().reset(closest.distance, direction, body1Contact, body2Contact, localBody1Contact, localBody2Contact);
        } else {
            polytope.addVertex(point);
            polytope.reshape();
        }
    }
    throw new Error('EPA failed to terminate in allotted iterations.');
}

module.exports.GJK = GJK;
module.exports.EPA = EPA;

},{"../../../math/Vec3":49,"../../../utilities/ObjectManager":93}],72:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var AABB = require('./AABB');

/**
 * @const {String[]} AXES x, y, and z axes
 */
var AXES = ['x', 'y', 'z'];

/**
 * Persistant object maintaining sorted lists of AABB endpoints used in a sweep-and-prune broadphase.
 * Used to accelerate collision detection.
 * http://en.wikipedia.org/wiki/Sweep_and_prune
 *
 * @class SweepAndPrune
 * @param {Body[]} targets
 */
function SweepAndPrune(targets) {
    this._sweepVolumes = [];
    this._entityRegistry = {};
    this._boundingVolumeRegistry = {};
    this.endpoints = {x: [], y: [], z: []};

    this.overlaps = [];
    this.overlapsMatrix = {};
    this._IDPool = [];
    targets = targets || [];
    for (var i = 0; i < targets.length; i++) {
        this.add(targets[i]);
    }
}

/**
 * Start tracking a body in the broad-phase.
 *
 * @method add
 * @param {Body} body
 */
SweepAndPrune.prototype.add = function(body) {
    var boundingVolume = new AABB(body);
    var sweepVolume = new SweepVolume(boundingVolume);

    this._entityRegistry[body._ID] = body;
    this._boundingVolumeRegistry[body._ID] = boundingVolume;
    this._sweepVolumes.push(sweepVolume);
    for (var i = 0; i < 3; i++) {
        var axis = AXES[i];
        this.endpoints[axis].push(sweepVolume.points[axis][0]);
        this.endpoints[axis].push(sweepVolume.points[axis][1]);
    }
};

/**
 * Stop tracking a body in the broad-phase.
 *
 * @method add
 * @param {Body} body
 */
SweepAndPrune.prototype.remove = function remove(body) {
    this._entityRegistry[body._ID] = null;
    this._boundingVolumeRegistry[body._ID] = null;
    var i, len;
    var index;
    for (i = 0, len = this._sweepVolumes.length; i < len; i++) {
        if (this._sweepVolumes[i]._ID === body._ID) {
            index = i;
            break;
        }
    }
    this._sweepVolumes.splice(index, 1);
    var endpoints = this.endpoints;
    var point;

    var xs = [];
    for (i = 0, len = endpoints.x.length; i < len; i++) {
        point = endpoints.x[i];
        if (point._ID !== body._ID) xs.push(point);
    }
    var ys = [];
    for (i = 0, len = endpoints.y.length; i < len; i++) {
        point = endpoints.y[i];
        if (point._ID !== body._ID) ys.push(point);
    }
    var zs = [];
    for (i = 0, len = endpoints.z.length; i < len; i++) {
        point = endpoints.z[i];
        if (point._ID !== body._ID) zs.push(point);
    }
    endpoints.x = xs;
    endpoints.y = ys;
    endpoints.z = zs;
};

/**
 * Update the endpoints of the tracked AABB's and resort the endpoint lists accordingly. Uses an insertion sort,
 * where swaps during the sort are taken to signify a potential change in overlap status for the two
 * relevant AABB's. Returns pairs of overlapping AABB's.
 *
 * @param update
 * @return {Particle[][]}
 */
SweepAndPrune.prototype.update = function() {
    var _sweepVolumes = this._sweepVolumes;
    var _entityRegistry = this._entityRegistry;
    var _boundingVolumeRegistry = this._boundingVolumeRegistry;

    var i, j, k, len;

    for (j = 0, len = _sweepVolumes.length; j < len; j++) {
        _sweepVolumes[j].update();
    }

    var endpoints = this.endpoints;
    var overlaps = this.overlaps;
    var overlapsMatrix = this.overlapsMatrix;
    var _IDPool = this._IDPool;

    for (k = 0; k < 3; k++) {
        var axis = AXES[k];
        // Insertion sort:
        var endpointAxis = endpoints[axis];
        for (j = 1, len = endpointAxis.length; j < len; j++) {
            var current = endpointAxis[j];
            var val = current.value;
            var swap;
            var row;
            var index;
            var lowID;
            var highID;
            var cID;
            var sID;

            i = j - 1;
            while (i >= 0 && (swap = endpointAxis[i]).value > val) {
                // A swap occurence indicates that current and swap either just started or just stopped overlapping

                cID = current._ID;
                sID = swap._ID;

                if (cID < sID) {
                    lowID = cID;
                    highID = sID;
                } else {
                    lowID = sID;
                    highID = cID;
                }

                // If, for this axis, min point of current and max point of swap
                if (~current.side & swap.side) {
                    // Now overlapping on this axis -> possible overlap, do full AABB check
                    if (AABB.checkOverlap(_boundingVolumeRegistry[cID], _boundingVolumeRegistry[sID])) {
                        row = overlapsMatrix[lowID] = overlapsMatrix[lowID] || {};
                        index = row[highID] = _IDPool.length ? _IDPool.pop() : overlaps.length;
                        overlaps[index] = [_entityRegistry[lowID], _entityRegistry[highID]];
                    }
                // // Else if, for this axis, max point of current and min point of swap
                } else if (current.side & ~swap.side) {
                    // Now not overlapping on this axis -> definitely not overlapping
                    if ((row = overlapsMatrix[lowID]) && row[highID] != null) {
                        index = row[highID];
                        overlaps[index] = null;
                        row[highID] = null;
                        _IDPool.push(index);
                    }
                }
                // Else if max of both or min of both, still overlapping

                endpointAxis[i + 1] = swap;
                i--;
            }
            endpointAxis[i + 1] = current;
        }
    }

    return overlaps;
};

/**
 * Object used to associate an AABB with its endpoints in the sorted lists.
 *
 * @class SweepVolume
 * @constructor
 * @param {AABB} boundingVolume
 */
function SweepVolume(boundingVolume) {
    this._boundingVolume = boundingVolume;
    this._ID = boundingVolume._ID;
    this.points = {
        x: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}],
        y: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}],
        z: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}]
    };
    this.update();
}

/**
 * Update the endpoints to reflect the current location of the AABB.
 *
 * @method update
 */
SweepVolume.prototype.update = function() {
    var boundingVolume = this._boundingVolume;
    boundingVolume.update();

    var points = this.points;

    for (var i = 0; i < 3; i++) {
        var axis = AXES[i];
        points[axis][0].value = boundingVolume.vertices[axis][0];
        points[axis][1].value = boundingVolume.vertices[axis][1];
    }
};

module.exports = SweepAndPrune;

},{"./AABB":68}],73:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Force = require('./Force');
var Vec3 = require('../../math/Vec3');

var FORCE_REGISTER = new Vec3();

/**
 * Use drag to oppose momentum of a moving object
 *
 * @class Drag
 * @extends Force
 * @param {Object} options
 */
function Drag(targets, options) {
    Force.call(this, targets, options);
}

Drag.prototype = Object.create(Force.prototype);
Drag.prototype.constructor = Drag;

/**
 * Used to scale velocity in the computation of the drag force.
 *
 * @attribute QUADRATIC
 * @type Function
 * @param {Number} v
 * @return {Number} used to square the magnitude of the velocity
 */
Drag.QUADRATIC = function QUADRATIC(v) {
    return v*v;
};

/**
 * Used to scale velocity in the computation of the drag force.
 *
 * @attribute LINEAR
 * @type Function
 * @param {Number} v
 * @return {Number} strength 1, will not scale the velocity
 */
Drag.LINEAR = function LINEAR(v) {
    return v;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Drag.prototype.init = function() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 1;
    this.type = this.type || Drag.LINEAR;
};

/**
 * Apply the force.
 *
 * @method update
 */
Drag.prototype.update = function update() {
    var targets = this.targets;
    var type = this.type;

    var force = FORCE_REGISTER;

    var max = this.max;
    var strength = this.strength;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var velocity = target.velocity;
        var v = velocity.length();
        var invV = v ? 1 / v : 0;
        var magnitude = -strength * type(v);
        Vec3.scale(velocity, (magnitude < -max ? -max : magnitude) * invV, force);
        target.applyForce(force);
    }
};

module.exports = Drag;

},{"../../math/Vec3":49,"./Force":74}],74:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var _ID = 0;
/**
 * Abstract force manager to apply forces to targets.
 *
 * @class Force
 * @virtual
 * @param {Particle[]} targets The targets of the force.
 * @param {Object} options The options hash.
 */
function Force(targets, options) {
    if (targets) {
        if (targets instanceof Array) this.targets = targets;
        else this.targets = [targets];
    }
    else this.targets = [];

    options = options || {};
    this.setOptions(options);

    this._ID = _ID++;
}

/**
 * Decorates the Force with the options object.
 *
 * @method setOptions
 * @param {Object} options The options hash.
 */
Force.prototype.setOptions = function setOptions(options) {
    for (var key in options) this[key] = options[key];
    this.init(options);
};

/**
 * Add a target or targets to the Force.
 *
 * @method addTarget
 * @param {Particle} target The body to begin targetting.
 */
Force.prototype.addTarget = function addTarget(target) {
    this.targets.push(target);
};

/**
 * Remove a target or targets from the Force.
 *
 * @method addTarget
 * @param {Particle} target The body to stop targetting.
 */
Force.prototype.removeTarget = function removeTarget(target) {
    var index = this.targets.indexOf(target);
    if (index < 0) return;
    this.targets.splice(index, 1);
};

/**
 * Method invoked upon instantiation and the setting of options.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Force.prototype.init = function init(options) {};

/**
 * Apply forces on each target.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Force.prototype.update = function update(time, dt) {};

module.exports = Force;

},{}],75:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Force = require('./Force');
var Vec3 = require('../../math/Vec3');

var FORCE_REGISTER = new Vec3();

/**
 * Force that pulls all objects in a direction with constant acceleration
 *
 * @class Gravity1D
 * @extends Force
 * @param {Object} options
 */
function Gravity1D(targets, options) {
    Force.call(this, targets, options);
}

Gravity1D.prototype = Object.create(Force.prototype);
Gravity1D.prototype.constructor = Gravity1D;

/**
 * @enum directions
 */
Gravity1D.DOWN     = 0;
Gravity1D.UP       = 1;
Gravity1D.LEFT     = 2;
Gravity1D.RIGHT    = 3;
Gravity1D.FORWARD  = 4;
Gravity1D.BACKWARD = 5;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Gravity1D.prototype.init = function(options) {
    this.max = this.max || Infinity;
    if (options.acceleration) {
        this.strength = this.acceleration.length();
        this.direction = -1;
        return;
    }
    var acceleration = this.acceleration = new Vec3();
    var direction = this.direction = this.direction || Gravity1D.DOWN;
    var magnitude = this.strength = this.strength || 200;
    switch (direction) {
        case Gravity1D.DOWN:
            acceleration.set(0, magnitude, 0);
            break;
        case Gravity1D.UP:
            acceleration.set(0, -1 * magnitude, 0);
            break;
        case Gravity1D.LEFT:
            acceleration.set(-1 * magnitude, 0, 0);
            break;
        case Gravity1D.RIGHT:
            acceleration.set(magnitude, 0, 0);
            break;
        case Gravity1D.FORWARD:
            acceleration.set(0, 0, -1 * magnitude);
            break;
        case Gravity1D.BACKWARD:
            acceleration.set(0, 0, magnitude);
            break;
        default:
            break;
    }
};

/**
 * Apply the force.
 *
 * @method update
 */
Gravity1D.prototype.update = function() {
    var targets = this.targets;

    var force = FORCE_REGISTER;

    var max = this.max;
    var acceleration = this.acceleration;
    var a = acceleration.length();
    var invA = a ? 1 / a : 0;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var magnitude = a * target.mass;
        Vec3.scale(acceleration, (magnitude > max ? max : magnitude) * invA, force);
        target.applyForce(force);
    }
};

module.exports = Gravity1D;

},{"../../math/Vec3":49,"./Force":74}],76:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Force = require('./Force');
var Vec3 = require('../../math/Vec3');

var FORCE_REGISTER = new Vec3();

/**
 * An inverse square force dependent on the masses of the source and targets.
 *
 * @class Gravity3D
 * @extends Force
 * @param {Object} options
 */
function Gravity3D(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

Gravity3D.prototype = Object.create(Force.prototype);
Gravity3D.prototype.constructor = Gravity3D;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 */
Gravity3D.prototype.init = function() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 200;
};

/**
 * Apply the force.
 *
 * @method update
 */
Gravity3D.prototype.update = function() {
    var source = this.source;
    var targets = this.targets;

    var force = FORCE_REGISTER;

    var strength = this.strength;
    var max = this.max;
    var anchor = this.anchor || source.position;
    var sourceMass = this.anchor ? 1 : source.mass;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        Vec3.subtract(anchor, target.position, force);
        var dist = force.length();
        var invDistance = dist ? 1 / dist : 0;
        var magnitude = strength * sourceMass * target.mass * invDistance * invDistance;
        if (magnitude < 0) {
            magnitude = magnitude < -max ? -max : magnitude;
        } else {
            magnitude = magnitude > max ? max : magnitude;
        }
        force.scale(magnitude * invDistance);
        target.applyForce(force);
        if (source) source.applyForce(force.invert());
    }
};

module.exports = Gravity3D;

},{"../../math/Vec3":49,"./Force":74}],77:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Force = require('./Force');
var Vec3 = require('../../math/Vec3');

var TORQUE_REGISTER = new Vec3();

/**
 * A behavior that slows angular velocity by applying torque.
 *
 * @class RotationalDrag
 * @extends Force
 * @param {Object} options options to set on drag
 */
function RotationalDrag(targets, options) {
    Force.call(this, targets, options);
}

RotationalDrag.prototype = Object.create(Force.prototype);
RotationalDrag.prototype.constructor = RotationalDrag;

/**
 * Used to scale angular velocity in the computation of the drag torque.
 *
 * @attribute QUADRATIC
 * @type Function
 * @param {Vec3} omega
 * @return {Number}
 */
RotationalDrag.QUADRATIC = function QUADRATIC(omega) {
    return omega.length();
};

/**
 * Used to scale angular velocity in the computation of the drag torque.
 *
 * @attribute LINEAR
 * @type Function
 * @return {Number}
 */
RotationalDrag.LINEAR = function LINEAR() {
    return 1;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 */
RotationalDrag.prototype.init = function init() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 1;
    this.type = this.type || RotationalDrag.LINEAR;
};

/**
 * Adds a rotational drag force to a physics body's torque accumulator.
 *
 * @method update
 */
RotationalDrag.prototype.update = function update() {
    var targets = this.targets;
    var type = this.type;

    var torque = TORQUE_REGISTER;

    var max = this.max;
    var strength = this.strength;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var omega = target.angularVelocity;
        var magnitude = -strength * type(omega);
        Vec3.scale(omega, magnitude < -max ? -max : magnitude, torque);
        target.applyTorque(torque);
    }
};

module.exports = RotationalDrag;

},{"../../math/Vec3":49,"./Force":74}],78:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Force = require('./Force');
var Vec3 = require('../../math/Vec3');
var Mat33 = require('../../math/Mat33');
var Quaternion = require('../../math/Quaternion');

var Q_REGISTER = new Quaternion();
var DAMPING_REGISTER = new Vec3();
var XYZ_REGISTER = new Vec3();
var MAT_REGISTER = new Mat33();

/** @const PI */
var PI = Math.PI;

/**
 * A spring-like behavior that attempts to enforce a specfic orientation by applying torque.
 *
 * @class RotationalSpring
 * @extends Force
 * @param {Object} options
 */
function RotationalSpring(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

RotationalSpring.prototype = Object.create(Force.prototype);
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
RotationalSpring.prototype.init = function init(options) {
    if (!this.source) this.anchor = this.anchor ? this.anchor.normalize() : new Quaternion(1,0,0,0);
    if (options.stiffness || options.damping) {
        this.stiffness = this.stiffness || 100;
        this.damping = this.damping || 0;
        this.period = null;
        this.dampingRatio = null;
    }
    else if (options.period || options.dampingRatio) {
        this.period = this.period || 1;
        this.dampingRatio = this.dampingRatio || 0;

        this.stiffness = 2 * PI / this.period;
        this.stiffness *= this.stiffness;
        this.damping = 4 * PI * this.dampingRatio / this.period;
    }
};

/**
 * Adds a torque force to a physics body's torque accumulator.
 *
 * @method update
 */
RotationalSpring.prototype.update = function update() {
    var source = this.source;
    var targets = this.targets;

    var deltaQ = Q_REGISTER;
    var dampingTorque = DAMPING_REGISTER;
    var XYZ = XYZ_REGISTER;
    var effInertia = MAT_REGISTER;

    var max = this.max;
    var stiffness = this.stiffness;
    var damping = this.damping;
    var anchor = this.anchor || source.orientation;
    var invSourceInertia = this.anchor ? null : source.inverseInertia;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var q = target.orientation;
        Quaternion.conjugate(q, deltaQ);
        deltaQ.multiply(anchor);

        if (deltaQ.w >= 1) continue;
        var halftheta = Math.acos(deltaQ.w);
        var length = Math.sqrt(1 - deltaQ.w * deltaQ.w);

        var deltaOmega = XYZ.copy(deltaQ).scale(2 * halftheta / length);

        deltaOmega.scale(stiffness);

        if (invSourceInertia !== null) {
            Mat33.add(invSourceInertia, target.inverseInertia, effInertia).inverse();
        } else {
            Mat33.inverse(target.inverseInertia, effInertia);
        }

        if (damping !== 0) {
            if (source) {
                deltaOmega.add(Vec3.subtract(target.angularVelocity, source.angularVelocity, dampingTorque).scale(-damping));
            }
            else {
                deltaOmega.add(Vec3.scale(target.angularVelocity, -damping, dampingTorque));
            }
        }

        var torque = deltaOmega.applyMatrix(effInertia);
        var magnitude = torque.length();

        if (magnitude > max) torque.scale(max/magnitude);

        target.applyTorque(torque);
        if (source) source.applyTorque(torque.invert());
    }
};

module.exports = RotationalSpring;

},{"../../math/Mat33":46,"../../math/Quaternion":47,"../../math/Vec3":49,"./Force":74}],79:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Force = require('./Force');
var Vec3 = require('../../math/Vec3');

var FORCE_REGISTER = new Vec3();
var DAMPING_REGISTER = new Vec3();

/**
 * A force that accelerates a Particle towards a specific anchor point. Can be anchored to
 * a Vec3 or another source Particle.
 *
 *  @class Spring
 *  @extends Force
 *  @param {Object} options options to set on drag
 */
function Spring(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

Spring.prototype = Object.create(Force.prototype);
Spring.prototype.constructor = Spring;

/** @const */
var PI = Math.PI;

/**
 * A FENE (Finitely Extensible Nonlinear Elastic) spring force
 *      see: http://en.wikipedia.org/wiki/FENE
 * @attribute FENE
 * @type Function
 * @param {Number} dist current distance target is from source body
 * @param {Number} rMax maximum range of influence
 * @return {Number} unscaled force
 */
Spring.FENE = function(dist, rMax) {
    var rMaxSmall = rMax * 0.99;
    var r = Math.max(Math.min(dist, rMaxSmall), -rMaxSmall);
    return r / (1 - r * r/(rMax * rMax));
};

/**
 * A Hookean spring force, linear in the displacement
 *      see: http://en.wikipedia.org/wiki/Hooke's_law
 * @attribute HOOKE
 * @type Function
 * @param {Number} dist current distance target is from source body
 * @return {Number} unscaled force
 */
Spring.HOOKE = function(dist) {
    return dist;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Spring.prototype.init = function(options) {
    this.max = this.max || Infinity;
    this.length = this.length || 0;
    this.type = this.type || Spring.HOOKE;
    this.maxLength = this.maxLength || Infinity;
    if (options.stiffness || options.damping) {
        this.stiffness = this.stiffness || 100;
        this.damping = this.damping || 0;
        this.period = null;
        this.dampingRatio = null;
    }
    else if (options.period || options.dampingRatio) {
        this.period = this.period || 1;
        this.dampingRatio = this.dampingRatio || 0;

        this.stiffness = 2 * PI / this.period;
        this.stiffness *= this.stiffness;
        this.damping = 4 * PI * this.dampingRatio / this.period;
    }
};

/**
 * Apply the force.
 *
 * @method update
 */
Spring.prototype.update = function() {
    var source = this.source;
    var targets = this.targets;

    var force = FORCE_REGISTER;
    var dampingForce = DAMPING_REGISTER;

    var max = this.max;
    var stiffness = this.stiffness;
    var damping = this.damping;
    var restLength = this.length;
    var maxLength = this.maxLength;
    var anchor = this.anchor || source.position;
    var invSourceMass = this.anchor ? 0 : source.inverseMass;
    var type = this.type;

    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        Vec3.subtract(anchor, target.position, force);
        var dist = force.length();
        var stretch = dist - restLength;

        if (Math.abs(stretch) < 1e-6) continue;

        var effMass = 1 / (target.inverseMass + invSourceMass);
        if (this.period !== null) {
            stiffness *= effMass;
            damping *= effMass;
        }

        force.scale(stiffness * type(stretch, maxLength) / stretch);

        if (damping !== 0) {
            if (source) {
                force.add(Vec3.subtract(target.velocity, source.velocity, dampingForce).scale(-damping));
            }
            else {
                force.add(Vec3.scale(target.velocity, -damping, dampingForce));
            }
        }

        var magnitude = force.length();
        var invMag = magnitude ? 1 / magnitude : 0;

        Vec3.scale(force, (magnitude > max ? max : magnitude) * invMag, force);

        target.applyForce(force);
        if (source) source.applyForce(force.invert());
    }
};

module.exports = Spring;

},{"../../math/Vec3":49,"./Force":74}],80:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Particle: require('./bodies/Particle'),
    ConvexBodyFactory: require('./bodies/ConvexBodyFactory'),
    Box: require('./bodies/Box'),
    Sphere: require('./bodies/Sphere'),
    Wall: require('./bodies/Wall'),

    Constraint: require('./constraints/Constraint'),
    Angle: require('./constraints/Angle'),
    Collision: require('./constraints/Collision'),
    Direction: require('./constraints/Direction'),
    Distance: require('./constraints/Distance'),
    Curve: require('./constraints/Curve'),
    Hinge: require('./constraints/Hinge'),
    BallAndSocket: require('./constraints/BallAndSocket'),

    Force: require('./forces/Force'),
    Drag: require('./forces/Drag'),
    RotationalDrag: require('./forces/RotationalDrag'),
    Gravity1D: require('./forces/Gravity1D'),
    Gravity3D: require('./forces/Gravity3D'),
    Spring: require('./forces/Spring'),
    RotationalSpring: require('./forces/RotationalSpring'),

    PhysicsEngine: require('./PhysicsEngine'),
    Geometry: require('./Geometry')
};

},{"./Geometry":53,"./PhysicsEngine":54,"./bodies/Box":55,"./bodies/ConvexBodyFactory":56,"./bodies/Particle":57,"./bodies/Sphere":58,"./bodies/Wall":59,"./constraints/Angle":60,"./constraints/BallAndSocket":61,"./constraints/Collision":62,"./constraints/Constraint":63,"./constraints/Curve":64,"./constraints/Direction":65,"./constraints/Distance":66,"./constraints/Hinge":67,"./forces/Drag":73,"./forces/Force":74,"./forces/Gravity1D":75,"./forces/Gravity3D":76,"./forces/RotationalDrag":77,"./forces/RotationalSpring":78,"./forces/Spring":79}],81:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 
// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel
 
// MIT license

'use strict';

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];

var rAF, cAF;

if (typeof window === 'object') {
    rAF = window.requestAnimationFrame;
    cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame;
    for (var x = 0; x < vendors.length && !rAF; ++x) {
        rAF = window[vendors[x] + 'RequestAnimationFrame'];
        cAF = window[vendors[x] + 'CancelRequestAnimationFrame'] ||
              window[vendors[x] + 'CancelAnimationFrame'];
    }

    if (rAF && !cAF) {
        // cAF not supported.
        // Fall back to setInterval for now (very rare).
        rAF = null;
    }
}

if (!rAF) {
    var now = Date.now ? Date.now : function () {
        return new Date().getTime();
    };

    rAF = function(callback) {
        var currTime = now();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };

    cAF = function (id) {
        clearTimeout(id);
    };
}

module.exports = {
    requestAnimationFrame: rAF,
    cancelAnimationFrame: cAF
};

},{}],82:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    requestAnimationFrame: require('./animationFrame').requestAnimationFrame,
    cancelAnimationFrame: require('./animationFrame').cancelAnimationFrame
};

},{"./animationFrame":81}],83:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Context = require('./Context');

/**
 * Instantiates a new Compositor, used for routing commands received from the
 * WebWorker to the WebGL and DOM renderer.
 *
 * @class Compositor
 * @constructor
 */
function Compositor() {
    this._contexts = {};
    this._outCommands = [];
    this._inCommands = [];
    this._time = null;

    this._resized = false;

    var _this = this;
    window.addEventListener('resize', function() {
        _this._resized = true;
    });
}

/**
 * Retrieves the time being used by the internal clock managed by
 * `FamousEngine`.
 * 
 * @method  getTime
 *  
 * @return {Number}     Clock time.
 */ 
Compositor.prototype.getTime = function getTime() {
    return this._time;
};

/**
 * Schedules an event to be sent to the WebWorker the next time the out command
 * queue is being flushed.
 *
 * @method sendEvent
 * @private
 *
 * @param  {String} path    render path to the node the event should be
 *                          triggered on (*targeted event*)
 * @param  {String} ev      event type
 * @param  {Object} payload event object (serializable using structured
 *                          cloning algorithm)
 */
Compositor.prototype.sendEvent = function sendEvent(path, ev, payload) {
    this._outCommands.push('WITH', path, 'TRIGGER', ev, payload);
};

/**
 * Internal helper method used for notifying the WebWorker about externally
 * resized contexts (e.g. by resizing the browser window).
 *
 * @method sendResize
 * @private
 *
 * @param  {String} selector    render path to the node (context) that should
 *                              be resized
 * @param  {Array} size         new context size
 */
Compositor.prototype.sendResize = function sendResize (selector, size) {
    this.sendEvent(selector, 'CONTEXT_RESIZE', size);
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method handleWith
 * @private
 *
 * @param  {Array} commands     remaining message queue received from the
 *                              WebWorker, used to shift single messages from
 */
Compositor.prototype.handleWith = function handleWith (iterator, commands) {
    var path = commands[iterator];
    var pathArr = path.split('/');
    var context = this.getOrSetContext(pathArr.shift());
    return context.receive(path, commands, iterator);
};

/**
 * Retrieves the top-level Context associated with the passed in document
 * query selector. If no such Context exists, a new one will be instantiated.
 *
 * @method getOrSetContext
 * @private
 *
 * @param  {String} selector            document query selector used for
 *                                      retrieving the DOM node the
 *                                      VirtualElement should be attached to
 * @return {Object} result
 * @return {Context}                    final VirtualElement
 */
Compositor.prototype.getOrSetContext = function getOrSetContext(selector) {
    if (this._contexts[selector]) return this._contexts[selector];
    else return (this._contexts[selector] = new Context(selector, this));
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method giveSizeFor
 * @private
 *
 * @param  {Array} commands     remaining message queue received from the
 *                              WebWorker, used to shift single messages from
 */
Compositor.prototype.giveSizeFor = function giveSizeFor(iterator, commands) {
    var selector = commands[iterator];
    var size = this.getOrSetContext(selector).getRootSize();
    this.sendResize(selector, size);
};

/**
 * Processes the previously via `receiveCommands` updated incoming "in"
 * command queue.
 * Called by ThreadManager.
 *
 * @method drawCommands
 *
 * @return {Array} outCommands  set of commands to be sent back to the
 *                              WebWorker
 */
Compositor.prototype.drawCommands = function drawCommands() {
    var commands = this._inCommands;
    var localIterator = 0;
    var command = commands[localIterator];
    while (command) {
        switch (command) {
            case 'TIME':
                this._time = commands[++localIterator];
                break;
            case 'WITH':
                localIterator = this.handleWith(++localIterator, commands);
                break;
            case 'NEED_SIZE_FOR':
                this.giveSizeFor(++localIterator, commands);
                break;
        }
        command = commands[++localIterator];
    }

    // TODO: Switch to associative arrays here...

    for (var key in this._contexts) {
        this._contexts[key].draw();
    }

    if (this._resized && this._contexts.body) {
        this.sendResize('body', this._contexts.body.getRootSize());
    }

    return this._outCommands;
};

/**
 * Used by ThreadManager to update the interal queue of incoming commands.
 * Receiving commands does not immediately start the rederning process.
 *
 * @param  {Array} commands     command queue to be processed by the
 *                              compositor's `drawCommands` method
 */
Compositor.prototype.receiveCommands = function receiveCommands(commands) {
    var len = commands.length;
    for (var i = 0; i < len; i++) {
        this._inCommands.push(commands[i]);
    }
};

/**
 * Flushes the queue of outgoing "out" commands.
 * Called by ThreadManager.
 *
 * @method clearCommands
 */
Compositor.prototype.clearCommands = function clearCommands() {
    this._inCommands.length = 0;
    this._outCommands.length = 0;
    this._resized = null;
};

module.exports = Compositor;

},{"./Context":84}],84:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var WebGLRenderer = require('../webgl-renderers/WebGLRenderer');
var Camera = require('../components/Camera');
var DOMRenderer = require('../dom-renderers/DOMRenderer');

/**
 * Context is a render layer with its own WebGLRenderer and DOMRenderer.
 * It is the interface between the Compositor which receives commands
 * and the renderers that interpret them.  It also relays information to
 * the renderers about resizing.
 *
 * The DOMElement at the given query selector is used as the root.  A
 * new DOMElement is appended to this root element, and used as the
 * parent element for all Famous DOM rendering at this context.  A 
 * canvas is added and used for all WebGL rendering at this context.
 *
 * @class Context
 * @constructor
 *
 * @param {String} selector Query selector used to locate root element of
 * context layer.
 * @param {Compositor} compositor Compositor reference to pass down to 
 * WebGLRenderer.
 */
function Context(selector, compositor) {
    this._compositor = compositor;
    this._rootEl = document.querySelector(selector);

    // If root element is the body, update size on the context
    // on window resize events.

    if (this._rootEl === document.body) {
        window.addEventListener('resize', this.updateSize.bind(this));
    }

    // Create DOM element to be used as root for all famous DOM
    // rendering and append element to the root element.

    var DOMLayerEl = document.createElement('div');
    DOMLayerEl.style.width = '100%';
    DOMLayerEl.style.height = '100%';
    DOMLayerEl.style.transformStyle = 'preserve-3d';
    DOMLayerEl.style.webkitTransformStyle = 'preserve-3d';

    this._rootEl.appendChild(DOMLayerEl);

    // Instantiate renderers

    this.DOMRenderer = new DOMRenderer(DOMLayerEl, selector, compositor);
    this.WebGLRenderer = null;
    this.canvas = null;

    // State holders

    this._renderState = {
        projectionType: Camera.ORTHOGRAPHIC_PROJECTION,
        perspectiveTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewDirty: false,
        perspectiveDirty: false
    };

    this._size = [];
    this._children = {};
    this._elementHash = {};

    this._meshTransform = [];
    this._meshSize = [0, 0, 0];
}

/**
 * Queries DOMRenderer size and updates canvas size.  Relays size information to 
 * WebGLRenderer.
 *
 * @method drawBuffers
 *
 * @return {Object} Current context.
 */
Context.prototype.updateSize = function () {
    var newSize = this.DOMRenderer.getSize();

    var width = newSize[0];
    var height = newSize[1];

    this._size[0] = width;
    this._size[1] = height;
    this._size[2] = (width > height) ? width : height;

    if (this.canvas) {
        this.canvas.width  = width;
        this.canvas.height = height;
    }

    if (this.WebGLRenderer) this.WebGLRenderer.updateSize(this._size);

    return this;
};

/**
 * Draw function called after all commands have been handled for current frame.
 * Issues draw commands to all renderers with current renderState.
 *
 * @method draw
 */
Context.prototype.draw = function draw() {
    this.DOMRenderer.draw(this._renderState);
    if (this.WebGLRenderer) this.WebGLRenderer.draw(this._renderState);

    if (this._renderState.perspectiveDirty) this._renderState.perspectiveDirty = false;
    if (this._renderState.viewDirty) this._renderState.viewDirty = false;
};

/**
 * Gets the size of the parent element of the DOMRenderer for this context.
 *
 * @method getRootSize
 */
Context.prototype.getRootSize = function getRootSize() {
    return this.DOMRenderer.getSize();
};

/**
 * Handles initialization of WebGLRenderer when necessary, including creation
 * of the canvas element and instantiation of the renderer.  Also updates size
 * to pass size information to the renderer.
 *
 * @method initWebGL
 */
Context.prototype.initWebGL = function initWebGL() {
    this.canvas = document.createElement('canvas');
    this._rootEl.appendChild(this.canvas);
    this.WebGLRenderer = new WebGLRenderer(this.canvas, this._compositor);
    this.updateSize();
};

/**
 * Handles delegation of commands to renderers of this context.
 *
 * @method receive
 *
 * @param {String} path String used as identifier of a given node in the
 * scene graph.
 * @param {Array} commands List of all commands from this frame.
 * @param {Number} iterator Number indicating progress through the command
 * queue.
 *
 * @return {Number} iterator indicating progress through the command queue.
 */
Context.prototype.receive = function receive(path, commands, iterator) {
    var localIterator = iterator;

    var command = commands[++localIterator];
    this.DOMRenderer.loadPath(path);
    this.DOMRenderer.findTarget();
    while (command) {

        switch (command) {
            case 'INIT_DOM':
                this.DOMRenderer.insertEl(commands[++localIterator]);
                break;

            case 'DOM_RENDER_SIZE':
                this.DOMRenderer.getSizeOf(commands[++localIterator]);
                break;

            case 'CHANGE_TRANSFORM':
                for (var i = 0 ; i < 16 ; i++) this._meshTransform[i] = commands[++localIterator];

                this.DOMRenderer.setMatrix(this._meshTransform);

                if (this.WebGLRenderer)
                    this.WebGLRenderer.setCutoutUniform(path, 'u_transform', this._meshTransform);

                break;

            case 'CHANGE_SIZE':
                var width = commands[++localIterator];
                var height = commands[++localIterator];

                this.DOMRenderer.setSize(width, height);
                if (this.WebGLRenderer) {
                    this._meshSize[0] = width;
                    this._meshSize[1] = height;
                    this.WebGLRenderer.setCutoutUniform(path, 'u_size', this._meshSize);
                }
                break;

            case 'CHANGE_PROPERTY':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setProperty(commands[++localIterator], commands[++localIterator]);
                break;

            case 'CHANGE_CONTENT':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setContent(commands[++localIterator]);
                break;

            case 'CHANGE_ATTRIBUTE':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setAttribute(commands[++localIterator], commands[++localIterator]);
                break;

            case 'ADD_CLASS':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.addClass(commands[++localIterator]);
                break;

            case 'REMOVE_CLASS':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.removeClass(commands[++localIterator]);
                break;
                
            case 'SUBSCRIBE':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.subscribe(commands[++localIterator], commands[++localIterator]);
                break;

            case 'GL_SET_DRAW_OPTIONS':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setMeshOptions(path, commands[++localIterator]);
                break;

            case 'GL_AMBIENT_LIGHT':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setAmbientLightColor(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_LIGHT_POSITION':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setLightPosition(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_LIGHT_COLOR':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setLightColor(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'MATERIAL_INPUT':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.handleMaterialInput(
                    path,
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_SET_GEOMETRY':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setGeometry(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_UNIFORMS':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setMeshUniform(
                    path,
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_BUFFER_DATA':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.bufferData(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_CUTOUT_STATE':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setCutoutState(path, commands[++localIterator]);
                break;

            case 'GL_MESH_VISIBILITY':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setMeshVisibility(path, commands[++localIterator]);
                break;

            case 'GL_REMOVE_MESH':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.removeMesh(path);
                break;

            case 'PINHOLE_PROJECTION':
                this._renderState.projectionType = Camera.PINHOLE_PROJECTION;
                this._renderState.perspectiveTransform[11] = -1 / commands[++localIterator];

                this._renderState.perspectiveDirty = true;
                break;

            case 'ORTHOGRAPHIC_PROJECTION':
                this._renderState.projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
                this._renderState.perspectiveTransform[11] = 0;

                this._renderState.perspectiveDirty = true;
                break;

            case 'CHANGE_VIEW_TRANSFORM':
                this._renderState.viewTransform[0] = commands[++localIterator];
                this._renderState.viewTransform[1] = commands[++localIterator];
                this._renderState.viewTransform[2] = commands[++localIterator];
                this._renderState.viewTransform[3] = commands[++localIterator];

                this._renderState.viewTransform[4] = commands[++localIterator];
                this._renderState.viewTransform[5] = commands[++localIterator];
                this._renderState.viewTransform[6] = commands[++localIterator];
                this._renderState.viewTransform[7] = commands[++localIterator];

                this._renderState.viewTransform[8] = commands[++localIterator];
                this._renderState.viewTransform[9] = commands[++localIterator];
                this._renderState.viewTransform[10] = commands[++localIterator];
                this._renderState.viewTransform[11] = commands[++localIterator];

                this._renderState.viewTransform[12] = commands[++localIterator];
                this._renderState.viewTransform[13] = commands[++localIterator];
                this._renderState.viewTransform[14] = commands[++localIterator];
                this._renderState.viewTransform[15] = commands[++localIterator];

                this._renderState.viewDirty = true;
                break;

            case 'WITH': return localIterator - 1;
        }

        command = commands[++localIterator];
    }

    return localIterator;
};

module.exports = Context;

},{"../components/Camera":2,"../dom-renderers/DOMRenderer":26,"../webgl-renderers/WebGLRenderer":131}],85:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The UIManager is being updated by an Engine by consecutively calling its
 * `update` method. It can either manage a real Web-Worker or the global
 * FamousEngine core singleton.
 *
 * @example
 * var compositor = new Compositor();
 * var engine = new Engine();
 * 
 * // Using a Web Worker
 * var worker = new Worker('worker.bundle.js');
 * var threadmanger = new UIManager(worker, compositor, engine);
 * 
 * // Without using a Web Worker
 * var threadmanger = new UIManager(Famous, compositor, engine);
 * 
 * @class  UIManager
 * @constructor
 * 
 * @param {Famous|Worker} thread        The thread being used to receive
 *                                      messages from and post messages to.
 *                                      Expected to expose a WebWorker-like
 *                                      API, which means providing a way to
 *                                      listen for updates by setting its
 *                                      `onmessage` property and sending
 *                                      updates using `postMessage`.
 * @param {Compositor} compositor       an instance of Compositor used to
 *                                      extract enqueued draw commands from to
 *                                      be sent to the thread.
 * @param {Engine} engine               an instance of Engine used for
 *                                      executing the `ENGINE` commands on.
 */
function UIManager (thread, compositor, engine) {
    this._thread = thread;
    this._compositor = compositor;
    this._engine = engine;

    this._engine.update(this);

    var _this = this;
    this._thread.onmessage = function (ev) {
        var message = ev.data ? ev.data : ev;
        if (message[0] === 'ENGINE') {
            switch (message[1]) {
                case 'START':
                    _this._engine.start();
                    break;
                case 'STOP':
                    _this._engine.stop();
                    break;
                default:
                    console.error(
                        'Unknown ENGINE command "' + message[1] + '"'
                    );
                    break;
            }
        } else {
            _this._compositor.receiveCommands(message);
        }
    };
    this._thread.onerror = function (error) {
        console.error(error);
    };
}

/**
 * Returns the thread being used by the UIManager.
 * This could either be an an actual web worker or a `FamousEngine` singleton.
 *
 * @method getThread
 * 
 * @return {Worker|FamousEngine}  Either a web worker or a `FamousEngine` singleton.
 */
UIManager.prototype.getThread = function getThread() {
    return this._thread;
};

/**
 * Returns the compositor being used by this UIManager.
 *
 * @method getCompositor
 * 
 * @return {Compositor}     The compositor used by the UIManager.
 */
UIManager.prototype.getCompositor = function getCompositor() {
    return this._compositor;
};

/**
 * Returns the engine being used by this UIManager.
 *
 * @method getEngine
 * 
 * @return {Engine}     The engine used by the UIManager.
 */
UIManager.prototype.getEngine = function getEngine() {
    return this._engine;
};

/**
 * Update method being invoked by the Engine on every `requestAnimationFrame`.
 * Used for updating the notion of time within the managed thread by sending
 * a FRAME command and sending messages to 
 * 
 * @method update
 * 
 * @param  {Number} time unix timestamp to be passed down to the worker as a
 *                       FRAME command
 */
UIManager.prototype.update = function update (time) {
    this._thread.postMessage(['FRAME', time]);
    var threadMessages = this._compositor.drawCommands();
    this._thread.postMessage(threadMessages);
    this._compositor.clearCommands();
};

module.exports = UIManager;

},{}],86:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Compositor: require('./Compositor'),
    UIManager: require('./UIManager')
};

},{"./Compositor":83,"./UIManager":85}],87:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W008 */

'use strict';

var Curves = {
    /**
     * @property linear
     * @static
     * @type {Function}
     */
    linear: function(t) {
        return t;
    },

    /**
     * @property easeIn
     * @static
     * @type {Function}
     */
    easeIn: function(t) {
        return t*t;
    },

    /**
     * @property easeOut
     * @static
     * @type {Function}
     */
    easeOut: function(t) {
        return t*(2-t);
    },

    /**
     * @property easeInOut
     * @static
     * @type {Function}
     */
    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    /**
     * @property easeOutBounce
     * @static
     * @type {Function}
     */
    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    /**
     * @property spring
     * @static
     * @type {Function}
     */
    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    /**
     * @property inQuad
     * @static
     * @type {Function}
     */
    inQuad: function(t) {
        return t*t;
    },

    /**
     * @property outQuad
     * @static
     * @type {Function}
     */
    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    /**
     * @property inOutQuad
     * @static
     * @type {Function}
     */
    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    /**
     * @property inCubic
     * @static
     * @type {Function}
     */
    inCubic: function(t) {
        return t*t*t;
    },

    /**
     * @property outCubic
     * @static
     * @type {Function}
     */
    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    /**
     * @property inOutCubic
     * @static
     * @type {Function}
     */
    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    /**
     * @property inQuart
     * @static
     * @type {Function}
     */
    inQuart: function(t) {
        return t*t*t*t;
    },

    /**
     * @property outQuart
     * @static
     * @type {Function}
     */
    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    /**
     * @property inOutQuart
     * @static
     * @type {Function}
     */
    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    /**
     * @property inQuint
     * @static
     * @type {Function}
     */
    inQuint: function(t) {
        return t*t*t*t*t;
    },

    /**
     * @property outQuint
     * @static
     * @type {Function}
     */
    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    /**
     * @property inOutQuint
     * @static
     * @type {Function}
     */
    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    /**
     * @property inSine
     * @static
     * @type {Function}
     */
    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    /**
     * @property outSine
     * @static
     * @type {Function}
     */
    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    /**
     * @property inOutSine
     * @static
     * @type {Function}
     */
    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    /**
     * @property inExpo
     * @static
     * @type {Function}
     */
    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    /**
     * @property outExpo
     * @static
     * @type {Function}
     */
    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    /**
     * @property inOutExpo
     * @static
     * @type {Function}
     */
    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    /**
     * @property inCirc
     * @static
     * @type {Function}
     */
    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    /**
     * @property outCirc
     * @static
     * @type {Function}
     */
    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    /**
     * @property inOutCirc
     * @static
     * @type {Function}
     */
    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    /**
     * @property inElastic
     * @static
     * @type {Function}
     */
    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    /**
     * @property outElastic
     * @static
     * @type {Function}
     */
    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    /**
     * @property inOutElastic
     * @static
     * @type {Function}
     */
    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    /**
     * @property inBack
     * @static
     * @type {Function}
     */
    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    /**
     * @property outBack
     * @static
     * @type {Function}
     */
    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    /**
     * @property inOutBack
     * @static
     * @type {Function}
     */
    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    /**
     * @property inBounce
     * @static
     * @type {Function}
     */
    inBounce: function(t) {
        return 1.0 - Curves.outBounce(1.0-t);
    },

    /**
     * @property outBounce
     * @static
     * @type {Function}
     */
    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        } else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        } else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        } else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    /**
     * @property inOutBounce
     * @static
     * @type {Function}
     */
    inOutBounce: function(t) {
        if (t < .5) return Curves.inBounce(t*2) * .5;
        return Curves.outBounce(t*2-1.0) * .5 + .5;
    },

    /**
     * @property flat
     *
     * Useful for delaying the execution of a subsequent transition.
     * 
     * @static
     * @type {Function}
     */
    flat: function() {
        return 0;
    }
};

module.exports = Curves;

},{}],88:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Curves = require('./Curves');
var FamousEngine = require('../core/FamousEngine');

/**
 * A state maintainer for a smooth transition between
 *    numerically-specified states. Example numeric states include floats and
 *    arrays of floats objects.
 *
 * An initial state is set with the constructor or using
 *     {@link Transitionable#from}. Subsequent transitions consist of an
 *     intermediate state, easing curve, duration and callback. The final state
 *     of each transition is the initial state of the subsequent one. Calls to
 *     {@link Transitionable#get} provide the interpolated state along the way.
 *
 * Note that there is no event loop here - calls to {@link Transitionable#get}
 *    are the only way to find state projected to the current (or provided)
 *    time and are the only way to trigger callbacks and mutate the internal
 *    transition queue.
 *
 * @example
 * var t = new Transitionable([0, 0]);
 * t
 *     .to([100, 0], 'linear', 1000)
 *     .delay(1000)
 *     .to([200, 0], 'outBounce', 1000);
 *
 * var div = document.createElement('div');
 * div.style.background = 'blue';
 * div.style.width = '100px';
 * div.style.height = '100px';
 * document.body.appendChild(div);
 *
 * div.addEventListener('click', function() {
 *     t.isPaused() ? t.resume() : t.pause();
 * });
 *
 * requestAnimationFrame(function loop() {
 *     div.style.transform = 'translateX(' + t.get()[0] + 'px)' + ' translateY(' + t.get()[1] + 'px)';
 *     requestAnimationFrame(loop);
 * });
 *
 * @class Transitionable
 * @constructor
 * @param {Number|Array.Number} initialState    initial state to transition
 *                                              from - equivalent to a pursuant
 *                                              invocation of
 *                                              {@link Transitionable#from}
 */
function Transitionable(initialState) {
    this._queue = [];
    this._from = null;
    this._state = null;
    this._startedAt = null;
    this._pausedAt = null;
    if (initialState != null) this.from(initialState);
}

/**
 * Internal Clock used for determining the current time for the ongoing
 * transitions.
 *
 * @type {Performance|Date|Clock}
 */
Transitionable.Clock = FamousEngine.getClock();

/**
 * Registers a transition to be pushed onto the internal queue.
 *
 * @method to
 * @chainable
 *
 * @param  {Number|Array.Number}    finalState              final state to
 *                                                          transiton to
 * @param  {String|Function}        [curve=Curves.linear]   easing function
 *                                                          used for
 *                                                          interpolating
 *                                                          [0, 1]
 * @param  {Number}                 [duration=100]          duration of
 *                                                          transition
 * @param  {Function}               [callback]              callback function
 *                                                          to be called after
 *                                                          the transition is
 *                                                          complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.to = function to(finalState, curve, duration, callback, method) {
    curve = curve != null && curve.constructor === String ? Curves[curve] : curve;
    if (this._queue.length === 0) {
        this._startedAt = this.constructor.Clock.now();
        this._pausedAt = null;
    }
    this._queue.push(
        finalState,
        curve != null ? curve : Curves.linear,
        duration != null ? duration : 100,
        callback,
        method
    );
    return this;
};

/**
 * Resets the transition queue to a stable initial state.
 *
 * @method from
 * @chainable
 *
 * @param  {Number|Array.Number}    initialState    initial state to
 *                                                  transition from
 * @return {Transitionable}         this
 */
Transitionable.prototype.from = function from(initialState) {
    this._state = initialState;
    this._from = this._sync(null, this._state);
    this._queue.length = 0;
    this._startedAt = this.constructor.Clock.now();
    this._pausedAt = null;
    return this;
};

/**
 * Delays the execution of the subsequent transition for a certain period of
 * time.
 *
 * @method delay
 * @chainable
 *
 * @param {Number}      duration    delay time in ms
 * @param {Function}    [callback]  Zero-argument function to call on observed
 *                                  completion (t=1)
 * @return {Transitionable}         this
 */
Transitionable.prototype.delay = function delay(duration, callback) {
    var endState = this._queue.length > 0 ? this._queue[this._queue.length - 5] : this._state;
    return this.to(endState, Curves.flat, duration, callback);
};

/**
 * Overrides current transition.
 *
 * @method override
 * @chainable
 *
 * @param  {Number|Array.Number}    [finalState]    final state to transiton to
 * @param  {String|Function}        [curve]         easing function used for
 *                                                  interpolating [0, 1]
 * @param  {Number}                 [duration]      duration of transition
 * @param  {Function}               [callback]      callback function to be
 *                                                  called after the transition
 *                                                  is complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.override = function override(finalState, curve, duration, callback, method) {
    if (this._queue.length > 0) {
        if (finalState != null) this._queue[0] = finalState;
        if (curve != null)      this._queue[1] = curve.constructor === String ? Curves[curve] : curve;
        if (duration != null)   this._queue[2] = duration;
        if (callback != null)   this._queue[3] = callback;
        if (method != null)     this._queue[4] = method;
    }
    return this;
};

Transitionable.prototype._interpolate = function _interpolate(output, from, to, progress, method) {
    if (to instanceof Object) {
        if (method === 'slerp') {
            var x, y, z, w;
            var qx, qy, qz, qw;
            var omega, cosomega, sinomega, scaleFrom, scaleTo;

            x = from[0];
            y = from[1];
            z = from[2];
            w = from[3];

            qx = to[0];
            qy = to[1];
            qz = to[2];
            qw = to[3];

            cosomega = w * qw + x * qx + y * qy + z * qz;
            if ((1.0 - cosomega) > 1e-5) {
                omega = Math.acos(cosomega);
                sinomega = Math.sin(omega);
                scaleFrom = Math.sin((1.0 - progress) * omega) / sinomega;
                scaleTo = Math.sin(progress * omega) / sinomega;
            }
            else {
                scaleFrom = 1.0 - progress;
                scaleTo = progress;
            }

            output[0] = x * scaleFrom + qx * scaleTo;
            output[1] = y * scaleFrom + qy * scaleTo;
            output[2] = z * scaleFrom + qz * scaleTo;
            output[3] = w * scaleFrom + qw * scaleTo;
        }
        else if (to instanceof Array) {
            for (var i = 0, len = to.length; i < len; i++) {
                output[i] = this._interpolate(output[i], from[i], to[i], progress, method);
            }
        }
        else {
            for (var key in to) {
                output[key] = this._interpolate(output[key], from[key], to[key], progress, method);
            }
        }
    } else {
        output = from + progress * (to - from);
    }
    return output;
};

Transitionable.prototype._sync = function _sync(output, input) {
    if (typeof input === 'number') output = input;
    else if (input instanceof Array) {
        if (output == null) output = [];
        for (var i = 0, len = input.length; i < len; i++) {
            output[i] = _sync(output[i], input[i]);
        }
    }
    else if (input instanceof Object) {
        if (output == null) output = {};
        for (var key in input) {
            output[key] = _sync(output[key], input[key]);
        }
    }
    return output;
};

/**
 * Get interpolated state of current action at provided time. If the last
 *    action has completed, invoke its callback.
 *
 * @method get
 *
 * @param {Number=} timestamp Evaluate the curve at a normalized version of this
 *    time. If omitted, use current time. (Unix epoch time)
 * @return {Number|Array.Number} beginning state
 *    interpolated to this point in time.
 */
Transitionable.prototype.get = function get(t) {
    if (this._queue.length === 0) return this._state;

    t = this._pausedAt ? this._pausedAt : t;
    t = t ? t : this.constructor.Clock.now();

    var progress = (t - this._startedAt) / this._queue[2];
    this._state = this._interpolate(this._state, this._from, this._queue[0], this._queue[1](progress > 1 ? 1 : progress), this._queue[4]);
    var state = this._state;
    if (progress >= 1) {
        this._startedAt = this._startedAt + this._queue[2];
        this._from = this._sync(this._from, this._state);
        this._queue.shift();
        this._queue.shift();
        this._queue.shift();
        var callback = this._queue.shift();
        this._queue.shift();
        if (callback) callback();
    }
    return progress > 1 ? this.get() : state;
};

/**
 * Is there at least one transition pending completion?
 *
 * @method isActive
 *
 * @return {boolean}
 */
Transitionable.prototype.isActive = function isActive() {
    return this._queue.length > 0;
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.halt = function halt() {
    return this.from(this.get());
};

/**
 * Pause transition. This will not erase any actions.
 *
 * @method pause
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.pause = function pause() {
    this._pausedAt = this.constructor.Clock.now();
    return this;
};

/**
 * Has the current action been paused?
 *
 * @method isPaused
 * @chainable
 *
 * @return {Boolean} if the current action has been paused
 */
Transitionable.prototype.isPaused = function isPaused() {
    return !!this._pausedAt;
};

/**
 * Resume transition.
 *
 * @method resume
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.resume = function resume() {
    var diff = this._pausedAt - this._startedAt;
    this._startedAt = this.constructor.Clock.now() - diff;
    this._pausedAt = null;
    return this;
};

/**
 * Cancel all transitions and reset to a stable state
 *
 * @method reset
 * @chainable
 * @deprecated Use `.from` instead!
 *
 * @param {Number|Array.Number|Object.<number, number>} startState
 *    stable state to set to
 */
Transitionable.prototype.reset = function(start) {
    return this.from(start);
};

/**
 * Add transition to end state to the queue of pending transitions. Special
 *    Use: calling without a transition resets the object to that state with
 *    no pending actions
 *
 * @method set
 * @chainable
 * @deprecated Use `.to` instead!
 *
 * @param {Number|FamousEngineMatrix|Array.Number|Object.<number, number>} endState
 *    end state to which we interpolate
 * @param {transition=} transition object of type {duration: number, curve:
 *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be
 *    instantaneous.
 * @param {function()=} callback Zero-argument function to call on observed
 *    completion (t=1)
 */
Transitionable.prototype.set = function(state, transition, callback) {
    if (transition == null) {
        this.from(state);
        if (callback) callback();
    } else {
        this.to(state, transition.curve, transition.duration, callback, transition.method);
    }
    return this;
};

module.exports = Transitionable;

},{"../core/FamousEngine":18,"./Curves":87}],89:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Curves: require('./Curves'),
    Transitionable: require('./Transitionable')
};

},{"./Curves":87,"./Transitionable":88}],90:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * A lightweight, featureless EventEmitter.
 * 
 * @class CallbackStore
 * @constructor
 */
function CallbackStore () {
    this._events = {};
}

/**
 * Adds a listener for the specified event (= key).
 *
 * @method on
 * @chainable
 * 
 * @param  {String}   key
 * @param  {Function} callback
 * @return {Function} A function to call if you want to remove the callback
 */
CallbackStore.prototype.on = function on (key, callback) {
    if (!this._events[key]) this._events[key] = [];
    var callbackList = this._events[key];
    callbackList.push(callback);
    return function () {
        callbackList.splice(callbackList.indexOf(callback), 1);
    };
};

/**
 * Removes a previously added event listener.
 *
 * @method off
 * @chainable
 * 
 * @param  {String}          key
 * @param  {Function}        callback
 * @return {CallbackStore}   this
 */
CallbackStore.prototype.off = function off (key, callback) {
    var events = this._events[key];
    if (events) events.splice(events.indexOf(callback), 1);
    return this;
};

/**
 * Invokes all the previously for this key registered callbacks.
 *
 * @method trigger
 * @chainable
 * 
 * @param  {String}        key
 * @param  {Object}        payload
 * @return {CallbackStore} this
 */
CallbackStore.prototype.trigger = function trigger (key, payload) {
    var events = this._events[key];
    if (events) {
        var i = 0;
        var len = events.length;
        for (; i < len ; i++) events[i](payload);
    }
    return this;
};

module.exports = CallbackStore;

},{}],91:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');

/**
 * @class Color
 * @constructor
 * @component
 * @param {Color|String|Array} Optional argument for setting color using
 * Hex, a Color instance, color name or RGB
 * @param {Object} Optional transition
 * @param {Function} Callback
 */
function Color(color, transition, cb) {
    this._r = new Transitionable(0);
    this._g = new Transitionable(0);
    this._b = new Transitionable(0);
    if (color) this.set(color, transition, cb);
}

/**
* Returns the definition of the Class: 'Color'
* @method toString
* @return {String} definition
*/
Color.prototype.toString = function toString() {
    return 'Color';
};

/**
* Sets the color. It accepts an optional transition parameter and callback.
* set(Color, transition, callback)
* set('#000000', transition, callback)
* set('black', transition, callback)
* set([r, g, b], transition, callback)
* @method set
 * @param {Color|String|Array} Optional argument for setting color using
 * Hex, a Color instance, color name or RGB
 * @param {Object} Optional transition
 * @param {Function} Callback
* @chainable
*/
Color.prototype.set = function set(color, transition, cb) {
    switch (Color.determineType(color)) {
        case 'hex': return this.setHex(color, transition, cb);
        case 'colorName': return this.setColor(color, transition, cb);
        case 'instance': return this.changeTo(color, transition, cb);
        case 'rgb': return this.setRGB(color[0], color[1], color[2], transition, cb);
    }
};

/**
 * Returns whether Color is still in an animating (transitioning) state.
 *
 * @method isActive
 * @returns {Boolean} boolean
 */
Color.prototype.isActive = function isActive() {
    return this._r.isActive() || this._g.isActive() || this._b.isActive();
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Color} this
 */
Color.prototype.halt = function halt() {
    this._r.halt();
    this._g.halt();
    this._b.halt();
    return this;
};

/**
 * Sets the color values from another Color instance.
 *
 * @method changeTo
 * @param {Color} Color instance
 * @param {Object} transition Optional transition
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.changeTo = function changeTo(color, transition, cb) {
    if (Color.isColorInstance(color)) {
        var rgb = color.getRGB();
        this.setRGB(rgb[0], rgb[1], rgb[2], transition, cb);
    }
    return this;
};

/**
 * Sets the color based on static color names.
 *
 * @method setColor
 * @param {String} Color name
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setColor = function setColor(name, transition, cb) {
    if (colorNames[name]) {
        this.setHex(colorNames[name], transition, cb);
    }
    return this;
};

/**
 * Returns the color in either RGB or with the requested format.
 *
 * @method getColor
 * @param {String} Optional argument for determining which type of color to get (default is RGB)
 * @returns Color in either RGB or specific option value
 */
Color.prototype.getColor = function getColor(option) {
    if (Color.isString(option)) option = option.toLowerCase();
    return (option === 'hex') ? this.getHex() : this.getRGB();
};

/**
 * Sets the R of the Color's RGB
 *
 * @method setR
 * @param {Integer} R channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setR = function setR(r, transition, cb) {
    this._r.set(r, transition, cb);
    return this;
};

/**
 * Sets the G of the Color's RGB
 *
 * @method setG
 * @param {Integer} G channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setG = function setG(g, transition, cb) {
    this._g.set(g, transition, cb);
    return this;
};

/**
 * Sets the B of the Color's RGB
 *
 * @method setB
 * @param {Integer} B channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setB = function setB(b, transition, cb) {
    this._b.set(b, transition, cb);
    return this;
};

/**
 * Sets RGB
 *
 * @method setRGB
 * @param {Integer} R channel of color
 * @param {Integer} G channel of color
 * @param {Integer} B channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setRGB = function setRGB(r, g, b, transition, cb) {
    this.setR(r, transition);
    this.setG(g, transition);
    this.setB(b, transition, cb);
    return this;
};

/**
 * Returns R of RGB
 *
 * @method getR
 * @returns R of Color
 */
Color.prototype.getR = function getR() {
    return this._r.get();
};

/**
 * Returns G of RGB
 *
 * @method getG
 * @returns G of Color
 */
Color.prototype.getG = function getG() {
    return this._g.get();
};

/**
 * Returns B of RGB
 *
 * @method getB
 * @returns B of Color
 */
Color.prototype.getB = function getB() {
    return this._b.get();
};

/**
 * Returns RGB
 *
 * @method getRGB
 * @returns RGB
 */
Color.prototype.getRGB = function getRGB() {
    return [this.getR(), this.getG(), this.getB()];
};

/**
 * Returns Normalized RGB
 *
 * @method getNormalizedRGB
 * @returns Normalized RGB
 */
Color.prototype.getNormalizedRGB = function getNormalizedRGB() {
    var r = this.getR() / 255.0;
    var g = this.getG() / 255.0;
    var b = this.getB() / 255.0;
    return [r, g, b];
};

/**
 * Returns the current color in Hex
 *
 * @method getHex
 * @returns Hex value
 */
Color.prototype.getHex = function getHex() {
    var r = Color.toHex(this.getR());
    var g = Color.toHex(this.getG());
    var b = Color.toHex(this.getB());
    return '#' + r + g + b;
};

/**
 * Sets color using Hex
 *
 * @method setHex
 * @param {String} Hex value
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setHex = function setHex(hex, transition, cb) {
    hex = (hex.charAt(0) === '#') ? hex.substring(1, hex.length) : hex;

    if (hex.length === 3) {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
    }

    var r = parseInt(hex.substring(0, 2), 16);
    var g = parseInt(hex.substring(2, 4), 16);
    var b = parseInt(hex.substring(4, 6), 16);
    this.setRGB(r, g, b, transition, cb);
    return this;
};

/**
 * Converts a number to a hex value
 *
 * @method toHex
 * @param {Integer} Number
 * @returns Hex value
 */
Color.toHex = function toHex(num) {
    var hex = num.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
};

/**
 * Determines the given input with the appropriate configuration
 *
 * @method determineType
 * @param {Color|String|Array} Color type
 * @returns {String} Appropriate color type
 */
Color.determineType = function determineType(type) {
    if (Color.isColorInstance(type)) return 'instance';
    if (colorNames[type]) return 'colorName';
    if (Color.isHex(type)) return 'hex';
    if (Array.isArray(type)) return 'rgb';
};

/**
 * Returns a boolean checking whether input is a 'String'
 *
 * @method isString
 * @param Primitive
 * @returns {Boolean} Boolean
 */
Color.isString = function isString(val) {
    return (typeof val === 'string');
};

/**
 * Returns a boolean checking whether string input has a hash (#) symbol
 *
 * @method isHex
 * @param String
 * @returns {Boolean} Boolean
 */
Color.isHex = function isHex(val) {
    if (!Color.isString(val)) return false;
    return val[0] === '#';
};

/**
 * Returns boolean whether the input is a Color instance
 *
 * @method isColorInstance
 * @param Color instance
 * @returns {Boolean} Boolean
 */
Color.isColorInstance = function isColorInstance(val) {
    return !!val.getColor;
};

/**
 * Common color names with their associated Hex values
 */
var colorNames = { aliceblue: '#f0f8ff', antiquewhite: '#faebd7', aqua: '#00ffff', aquamarine: '#7fffd4', azure: '#f0ffff', beige: '#f5f5dc', bisque: '#ffe4c4', black: '#000000', blanchedalmond: '#ffebcd', blue: '#0000ff', blueviolet: '#8a2be2', brown: '#a52a2a', burlywood: '#deb887', cadetblue: '#5f9ea0', chartreuse: '#7fff00', chocolate: '#d2691e', coral: '#ff7f50', cornflowerblue: '#6495ed', cornsilk: '#fff8dc', crimson: '#dc143c', cyan: '#00ffff', darkblue: '#00008b', darkcyan: '#008b8b', darkgoldenrod: '#b8860b', darkgray: '#a9a9a9', darkgreen: '#006400', darkgrey: '#a9a9a9', darkkhaki: '#bdb76b', darkmagenta: '#8b008b', darkolivegreen: '#556b2f', darkorange: '#ff8c00', darkorchid: '#9932cc', darkred: '#8b0000', darksalmon: '#e9967a', darkseagreen: '#8fbc8f', darkslateblue: '#483d8b', darkslategray: '#2f4f4f', darkslategrey: '#2f4f4f', darkturquoise: '#00ced1', darkviolet: '#9400d3', deeppink: '#ff1493', deepskyblue: '#00bfff', dimgray: '#696969', dimgrey: '#696969', dodgerblue: '#1e90ff', firebrick: '#b22222', floralwhite: '#fffaf0', forestgreen: '#228b22', fuchsia: '#ff00ff', gainsboro: '#dcdcdc', ghostwhite: '#f8f8ff', gold: '#ffd700', goldenrod: '#daa520', gray: '#808080', green: '#008000', greenyellow: '#adff2f', grey: '#808080', honeydew: '#f0fff0', hotpink: '#ff69b4', indianred: '#cd5c5c', indigo: '#4b0082', ivory: '#fffff0', khaki: '#f0e68c', lavender: '#e6e6fa', lavenderblush: '#fff0f5', lawngreen: '#7cfc00', lemonchiffon: '#fffacd', lightblue: '#add8e6', lightcoral: '#f08080', lightcyan: '#e0ffff', lightgoldenrodyellow: '#fafad2', lightgray: '#d3d3d3', lightgreen: '#90ee90', lightgrey: '#d3d3d3', lightpink: '#ffb6c1', lightsalmon: '#ffa07a', lightseagreen: '#20b2aa', lightskyblue: '#87cefa', lightslategray: '#778899', lightslategrey: '#778899', lightsteelblue: '#b0c4de', lightyellow: '#ffffe0', lime: '#00ff00', limegreen: '#32cd32', linen: '#faf0e6', magenta: '#ff00ff', maroon: '#800000', mediumaquamarine: '#66cdaa', mediumblue: '#0000cd', mediumorchid: '#ba55d3', mediumpurple: '#9370db', mediumseagreen: '#3cb371', mediumslateblue: '#7b68ee', mediumspringgreen: '#00fa9a', mediumturquoise: '#48d1cc', mediumvioletred: '#c71585', midnightblue: '#191970', mintcream: '#f5fffa', mistyrose: '#ffe4e1', moccasin: '#ffe4b5', navajowhite: '#ffdead', navy: '#000080', oldlace: '#fdf5e6', olive: '#808000', olivedrab: '#6b8e23', orange: '#ffa500', orangered: '#ff4500', orchid: '#da70d6', palegoldenrod: '#eee8aa', palegreen: '#98fb98', paleturquoise: '#afeeee', palevioletred: '#db7093', papayawhip: '#ffefd5', peachpuff: '#ffdab9', peru: '#cd853f', pink: '#ffc0cb', plum: '#dda0dd', powderblue: '#b0e0e6', purple: '#800080', rebeccapurple: '#663399', red: '#ff0000', rosybrown: '#bc8f8f', royalblue: '#4169e1', saddlebrown: '#8b4513', salmon: '#fa8072', sandybrown: '#f4a460', seagreen: '#2e8b57', seashell: '#fff5ee', sienna: '#a0522d', silver: '#c0c0c0', skyblue: '#87ceeb', slateblue: '#6a5acd', slategray: '#708090', slategrey: '#708090', snow: '#fffafa', springgreen: '#00ff7f', steelblue: '#4682b4', tan: '#d2b48c', teal: '#008080', thistle: '#d8bfd8', tomato: '#ff6347', turquoise: '#40e0d0', violet: '#ee82ee', wheat: '#f5deb3', white: '#ffffff', whitesmoke: '#f5f5f5', yellow: '#ffff00', yellowgreen: '#9acd32' };

module.exports = Color;

},{"../transitions/Transitionable":88}],92:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 
'use strict';

/**
 * Collection to map keyboard codes in plain english
 *
 * @class KeyCodes
 * @static
 */
module.exports = {
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 97,
    b: 98,
    c: 99,
    d: 100,
    e: 101,
    f: 102,
    g: 103,
    h: 104,
    i: 105,
    j: 106,
    k: 107,
    l: 108,
    m: 109,
    n: 110,
    o: 111,
    p: 112,
    q: 113,
    r: 114,
    s: 115,
    t: 116,
    u: 117,
    v: 118,
    w: 119,
    x: 120,
    y: 121,
    z: 122,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    ENTER : 13,
    LEFT_ARROW: 37,
    RIGHT_ARROW: 39,
    UP_ARROW: 38,
    DOWN_ARROW: 40,
    SPACE: 32,
    SHIFT: 16,
    TAB: 9
};


},{}],93:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Singleton object to manage recycling of objects with typically short lifespans, used to cut down on the
 * amount of garbage collection required.
 *
 * @singleton
 */
var ObjectManager = {};

ObjectManager.pools = {};

/**
 * Register request and free functions for the given type.
 *
 * @method register
 * @param {String} type
 * @param {Function} Constructor
 */
ObjectManager.register = function(type, Constructor) {
    var pool = this.pools[type] = [];

    this['request' + type] = _request(pool, Constructor);
    this['free' + type] = _free(pool);
};

function _request(pool, Constructor) {
    return function request() {
        if (pool.length !== 0) return pool.pop();
        else return new Constructor();
    };
}

function _free(pool) {
    return function free(obj) {
        pool.push(obj);
    };
}

/**
 * Untrack all object of the given type. Used to allow allocated objects to be garbage collected.
 *
 * @method disposeOf
 * @param {String}
 */
ObjectManager.disposeOf= function(type) {
    var pool = this.pools[type];
    var i = pool.length;
    while (i--) pool.pop();
};

module.exports = ObjectManager;

},{}],94:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Returns a number guaranteed to be within the range [lower, upper].
 *
 * @method clamp
 * 
 * @param  {Number} value value to be processed by clamp
 * @param  {Number} lower lower bound  of the range
 * @param  {Number} upper upper bound of the range
 * @return {Number}       value between [lower, upper]
 */
function clamp(value, lower, upper) {
    return value < lower ? lower : value > upper ? upper : value;
}

module.exports = clamp;


},{}],95:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 *  Deep clone an object.
 *  @memberof Utilities
 *  @param b {Object} Object to clone
 *  @return a {Object} Cloned object.
 */
var clone = function clone(b) {
    var a;
    if (typeof b === 'object') {
        a = (b instanceof Array) ? [] : {};
        for (var key in b) {
            if (typeof b[key] === 'object' && b[key] !== null) {
                if (b[key] instanceof Array) {
                    a[key] = new Array(b[key].length);
                    for (var i = 0; i < b[key].length; i++) {
                        a[key][i] = clone(b[key][i]);
                    }
                }
                else {
                  a[key] = clone(b[key]);
                }
            }
            else {
                a[key] = b[key];
            }
        }
    }
    else {
        a = b;
    }
    return a;
};

module.exports = clone;

},{}],96:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    CallbackStore: require('./CallbackStore'),
    clamp: require('./clamp'),
    clone: require('./clone'),
    Color: require('./Color'),
    KeyCodes: require('./KeyCodes'),
    keyValueToArrays: require('./keyValueToArrays'),
    loadURL: require('./loadURL'),
    ObjectManager: require('./ObjectManager'),
    strip: require('./strip'),
    vendorPrefix: require('./vendorPrefix')
};


},{"./CallbackStore":90,"./Color":91,"./KeyCodes":92,"./ObjectManager":93,"./clamp":94,"./clone":95,"./keyValueToArrays":97,"./loadURL":98,"./strip":99,"./vendorPrefix":100}],97:[function(require,module,exports){
'use strict';

/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Takes an object containing keys and values and returns an object
 * comprising two "associate" arrays, one with the keys and the other
 * with the values.
 *
 * @method keyValuesToArrays
 *
 * @param {Object} Object
 * @returns {Object} Object Object containing two arrays, one with the keys and the other for values
 */
module.exports = function keyValuesToArrays(obj) {
    var keysArray = [], valuesArray = [];
    var i = 0;
    for(var key in obj) {
        if (obj.hasOwnProperty(key)) {
            keysArray[i] = key;
            valuesArray[i] = obj[key];
            i++;
        }
    }
    return {
        keys: keysArray,
        values: valuesArray
    };
};

},{}],98:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Load a URL and return its contents in a callback
 *
 * @method loadURL
 * @memberof Utilities
 * @param {string} url URL of object
 * @param {function} callback callback to dispatch with content
 */
var loadURL = function loadURL(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function onreadystatechange() {
        if (this.readyState === 4) {
            if (callback) callback(this.responseText);
        }
    };
    xhr.open('GET', url);
    xhr.send();
};

module.exports = loadURL;

},{}],99:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Removes all values not being of a primitive type from an arbitrary object
 * literal.
 *
 * @method strip
 * @memberof Utilities
 * @param  {any}        primitive or (non-)serializable object without
 *                      circular references
 * @return {any}        primitive or (nested) object only containing primitive
 *                      types (serializable)
 */
function strip(obj) {
    switch (obj) {
        case null:
        case undefined:
            return obj;
    }
    switch (obj.constructor) {
        case Boolean:
        case Number:
        case String:
        case Symbol:
            return obj;
        case Object:
            for (var key in obj) {
                var stripped = strip(obj[key], true);
                obj[key] = stripped;
            }
            return obj;
        default:
            return null;
    }
}

module.exports = strip;

},{}],100:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PREFIXES = ['', '-ms-', '-webkit-', '-moz-', '-o-'];

/**
 * A helper function for determining if a CSS property
 * has a vendor prefix.
 *
 * @method vendorPrefix
 * @private
 * 
 * @param {String} property
 */
function vendorPrefix(property) {
    for (var i = 0; i < PREFIXES.length; i++) {
        var prefixed = PREFIXES[i] + property;
        if (document.documentElement.style[prefixed] === '') {
            return prefixed;
        }
    }
    return property;
}

module.exports = vendorPrefix;

},{}],101:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('./Geometry');

/**
 * DynamicGeometry is a component that defines the data that should
 *   be drawn to the webGL canvas. Manages vertex data and attributes.
 *
 * @class DynamicGeometry
 * @constructor
 * 
 * @param {Object} options instantiation options
 */
function DynamicGeometry(options) {
    Geometry.call(this, options);

    this.spec.dynamic = true;
}

/**
 * Returns the number of attribute values used to draw the DynamicGeometry.
 *
 * @class DynamicGeometry
 * @constructor
 * 
 * @return {Object} flattened length of the vertex positions attribute
 * in the geometry.
 */
DynamicGeometry.prototype.getLength = function getLength() {
    return this.getVertexPositions().length;
};

/**
 * Gets the buffer object based on buffer name. Throws error
 * if bufferName is not provided.
 *
 * @method getVertexBuffer
 *
 * @param {String} bufferName Name of vertexBuffer to be retrieved.
 * @return {Object} value of buffer with corresponding bufferName.
 */
DynamicGeometry.prototype.getVertexBuffer = function getVertexBuffer(bufferName) {
    if (! bufferName) throw 'getVertexBuffer requires a name';

    var idx = this.spec.bufferNames.indexOf(bufferName);
    if (idx === -1) throw 'buffer does not exist';
    else {
        return this.spec.bufferValues[idx];
    }
};

/**
 * Sets a vertex buffer with given name to input value. Registers a new 
 * buffer if one does not exist with given name.
 * 
 * @method setVertexBuffer
 * @param {String} bufferName Name of vertexBuffer to be set.
 * @param {Array} value Input data to fill target buffer.
 * @param {Number} size Vector size of input buffer data.
 * @return {Object} current geometry.
 */
DynamicGeometry.prototype.setVertexBuffer = function setVertexBuffer(bufferName, value, size) {
    var idx = this.spec.bufferNames.indexOf(bufferName);

    if (idx === -1) {
        idx = this.spec.bufferNames.push(bufferName) - 1;
    }

    this.spec.bufferValues[idx] = value || [];
    this.spec.bufferSpacings[idx] = size || this.DEFAULT_BUFFER_SIZE;

    if (this.spec.invalidations.indexOf(idx) === -1) {
        this.spec.invalidations.push(idx);
    }

    return this;
};

/**
 * Copies and sets all buffers from another geometry instance.
 *
 * @method fromGeometry
 *
 * @param {Object} geometry Geometry instance to copy buffers from.
 * @return {Object} current geometry.
 */
DynamicGeometry.prototype.fromGeometry = function fromGeometry(geometry) {
    var len = geometry.spec.bufferNames.length;
    for (var i = 0; i < len; i++) {
        this.setVertexBuffer(
            geometry.spec.bufferNames[i],
            geometry.spec.bufferValues[i],
            geometry.spec.bufferSpacings[i]
        );
    }
    return this;
};

/**
 *  Set the positions of the vertices in this geometry.
 * 
 *  @method setVertexPositions
 *  @param {Array} value New value for vertex position buffer
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setVertexPositions = function (value) {
    return this.setVertexBuffer('a_pos', value, 3);
};

/**
 *  Set the normals on this geometry.
 * 
 *  @method setNormals
 *  @param {Array} value Value to set normal buffer to.
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setNormals = function (value) {
    return this.setVertexBuffer('a_normals', value, 3);
};

/**
 *  Set the texture coordinates on this geometry.
 * 
 *  @method setTextureCoords
 *  @param {Array} value New value for texture coordinates buffer.
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setTextureCoords = function (value) {
    return this.setVertexBuffer('a_texCoord', value, 2);
};

/**
 *  Set the texture coordinates on this geometry.
 *  @method setTextureCoords
 *  @param {Array} value New value for index buffer
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setIndices = function (value) {
    return this.setVertexBuffer('indices', value, 1);
};

/**
 *  Set the WebGL drawing primitive for this geometry.
 *  @method setDrawType
 *  @param {String} type New drawing primitive for geometry
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setDrawType = function (value) {
    this.spec.type = value.toUpperCase();
    return this;
};

/**
 * Returns the 'pos' vertex buffer of the geometry.
 * @method getVertexPositions
 * @return {Array} Vertex buffer.
 */
DynamicGeometry.prototype.getVertexPositions = function () {
    return this.getVertexBuffer('a_pos');
};

/**
 * Returns the 'normal' vertex buffer of the geometry.
 * @method getNormals
 * @return {Array} Vertex Buffer.
 */
DynamicGeometry.prototype.getNormals = function () {
    return this.getVertexBuffer('a_normals');
};

/**
 * Returns the 'textureCoord' vertex buffer of the geometry.
 * @method getTextureCoords
 * @return {Array} Vertex Buffer.
 */
DynamicGeometry.prototype.getTextureCoords = function () {
    return this.getVertexBuffer('a_texCoord');
};

module.exports = DynamicGeometry;

},{"./Geometry":102}],102:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var GeometryIds = 0;

/**
 * Geometry is a component that defines the data that should
 * be drawn to the webGL canvas. Manages vertex data and attributes.
 *
 * @class Geometry
 * @constructor
 * 
 * @param {Object} options Instantiation options.
 */
function Geometry(options) {
    this.options = options || {};
    this.DEFAULT_BUFFER_SIZE = 3;

    this.spec = {
        id: GeometryIds++,
        dynamic: false,
        type: this.options.type || 'TRIANGLES',
        bufferNames: [],
        bufferValues: [],
        bufferSpacings: [],
        invalidations: []
    };

    if (this.options.buffers) {
        var len = this.options.buffers.length;
        for (var i = 0; i < len;) {
            this.spec.bufferNames.push(this.options.buffers[i].name);
            this.spec.bufferValues.push(this.options.buffers[i].data);
            this.spec.bufferSpacings.push(this.options.buffers[i].size || this.DEFAULT_BUFFER_SIZE);
            this.spec.invalidations.push(i++);
        }
    }
}

module.exports = Geometry;

},{}],103:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Vec3 = require('../math/Vec3');
var Vec2 = require('../math/Vec2');

var outputs = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec2(),
    new Vec2()
];

/**
 * A helper object used to calculate buffers for complicated geometries.
 * Tailored for the WebGLRenderer, used by most primitives.
 *
 * @static
 * @class GeometryHelper
 */
var GeometryHelper = {};

/**
 * A function that iterates through vertical and horizontal slices
 * based on input detail, and generates vertices and indices for each
 * subdivision.
 *
 * @static
 * @method generateParametric
 *
 * @param {Number} detailX Amount of slices to iterate through.
 * @param {Number} detailY Amount of stacks to iterate through.
 * @param {Function} func Function used to generate vertex positions at each point.
 * 
 * @return {Object} Object containing generated vertices and indices.
 */
GeometryHelper.generateParametric = function generateParametric(detailX, detailY, func, wrap) {
    var vertices = [],
        i, theta, phi, result, j;

    // We can wrap around slightly more than once for uv coordinates to look correct.

    var Xrange = wrap ? Math.PI + (Math.PI / (detailX - 1)) : Math.PI;
    var out = [];

    for (i = 0; i < detailX + 1; i++) {
        theta = i * Xrange / detailX;
        for (j = 0; j < detailY; j++) {
            phi = j * 2.0 * Xrange / detailY;
            func(theta, phi, out);
            vertices.push(out[0], out[1], out[2]);
        }
    }

    var indices = [],
        v = 0,
        next;
    for (i = 0; i < detailX; i++) {
        for (j = 0; j < detailY; j++) {
            next = (j + 1) % detailY;
            indices.push(v + j, v + j + detailY, v + next);
            indices.push(v + next, v + j + detailY, v + next + detailY);
        }
        v += detailY;
    }

    return {
        vertices: vertices,
        indices: indices
    };
}

/**
 * Calculates normals belonging to each face of a geometry.  
 * Assumes clockwise declaration of vertices.
 *
 * @static
 * @method computeNormals
 *
 * @param {Array} vertices Vertices of all points on the geometry.
 * @param {Array} indices Indices declaring faces of geometry.
 * @param {Array} out Array to be filled and returned.
 * 
 * @return {Array} Calculated face normals.
 */
GeometryHelper.computeNormals = function computeNormals(vertices, indices, out) {
    var normals = out || [];
    var vertexThree;
    var vertexTwo;
    var vertexOne;
    var indexOne;
    var indexTwo;
    var indexThree;
    var start;
    var end;
    var normal;
    var j;
    var len = indices.length / 3;

    for (var i = 0; i < len; i++) {
        j = i * 3;
        indexTwo = indices[j + 0] * 3;
        indexOne = indices[j + 1] * 3;
        indexThree = indices[j + 2] * 3;

        outputs[0].set(vertices[indexOne], vertices[indexOne + 1], vertices[indexOne + 2]);
        outputs[1].set(vertices[indexTwo], vertices[indexTwo + 1], vertices[indexTwo + 2]);
        outputs[2].set(vertices[indexThree], vertices[indexThree + 1], vertices[indexThree + 2]);

        normal = outputs[2].subtract(outputs[0]).cross(outputs[1].subtract(outputs[0]));
        normal = normal.normalize().toArray();

        normals[indexOne + 0] = normal[0];
        normals[indexOne + 1] = normal[1];
        normals[indexOne + 2] = normal[2];

        normals[indexTwo + 0] = normal[0];
        normals[indexTwo + 1] = normal[1];
        normals[indexTwo + 2] = normal[2];

        normals[indexThree + 0] = normal[0];
        normals[indexThree + 1] = normal[1];
        normals[indexThree + 2] = normal[2];
    }

    return normals;
};

/**
 * Divides all inserted triangles into four sub-triangles. Alters the
 * passed in arrays.
 *
 * @static
 * @method subdivide
 *
 * @param {Array} indices Indices declaring faces of geometry
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} texutureCoords Texture coordinates of all points on the geometry
 * 
 */
GeometryHelper.subdivide = function subdivide(indices, vertices, textureCoords) {
    var triangleIndex = indices.length / 3,
        abc,
        face,
        i, j, k, pos, tex;

    while (triangleIndex--) {
        face = indices.slice(triangleIndex * 3, triangleIndex * 3 + 3);

        pos = face.map(function(vertIndex) {
            return new Vec3(vertices[vertIndex * 3], vertices[vertIndex * 3 + 1], vertices[vertIndex * 3 + 2]);
        });
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[0], pos[1], outputs[0]), 0.5, outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[1], pos[2], outputs[0]), 0.5, outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[0], pos[2], outputs[0]), 0.5, outputs[1]).toArray());

        if (textureCoords) {
            tex = face.map(function(vertIndex) {
                return new Vec2(textureCoords[vertIndex * 2], textureCoords[vertIndex * 2 + 1]);
            });
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[0], tex[1], outputs[3]), 0.5, outputs[4]).toArray());
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[1], tex[2], outputs[3]), 0.5, outputs[4]).toArray());
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[0], tex[2], outputs[3]), 0.5, outputs[4]).toArray());
        }

        i = vertices.length - 3, j = i + 1, k = i + 2;
        indices.push(i, j, k);
        indices.push(face[0], i, k);
        indices.push(i, face[1], j);
        indices[triangleIndex] = k;
        indices[triangleIndex + 1] = j;
        indices[triangleIndex + 2] = face[2];
    }
};

/**
 * Creates duplicate of vertices that are shared between faces.
 * Alters the input vertex and index arrays.
 *
 * @static
 * @method getUniqueFaces
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} indices Indices declaring faces of geometry
 * 
 */
GeometryHelper.getUniqueFaces = function getUniqueFaces(vertices, indices) {
    var triangleIndex = indices.length / 3,
        registered = [],
        index;

    while (triangleIndex--) {
        for (var i = 0; i < 3; i++) {

            index = indices[triangleIndex * 3 + i];

            if (registered[index]) {
                vertices.push(vertices[index * 3], vertices[index * 3 + 1], vertices[index * 3 + 2]);
                indices[triangleIndex * 3 + i] = vertices.length / 3 - 1;
            } else {
                registered[index] = true;
            }
        }
    }
};

/**
 * Divides all inserted triangles into four sub-triangles while maintaining
 * a radius of one. Alters the passed in arrays.
 *
 * @static
 * @method subdivide
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} indices Indices declaring faces of geometry
 * 
 */
GeometryHelper.subdivideSpheroid = function subdivideSpheroid(vertices, indices) {
    var triangleIndex = indices.length / 3,
        abc,
        face,
        i, j, k;

    while (triangleIndex--) {
        face = indices.slice(triangleIndex * 3, triangleIndex * 3 + 3);
        abc = face.map(function(vertIndex) {
            return new Vec3(vertices[vertIndex * 3], vertices[vertIndex * 3 + 1], vertices[vertIndex * 3 + 2]);
        });

        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[0], abc[1], outputs[0]), outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[1], abc[2], outputs[0]), outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[0], abc[2], outputs[0]), outputs[1]).toArray());

        i = vertices.length / 3 - 3, j = i + 1, k = i + 2;

        indices.push(i, j, k);
        indices.push(face[0], i, k);
        indices.push(i, face[1], j);
        indices[triangleIndex * 3] = k;
        indices[triangleIndex * 3 + 1] = j;
        indices[triangleIndex * 3 + 2] = face[2];
    }
};

/**
 * Divides all inserted triangles into four sub-triangles while maintaining
 * a radius of one. Alters the passed in arrays.
 *
 * @static
 * @method getSpheroidNormals
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting normals.
 * 
 * @return {Array} new list of calculated normals.
 */
GeometryHelper.getSpheroidNormals = function getSpheroidNormals(vertices, out) {
    var out = out || [];
    var length = vertices.length / 3;
    var normalized;

    for(var i = 0; i < length; i++) {
        normalized = new Vec3(
            vertices[i * 3 + 0],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        ).normalize().toArray();

        out[i * 3 + 0] = normalized[0];
        out[i * 3 + 1] = normalized[1];
        out[i * 3 + 2] = normalized[2];
    }

    return out;
};

/**
 * Calculates texture coordinates for spheroid primitives based on
 * input vertices.
 *
 * @static
 * @method getSpheroidUV
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting texture coordinates.
 * 
 * @return {Array} new list of calculated texture coordinates
 */
GeometryHelper.getSpheroidUV = function getSpheroidUV(vertices, out) {
    var out = out || [];
    var length = vertices.length / 3;
    var vertex;

    var uv = [];

    for(var i = 0; i < length; i++) {
        vertex = outputs[0].set(
            vertices[i * 3],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        )
        .normalize()
        .toArray();

        uv[0] = this.getAzimuth(vertex) * 0.5 / Math.PI + 0.5;
        uv[1] = this.getAltitude(vertex) / Math.PI + 0.5;

        out.push.apply(out, uv);
    }

    return out;
};

/**
 * Iterates through and normalizes a list of vertices.
 *
 * @static
 * @method normalizeAll
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting normalized vectors.
 * 
 * @return {Array} new list of normalized vertices
 */
GeometryHelper.normalizeAll = function normalizeAll(vertices, out) {
    var out = out || [];
    var vertex;
    var len = vertices.length / 3;

    for (var i = 0; i < len; i++) {
        Array.prototype.push.apply(out, new Vec3(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]).normalize().toArray());
    }

    return out;
};

/**
 * Normalizes a set of vertices to model space.
 *
 * @static
 * @method normalizeVertices
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with model space position vectors.
 * 
 * @return {Array} Output vertices.
 */
GeometryHelper.normalizeVertices = function normalizeVertices(vertices, out) {
    var out = out || [];
    var len = vertices.length / 3;
    var vectors = [];
    var minX;
    var maxX;
    var minY;
    var maxY;
    var minZ;
    var maxZ;
    var v;

    for (var i = 0; i < len; i++) {
        v = vectors[i] = new Vec3(
            vertices[i * 3],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        );

        if (minX == null || v.x < minX) minX = v.x;
        if (maxX == null || v.x > maxX) maxX = v.x;

        if (minY == null || v.y < minY) minY = v.y;
        if (maxY == null || v.y > maxY) maxY = v.y;

        if (minZ == null || v.z < minZ) minZ = v.z;
        if (maxZ == null || v.z > maxZ) maxZ = v.z;
    };

    var translation = new Vec3(
        getTranslationFactor(maxX, minX),
        getTranslationFactor(maxY, minY),
        getTranslationFactor(maxZ, minZ)
    );

    var scale = Math.min(
        getScaleFactor(maxX + translation.x, minX + translation.x),
        getScaleFactor(maxY + translation.y, minY + translation.y),
        getScaleFactor(maxZ + translation.z, minZ + translation.z)
    );

    for (var i = 0; i < vectors.length; i++) {
        out.push.apply(out, vectors[i].add(translation).scale(scale).toArray());
    }

    return out;
};

/**
 * Determines translation amount for a given axis to normalize model coordinates.
 *
 * @method getTranslationFactor
 * @private
 *
 * @param {Number} max Maximum position value of given axis on the model.
 * @param {Number} min Minimum position value of given axis on the model.
 *
 * @return {Number} Number by which the given axis should be translated for all vertices.
 */
function getTranslationFactor(max, min) {
    return -(min + (max - min) / 2);
}

/**
 * Determines scale amount for a given axis to normalize model coordinates.
 *
 * @method getScaleFactor
 * @private
 *
 * @param {Number} max Maximum scale value of given axis on the model.
 * @param {Number} min Minimum scale value of given axis on the model.
 *
 * @return {Number} Number by which the given axis should be scaled for all vertices.
 */
function getScaleFactor(max, min) {
    return 1 / ((max - min) / 2);
}

/**
 * Finds the azimuth, or angle above the XY plane, of a given vector.
 *
 * @static
 * @method getAzimuth
 *
 * @param {Array} v Vertex to retreive azimuth from.
 * 
 * @return {Number} Azimuth value in radians. 
 */
GeometryHelper.getAzimuth = function azimuth(v) {
    return Math.atan2(v[2], -v[0]);
};

/**
 * Finds the altitude, or angle above the XZ plane, of a given vector.
 *
 * @static
 * @method getAltitude
 *
 * @param {Array} v Vertex to retreive altitude from.
 * 
 * @return {Number} Altitude value in radians. 
 */
GeometryHelper.getAltitude = function altitude(v) {
    return Math.atan2(-v[1], Math.sqrt((v[0] * v[0]) + (v[2] * v[2])));
};

/**
 * Converts a list of indices from 'triangle' to 'line' format.
 *
 * @static
 * @method trianglesToLines
 *
 * @param {Array} indices Indices of all faces on the geometry
 * @param {Array} out Indices of all faces on the geometry
 * 
 * @return {Array} new list of line-formatted indices
 */
GeometryHelper.trianglesToLines = function triangleToLines(indices, out) {
    var numVectors = indices.length / 3;
    var out = [];
    var face;
    var j;
    var i;

    for (i = 0; i < numVectors; i++) {
        out.push(indices[i * 3 + 0], indices[i * 3 + 1]);
        out.push(indices[i * 3 + 1], indices[i * 3 + 2]);
        out.push(indices[i * 3 + 2], indices[i * 3 + 0]);
    }

    return out;
};

/**
 * Adds a reverse order triangle for every triangle in the mesh.  Adds extra vertices
 * and indices to input arrays.
 *
 * @static
 * @method addBackfaceTriangles
 *
 * @param {Array} vertices X, Y, Z positions of all vertices in the geometry
 * @param {Array} indices Indices of all faces on the geometry
 */
GeometryHelper.addBackfaceTriangles = function addBackfaceTriangles(vertices, indices) {
    var nFaces = indices.length / 3;
    
    var maxIndex = 0;
    var i = indices.length;
    while (i--) if (indices[i] > maxIndex) maxIndex = indices[i];

    maxIndex++;

    for (var i = 0; i < nFaces; i++) {
        var indexOne = indices[i * 3],
            indexTwo = indices[i * 3 + 1],
            indexThree = indices[i * 3 + 2];

        indices.push(indexOne + maxIndex, indexThree + maxIndex, indexTwo + maxIndex);
    }

    // Iterating instead of .slice() here to avoid max call stack issue.

    var nVerts = vertices.length;
    for (var i = 0; i < nVerts; i++) {
        vertices.push(vertices[i]);
    }
};

module.exports = GeometryHelper;

},{"../math/Vec2":48,"../math/Vec3":49}],104:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var loadURL        = require('../utilities/loadURL');
var GeometryHelper = require('./GeometryHelper');

/*
 * A singleton object that takes that makes requests
 * for OBJ files and returns the formatted data as
 * an argument to a callback function.
 *
 * @static
 * @class OBJLoader
 */

var OBJLoader = {
    cached: {},
    requests: {},
    formatText: format
};

/*
 * Takes a path to desired obj file and makes an XMLHttp request
 * if the resource is not cached. Sets up the 'onresponse' function
 * as a callback for formatting and callback invocation.
 *
 * @method load
 *
 * @param {String} url URL of desired obj
 * @param {Function} cb Function to be fired upon successful formatting of obj
 * @param {Object} options Options hash to that can affect the output of the OBJ
 * vertices.
 */
OBJLoader.load = function load(url, cb, options) {
    if (! this.cached[url]) {
        if(! this.requests[url]) {
            this.requests[url] = [cb];
            loadURL(
                url,
                this._onsuccess.bind(
                    this,
                    url,
                    options
                )
            );
        } else {
            this.requests[url].push(cb);
        }
    } else {
        cb(this.cached[url]);
    }
};

/*
 * Fired on response from server for OBJ asset.  Formats the
 * returned string and stores the buffer data in cache.
 * Invokes all queued callbacks before clearing them.
 *
 * @method _onsuccess
 * @private
 *
 * @param {String} URL of requested obj
 * @param {Boolean} value determining whether or not to manually calculate normals
 * @param {String} content of the server response
 */
OBJLoader._onsuccess = function _onsuccess(url, options, text) {
    var buffers = format.call(this, text, options || {});
    this.cached[url] = buffers;

    for (var i = 0; i < this.requests[url].length; i++) {
        this.requests[url][i](buffers);
    }

    this.requests[url] = null;
};

/*
 * Takes raw string format of obj and converts it to a javascript
 * object representing the buffers needed to draw the geometry.
 *
 * @method format
 * @private
 *
 * @param {String} raw obj data in text format
 * @param {Boolean} value determining whether or not to manually calculate normals
 *
 * @return {Object} vertex buffer data
 */
function format(text, options) {
    text = sanitize(text);

    var lines = text.split('\n');

    var faceTexCoords = [];
    var faceVertices = [];
    var faceNormals = [];

    var normals = [];
    var texCoords = [];
    var vertices = [];

    var i1, i2, i3, i4;
    var split;
    var line;

    var length = lines.length;

    for (var i = 0; i < length; i++) {
        line = lines[i];
        split = lines[i].split(' ');

        // Handle vertex positions

        if (line.indexOf('v ') !== -1) {
            vertices.push([
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
            ]);
        }

        // Handle texture coordinates

        else if(line.indexOf('vt ') !== -1) {
            texCoords.push([
                parseFloat(split[1]),
                parseFloat(split[2])
            ]);
        }

        // Handle vertex normals

        else if (line.indexOf('vn ') !== -1) {
            normals.push([
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
            ]);
        }

        // Handle face

        else if (line.indexOf('f ') !== -1) {

            // Vertex, Normal

            if (split[1].indexOf('//') !== -1) {
                i1 = split[1].split('//');
                i2 = split[2].split('//');
                i3 = split[3].split('//');

                faceVertices.push([
                    parseFloat(i1[0]) - 1,
                    parseFloat(i2[0]) - 1,
                    parseFloat(i3[0]) - 1
                ]);
                faceNormals.push([
                    parseFloat(i1[1]) - 1,
                    parseFloat(i2[1]) - 1,
                    parseFloat(i3[1]) - 1
                ]);

                // Handle quad

                if (split[4]) {
                    i4 = split[4].split('//');
                    faceVertices.push([
                        parseFloat(i1[0]) - 1,
                        parseFloat(i3[0]) - 1,
                        parseFloat(i4[0]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(i1[2]) - 1,
                        parseFloat(i3[2]) - 1,
                        parseFloat(i4[2]) - 1
                    ]);
                }
            }

            // Vertex, TexCoord, Normal

            else if (split[1].indexOf('/') !== -1) {
                i1 = split[1].split('/');
                i2 = split[2].split('/');
                i3 = split[3].split('/');

                faceVertices.push([
                    parseFloat(i1[0]) - 1,
                    parseFloat(i2[0]) - 1,
                    parseFloat(i3[0]) - 1
                ]);
                faceTexCoords.push([
                    parseFloat(i1[1]) - 1,
                    parseFloat(i2[1]) - 1,
                    parseFloat(i3[1]) - 1
                ]);
                faceNormals.push([
                    parseFloat(i1[2]) - 1,
                    parseFloat(i2[2]) - 1,
                    parseFloat(i3[2]) - 1
                ]);

                // Handle Quad

                if (split[4]) {
                    i4 = split[4].split('/');

                    faceVertices.push([
                        parseFloat(i1[0]) - 1,
                        parseFloat(i3[0]) - 1,
                        parseFloat(i4[0]) - 1
                    ]);
                    faceTexCoords.push([
                        parseFloat(i1[1]) - 1,
                        parseFloat(i3[1]) - 1,
                        parseFloat(i4[1]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(i1[2]) - 1,
                        parseFloat(i3[2]) - 1,
                        parseFloat(i4[2]) - 1
                    ]);
                }
            }

            // Vertex

            else {
                faceVertices.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);
                faceTexCoords.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);
                faceNormals.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);

                // Handle Quad

                if (split[4]) {
                    faceVertices.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                    faceTexCoords.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                }
            }
        }
    }

    var cached = cacheVertices(
        vertices,
        normals,
        texCoords,
        faceVertices,
        faceNormals,
        faceTexCoords
    );


    cached.vertices = flatten(cached.vertices);
    cached.normals = flatten(cached.normals);
    cached.texCoords = flatten(cached.texCoords);
    cached.indices = flatten(cached.indices);

    if (options.normalize) {
        cached.vertices = GeometryHelper.normalizeVertices(
            cached.vertices
        );
    }

    if (options.computeNormals) {
        cached.normals = GeometryHelper.computeNormals(
            cached.vertices,
            cached.indices
        );
    }

    return {
        vertices: cached.vertices,
        normals: cached.normals,
        textureCoords: cached.texCoords,
        indices: cached.indices
    };
}

/*
 * Replaces all double spaces with single spaces and removes
 * all trailing spaces from lines of a given string.
 *
 * @method sanitize
 * @private
 *
 * @param {String} text String to be sanitized.
 *
 * @return {String} sanitized string.
 */
function sanitize(text) {
    return text.replace(/ +(?= )/g,'').replace(/\s+$/g, '');
}

/*
 * Takes a given pool of attributes and face definitions
 * and removes all duplicate vertices.
 *
 * @method cacheVertices
 * @private
 *
 * @param {Array} v Pool of vertices used in face declarations.
 * @param {Array} n Pool of normals used in face declarations.
 * @param {Array} t Pool of textureCoords used in face declarations.
 * @param {Array} fv Vertex positions at each face in the OBJ.
 * @param {Array} fn Normals at each face in the OBJ.
 * @param {Array} ft Texture coordinates at each face in the OBJ.
 *
 * @return {Object} Object containing the vertices, textureCoordinates and
 * normals of the OBJ.
 */
function cacheVertices(v, n, t, fv, fn, ft) {
    var outNormals = [];
    var outPos = [];
    var outTexCoord = [];
    var outIndices = [];

    var vertexCache = {};

    var positionIndex;
    var normalIndex;
    var texCoordIndex;

    var currentIndex = 0;
    var fvLength = fv.length;
    var fnLength = fn.length;
    var ftLength = ft.length;
    var faceLength;
    var index;

    for (var i = 0; i < fvLength; i++) {
        outIndices[i] = [];
        faceLength = fv[i].length;

        for (var j = 0; j < faceLength; j++) {
            if (ftLength) texCoordIndex = ft[i][j];
            if (fnLength) normalIndex   = fn[i][j];
                          positionIndex = fv[i][j];

            index = vertexCache[positionIndex + ',' + normalIndex + ',' + texCoordIndex];

            if(index === undefined) {
                index = currentIndex++;

                              outPos.push(v[positionIndex]);
                if (fnLength) outNormals.push(n[normalIndex]);
                if (ftLength) outTexCoord.push(t[texCoordIndex]);

                vertexCache[positionIndex + ',' + normalIndex + ',' + texCoordIndex] = index;
            }

            outIndices[i].push(index);
        }
    }

    return {
        vertices: outPos,
        normals: outNormals,
        texCoords: outTexCoord,
        indices: outIndices
    };
}

/*
 * Flattens an array of arrays. Not recursive. Assumes
 * all children are arrays.
 *
 * @method flatten
 * @private
 *
 * @param {Array} arr Input array to be flattened.
 *
 * @return {Array} Flattened version of input array.
 */
function flatten(arr) {
    var len = arr.length;
    var out = [];

    for (var i = 0; i < len; i++) {
        out.push.apply(out, arr[i]);
    }

    return out;
}

module.exports = OBJLoader;

},{"../utilities/loadURL":98,"./GeometryHelper":103}],105:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Box: require('./primitives/Box'),
    Circle: require('./primitives/Circle'),
    Cylinder: require('./primitives/Cylinder'),
    GeodesicSphere: require('./primitives/GeodesicSphere'),
    Icosahedron: require('./primitives/Icosahedron'),
    ParametricCone: require('./primitives/ParametricCone'),
    Plane: require('./primitives/Plane'),
    Sphere: require('./primitives/Sphere'),
    Tetrahedron: require('./primitives/Tetrahedron'),
    Torus: require('./primitives/Torus'),
    Triangle: require('./primitives/Triangle'),
    GeometryHelper: require('./GeometryHelper'),
    DynamicGeometry: require('./DynamicGeometry'),
    Geometry: require('./Geometry'),
    OBJLoader: require('./OBJLoader'),
};
},{"./DynamicGeometry":101,"./Geometry":102,"./GeometryHelper":103,"./OBJLoader":104,"./primitives/Box":106,"./primitives/Circle":107,"./primitives/Cylinder":108,"./primitives/GeodesicSphere":109,"./primitives/Icosahedron":110,"./primitives/ParametricCone":111,"./primitives/Plane":112,"./primitives/Sphere":113,"./primitives/Tetrahedron":114,"./primitives/Torus":115,"./primitives/Triangle":116}],106:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');

function pickOctant(i) {
    return [(i & 1) * 2 - 1, (i & 2) - 1, (i & 4) / 2 - 1];
}

var boxData = [
    [0, 4, 2, 6, -1, 0, 0], 
    [1, 3, 5, 7, +1, 0, 0],
    [0, 1, 4, 5, 0, -1, 0],
    [2, 6, 3, 7, 0, +1, 0],
    [0, 2, 1, 3, 0, 0, -1],
    [4, 5, 6, 7, 0, 0, +1]
];

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class BoxGeometry
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function BoxGeometry(options) {
    options = options || {};

    var vertices      = [];
    var textureCoords = [];
    var normals       = [];
    var indices       = [];

    var data;
    var d;
    var v;
    var i;
    var j;

    for (i = 0; i < boxData.length; i++) {
        data = boxData[i], v = i * 4;
        for (j = 0; j < 4; j++) {
            d = data[j];
            var octant = pickOctant(d);
            vertices.push(octant[0], octant[1], octant[2]);
            textureCoords.push(j & 1, (j & 2) / 2);
            normals.push(data[4], data[5], data[6]);
        }
        indices.push(v, v + 1, v + 2);
        indices.push(v + 2, v + 1, v + 3);
    }

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: vertices },
            { name: 'a_texCoord', data: textureCoords, size: 2 },
            { name: 'a_normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = BoxGeometry;

},{"../Geometry":102}],107:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Circle
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Circle (options) {
    options  = options || {};
    var detail   = options.detail || 30;
    var buffers  = getCircleBuffers(detail, true);

    if (options.backface !== false) {
        GeometryHelper.addBackfaceTriangles(buffers.vertices, buffers.indices);
    }

    var textureCoords = getCircleTexCoords(buffers.vertices);
    var normals = GeometryHelper.computeNormals(buffers.vertices, buffers.indices);

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: buffers.vertices },
            { name: 'a_texCoord', data: textureCoords, size: 2 },
            { name: 'a_normals', data: normals },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

function getCircleTexCoords (vertices) {
    var textureCoords = [];
    var nFaces = vertices.length / 3;

    for (var i = 0; i < nFaces; i++) {
        var x = vertices[i * 3],
            y = vertices[i * 3 + 1];

        textureCoords.push(0.5 + x * 0.5, 0.5 + -y * 0.5);
    }

    return textureCoords;
}

/**
 * Calculates and returns all vertex positions, texture
 * coordinates and normals of the circle primitive.
 *
 * @method getBuffers
 *
 * @param {Number} detail Amount of detail that determines how many
 * vertices are created and where they are placed
 * 
 * @return {Object} constructed geometry
 */
function getCircleBuffers(detail) {
    var vertices = [0, 0, 0];
    var indices = [];
    var counter = 1;
    var theta;
    var x;
    var y;

    for (var i = 0; i < detail + 1; i++) {
        theta = i / detail * Math.PI * 2;

        x = Math.cos(theta),
        y = Math.sin(theta);

        vertices.push(x, y, 0);

        if (i > 0) indices.push(0, counter, ++counter);
    }

    return {
        vertices: vertices,
        indices: indices
    };
}

module.exports = Circle;

},{"../Geometry":102,"../GeometryHelper":103}],108:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This class creates a new geometry instance and sets
 * its vertex positions, texture coordinates, normals,
 * and indices to based on the primitive.
 *
 * @class Cylinder
 * @constructor
 * 
 * @param {Object} options Parameters that alter thed
 * vertex buffers of the generated geometry.
 *
 * @return {Object} constructed geometry
 */
function Cylinder (options) {
    options  = options || {};
    var radius   = options.radius || 1;
    var detail   = options.detail || 15;
    var buffers;

    buffers = GeometryHelper.generateParametric(
        detail,
        detail,
        Cylinder.generator.bind(null, radius)
    );

    if (options.backface !== false) {
        GeometryHelper.addBackfaceTriangles(buffers.vertices, buffers.indices);
    }

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: buffers.vertices },
            { name: 'a_texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'a_normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * Function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} r Cylinder radius.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 *
 * @return {Array} x, y and z coordinate of geometry.
 */
Cylinder.generator = function generator(r, u, v, pos) {
    pos[1] = r * Math.sin(v);
    pos[0] = r * Math.cos(v);
    pos[2] = r * (-1 + u / Math.PI * 2);
};

module.exports = Cylinder;

},{"../Geometry":102,"../GeometryHelper":103}],109:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class GeodesicSphere
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function GeodesicSphere (options) {
    var t = (1 + Math.sqrt(5)) * 0.5;

    var vertices = [
        - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
         0, - 1, -t,    0,  1, -t,    0, - 1,   t,    0,  1,   t,
         t,  0,   1,    t,  0, -1,   - t,  0,   1,   - t,  0, -1
    ];
    var indices = [
        0,  5, 11,    0,  1,  5,    0,  7,  1,    0, 10,  7,    0, 11, 10,
        1,  9,  5,    5,  4, 11,    11, 2, 10,   10,  6,  7,    7,  8,  1,
        3,  4,  9,    3,  2,  4,    3,  6,  2,    3,  8,  6,    3,  9,  8,
        4,  5,  9,    2, 11,  4,    6, 10,  2,    8,  7,  6,    9,  1,  8
    ];

    vertices = GeometryHelper.normalizeAll(vertices);

    options = options || {};
    var detail  = options.detail || 3;

    while(--detail) GeometryHelper.subdivideSpheroid(vertices, indices);
    GeometryHelper.getUniqueFaces(vertices, indices);

    var normals       = GeometryHelper.computeNormals(vertices, indices);
    var textureCoords = GeometryHelper.getSpheroidUV(vertices);

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: vertices },
            { name: 'a_texCoord', data: textureCoords, size: 2 },
            { name: 'a_normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = GeodesicSphere;

},{"../Geometry":102,"../GeometryHelper":103}],110:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Icosahedron
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Icosahedron() {
    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var vertices = [
        - 1,   t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
          0, - 1, -t,    0,  1, -t,     0, - 1,  t,    0,   1,  t,
          t,   0,  1,    t,  0, -1,   - t,   0,  1,  - t,   0, -1
    ];
    var indices = [
        0,  5, 11,    0,  1,  5,    0,  7,  1,    0, 10,  7,    0, 11, 10,
        1,  9,  5,    5,  4, 11,    11, 2, 10,   10,  6,  7,    7,  8,  1,
        3,  4,  9,    3,  2,  4,    3,  6,  2,    3,  8,  6,    3,  9,  8,
        4,  5,  9,    2, 11,  4,    6, 10,  2,    8,  7,  6,    9,  1,  8
    ];

    GeometryHelper.getUniqueFaces(vertices, indices);

    var normals       = GeometryHelper.computeNormals(vertices, indices);
    var textureCoords = GeometryHelper.getSpheroidUV(vertices);

    vertices      = GeometryHelper.normalizeAll(vertices);

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: vertices },
            { name: 'a_texCoord', data: textureCoords, size: 2 },
            { name: 'a_normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Icosahedron;

},{"../Geometry":102,"../GeometryHelper":103}],111:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class ParametricCone
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function ParametricCone (options) {
    options  = options || {};
    var detail   = options.detail || 15;
    var radius   = options.radius || 1 / Math.PI;

    var buffers = GeometryHelper.generateParametric(
        detail,
        detail,
        ParametricCone.generator.bind(null, radius)
    );

    if (options.backface !== false) {
        GeometryHelper.addBackfaceTriangles(buffers.vertices, buffers.indices);
    }

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: buffers.vertices },
            { name: 'a_texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'a_normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} r Cone Radius.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinate of geometry.
 */

ParametricCone.generator = function generator(r, u, v, pos) {
    pos[0] = -r * u * Math.cos(v);
    pos[1] = r * u * Math.sin(v);
    pos[2] = -u / (Math.PI / 2) + 1;
};

module.exports = ParametricCone;

},{"../Geometry":102,"../GeometryHelper":103}],112:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Plane
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Plane(options) {
    options = options || {};
    var detailX = options.detailX || options.detail || 1;
    var detailY = options.detailY || options.detail || 1;

    var vertices      = [];
    var textureCoords = [];
    var normals       = [];
    var indices       = [];

    for (var y = 0; y <= detailY; y++) {
        var t = y / detailY;
        for (var x = 0; x <= detailX; x++) {
            var s = x / detailX;
            vertices.push(2. * (s - .5), 2 * (t - .5), 0);
            textureCoords.push(s, 1 - t);
            if (x < detailX && y < detailY) {
                var i = x + y * (detailX + 1);
                indices.push(i, i + 1, i + detailX + 1);
                indices.push(i + detailX + 1, i + 1, i + detailX + 2);
            }
        }
    }

    if (options.backface !== false) {
        GeometryHelper.addBackfaceTriangles(vertices, indices);
        
        // duplicate texture coordinates as well

        var len = textureCoords.length;
        for (var i = 0; i < len; i++) textureCoords.push(textureCoords[i]);
    }

    var normals = GeometryHelper.computeNormals(vertices, indices);

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: vertices },
            { name: 'a_texCoord', data: textureCoords, size: 2 },
            { name: 'a_normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
};

module.exports = Plane;

},{"../Geometry":102,"../GeometryHelper":103}],113:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class ParametricSphere
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function ParametricSphere (options) {
    options = options || {};
    var detail = options.detail || 10;
    var detailX = options.detailX || detail;    
    var detailY = options.detailY || detail;

    var buffers = GeometryHelper.generateParametric(
        detailX,
        detailY,
        ParametricSphere.generator,
        true
    );

    GeometryHelper.getUniqueFaces(buffers.vertices, buffers.indices);

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: buffers.vertices },
            { name: 'a_texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'a_normals', data: GeometryHelper.getSpheroidNormals(buffers.vertices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * Function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinates of geometry
 */
ParametricSphere.generator = function generator(u, v, pos) {
    var x = Math.sin(u) * Math.cos(v);
    var y = Math.cos(u);
    var z = -Math.sin(u) * Math.sin(v);

    pos[0] = x;
    pos[1] = y;
    pos[2] = z;
};

module.exports = ParametricSphere;

},{"../Geometry":102,"../GeometryHelper":103}],114:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function generates custom buffers and passes them to
 * a new static geometry, which is returned to the user.
 *
 * @class Tetrahedron
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Tetrahedron(options) {
    var textureCoords = [];
    var normals = [];
    var detail;
    var i;
    var t = Math.sqrt(3);
    
    var vertices = [
        // Back 
         1, -1, -1 / t,
        -1, -1, -1 / t,
         0,  1,  0,
        
        // Right
         0,  1,  0,
         0, -1, t - 1 / t,
         1, -1, -1 / t,

        // Left
         0,  1,  0,
        -1, -1, -1 / t,
         0, -1,  t - 1 / t,

        // Bottom
         0, -1,  t - 1 / t,
        -1, -1, -1 / t,
         1, -1, -1 / t,
    ];

    var indices = [
        0, 1, 2,
        3, 4, 5,
        6, 7, 8,
        9, 10, 11,
    ];

    for (i = 0; i < 4; i++) {
        textureCoords.push(
            0.0, 0.0,
            0.5, 1.0,
            1.0, 0.0
        );
    }

    options       = options || {};

    while(--detail) GeometryHelper.subdivide(indices, vertices, textureCoords);
    normals       = GeometryHelper.computeNormals(vertices, indices);

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: vertices },
            { name: 'a_texCoord', data: textureCoords, size: 2 },
            { name: 'a_normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Tetrahedron;

},{"../Geometry":102,"../GeometryHelper":103}],115:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Torus
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */

function Torus(options) {
    var options  = options || {};
    var detail   = options.detail || 30;
    var holeRadius = options.holeRadius || 0.80;
    var tubeRadius = options.tubeRadius || 0.20;

    var buffers = GeometryHelper.generateParametric(
        detail,
        detail,
        Torus.generator.bind(null, holeRadius, tubeRadius)
    );

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: buffers.vertices },
            { name: 'a_texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'a_normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} c Radius of inner hole.
 * @param {Number} a Radius of tube.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinate of the vertex.
 */
Torus.generator = function generator(c, a, u, v, pos) {
    pos[0] = (c + a * Math.cos(2 * v)) * Math.sin(2 * u);
    pos[1] = -(c + a * Math.cos(2 * v)) * Math.cos(2 * u);
    pos[2] = a * Math.sin(2 * v);
}

module.exports = Torus;

},{"../Geometry":102,"../GeometryHelper":103}],116:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Triangle
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Triangle (options) {
    var options  = options || {};
    var detail   = options.detail || 1;
    var normals  = [];
    var textureCoords = [
        0.0, 0.0,
        0.5, 1.0,
        1.0, 0.0
    ];
    var indices  = [
        0, 1, 2
    ];
    var vertices = [
        -1, -1, 0,
         0,  1, 0,
         1, -1, 0
    ];

    while(--detail) GeometryHelper.subdivide(indices, vertices, textureCoords);

    if (options.backface !== false) {
        GeometryHelper.addBackfaceTriangles(vertices, indices);
    }

    normals = GeometryHelper.computeNormals(vertices, indices);

    return new Geometry({
        buffers: [
            { name: 'a_pos', data: vertices },
            { name: 'a_texCoord', data: textureCoords, size: 2 },
            { name: 'a_normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Triangle;

},{"../Geometry":102,"../GeometryHelper":103}],117:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 
'use strict';

var TextureRegistry = require('./TextureRegistry');

var expressions = {};

var snippets = {

    /* Abs - The abs function returns the absolute value of x, i.e. x when x is positive or zero and -x for negative x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
     */

    abs: {glsl: 'abs(%1);', output: { 4: 4, 3: 3, 2: 2, 1: 1 }},
    /* Sign - The sign function returns 1.0 when x is positive, 0.0 when x is zero and -1.0 when x is negative. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    sign: {glsl: 'sign(%1);', output: { 4: 4, 3: 3, 2: 2, 1: 1 }},

    /* Floor - The floor function returns the largest integer number that is smaller or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    floor: {glsl: 'floor(%1);', output: { 4: 4, 3: 3, 2: 2, 1: 1 }},

    /* Ceiling - The ceiling function returns the smallest number that is larger or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    ceiling: {glsl: 'ceil(%1);', output: { 4: 4, 3: 3, 2: 2, 1: 1 }},

    /* The mod expression returns the remained of the division operation of the two inputs. */

    mod: {glsl: 'mod(%1, %2);'},

    /* Min - The min function returns the smaller of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    min: {glsl: 'min(%1, %2);', output: { 4: 4, 3: 3, 2: 2, 1: 1 }},

    /* Max - The max function returns the larger of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    max: {glsl: 'max(%1, %2);', output: { 4: 4, 3: 3, 2: 2, 1: 1 }},

    /* Clamp - The clamp function returns x if it is larger than minVal and smaller than maxVal. In case x is smaller than minVal, minVal is returned. If x is larger than maxVal, maxVal is returned. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    clamp: {glsl: 'clamp(%1, %2, %3);', output: { '4,1,1': 4, '3,1,1': 3, '2,1,1': 2, '1,1,1': 1 }},

    /* Mix - The mix function returns the linear blend of x and y, i.e. the product of x and (1 - a) plus the product of y and a. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    mix: {glsl: 'mix(%1, %2, %3);', output: { '4,4,1': 4, '3,3,1': 3, '2,2,1': 2, '1,1,1': 1 }},

    /* Step - The step function returns 0.0 if x is smaller then edge and otherwise 1.0. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    step: {glsl: 'step(%1, %2, %3);', output: { '1,1': 1, '1,2': 2, '1,3': 3, '1,4': 4 }},

    /* Smoothstep - The smoothstep function returns 0.0 if x is smaller then edge0 and 1.0 if x is larger than edge1. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomirals. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    smoothstep: {glsl: 'smoothstep(%1);', output: { '1,1,1':1, '2,2,2':2, '3,3,3':3, '4,4,4':4 }},


    /* fragCoord - The fragCoord function returns the fragment's position in screenspace. */

    fragCoord: {glsl: 'gl_FragColor;', output: 4 },

    /* Sin - The sin function returns the sine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the sine is calculated separately for every component. */


    sin: {glsl: 'sin(%1);', output: {'1':1, '2':2, '3':3, '4':4}},

    /* Cos - The cos function returns the cosine of an angle in radians. The input parameter can be a floating scalar or a float vector. */

    cos: {glsl: 'cos(%1);', output: {'1':1, '2':2, '3':3, '4':4}},

    /* Pow - The power function returns x raised to the power of y. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    pow: {glsl: 'pow(%1, %2);', output: {'1,1':1, '2,2':2, '3,3':3, '1,4':4}},

    /* Sqrt - The sqrt function returns the square root of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    sqrt: {glsl: 'sqrt(%1);', output: {'1,1':1, '2,2':2, '3,3':3, '1,4':4}},

    /* time - The time function returns the elapsed time in the unix epoch in milliseconds.*/

    time: {glsl: 'time;', output: 1},

    /* The Add function takes two inputs, adds them together and outputs the result. This addition operation is performed on a per channel basis, meaning that the inputs' R channels get added, G channels get added, B channels get added, etc. Both inputs must have the same number of channels unless one of them is a single Constant value. Constants can be added to a vector with any number of inputs. */

    add: {glsl: '%1 + %2;', output:  {'1,1':1, '2,2':2, '3,3':3, '4,4':4, '2,1':2, '3,1':3, '4,1':4}},

    /* The subtract function takes two inputs, subtracts the first from the second,  and outputs the result. This addition operation is performed on a per channel basis, meaning that the inputs' R channels get subtracted, G channels get subtracted, B channels get subtracted, etc. Both inputs must have the same number of channels unless one of them is a single Constant value. Constants can be added to a vector with any number of inputs. */

    subtract: {glsl: '%1 - %2;', output: {'1,1':1, '2,2':2, '3,3':3, '4,4':4, '2,1':2, '3,1':3, '4,1':4}},

    /* The Add function takes two inputs, adds them together and outputs the result. This addition operation is performed on a per channel basis, meaning that the inputs' R channels get added, G channels get added, B channels get added, etc. Both inputs must have the same number of channels unless one of them is a single Constant value. Constants can be added to a vector with any number of inputs. */

    multiply: {glsl: '%1 * %2;', output: {'1,1':1, '2,2':2, '3,3':3, '4,4':4, '2,1':2, '3,1':3, '4,1':4}},

    /* The normal function returns the 3-dimensional surface normal, which is a vector that is perpendicular to the tangent plane at that point.*/

    normal: { glsl: 'vec4((v_normal + 1.0) * 0.5, 1.0);', output: 4 },

    /* The uv function returns the 2-dimensional vector that maps the object's 3-dimensional vertices to a 2D plane. */

    uv: {glsl:'v_textureCoordinate;', output: 2},

    /* The mesh position function returns the transformed fragment's position in world-space.  */

    meshPosition: {glsl:'(v_position + 1.0) * 0.5;', output: 3},


    normalize: {glsl: 'normalize(%1)', output: {1: 1, 2: 2, 3: 3, 4: 4}},


    dot: {glsl: 'dot(%1, %2);', output: {'1,1': 1,'2,2':1, '3,3': 1, '4,4':1 }},

    /* The image function fetches the model's */

    image: {glsl:'texture2D($TEXTURE, v_textureCoordinate);', output: 4 },


    /* The constant function returns a static value which is defined at compile-time that cannot be changed dynamically.*/

    constant: {glsl: '%1;'},

    /* The Parameter expression has values that can be modified (dynamically during runtime in some cases) in a MaterialInstance of the base material containing the parameter. These expressions should be given unique names, via the Parameter Name property, to be used when identifying the specific parameter in the MaterialInstance. If two parameters of the same type have the same name in the same material, they will be assumed to be the same parameter. Changing the value of the parameter in the MaterialInstance would change the value of both the parameter expressions in the material. A default value for the parameter will also be set in the base material. This will be the value of the parameter in the MaterialInstance unless it is overridden and modified there. */

    parameter: {uniforms: {parameter: 1}, glsl: 'parameter;'},
    vec3: {glsl: 'vec3(%1);', output: 3},
    vec2: {glsl: 'vec2(%1);', output: 2}
};

expressions.registerExpression = function registerExpression(name, schema) {
    this[name] = function (inputs, options) {
        return new Material(name, schema, inputs, options);
    };
};

for (var snippetName in snippets) {
    expressions.registerExpression(snippetName, snippets[snippetName]);
}

/**
 * Material is a public class that composes a material-graph out of expressions
 *
 *
 * @class Material
 * @constructor
 *
 * @param {Object} definiton of nascent expression with shader code, inputs and uniforms
 * @param {Array} list of Material expressions, images, or constant
 * @param {Object} map of uniform data of float, vec2, vec3, vec4
 */

function Material(name, chunk, inputs, options) {
    options = options || {};

    this.name = name;
    this.chunk = chunk;
    this.inputs = inputs ? (Array.isArray(inputs) ? inputs : [inputs]): [];
    this.uniforms = options.uniforms || {};
    this.varyings = options.varyings;
    this.attributes = options.attributes;

    if (options.texture) {
        this.texture = options.texture.__isATexture__ ? options.texture : TextureRegistry.register(null, options.texture);
    }

    this._id = Material.id++;

    this.invalidations = [];
    this.__isAMaterial__ = true;
}

Material.id = 2;

Material.prototype.setUniform = function setUniform(name, value) {
    this.uniforms[name] = value;

    this.invalidations.push(name);
};

module.exports = expressions;
expressions.Material = Material;

expressions.Texture = function (source) {
    if (typeof window === 'undefined') return console.error('Texture constructor cannot be run inside of a worker');
    return expressions.image([], { texture: source });
};

expressions.Custom = function (schema, inputs, uniforms) {
    return new Material('custom', {glsl: schema, output: 1, uniforms: uniforms || {}} , inputs);
};

},{"./TextureRegistry":118}],118:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/*
 * A singleton object that holds texture instances in a registry which
 * can be accessed by key.  Allows for texture sharing and easy referencing.
 *
 * @static
 * @class TextureRegistry
 */
var TextureRegistry = {
	registry: {},
	textureIds: 1
};

/*
 * Registers a new Texture object with a unique id and input parameters to be
 * handled by the WebGLRenderer.  If no accessor is input the texture will be 
 * created but not store in the registry.
 *
 * @method register
 *
 * @param {String} accessor Key used to later access the texture object.
 * @param {Object | Array | String} data Data to be used in the WebGLRenderer to
 * generate texture data.
 * @param {Object} options Optional parameters to affect the rendering of the
 * WebGL texture.
 *
 * @return {Object} Newly generated texture object.
 */
TextureRegistry.register = function register(accessor, data, options) {
	if (accessor) return (this.registry[accessor] = { id: this.textureIds++, __isATexture__: true, data: data, options: options });
	else return { id: this.textureIds++, data: data, __isATexture__: true, options: options };
};

/*
 * Retreives the texture object from registry.  Throws if no texture is
 * found at given key.
 *
 * @method get
 *
 * @param {String} accessor Key of a desired texture in the registry.
 *
 * @return {Object} Desired texture object.
 */
TextureRegistry.get = function get(accessor) {
	if (!this.registry[accessor]) {
		throw 'Texture "' + accessor + '" not found!';
	}
	else {
		return this.registry[accessor];
	}
};

module.exports = TextureRegistry;

},{}],119:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Material: require('./Material'),
    TextureRegistry: require('./TextureRegistry')
};
},{"./Material":117,"./TextureRegistry":118}],120:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';
var Geometry = require('../webgl-geometries');

/**
 * The Mesh class is responsible for providing the API for how
 * a RenderNode will interact with the WebGL API by adding
 * a set of commands to the renderer.
 *
 * @class Mesh
 * @constructor
 * @renderable
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * @param {object} Options Optional params for configuring Mesh
 */
function Mesh (node, options) {
    this._node = node;
    this._changeQueue = [];
    this._initialized = false;
    this._requestingUpdate = false;
    this._inDraw = false;
    this.value = {
        drawOptions: {},
        color: null,
        expressions: {},
        geometry: null,
        flatShading: null,
        glossiness: null,
        baseColor: [0, 0, 0, 1],
        positionOffset: null,
        normals: null,
    };

    if (options) this.setDrawOptions(options);
    this._id = node.addComponent(this);
}

/**
 * Pass custom options to Mesh, such as a 3 element map
 * which displaces the position of each vertex in world space.
 *
 * @method setDrawOptions
 * @chainable
 *
 * @param {Object} Options
 * @chainable
 */
Mesh.prototype.setDrawOptions = function setOptions (options) {
    this._changeQueue.push('GL_SET_DRAW_OPTIONS');
    this._changeQueue.push(options);
    return this;
};

/**
 * Get the mesh's custom options.
 *
 * @method getDrawOptions
 * @returns {Object} Options
 */
Mesh.prototype.getDrawOptions = function getDrawOptions () {
    return this.value.drawOptions;
};

/**
 * Assigns a geometry to be used for this mesh.  Will create new Geometry
 * from primtives if input is a string.  Queues the set command for this 
 * geometry and looks for buffers to send to the renderer to update geometry.
 *
 * @method setGeometry
 * @chainable
 *
 * @param {Geometry} geometry instance to be associated with the mesh
 * @param {Object} Options Various configurations for geometries.
 * @chainable
 */
Mesh.prototype.setGeometry = function setGeometry (geometry, options) {
    if (typeof geometry === 'string') {
        if (!Geometry[geometry]) throw 'Invalid geometry: "' + geometry + '".';
        else geometry = new Geometry[geometry](options);
    }

    if (this.value.geometry !== geometry || this._inDraw) {
        if (this._initialized) {
            this._changeQueue.push('GL_SET_GEOMETRY');
            this._changeQueue.push(geometry.spec.id);
            this._changeQueue.push(geometry.spec.type);
            this._changeQueue.push(geometry.spec.dynamic);
        }
        this._requestUpdate();
        this.value.geometry = geometry;
    }

    if (this._initialized) {
        if (this._node) {
            var i = this.value.geometry.spec.invalidations.length;
            while (i--) {
                this.value.geometry.spec.invalidations.pop();
                this._changeQueue.push('GL_BUFFER_DATA');
                this._changeQueue.push(this.value.geometry.spec.id);
                this._changeQueue.push(this.value.geometry.spec.bufferNames[i]);
                this._changeQueue.push(this.value.geometry.spec.bufferValues[i]);
                this._changeQueue.push(this.value.geometry.spec.bufferSpacings[i]);
                this._changeQueue.push(this.value.geometry.spec.dynamic);
            }
            if (i) this._requestUpdate();
        }
    }
    return this;
};

/**
 * Gets the geometry of a mesh.
 *
 * @method getGeometry
 * @returns {Geometry} geometry Geometry of mesh
 */
Mesh.prototype.getGeometry = function getGeometry () {
    return this.value.geometry;
};

/**
* Changes the color of Mesh, passing either a material expression or
* color using the 'Color' utility component.
*
* @method setBaseColor
* @param {Object|Color} Material, image, vec3, or Color instance
* @chainable
*/
Mesh.prototype.setBaseColor = function setBaseColor (color) {
    var uniformValue;

    if (color.__isAMaterial__) {
        this.value.color = null;
        this.value.expressions.baseColor = color;
        uniformValue = color;
    }
    else if (color.getNormalizedRGB) {
        this.value.expressions.baseColor = null;
        this.value.color = color;
        var value = color.getNormalizedRGB();
        this.value.baseColor[0] = value[0];
        this.value.baseColor[1] = value[1];
        this.value.baseColor[2] = value[2];

        uniformValue = this.value.baseColor;
    }

    if (this._initialized) {

        // If a material expression

        if (color.__isAMaterial__) {
            this._changeQueue.push('MATERIAL_INPUT');
        }

        // If a color component

        else if (color.getNormalizedRGB) {
            this._changeQueue.push('GL_UNIFORMS');
        }

        this._changeQueue.push('u_baseColor');
        this._changeQueue.push(uniformValue);
    }

    this._requestUpdate();

    return this;
};

/**
 * Returns either the material expression or the color instance of Mesh.
 *
 * @method getBaseColor
 * @returns {MaterialExpress|Color}
 */
Mesh.prototype.getBaseColor = function getBaseColor () {
    return this.value.expressions.baseColor || this.value.color;
};

/**
 * Change whether the Mesh is affected by light. Default is true.
 *
 * @method setFlatShading
 * @param {boolean} Boolean
 * @chainable
 */
Mesh.prototype.setFlatShading = function setFlatShading (bool) {
    if (this._inDraw || this.value.flatShading !== bool) {
        this.value.flatShading = bool;
        if (this._initialized) {
            this._changeQueue.push('GL_UNIFORMS');
            this._changeQueue.push('u_flatShading');
            this._changeQueue.push(bool ? 1 : 0);
        }
        this._requestUpdate();
    }

    return this;
};

/**
 * Returns a boolean for whether Mesh is affected by light.
 *
 * @method getFlatShading
 * @returns {Boolean} Boolean
 */
Mesh.prototype.getFlatShading = function getFlatShading () {
    return this.value.flatShading;
};


/**
 * Defines a 3-element map which is used to provide significant physical
 * detail to the surface by perturbing the facing direction of each individual
 * pixel.
 *
 * @method normal
 * @chainable
 *
 * @param {Object|Array} Material, Image or vec3
 * @return {Element} current Mesh
 */
Mesh.prototype.setNormals = function setNormals (materialExpression) {
    if (materialExpression.__isAMaterial__) {
        this.value.expressions.normals = materialExpression;
    }

    if (this._initialized) {
        this._changeQueue.push(materialExpression.__isAMaterial__ ? 'MATERIAL_INPUT' : 'UNIFORM_INPUT');
        this._changeQueue.push('u_normals');
        this._changeQueue.push(materialExpression);
    }

    this._requestUpdate();

    return this;
};

/**
 * Returns the Normals expression of Mesh
 *
 * @method getNormals
 * @returns The normals expression for Mesh
 */
Mesh.prototype.getNormals = function getNormals (materialExpression) {
    return this.value.expressions.normals;
};

/**
 * Defines the glossiness of the mesh from either a material expression or a
 * scalar value
 *
 * @method setGlossiness
 * @param {MaterialExpression|Color} Accepts either a material expression or Color instance
 * @param {Number} Optional value for changing the strength of the glossiness
 * @chainable
 */
Mesh.prototype.setGlossiness = function setGlossiness(glossiness, strength) {
    if (glossiness.__isAMaterial__) {
        this.value.glossiness = [null, null];
        this.value.expressions.glossiness = glossiness;
    }
    else if (glossiness.getNormalizedRGB) {
        this.value.expressions.glossiness = null;
        this.value.glossiness = [glossiness, strength || 20];
        glossiness = glossiness ? glossiness.getNormalizedRGB() : [0, 0, 0];
        glossiness.push(strength || 20);
    }

    if (this._initialized) {
        this._changeQueue.push(glossiness.__isAMaterial__ ? 'MATERIAL_INPUT' : 'GL_UNIFORMS');
        this._changeQueue.push('u_glossiness');
        this._changeQueue.push(glossiness);
    }

    this._requestUpdate();
    return this;
};

/**
 * Returns material expression or scalar value for glossiness.
 *
 * @method getGlossiness
 * @returns {MaterialExpress|Number}
 */
Mesh.prototype.getGlossiness = function getGlossiness() {
    return this.value.expressions.glossiness || this.value.glossiness;
};

/**
 * Defines 3 element map which displaces the position of each vertex in world
 * space.
 *
 * @method setPositionOffset
 * @chainable
 *
 * @param {MaterialExpression|Array}
 * @param {Object} Optional tweening parameter
 * @param {Function} Callback
 * @chainable
 */
Mesh.prototype.setPositionOffset = function positionOffset(materialExpression) {
    var uniformValue;

    if (materialExpression.__isAMaterial__) {
        this.value.expressions.positionOffset = materialExpression;
        uniformValue = materialExpression;
    }
    else {
        this.value.expressions.positionOffset = null;
        this.value.positionOffset = materialExpression;
        uniformValue = this.value.positionOffset;
    }

    if (this._initialized) {
        this._changeQueue.push(materialExpression.__isAMaterial__ ? 'MATERIAL_INPUT' : 'GL_UNIFORMS');
        this._changeQueue.push('u_positionOffset');
        this._changeQueue.push(uniformValue);
    }

    this._requestUpdate();

    return this;
};

/**
 * Returns position offset.
 *
 * @method getPositionOffset
 * @returns {MaterialExpress|Number}
 */
Mesh.prototype.getPositionOffset = function getPositionOffset () {
    return this.value.expressions.positionOffset || this.value.positionOffset;
};

/**
 * Get the mesh's custom options.
 *
 * @method getDrawOptions
 * @returns {Object} Options
 */
Mesh.prototype.getMaterialExpressions = function getMaterialExpressions () {
    return this.value.expressions;
};

Mesh.prototype.getValue = function getValue () {
    return this.value;
};

Mesh.prototype._pushInvalidations = function pushInvalidations (expressionName) {
    var uniformKey;
    var expression = this.value.expressions[expressionName];
    if (expression) {
        var i = expression.invalidations.length;
        while (i--) {
            uniformKey = expression.invalidations.pop();
            this._node.sendDrawCommand('GL_UNIFORMS');
            this._node.sendDrawCommand(uniformKey);
            this._node.sendDrawCommand(expression.uniforms[uniformKey]);
        }
    }
};

/**
* Sends draw commands to the renderer
*
* @private
* @method onUpdate
*/
Mesh.prototype.onUpdate = function onUpdate() {
    var node = this._node;
    var queue = this._changeQueue;

    if (node) {
        node.sendDrawCommand('WITH');
        node.sendDrawCommand(node.getLocation());

        // If any invalidations exist, push them into the queue
        if (this.value.color && this.value.color.isActive()) {
            this._node.sendDrawCommand('GL_UNIFORMS');
            this._node.sendDrawCommand('u_baseColor');
            this._node.sendDrawCommand(this.value.color.getNormalizedRGB());
            this._node.requestUpdateOnNextTick(this._id);
        }
        if (this.value.glossiness && this.value.glossiness[0] && this.value.glossiness[0].isActive()) {
            this._node.sendDrawCommand('GL_UNIFORMS');
            this._node.sendDrawCommand('u_glossiness');
            var glossiness = this.value.glossiness[0].getNormalizedRGB();
            glossiness.push(this.value.glossiness[1]);
            this._node.sendDrawCommand(glossiness);
            this._node.requestUpdateOnNextTick(this._id);
        }
        else {
            this._requestingUpdate = false;
        }

        // If any invalidations exist, push them into the queue
        this._pushInvalidations('baseColor');
        this._pushInvalidations('positionOffset');

        for (var i = 0; i < queue.length; i++) {
            node.sendDrawCommand(queue[i]);
        }

        queue.length = 0;
    }

};

Mesh.prototype.onMount = function onMount (node, id) {
    this._node = node;
    this._id = id;

    this.draw();
};

Mesh.prototype.onDismount = function onDismount () {
    this._initialized = false;
    this._changeQueue.push('GL_REMOVE_MESH');

    this._requestUpdate();
};

Mesh.prototype.onShow = function onShow () {
    this._changeQueue.push('GL_MESH_VISIBILITY', true);

    this._requestUpdate();
};

Mesh.prototype.onHide = function onHide () {
    this._changeQueue.push('GL_MESH_VISIBILITY', false);

    this._requestUpdate();
};

/**
 * Receives transform change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onTransformChange = function onTransformChange (transform) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('u_transform');
        this._changeQueue.push(transform);
    }

    this._requestUpdate();
};

/**
 * Receives size change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onSizeChange = function onSizeChange (size) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('u_size');
        this._changeQueue.push(size);
    }

    this._requestUpdate();
};

/**
 * Receives opacity change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onOpacityChange = function onOpacityChange (opacity) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('u_opacity');
        this._changeQueue.push(opacity);
    }

    this._requestUpdate();
};

Mesh.prototype.onAddUIEvent = function onAddUIEvent (UIEvent) {
    //TODO
};

Mesh.prototype._requestUpdate = function _requestUpdate () {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

Mesh.prototype.init = function init () {
    this._initialized = true;
    this.onTransformChange(this._node.getTransform());
    this.onSizeChange(this._node.getSize());
    this.onOpacityChange(this._node.getOpacity());
    this._requestUpdate();
};

Mesh.prototype.draw = function draw () {
    this._inDraw = true;

    this.init();

    var value = this.getValue();

    if (value.geometry != null) this.setGeometry(value.geometry);
    if (value.color != null) this.setBaseColor(value.color);
    if (value.glossiness != null) this.setGlossiness.apply(this, value.glossiness);
    if (value.drawOptions != null) this.setDrawOptions(value.drawOptions);
    if (value.flatShading != null) this.setFlatShading(value.flatShading);

    if (value.expressions.normals != null) this.setNormals(value.expressions.normals);
    if (value.expressions.baseColor != null) this.setBaseColor(value.expressions.baseColor);
    if (value.expressions.glossiness != null) this.setGlossiness(value.expressions.glossiness);
    if (value.expressions.positionOffset != null) this.setPositionOffset(value.expressions.positionOffset);

    this._inDraw = false;
};

module.exports = Mesh;
},{"../webgl-geometries":105}],121:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Mesh: require('./Mesh'),
    PointLight: require('./lights/PointLight'),
    AmbientLight: require('./lights/AmbientLight'),
};

},{"./Mesh":120,"./lights/AmbientLight":122,"./lights/PointLight":124}],122:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Light = require('./Light');

/**
 * AmbientLight extends the functionality of Light. It sets the ambience in
 * the scene. Ambience is a light source that emits light in the entire
 * scene, evenly.
 *
 * @class AmbientLight
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * from the corresponding Render Node
 */
function AmbientLight(node) {
    Light.call(this, node);
    this.commands.color = 'GL_AMBIENT_LIGHT';
}

/**
* Returns the definition of the Class: 'AmbientLight'
*
* @method toString
* @return {string} definition
*/
AmbientLight.prototype.toString = function toString() {
    return 'AmbientLight';
};

/**
 * Extends Light constructor
 */
AmbientLight.prototype = Object.create(Light.prototype);

/**
 * Sets AmbientLight as the constructor
 */
AmbientLight.prototype.constructor = AmbientLight;

module.exports = AmbientLight;

},{"./Light":123}],123:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The blueprint for all light components for inheriting common functionality.
 *
 * @class Light
 * @constructor
 * @component
 * @param {Node} node The controlling node
 * from the corresponding Render Node
 */
function Light(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._requestingUpdate = false;
    this.queue = [];
    this._color;
    this.commands = { color: 'GL_LIGHT_COLOR' };
}

/**
* Returns the definition of the Class: 'Light'
*
* @method toString
* @return {String} definition
*/
Light.prototype.toString = function toString() {
    return 'Light';
};

/**
* Changes the color of the light, using the 'Color' utility component.
*
* @method setColor
* @param {Color} Color instance
* @chainable
*/
Light.prototype.setColor = function setColor(color) {
    if (!color.getNormalizedRGB) return false;
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._color = color;
    this.queue.push(this.commands.color);
    var rgb = this._color.getNormalizedRGB();
    this.queue.push(rgb[0]);
    this.queue.push(rgb[1]);
    this.queue.push(rgb[2]);
    return this;
};

/**
* Returns the current color.

* @method getColor
* @returns {Color} Color.
*/
Light.prototype.getColor = function getColor() {
    return this._color;
};

/**
* Sends draw commands to the renderer
*
* @private
* @method onUpdate
*/
Light.prototype.onUpdate = function onUpdate() {
    var path = this._node.getLocation();

    this._node
        .sendDrawCommand('WITH')
        .sendDrawCommand(path);

    var i = this.queue.length;
    while (i--) {
        this._node.sendDrawCommand(this.queue.shift());
    }

    if (this._color && this._color.isActive()) {
        this._node.sendDrawCommand(this.commands.color);
        var rgb = this._color.getNormalizedRGB();
        this._node.sendDrawCommand(rgb[0]);
        this._node.sendDrawCommand(rgb[1]);
        this._node.sendDrawCommand(rgb[2]);
        this._node.requestUpdateOnNextTick(this._id);
    } else {
        this._requestingUpdate = false;
    }
};

module.exports = Light;

},{}],124:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Light = require('./Light');

/**
 * PointLight extends the functionality of Light. PointLight is a light source
 * that emits light in all directions from a point in space.
 *
 * @class PointLight
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * from the corresponding Render Node
 */
function PointLight(node) {
    Light.call(this, node);
    this.commands.position = 'GL_LIGHT_POSITION';
    this.onTransformChange(node.getTransform());
}

/**
* Returns the definition of the Class: 'PointLight'
*
* @method toString
* @return {string} definition
*/
PointLight.prototype.toString = function toString() {
    return 'PointLight';
};

/**
 * Extends Light constructor
 */
PointLight.prototype = Object.create(Light.prototype);

/**
 * Sets PointLight as the constructor
 */
PointLight.prototype.constructor = PointLight;

/**
 * Receives transform change updates from the scene graph.
 *
 * @private
 */
PointLight.prototype.onTransformChange = function onTransformChange (transform) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this.queue.push(this.commands.position);
    this.queue.push(transform[12]);
    this.queue.push(transform[13]);
    this.queue.push(transform[14]);
};

module.exports = PointLight;

},{"./Light":123}],125:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Buffer is a private class that wraps the vertex data that defines
 * the the points of the triangles that webgl draws. Each buffer 
 * maps to one attribute of a mesh.
 * 
 * @class Buffer
 * @constructor
 * 
 * @param {Number} target The bind target of the buffer to update: ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER
 * @param {Object} type Array type to be used in calls to gl.bufferData.
 * @param {WebGLContext} gl The WebGL context that the buffer is hosted by.
 * 
 */
function Buffer(target, type, gl) {
    this.buffer = null;
    this.target = target;
    this.type = type;
    this.data = [];
    this.gl = gl;
}

/**
 * Creates a WebGL buffer if one does not yet exist and binds the buffer to
 * to the context.  Runs bufferData with appropriate data.
 * 
 * @method subData
 * 
 */
Buffer.prototype.subData = function subData() {
    var gl = this.gl;
    var data = [];

    // to prevent against maximum call-stack issue.
    for (var i = 0, chunk = 10000; i < this.data.length; i += chunk)
        data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));

    this.buffer = this.buffer || gl.createBuffer();
    gl.bindBuffer(this.target, this.buffer);
    gl.bufferData(this.target, new this.type(data), gl.STATIC_DRAW);
};

module.exports = Buffer;

},{}],126:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var INDICES = 'indices';

var Buffer = require('./Buffer');

/**
 * BufferRegistry is a class that manages allocation of buffers to
 * input geometries.
 * 
 * @class BufferRegistry
 * @constructor
 * 
 * @param {WebGLContext} context WebGL drawing context to be passed to buffers.
 */
function BufferRegistry(context) {
    this.gl = context;

    this.registry = {};
    this._dynamicBuffers = [];
    this._staticBuffers = [];
    
    this._arrayBufferMax = 30000;
    this._elementBufferMax = 30000;
}

/**
 * Binds and fills all the vertex data into webgl buffers.  Will reuse buffers if
 * possible.  Populates registry with the name of the buffer, the WebGL buffer
 * object, spacing of the attribute, the attribute's offset within the buffer, 
 * and finally the length of the buffer.  This information is later accessed by
 * the root to draw the buffers.
 *
 * @method allocate
 *
 * @param {Number} geometryId Id of the geometry instance that holds the buffers.
 * @param {String} name Key of the input buffer in the geometry.
 * @param {Array} value Flat array containing input data for buffer.
 * @param {Number} spacing The spacing, or itemSize, of the input buffer.
 * @param {Boolean} dynamic Boolean denoting whether a geometry is dynamic or static.
 */
BufferRegistry.prototype.allocate = function allocate(geometryId, name, value, spacing, dynamic) {
    var vertexBuffers = this.registry[geometryId] || (this.registry[geometryId] = { keys: [], values: [], spacing: [], offset: [], length: [] });

    var j = vertexBuffers.keys.indexOf(name);
    var isIndex = name === INDICES;
    var bufferFound = false;
    var newOffset;
    var offset = 0;
    var length;
    var buffer;
    var k;

    if (j === -1) {
        j = vertexBuffers.keys.length;
        length = isIndex ? value.length : Math.floor(value.length / spacing);

        if (!dynamic) {

            // Use a previously created buffer if available.

            for (k = 0; k < this._staticBuffers.length; k++) {
                
                if (isIndex === this._staticBuffers[k].isIndex) {
                    newOffset = this._staticBuffers[k].offset + value.length;
                    if ((!isIndex && newOffset < this._arrayBufferMax) || (isIndex && newOffset < this._elementBufferMax)) {
                        buffer = this._staticBuffers[k].buffer;
                        offset = this._staticBuffers[k].offset;
                        this._staticBuffers[k].offset += value.length;
                        bufferFound = true;
                        break;
                    }
                }
            }

            // Create a new static buffer in none were found.

            if (!bufferFound) {
                buffer = new Buffer(
                    isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                    isIndex ? Uint16Array : Float32Array,
                    this.gl
                );

                this._staticBuffers.push({ buffer: buffer, offset: value.length, isIndex: isIndex });
            }
        }
        else {

            // For dynamic geometries, always create new buffer.

            buffer = new Buffer(
                isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                isIndex ? Uint16Array : Float32Array,
                this.gl
            );

            this._dynamicBuffers.push({ buffer: buffer, offset: value.length, isIndex: isIndex });
        }

        // Update the registry for the spec with buffer information.

        vertexBuffers.keys.push(name);
        vertexBuffers.values.push(buffer);
        vertexBuffers.spacing.push(spacing);
        vertexBuffers.offset.push(offset);
        vertexBuffers.length.push(length);
    }
    
    var len = value.length;
    for (k = 0; k < len; k++) {
        vertexBuffers.values[j].data[offset + k] = value[k];
    }
    vertexBuffers.values[j].subData();
};

module.exports = BufferRegistry;

},{"./Buffer":125}],127:[function(require,module,exports){
'use strict';

/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Takes the original rendering contexts' compiler function
 * and augments it with added functionality for parsing and
 * displaying errors.
 *
 * @method debug
 *
 * @returns {Function}
 */
module.exports = function Debug() {
    return _augmentFunction(
        this.gl.compileShader,
        function(shader) {
            if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
                var errors = this.getShaderInfoLog(shader);
                var source = this.getShaderSource(shader);
                _processErrors(errors, source);
            }
        }
    );
};

// Takes a function, keeps the reference and replaces it by a closure that
// executes the original function and the provided callback.

function _augmentFunction(func, callback) {
    return function() {
        var res = func.apply(this, arguments);
        callback.apply(this, arguments);
        return res;
    };
}

// Parses errors and failed source code from shaders in order
// to build displayable error blocks.
// Inspired by Jaume Sanchez Elias.

function _processErrors(errors, source) {

    var css = 'body,html{background:#e3e3e3;font-family:monaco,monospace;font-size:14px;line-height:1.7em}' +
              '#shaderReport{left:0;top:0;right:0;box-sizing:border-box;position:absolute;z-index:1000;color:' +
              '#222;padding:15px;white-space:normal;list-style-type:none;margin:50px auto;max-width:1200px}' +
              '#shaderReport li{background-color:#fff;margin:13px 0;box-shadow:0 1px 2px rgba(0,0,0,.15);' +
              'padding:20px 30px;border-radius:2px;border-left:20px solid #e01111}span{color:#e01111;' +
              'text-decoration:underline;font-weight:700}#shaderReport li p{padding:0;margin:0}' +
              '#shaderReport li:nth-child(even){background-color:#f4f4f4}' +
              '#shaderReport li p:first-child{margin-bottom:10px;color:#666}';

    var el = document.createElement('style');
    document.getElementsByTagName('head')[0].appendChild(el);
    el.textContent = css;

    var report = document.createElement('ul');
    report.setAttribute('id', 'shaderReport');
    document.body.appendChild(report);

    var re = /ERROR: [\d]+:([\d]+): (.+)/gmi;
    var lines = source.split('\n');

    var m;
    while ((m = re.exec(errors)) != null) {
        if (m.index === re.lastIndex) re.lastIndex++;
        var li = document.createElement('li');
        var code = '<p><span>ERROR</span> "' + m[2] + '" in line ' + m[1] + '</p>';
        code += '<p><b>' + lines[m[1] - 1].replace(/^[ \t]+/g, '') + '</b></p>';
        li.innerHTML = code;
        report.appendChild(li);
    }
}

},{}],128:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var clone = require('../utilities/clone');
var keyValueToArrays = require('../utilities/keyValueToArrays');

var vertexWrapper = require('../webgl-shaders').vertex;
var fragmentWrapper = require('../webgl-shaders').fragment;
var Debug = require('./Debug');

var VERTEX_SHADER = 35633;
var FRAGMENT_SHADER = 35632;
var identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

var header = 'precision mediump float;\n';

var TYPES = {
    undefined: 'float ',
    1: 'float ',
    2: 'vec2 ',
    3: 'vec3 ',
    4: 'vec4 ',
    16: 'mat4 '
};

var inputTypes = {
    u_baseColor: 'vec4',
    u_normals: 'vert',
    u_glossiness: 'vec4',
    u_positionOffset: 'vert'
};

var masks =  {
    vert: 1,
    vec3: 2,
    vec4: 4,
    float: 8
};

/**
 * Uniform keys and values
 */
var uniforms = keyValueToArrays({
    u_perspective: identityMatrix,
    u_view: identityMatrix,
    u_resolution: [0, 0, 0],
    u_transform: identityMatrix,
    u_size: [1, 1, 1],
    u_time: 0,
    u_opacity: 1,
    u_metalness: 0,
    u_glossiness: [0, 0, 0, 0],
    u_baseColor: [1, 1, 1, 1],
    u_normals: [1, 1, 1],
    u_positionOffset: [0, 0, 0],
    u_lightPosition: identityMatrix,
    u_lightColor: identityMatrix,
    u_ambientLight: [0, 0, 0],
    u_flatShading: 0,
    u_numLights: 0
});

/**
 * Attributes keys and values
 */
var attributes = keyValueToArrays({
    a_pos: [0, 0, 0],
    a_texCoord: [0, 0],
    a_normals: [0, 0, 0]
});

/**
 * Varyings keys and values
 */
var varyings = keyValueToArrays({
    v_textureCoordinate: [0, 0],
    v_normal: [0, 0, 0],
    v_position: [0, 0, 0],
    v_eyeVector: [0, 0, 0]
});

/**
 * A class that handles interactions with the WebGL shader program
 * used by a specific context.  It manages creation of the shader program
 * and the attached vertex and fragment shaders.  It is also in charge of
 * passing all uniforms to the WebGLContext.
 *
 * @class Program
 * @constructor
 *
 * @param {WebGL_Context} gl Context to be used to create the shader program.
 */
function Program(gl, options) {
    this.gl = gl;
    this.textureSlots = 1;
    this.options = options || {};

    this.registeredMaterials = {};
    this.flaggedUniforms = [];
    this.cachedUniforms  = {};
    this.uniformTypes = [];

    this.definitionVec4 = [];
    this.definitionVec3 = [];
    this.definitionFloat = [];
    this.applicationVec3 = [];
    this.applicationVec4 = [];
    this.applicationFloat = [];
    this.applicationVert = [];
    this.definitionVert = [];

    this.resetProgram();
}

/**
 * Determines whether a material has already been registered to
 * the shader program.
 *
 * @method registerMaterial
 *
 * @param {String} name Name of target input of material.
 * @param {Object} material Compiled material object being verified.
 *
 * @return {Object} Current program.
 */
Program.prototype.registerMaterial = function registerMaterial(name, material) {
    var compiled = material;
    var type = inputTypes[name];
    var mask = masks[type];

    if ((this.registeredMaterials[material._id] & mask) === mask) return;

    var k;

    for (k in compiled.uniforms) {
        if (uniforms.keys.indexOf(k) === -1) {
            uniforms.keys.push(k);
            uniforms.values.push(compiled.uniforms[k]);
        }
    }

    for (k in compiled.varyings) {
        if (varyings.keys.indexOf(k) === -1) {
            varyings.keys.push(k);
            varyings.values.push(compiled.varyings[k]);
        }
    }

    for (k in compiled.attributes) {
        if (attributes.keys.indexOf(k) === -1) {
            attributes.keys.push(k);
            attributes.values.push(compiled.attributes[k]);
        }
    }

    this.registeredMaterials[material._id] |= mask;

    if (type === 'float') {
        this.definitionFloat.push(material.defines);
        this.definitionFloat.push('float fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationFloat.push('if (int(abs(ID)) == ' + material._id + ') return fa_' + material._id  + '();');
    }

    if (type === 'vec3') {
        this.definitionVec3.push(material.defines);
        this.definitionVec3.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVec3.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    if (type === 'vec4') {
        this.definitionVec4.push(material.defines);
        this.definitionVec4.push('vec4 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVec4.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    if (type === 'vert') {
        this.definitionVert.push(material.defines);
        this.definitionVert.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVert.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    return this.resetProgram();
};

/**
 * Clears all cached uniforms and attribute locations.  Assembles
 * new fragment and vertex shaders and based on material from
 * currently registered materials.  Attaches said shaders to new
 * shader program and upon success links program to the WebGL
 * context.
 *
 * @method resetProgram
 *
 * @return {Program} Current program.
 */
Program.prototype.resetProgram = function resetProgram() {
    var vertexHeader = [header];
    var fragmentHeader = [header];

    var fragmentSource;
    var vertexSource;
    var program;
    var name;
    var value;
    var i;

    this.uniformLocations   = [];
    this.attributeLocations = {};

    this.uniformTypes = {};

    this.attributeNames = clone(attributes.keys);
    this.attributeValues = clone(attributes.values);

    this.varyingNames = clone(varyings.keys);
    this.varyingValues = clone(varyings.values);

    this.uniformNames = clone(uniforms.keys);
    this.uniformValues = clone(uniforms.values);

    this.flaggedUniforms = [];
    this.cachedUniforms = {};

    fragmentHeader.push('uniform sampler2D u_textures[7];\n');

    if (this.applicationVert.length) {
        vertexHeader.push('uniform sampler2D u_textures[7];\n');
    }

    for(i = 0; i < this.uniformNames.length; i++) {
        name = this.uniformNames[i], value = this.uniformValues[i];
        vertexHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
        fragmentHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
    }

    for(i = 0; i < this.attributeNames.length; i++) {
        name = this.attributeNames[i], value = this.attributeValues[i];
        vertexHeader.push('attribute ' + TYPES[value.length] + name + ';\n');
    }

    for(i = 0; i < this.varyingNames.length; i++) {
        name = this.varyingNames[i], value = this.varyingValues[i];
        vertexHeader.push('varying ' + TYPES[value.length]  + name + ';\n');
        fragmentHeader.push('varying ' + TYPES[value.length] + name + ';\n');
    }

    vertexSource = vertexHeader.join('') + vertexWrapper
        .replace('#vert_definitions', this.definitionVert.join('\n'))
        .replace('#vert_applications', this.applicationVert.join('\n'));

    fragmentSource = fragmentHeader.join('') + fragmentWrapper
        .replace('#vec3_definitions', this.definitionVec3.join('\n'))
        .replace('#vec3_applications', this.applicationVec3.join('\n'))
        .replace('#vec4_definitions', this.definitionVec4.join('\n'))
        .replace('#vec4_applications', this.applicationVec4.join('\n'))
        .replace('#float_definitions', this.definitionFloat.join('\n'))
        .replace('#float_applications', this.applicationFloat.join('\n'));

    program = this.gl.createProgram();

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(VERTEX_SHADER), vertexSource)
    );

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(FRAGMENT_SHADER), fragmentSource)
    );

    this.gl.linkProgram(program);

    if (! this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        console.error('link error: ' + this.gl.getProgramInfoLog(program));
        this.program = null;
    }
    else {
        this.program = program;
        this.gl.useProgram(this.program);
    }

    this.setUniforms(this.uniformNames, this.uniformValues);

    var textureLocation = this.gl.getUniformLocation(this.program, 'u_textures[0]');
    this.gl.uniform1iv(textureLocation, [0, 1, 2, 3, 4, 5, 6]);

    return this;
};

/**
 * Compares the value of the input uniform value against
 * the cached value stored on the Program class.  Updates and
 * creates new entries in the cache when necessary.
 *
 * @method uniformIsCached
 *
 * @param {String} targetName Key of uniform spec being evaluated.
 * @param {Number|Array} value Value of uniform spec being evaluated.
 *
 * @return {Boolean} Value indicating whether the uniform being set
 * is cached.
 */
Program.prototype.uniformIsCached = function(targetName, value) {
    if(this.cachedUniforms[targetName] == null) {
        if (value.length) {
            this.cachedUniforms[targetName] = new Float32Array(value);
        }
        else {
            this.cachedUniforms[targetName] = value;
        }
        return false;
    }
    else if (value.length) {
        var i = value.length;
        while (i--) {
            if(value[i] !== this.cachedUniforms[targetName][i]) {
                i = value.length;
                while(i--) this.cachedUniforms[targetName][i] = value[i];
                return false;
            }
        }
    }

    else if (this.cachedUniforms[targetName] !== value) {
        this.cachedUniforms[targetName] = value;
        return false;
    }

    return true;
};

/**
 * Handles all passing of uniforms to WebGL drawing context.  This
 * function will find the uniform location and then, based on
 * a type inferred from the javascript value of the uniform, it will call
 * the appropriate function to pass the uniform to WebGL.  Finally,
 * setUniforms will iterate through the passed in shaderChunks (if any)
 * and set the appropriate uniforms to specify which chunks to use.
 *
 * @method setUniforms
 *
 * @param {Array} uniformNames Array containing the keys of all uniforms to be set.
 * @param {Array} uniformValue Array containing the values of all uniforms to be set.
 *
 * @return {Program} Current program.
 */
Program.prototype.setUniforms = function (uniformNames, uniformValue) {
    var gl = this.gl;
    var location;
    var value;
    var name;
    var len;
    var i;

    if (!this.program) return;

    len = uniformNames.length;
    for (i = 0; i < len; i++) {
        name = uniformNames[i];
        value = uniformValue[i];

        // Retreive the cached location of the uniform,
        // requesting a new location from the WebGL context
        // if it does not yet exist.

        location = this.uniformLocations[name] || gl.getUniformLocation(this.program, name);
        if (!location) continue;

        this.uniformLocations[name] = location;

        // Check if the value is already set for the
        // given uniform.

        if (this.uniformIsCached(name, value)) continue;

        // Determine the correct function and pass the uniform
        // value to WebGL.

        if (!this.uniformTypes[name]) {
            this.uniformTypes[name] = this.getUniformTypeFromValue(value);
        }

        // Call uniform setter function on WebGL context with correct value

        switch (this.uniformTypes[name]) {
            case 'uniform4fv':  gl.uniform4fv(location, value); break;
            case 'uniform3fv':  gl.uniform3fv(location, value); break;
            case 'uniform2fv':  gl.uniform2fv(location, value); break;
            case 'uniform1fv':  gl.uniform1fv(location, value); break;
            case 'uniform1f' :  gl.uniform1f(location, value); break;
            case 'uniformMatrix3fv': gl.uniformMatrix3fv(location, false, value); break;
            case 'uniformMatrix4fv': gl.uniformMatrix4fv(location, false, value); break;
        }
    }

    return this;
};

/**
 * Infers uniform setter function to be called on the WebGL context, based
 * on an input value.
 *
 * @method getUniformTypeFromValue
 *
 * @param {Number | Array} value Value from which uniform type is inferred.
 *
 * @return {String} Name of uniform function for given value.
 */
Program.prototype.getUniformTypeFromValue = function getUniformTypeFromValue(value) {
    if (Array.isArray(value) || value instanceof Float32Array) {
        switch (value.length) {
            case 1:  return 'uniform1fv';
            case 2:  return 'uniform2fv';
            case 3:  return 'uniform3fv';
            case 4:  return 'uniform4fv';
            case 9:  return 'uniformMatrix3fv';
            case 16: return 'uniformMatrix4fv';
        }
    }
    else if (!isNaN(parseFloat(value)) && isFinite(value)) {
        return 'uniform1f';
    }
    
    throw 'cant load uniform "' + name + '" with value:' + JSON.stringify(value);
};

/**
 * Adds shader source to shader and compiles the input shader.  Checks
 * compile status and logs error if necessary.
 *
 * @method compileShader
 *
 * @param {Object} shader Program to be compiled.
 * @param {String} source Source to be used in the shader.
 *
 * @return {Object} Compiled shader.
 */
Program.prototype.compileShader = function compileShader(shader, source) {
    var i = 1;

    if (this.options.debug) {
        this.gl.compileShader = Debug.call(this);
    }

    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error('compile error: ' + this.gl.getShaderInfoLog(shader));
        console.error('1: ' + source.replace(/\n/g, function () { return '\n' + (i+=1) + ': '; }));
    }

    return shader;
};

module.exports = Program;

},{"../utilities/clone":95,"../utilities/keyValueToArrays":97,"../webgl-shaders":136,"./Debug":127}],129:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Texture is a private class that stores image data
 * to be accessed from a shader or used as a render target.
 *
 * @class Texture
 * @constructor
 */
function Texture(gl, options) {
    options = options || {};
    this.id = gl.createTexture();
    this.width = options.width || 0;
    this.height = options.height || 0;
    this.mipmap = options.mipmap;
    this.format = options.format || 'RGBA';
    this.type = options.type || 'UNSIGNED_BYTE';
    this.gl = gl;

    this.bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[options.magFilter] || gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[options.minFilter] || gl.NEAREST);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[options.wrapS] || gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[options.wrapT] || gl.CLAMP_TO_EDGE);
}

/**
 * Binds this texture as the selected target.
 *
 * @method bind
 * @chainable
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.bind = function bind() {
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    return this;
};

/**
 * Erases the texture data in the given texture slot.
 *
 * @method unbind
 * @chainable
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.unbind = function unbind() {
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Replaces the image data in the texture with the given image.
 *
 * @method setImage
 * @chainable
 *
 * @param {Image} img The image object to upload pixel data from.
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.setImage = function setImage(img) {
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl[this.format], this.gl[this.format], this.gl[this.type], img);
    if (this.mipmap) this.gl.generateMipmap(this.gl.TEXTURE_2D);
    return this;
};

/**
 * Replaces the image data in the texture with an array of arbitrary data.
 *
 * @method setArray
 * @chainable
 *
 * @param {Array} input Array to be set as data to texture. 
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.setArray = function setArray(input) {
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl[this.format], this.width, this.height, 0, this.gl[this.format], this.gl[this.type], input);
    return this;
};

/**
 * Dumps the rgb-pixel contents of a texture into an array for debugging purposes
 *
 * @method readBack
 * @chainable
 *
 * @param {Number} x-offset between texture coordinates and snapshot
 * @param {Number} y-offset between texture coordinates and snapshot
 * @param {Number} x-depth of the snapshot
 * @param {Number} y-depth of the snapshot
 * 
 * @return {Array} An array of the pixels contained in the snapshot.
 */
Texture.prototype.readBack = function readBack(x, y, width, height) {
    var gl = this.gl;
    var pixels;
    x = x || 0;
    y = y || 0;
    width = width || this.width;
    height = height || this.height;
    var fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) {
        pixels = new Uint8Array(width * height * 4);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    }
    return pixels;
};

/*
 * Determines whether both input values are power-of-two numbers.
 *
 * @method isPowerOfTwo
 * @private
 *
 * @param {Number} width Number representing texture width.
 * @param {Number} height Number representing texture height.
 *
 * @return {Boolean} Boolean denoting whether the input dimensions
 * are both power-of-two values.
 */
function isPowerOfTwo(width, height) {
    return (width & width - 1) === 0 
        && (height & height - 1) === 0;
};

module.exports = Texture;

},{}],130:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
'use strict';

var Texture = require('./Texture');
var createCheckerboard = require('./createCheckerboard');

/**
 * Handles loading, binding, and resampling of textures for WebGLRenderer.
 *
 * @class TextureManager
 * @constructor
 *
 * @param {WebGL_Context} gl Context used to create and bind textures.
 */
function TextureManager(gl) {
    this.registry = [];
    this._needsResample = [];

    this._activeTexture = 0;
    this._boundTexture = null;
    
    this._checkerboard = createCheckerboard();

    this.gl = gl;
}

/**
 * Update function used by WebGLRenderer to queue resamples on 
 * registered textures.
 *
 * @method update
 *
 * @param {Number} time Time in milliseconds according to the compositor.
 */
TextureManager.prototype.update = function update(time) {
    var registryLength = this.registry.length;

    for (var i = 1; i < registryLength; i++) {
        var texture = this.registry[i];

        if (texture && texture.isLoaded && texture.resampleRate) {
            if (!texture.lastResample || time - texture.lastResample > texture.resampleRate) {
                if (!this._needsResample[texture.id]) {
                    this._needsResample[texture.id] = true;
                    texture.lastResample = time;
                }
            }
        }
    }
};

/**
 * Creates a spec and creates a texture based on given texture data.
 * Handles loading assets if necessary.
 *
 * @method register
 *
 * @param {Object} input Object containing texture id, texture data
 * and options used to draw texture.
 * @param {Number} slot Texture slot to bind generated texture to.
 */
TextureManager.prototype.register = function register(input, slot) {
    var source = input.data;
    var textureId = input.id;
    var options = input.options || {};
    var texture = this.registry[textureId];
    var spec;

    if (!texture) {

        texture = new Texture(this.gl, options);
        texture.setImage(this._checkerboard);

        // Add texture to registry

        spec = this.registry[textureId] = {
            resampleRate: options.resampleRate || null,
            lastResample: null,
            isLoaded: false,
            texture: texture,
            source: source,
            id: textureId,
            slot: slot
        };

        // Handle array

        if (Array.isArray(source) || source instanceof Uint8Array || source instanceof Float32Array) {
            this.bindTexture(textureId);
            texture.setArray(source);
            spec.isLoaded = true;
        }

        // Handle video

        else if (window && source instanceof window.HTMLVideoElement) {
            source.addEventListener('loadeddata', function() {
                this.bindTexture(textureId);
                texture.setImage(source);

                spec.isLoaded = true;
                spec.source = source;
            }.bind(this));
        }

        // Handle image url

        else if ('string' === typeof source) {
            loadImage(source, function (img) {
                this.bindTexture(textureId);
                texture.setImage(img);

                spec.isLoaded = true;
                spec.source = img;
            }.bind(this));
        }
    }

    return textureId;
};

/**
 * Loads an image from a string or Image object and executes a callback function.
 *
 * @method loadImage
 * @private
 *
 * @param {Object | String} img The input image data to load as an asset.
 * @param {Function} callback The callback function to be fired when
 * the image has finished loading.
 *
 * @return {Object} Image object being loaded.
 */
function loadImage (input, callback) {
    var image = (typeof input === 'string' ? new Image() : input) || {};
        image.crossOrigin = 'anonymous';

    if (!image.src) image.src = input;
    if (!image.complete) image.onload = function () { callback(image); };
    else callback(image);

    return image;
}

/**
 * Sets active texture slot and binds target texture.  Also handles 
 * resampling when necessary.
 *
 * @method bindTexture
 *
 * @param {Number} id Identifier used to retreive texture spec.
 */
TextureManager.prototype.bindTexture = function bindTexture(id) {
    var spec = this.registry[id];

    if (this._activeTexture !== spec.slot) {
        this.gl.activeTexture(this.gl.TEXTURE0 + spec.slot);
        this._activeTexture = spec.slot;
    }

    if (this._boundTexture !== id) {
        this._boundTexture = id;
        spec.texture.bind();
    }

    if (this._needsResample[spec.id]) {

        // TODO: Account for resampling of arrays.

        spec.texture.setImage(spec.source);
        this._needsResample[spec.id] = false;
    }
};

module.exports = TextureManager;
},{"./Texture":129,"./createCheckerboard":133}],131:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Texture = require('./Texture');
var Program = require('./Program');
var Buffer = require('./Buffer');
var BufferRegistry = require('./BufferRegistry');
var Plane = require('../webgl-geometries/primitives/Plane');
var sorter = require('./radixSort');
var keyValueToArrays = require('../utilities/keyValueToArrays');
var TextureManager = require('./TextureManager');
var compileMaterial = require('./compileMaterial');

var identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

var globalUniforms = keyValueToArrays({
    'u_numLights': 0,
    'u_ambientLight': new Array(3),
    'u_lightPosition': new Array(3),
    'u_lightColor': new Array(3),
    'u_perspective': new Array(16),
    'u_time': 0,
    'u_view': new Array(16)
});

/**
 * WebGLRenderer is a private class that manages all interactions with the WebGL
 * API.  Each frame it receives commands from the compositor and updates its
 * registries accordingly.  Subsequently, the draw function is called and the
 * WebGLRenderer issues draw calls for all meshes in its registry.
 *
 * @class WebGLRenderer
 * @constructor
 *
 * @param {Element} canvas          The DOM element that GL will paint itself
 *                                  onto.
 * @param {Compositor} compositor   Compositor used for querying the time from.
 *
 */
function WebGLRenderer(canvas, compositor) {
    this.canvas = canvas;
    this.compositor = compositor;
    
    for (var key in this.constructor.DEFAULT_STYLES) {
        this.canvas.style[key] = this.constructor.DEFAULT_STYLES[key];
    }

    var gl = this.gl = this.getWebGLContext(this.canvas);

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.polygonOffset(0.1, 0.1);
    gl.enable(gl.POLYGON_OFFSET_FILL);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.depthFunc(gl.LEQUAL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);

    this.meshRegistry = {};
    this.meshRegistryKeys = [];

    this.cutoutRegistry = {};
    
    this.cutoutRegistryKeys = [];

    /**
     * Lights
     */
    this.numLights = 0;
    this.ambientLightColor = [0, 0, 0];
    this.lightRegistry = {};
    this.lightRegistryKeys = [];
    this.lightPositions = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.lightColors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    this.textureManager = new TextureManager(gl);
    this.texCache = {};
    this.bufferRegistry = new BufferRegistry(gl);
    this.program = new Program(gl, { debug: true });

    this.state = {
        boundArrayBuffer: null,
        boundElementBuffer: null,
        lastDrawn: null,
        enabledAttributes: {},
        enabledAttributesKeys: []
    };

    this.resolutionName = ['u_resolution'];
    this.resolutionValues = [];

    this.cachedSize = [];

    /*
    The projectionTransform has some constant components, i.e. the z scale, and the x and y translation.

    The z scale keeps the final z position of any vertex within the clip's domain by scaling it by an
    arbitrarily small coefficient. This has the advantage of being a useful default in the event of the
    user forgoing a near and far plane, an alien convention in dom space as in DOM overlapping is
    conducted via painter's algorithm.

    The x and y translation transforms the world space origin to the top left corner of the screen.

    The final component (this.projectionTransform[15]) is initialized as 1 because certain projection models,
    e.g. the WC3 specified model, keep the XY plane as the projection hyperplane.
    */
    
    this.projectionTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -0.000001, 0, -1, 1, 0, 1];

    // TODO: remove this hack

    var cutout = this.cutoutGeometry = new Plane();

    this.bufferRegistry.allocate(cutout.spec.id, 'a_pos', cutout.spec.bufferValues[0], 3);
    this.bufferRegistry.allocate(cutout.spec.id, 'a_texCoord', cutout.spec.bufferValues[1], 2);
    this.bufferRegistry.allocate(cutout.spec.id, 'a_normals', cutout.spec.bufferValues[2], 3);
    this.bufferRegistry.allocate(cutout.spec.id, 'indices', cutout.spec.bufferValues[3], 1);
}

/**
 * Attempts to retreive the WebGLRenderer context using several
 * accessors.  For browser compatability.  Throws on error.
 *
 * @method getWebGLContext
 *
 * @param {Object} canvas Canvas element from which the context is retreived.
 *
 * @return {Object} WebGLContext of canvas element.
 */
WebGLRenderer.prototype.getWebGLContext = function getWebGLContext(canvas) {
    var names = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
    var context = null;
    for (var i = 0; i < names.length; i++) {
        try {
            context = canvas.getContext(names[i]);
        }
        catch (error) {
            var msg = 'Error creating WebGL context: ' + error.prototype.toString();
            console.error(msg);
        }
        if (context) {
            break;
        }
    }
    return context ? context : false;
};

/**
 * Adds a new base spec to the light registry at a given path.
 *
 * @method createLight
 *
 * @param {String} Path used as id of new light in lightRegistry.
 *
 * @return {Object} Newly created light spec.
 */
WebGLRenderer.prototype.createLight = function createLight(path) {
    this.numLights++;
    this.lightRegistryKeys.push(path);
    return this.lightRegistry[path] = {
        color: [0, 0, 0],
        position: [0, 0, 0]
    };
};

/**
 * Adds a new base spec to the mesh registry at a given path.
 *
 * @method createMesh
 *
 * @param {String} path Path used as id of new mesh in meshRegistry.
 *
 * @return {Object} Newly created mesh spec.
 */
WebGLRenderer.prototype.createMesh = function createMesh(path) {
    this.meshRegistryKeys.push(path);

    var uniforms = keyValueToArrays({
        u_opacity: 1,
        u_transform: identity,
        u_size: [0, 0, 0],
        u_baseColor: [0.5, 0.5, 0.5, 1],
        u_positionOffset: [0, 0, 0],
        u_normals: [0, 0, 0],
        u_flatShading: 0,
        u_glossiness: [0, 0, 0, 0]
    });
    return this.meshRegistry[path] = {
        depth: null,
        uniformKeys: uniforms.keys,
        uniformValues: uniforms.values,
        buffers: {},
        geometry: null,
        drawType: null,
        textures: [],
        visible: true
    };
};

/**
 * Sets flag on indicating whether to do skip draw phase for
 * cutout mesh at given path. 
 *
 * @method setCutoutState
 *
 * @param {String} path Path used as id of target cutout mesh.
 * @param {Boolean} usesCutout Indicates the presence of a 
 * cutout mesh.
 */
WebGLRenderer.prototype.setCutoutState = function setCutoutState(path, usesCutout) {
    var cutout = this.getOrSetCutout(path);

    cutout.visible = usesCutout;
};

/**
 * Creates or retreives cutout
 *
 * @method getOrSetCutout
 *
 * @param {String} path Path used as id of target cutout mesh.
 *
 * @return {Object} Newly created cutout spec.
 */
WebGLRenderer.prototype.getOrSetCutout = function getOrSetCutout(path) {
    var geometry;

    if (this.cutoutRegistry[path]) {
        return this.cutoutRegistry[path];
    }
    else {
        var uniforms = keyValueToArrays({
            u_opacity: 0,
            u_transform: identity.slice(),
            u_size: [0, 0, 0],
            u_origin: [0, 0, 0],
            u_baseColor: [0, 0, 0, 1]
        });

        this.cutoutRegistryKeys.push(path);

        return this.cutoutRegistry[path] = {
            uniformKeys: uniforms.keys,
            uniformValues: uniforms.values,
            geometry: this.cutoutGeometry.spec.id,
            drawType: this.cutoutGeometry.spec.type,
            visible: true
        };
    }
};

/**
 * Sets flag on indicating whether to do skip draw phase for
 * mesh at given path. 
 *
 * @method setMeshVisibility
 *
 * @param {String} path Path used as id of target mesh.
 * @param {Boolean} visibility Indicates the visibility of target mesh.
 */
WebGLRenderer.prototype.setMeshVisibility = function setMeshVisibility(path, visibility) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);
    
    mesh.visible = visibility;
};

/**
 * Deletes a mesh from the meshRegistry.
 *
 * @method removeMesh
 *
 * @param {String} path Path used as id of target mesh.
 */
WebGLRenderer.prototype.removeMesh = function removeMesh(path) {
    var keyLocation = this.meshRegistryKeys.indexOf(path);
    this.meshRegistryKeys.splice(keyLocation, 1);
    this.meshRegistry[path] = null;
};

/**
 * Creates or retreives cutout
 *
 * @method setCutoutUniform
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {String} uniformLocation identifier used to upload value
 * @param {Array} value of uniform data
 *
 */
WebGLRenderer.prototype.setCutoutUniform = function setCutoutUniform(path, uniformName, uniformValue) {
    var cutout = this.getOrSetCutout(path);

    var index = cutout.uniformKeys.indexOf(uniformName);

    if (Array.isArray(uniformValue)) {
        for (var i = 0, len = uniformValue.length; i < len; i++) {
            cutout.uniformValues[index][i] = uniformValue[i];
        }
    }
    else {
        cutout.uniformValues[index] = uniformValue;
    }
};

/**
 * Edits the options field on a mesh
 *
 * @method setMeshOptions
 *
 * @param {String} Path used as id of target mesh.
 * @param {Object} map of draw options for mesh
 *
**/
WebGLRenderer.prototype.setMeshOptions = function(path, options) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.options = options;
    return this;
};

/**
 * Changes the color of the fixed intensity lighting in the scene
 *
 * @method setAmbientLightColor
 *
 * @param {String} path used as id of light
 * @param {Number} red channel
 * @param {Number} green channel
 * @param {Number} blue channel
 *
**/
WebGLRenderer.prototype.setAmbientLightColor = function setAmbientLightColor(path, r, g, b) {
    this.ambientLightColor[0] = r;
    this.ambientLightColor[1] = g;
    this.ambientLightColor[2] = b;
    return this;
};

/**
 * Changes the location of the light in the scene
 *
 * @method setLightPosition
 *
 * @param {String} path used as id of light
 * @param {Number} x position
 * @param {Number} y position
 * @param {Number} z position
 *
**/
WebGLRenderer.prototype.setLightPosition = function setLightPosition(path, x, y, z) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.position[0] = x;
    light.position[1] = y;
    light.position[2] = z;
    return this;
};

/**
 * Changes the color of a dynamic intensity lighting in the scene
 *
 * @method setLightColor
 *
 * @param {String} path used as id of light in light Registry.
 * @param {Number} red channel
 * @param {Number} green channel
 * @param {Number} blue channel
 *
**/
WebGLRenderer.prototype.setLightColor = function setLightColor(path, r, g, b) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.color[0] = r;
    light.color[1] = g;
    light.color[2] = b;
    return this;
};

/**
 * Compiles material spec into program shader
 *
 * @method handleMateriaInput
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {String} which rendering input the material is bound to
 * @param {Object} material spec
 *
**/
WebGLRenderer.prototype.handleMaterialInput = function handleMaterialInput(path, name, material) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);
    var material = compileMaterial(material, mesh.textures.length);

    // Set uniforms to enable texture!

    mesh.uniformValues[mesh.uniformKeys.indexOf(name)][0] = -material._id;

    // Register textures!

    var i = material.textures.length;
    while (i--) {
        mesh.textures.push(
            this.textureManager.register(material.textures[i], mesh.textures.length + i)
        );
    }

    // Register material!

    this.program.registerMaterial(name, material);

    return this.updateSize();
};

/**
 * Changes the geometry data of a mesh
 *
 * @method setGeometry
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {Object} Geometry object containing vertex data to be drawn
 * @param {Number} primitive identifier
 * @param {Boolean} will the geometry data change?
 *
**/
WebGLRenderer.prototype.setGeometry = function setGeometry(path, geometry, drawType, dynamic) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.geometry = geometry;
    mesh.drawType = drawType;
    mesh.dynamic = dynamic;

    return this;
};

/**
 * Uploads a new value for the uniform data when the mesh is being drawn
 *
 * @method setMeshUniform
 *
 * @param {String} Path used as id of mesh in mesh registry
 * @param {String} uniformLocation identifier used to upload value
 * @param {Array} value of uniform data
 *
**/
WebGLRenderer.prototype.setMeshUniform = function setMeshUniform(path, uniformName, uniformValue) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    var index = mesh.uniformKeys.indexOf(uniformName);

    if (index === -1) {
        mesh.uniformKeys.push(uniformName);
        mesh.uniformValues.push(uniformValue);
    }
    else {
        mesh.uniformValues[index] = uniformValue;
    }
};

/**
 * Triggers the 'draw' phase of the WebGLRenderer.  Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method bufferData
 *
 * @param {String} Path used as id of mesh in mesh registry
 * @param {Number} Id of geometry in geometry registry
 * @param {String} Attribute location name
 * @param {Array} Vertex data
 * @param {Number} The dimensions of the vertex
 */
WebGLRenderer.prototype.bufferData = function bufferData(path, geometryId, bufferName, bufferValue, bufferSpacing, isDynamic) {
    this.bufferRegistry.allocate(geometryId, bufferName, bufferValue, bufferSpacing, isDynamic);

    return this;
};

/**
 * Triggers the 'draw' phase of the WebGLRenderer.  Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method draw
 *
 * @param {Object} renderState Parameters provided by the compositor, that
 * affect the rendering of all renderables.
 */
WebGLRenderer.prototype.draw = function draw(renderState) {
    var time = this.compositor.getTime();
    
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    this.textureManager.update(time);
    
    this.meshRegistryKeys = sorter(this.meshRegistryKeys, this.meshRegistry);

    this.setGlobalUniforms(renderState);
    this.drawCutouts();
    this.drawMeshes();
};

/**
 * Iterates through and draws all registered meshes.  This includes
 * binding textures, handling draw options, setting mesh uniforms
 * and drawing mesh buffers.
 *
 * @method drawMeshes
 */
WebGLRenderer.prototype.drawMeshes = function drawMeshes() {
    var gl = this.gl;
    var buffers;
    var mesh;

    for(var i = 0; i < this.meshRegistryKeys.length; i++) {
        mesh = this.meshRegistry[this.meshRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[mesh.geometry];

        if (!mesh.visible) continue;

        if (mesh.uniformValues[0] < 1) {
            gl.depthMask(false);
            gl.enable(gl.BLEND);
        } else {
            gl.depthMask(true);
            gl.disable(gl.BLEND);
        }

        if (!buffers) continue;

        var j = mesh.textures.length;
        while (j--) this.textureManager.bindTexture(mesh.textures[j]);
        
        if (mesh.options) this.handleOptions(mesh.options, mesh);
        
        this.program.setUniforms(mesh.uniformKeys, mesh.uniformValues);
        this.drawBuffers(buffers, mesh.drawType, mesh.geometry);

        if (mesh.options) this.resetOptions(mesh.options);
    }
};

/**
 * Iterates through and draws all registered cutout meshes.  Blending 
 * is disabled, cutout uniforms are set and finally buffers are drawn.
 *
 * @method drawCutouts
 */
WebGLRenderer.prototype.drawCutouts = function drawCutouts() {
    var cutout;
    var buffers;
    var len = this.cutoutRegistryKeys.length;

    if (len) this.gl.enable(this.gl.BLEND);

    for (var i = 0; i < len; i++) {
        cutout = this.cutoutRegistry[this.cutoutRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[cutout.geometry];

        if (!cutout.visible) continue;

        this.program.setUniforms(cutout.uniformKeys, cutout.uniformValues);
        this.drawBuffers(buffers, cutout.drawType, cutout.geometry);
    }

    if (len) this.gl.disable(this.gl.BLEND);
};

/**
 * Sets uniforms to be shared by all meshes.
 *
 * @method setGlobalUniforms
 *
 * @param {Object} renderState Draw state options passed down from compositor.
 */
WebGLRenderer.prototype.setGlobalUniforms = function setGlobalUniforms(renderState) {
    var light;
    var stride;

    for (var i = 0, len = this.lightRegistryKeys.length; i < len; i++) {
        light = this.lightRegistry[this.lightRegistryKeys[i]];
        stride = i * 4;

        // Build the light positions' 4x4 matrix

        this.lightPositions[0 + stride] = light.position[0];
        this.lightPositions[1 + stride] = light.position[1];
        this.lightPositions[2 + stride] = light.position[2];

        // Build the light colors' 4x4 matrix

        this.lightColors[0 + stride] = light.color[0];
        this.lightColors[1 + stride] = light.color[1];
        this.lightColors[2 + stride] = light.color[2];
    }

    globalUniforms.values[0] = this.numLights;
    globalUniforms.values[1] = this.ambientLightColor;
    globalUniforms.values[2] = this.lightPositions;
    globalUniforms.values[3] = this.lightColors;

    /*
     * Set time and projection uniforms
     * projecting world space into a 2d plane representation of the canvas.
     * The x and y scale (this.projectionTransform[0] and this.projectionTransform[5] respectively)
     * convert the projected geometry back into clipspace.
     * The perpective divide (this.projectionTransform[11]), adds the z value of the point
     * multiplied by the perspective divide to the w value of the point. In the process
     * of converting from homogenous coordinates to NDC (normalized device coordinates)
     * the x and y values of the point are divided by w, which implements perspective.
     */

    this.projectionTransform[0] = 1 / (this.cachedSize[0] * 0.5);
    this.projectionTransform[5] = -1 / (this.cachedSize[1] * 0.5);
    this.projectionTransform[11] = renderState.perspectiveTransform[11];

    globalUniforms.values[4] = this.projectionTransform;
    globalUniforms.values[5] = this.compositor.getTime() * 0.001;
    globalUniforms.values[6] = renderState.viewTransform;

    this.program.setUniforms(globalUniforms.keys, globalUniforms.values);
};

/**
 * Loads the buffers and issues the draw command for a geometry.
 *
 * @method drawBuffers
 *
 * @param {Object} vertexBuffers All buffers used to draw the geometry.
 * @param {Number} mode Enumerator defining what primitive to draw
 * @param {Number} id ID of geometry being drawn.
 */
WebGLRenderer.prototype.drawBuffers = function drawBuffers(vertexBuffers, mode, id) {
    var gl = this.gl;
    var length = 0;
    var attribute;
    var location;
    var spacing;
    var offset;
    var buffer;
    var iter;
    var j;

    iter = vertexBuffers.keys.length;
    for (var i = 0; i < iter; i++) {
        attribute = vertexBuffers.keys[i];

        // Do not set vertexAttribPointer if index buffer.

        if (attribute === 'indices') {
            j = i; continue;
        }

        // Retreive the attribute location and make sure it is enabled.

        location = this.program.attributeLocations[attribute];

        if (location === -1) continue;
        if (location === undefined) {
            location = gl.getAttribLocation(this.program.program, attribute);
            this.program.attributeLocations[attribute] = location;
            if (location === -1) continue;
        }

        if (!this.state.enabledAttributes[attribute]) {
            gl.enableVertexAttribArray(location);
            this.state.enabledAttributes[attribute] = true;
            this.state.enabledAttributesKeys.push(attribute);
        }

        // Retreive buffer information used to set attribute pointer.

        buffer = vertexBuffers.values[i];
        spacing = vertexBuffers.spacing[i];
        offset = vertexBuffers.offset[i];
        length = vertexBuffers.length[i];

        // Skip bindBuffer if buffer is currently bound.

        if (this.state.boundArrayBuffer !== buffer) {
            gl.bindBuffer(buffer.target, buffer.buffer);
            this.state.boundArrayBuffer = buffer;
        }

        if (this.state.lastDrawn !== id) {
            gl.vertexAttribPointer(location, spacing, gl.FLOAT, gl.FALSE, 0, 4 * offset);
        }
    }

    // Disable any attributes that not currently being used.

    for(var i = 0, len = this.state.enabledAttributesKeys.length; i < len; i++) {
        var key = this.state.enabledAttributesKeys[i];
        if (this.state.enabledAttributes[key] && vertexBuffers.keys.indexOf(key) === -1) {
            gl.disableVertexAttribArray(this.program.attributeLocations[key]);
            this.state.enabledAttributes[key] = false;
        }
    }

    if (length) {

        // If index buffer, use drawElements.

        if (j !== undefined) {
            buffer = vertexBuffers.values[j];
            offset = vertexBuffers.offset[j];
            spacing = vertexBuffers.spacing[j];
            length = vertexBuffers.length[j];

            // Skip bindBuffer if buffer is currently bound.

            if (this.state.boundElementBuffer !== buffer) {
                gl.bindBuffer(buffer.target, buffer.buffer);
                this.state.boundElementBuffer = buffer;
            }

            gl.drawElements(gl[mode], length, gl.UNSIGNED_SHORT, 2 * offset);
        }
        else {
            gl.drawArrays(gl[mode], 0, length);
        }
    }

    this.state.lastDrawn = id;
};

/**
 * Wraps draw methods in bound frame buffer
 *
 * @method renderOffscreen
 *
 * @param {Function} callback The render function to be called after setup and before cleanup.
 * @param {Array} size Size of framebuffer being drawn to.
 * @param {Object} texture Location where the render data is stored.
 */
function renderOffscreen(callback, size, texture) {
    var gl = this.gl;

    var framebuffer  = this.framebuffer ? this.framebuffer : this.framebuffer = gl.createFramebuffer();
    var renderbuffer = this.renderbuffer ? this.renderbuffer : this.renderbuffer = gl.createRenderbuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);

    if (size[0] != renderbuffer.width || size[1] != renderbuffer.height) {
        renderbuffer.width = size[0];
        renderbuffer.height = size[1];
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, size[0], size[1]);
    }

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.id, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    if (this.debug) checkFrameBufferStatus(gl);

    callback.call(this);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
};

/**
 * Diagnoses the failed intialization of an FBO.
 *
 * @method checkFrameBufferStatus
 *
 * @param {Object} the WebGLContext that owns this FBO.
 */
function checkFrameBufferStatus(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    switch (status) {
        case gl.FRAMEBUFFER_COMPLETE:
            break;
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"); break;
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"); break;
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"); break;
        case gl.FRAMEBUFFER_UNSUPPORTED:
            throw("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED"); break;
        default:
            throw("Incomplete framebuffer: " + status);
    }
};

/**
 * Updates the width and height of parent canvas, sets the viewport size on
 * the WebGL context and updates the resolution uniform for the shader program.
 * Size is retreived from the container object of the renderer.
 *
 * @method updateSize
 *
 * @param {Array} width, height and depth of canvas
 *
 */
WebGLRenderer.prototype.updateSize = function updateSize(size) {
    if (size) {
        this.cachedSize[0] = size[0];
        this.cachedSize[1] = size[1];
        this.cachedSize[2] = (size[0] > size[1]) ? size[0] : size[1];
    }

    this.gl.viewport(0, 0, this.cachedSize[0], this.cachedSize[1]);

    this.resolutionValues[0] = this.cachedSize;
    this.program.setUniforms(this.resolutionName, this.resolutionValues);

    return this;
};

/**
 * Updates the state of the WebGL drawing context based on custom parameters
 * defined on a mesh.
 *
 * @method handleOptions
 *
 * @param {Object} options Draw state options to be set to the context.
 */
WebGLRenderer.prototype.handleOptions = function handleOptions(options, mesh) {
    var gl = this.gl;
    if (!options) return;

    if (options.side === 'double') {
        this.gl.cullFace(this.gl.FRONT);
        this.drawBuffers(this.bufferRegistry.registry[mesh.geometry], mesh.drawType, mesh.geometry);
        this.gl.cullFace(this.gl.BACK);
    }

    if (options.blending) gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    if (options.side === 'back') gl.cullFace(gl.FRONT);
};

/**
 * Resets the state of the WebGL drawing context to default values.
 *
 * @method resetOptions
 *
 * @param {Object} options Draw state options to be set to the context.
 */
WebGLRenderer.prototype.resetOptions = function resetOptions(options) {
    var gl = this.gl;
    if (!options) return;
    if (options.blending) gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    if (options.side === 'back') gl.cullFace(gl.BACK);
};

WebGLRenderer.DEFAULT_STYLES = {
    pointerEvents: 'none',
    position: 'absolute',
    zIndex: 1,
    top: '0px',
    left: '0px'
};

module.exports = WebGLRenderer;

},{"../utilities/keyValueToArrays":97,"../webgl-geometries/primitives/Plane":112,"./Buffer":125,"./BufferRegistry":126,"./Program":128,"./Texture":129,"./TextureManager":130,"./compileMaterial":132,"./radixSort":135}],132:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
'use strict';

var types = {
    1: 'float ',
    2: 'vec2 ',
    3: 'vec3 ',
    4: 'vec4 '
};

/**
 * Traverses material to create a string of glsl code to be applied in
 * the vertex or fragment shader.
 *
 * @method _compile
 * @protected
 *
 * @param {Object} material Material to be compiled.
 * @param {Number} textureSlot Next available texture slot for Mesh.
 *
 */
function compileMaterial(material, textureSlot) {
    var glsl = '';
    var uniforms = {};
    var varyings = {};
    var attributes = {};
    var defines = [];
    var textures = [];

    _traverse(material, function (node, depth) {
        if (! node.chunk) return;
        
        var type = types[_getOutputLength(node)];
        var label = _makeLabel(node);
        var output = _processGLSL(node.chunk.glsl, node.inputs, textures.length + textureSlot);

        glsl += type + label + ' = ' + output + '\n ';

        if (node.uniforms) _extend(uniforms, node.uniforms);
        if (node.varyings) _extend(varyings, node.varyings);
        if (node.attributes) _extend(attributes, node.attributes);
        if (node.chunk.defines) defines.push(node.chunk.defines);
        if (node.texture) textures.push(node.texture);
    });

    return {
        _id: material._id,
        glsl: glsl + 'return ' + _makeLabel(material) + ';',
        defines: defines.join('\n'),
        uniforms: uniforms,
        varyings: varyings,
        attributes: attributes,
        textures: textures
    };
}

// Recursively iterates over a material's inputs, invoking a given callback
// with the current material

function _traverse(material, callback) {
	var inputs = material.inputs;
    var len = inputs && inputs.length;
    var idx = -1;
    var save;

    while (++idx < len) save = _traverse(inputs[idx], callback);

    callback(material);

    return material;
}

// Helper function used to infer length of the output
// from a given material node.

function _getOutputLength(node) {

    // Handle constant values

    if (typeof node === 'number') return 1;
    if (Array.isArray(node)) return node.length;

    // Handle materials
    
    var output = node.chunk.output;
    if (typeof output === 'number') return output;

    // Handle polymorphic output

    var key = node.inputs.map(function recurse(node) { return _getOutputLength(node); }).join(',');
    return output[key];
}

// Helper function to run replace inputs and texture tags with
// correct glsl.

function _processGLSL(str, inputs, textureSlot) {
    return str
        .replace(/%\d/g, function (s) {
            return _makeLabel(inputs[s[1]-1]);
        })
        .replace(/\$TEXTURE/, 'u_textures[' + textureSlot + ']');
}

// Helper function used to create glsl definition of the 
// input material node.

function _makeLabel (n) {
    if (Array.isArray(n)) return arrayToVec(n);
    if (typeof n == 'object') return 'fa_' + (n._id);
    else return n.toFixed(6);
}

// Helper to copy the properties of an object onto another object.

function _extend (a, b) {
	for (var k in b) a[k] = b[k];
}

// Helper to create glsl vector representation of a javascript array.

function _arrayToVec(array) {
    var len = array.length;
    return 'vec' + len + '(' + array.join(',')  + ')';
}

module.exports = compileMaterial;
},{}],133:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

// Generates a checkerboard pattern to be used as a placeholder texture while an
// image loads over the network.

function createCheckerBoard() {
    var context = document.createElement('canvas').getContext('2d');
    context.canvas.width = context.canvas.height = 128;
    for (var y = 0; y < context.canvas.height; y += 16) {
        for (var x = 0; x < context.canvas.width; x += 16) {
            context.fillStyle = (x ^ y) & 16 ? '#FFF' : '#DDD';
            context.fillRect(x, y, 16, 16);
        }
    }
    
    return context.canvas;
}

module.exports = createCheckerBoard;

},{}],134:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    Buffer: require('./Buffer'),
    BufferRegistry: require('./BufferRegistry'),
    createCheckerboard: require('./createCheckerboard'),
    Program: require('./Program'),
    WebGLRenderer: require('./WebGLRenderer'),
    Texture: require('./Texture')
};

},{"./Buffer":125,"./BufferRegistry":126,"./Program":128,"./Texture":129,"./WebGLRenderer":131,"./createCheckerboard":133}],135:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
'use strict';

var radixBits = 11,
    maxRadix = 1 << (radixBits),
    radixMask = maxRadix - 1,
    buckets = new Array(maxRadix * Math.ceil(64 / radixBits)),
    msbMask = 1 << ((32 - 1) % radixBits),
    lastMask = (msbMask << 1) - 1,
    passCount = ((32 / radixBits) + 0.999999999999999) | 0,
    maxOffset = maxRadix * (passCount - 1),
    normalizer = Math.pow(20, 6);

var buffer = new ArrayBuffer(4);
var floatView = new Float32Array(buffer, 0, 1);
var intView = new Int32Array(buffer, 0, 1);

function comp(list, registry, i) {
    var key = list[i];
    var item = registry[key];
    return (item.depth ? item.depth : registry[key].uniformValues[1][14]) + normalizer;
}

function mutator(list, registry, i, value) {
    var key = list[i];
    registry[key].depth = intToFloat(value) - normalizer;
    return key;
}
function clean(list, registry, i) {
    registry[list[i]].depth = null;
}

function floatToInt(k) {
    floatView[0] = k;
    return intView[0];
}

function intToFloat(k) {
    intView[0] = k;
    return floatView[0];
}

function sort(list, registry) {
    var pass = 0;
    var out = [];

    var i, j, k, n, div, offset, swap, id, sum, tsum, size;

    passCount = ((32 / radixBits) + 0.999999999999999) | 0;

    for (i = 0, n = maxRadix * passCount; i < n; i++) buckets[i] = 0;

    for (i = 0, n = list.length; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        div ^= div >> 31 | 0x80000000;
        for (j = 0, k = 0; j < maxOffset; j += maxRadix, k += radixBits) {
            buckets[j + (div >>> k & radixMask)]++;
        }
        buckets[j + (div >>> k & lastMask)]++;
    }

    for (j = 0; j <= maxOffset; j += maxRadix) {
        for (id = j, sum = 0; id < j + maxRadix; id++) {
            tsum = buckets[id] + sum;
            buckets[id] = sum - 1;
            sum = tsum;
        }
    }
    if (--passCount) {
        for (i = 0, n = list.length; i < n; i++) {
            div = floatToInt(comp(list, registry, i));
            out[++buckets[div & radixMask]] = mutator(list, registry, i, div ^= div >> 31 | 0x80000000);
        }
        swap = out, out = list, list = swap;
        while (++pass < passCount) {
            for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
                div = floatToInt(comp(list, registry, i));
                out[++buckets[offset + (div >>> size & radixMask)]] = list[i];
            }
            swap = out, out = list, list = swap;
        }
    }

    for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        out[++buckets[offset + (div >>> size & lastMask)]] = mutator(list, registry, i, div ^ (~div >> 31 | 0x80000000));
        clean(list, registry, i);
    }

    return out;

}

module.exports = sort;

},{}],136:[function(require,module,exports){
"use strict";
var glslify = require("glslify");
var shaders = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nmat3 a_x_getNormalMatrix(in mat4 t) {\n  mat3 matNorm;\n  mat4 a = t;\n  float a00 = a[0][0], a01 = a[0][1], a02 = a[0][2], a03 = a[0][3], a10 = a[1][0], a11 = a[1][1], a12 = a[1][2], a13 = a[1][3], a20 = a[2][0], a21 = a[2][1], a22 = a[2][2], a23 = a[2][3], a30 = a[3][0], a31 = a[3][1], a32 = a[3][2], a33 = a[3][3], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  det = 1.0 / det;\n  matNorm[0][0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  matNorm[0][1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  matNorm[0][2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  matNorm[1][0] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  matNorm[1][1] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  matNorm[1][2] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  matNorm[2][0] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  matNorm[2][1] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  matNorm[2][2] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return matNorm;\n}\nfloat b_x_inverse(float m) {\n  return 1.0 / m;\n}\nmat2 b_x_inverse(mat2 m) {\n  return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / (m[0][0] * m[1][1] - m[0][1] * m[1][0]);\n}\nmat3 b_x_inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\nmat4 b_x_inverse(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07, a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06, a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00, a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nfloat c_x_transpose(float m) {\n  return m;\n}\nmat2 c_x_transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0], m[0][1], m[1][1]);\n}\nmat3 c_x_transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2]);\n}\nmat4 c_x_transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0], m[0][1], m[1][1], m[2][1], m[3][1], m[0][2], m[1][2], m[2][2], m[3][2], m[0][3], m[1][3], m[2][3], m[3][3]);\n}\nvec4 applyTransform(vec4 pos) {\n  mat4 MVMatrix = u_view * u_transform;\n  pos.x += 1.0;\n  pos.y -= 1.0;\n  pos.xyz *= u_size * 0.5;\n  pos.y *= -1.0;\n  v_position = (MVMatrix * pos).xyz;\n  v_eyeVector = (u_resolution * 0.5) - v_position;\n  pos = u_perspective * MVMatrix * pos;\n  return pos;\n}\n#vert_definitions\n\nvec3 calculateOffset(vec3 ID) {\n  \n  #vert_applications\n  return vec3(0.0);\n}\nvoid main() {\n  v_textureCoordinate = a_texCoord;\n  vec3 invertedNormals = a_normals + (u_normals.x < 0.0 ? calculateOffset(u_normals) * 2.0 - 1.0 : vec3(0.0));\n  invertedNormals.y *= -1.0;\n  v_normal = c_x_transpose(mat3(b_x_inverse(u_transform))) * invertedNormals;\n  vec3 offsetPos = a_pos + calculateOffset(u_positionOffset);\n  gl_Position = applyTransform(vec4(offsetPos, 1.0));\n}", "\n#define GLSLIFY 1\n\n#float_definitions\n\nfloat a_x_applyMaterial(float ID) {\n  \n  #float_applications\n  return 1.;\n}\n#vec3_definitions\n\nvec3 a_x_applyMaterial(vec3 ID) {\n  \n  #vec3_applications\n  return vec3(0);\n}\n#vec4_definitions\n\nvec4 a_x_applyMaterial(vec4 ID) {\n  \n  #vec4_applications\n  return vec4(0);\n}\nvec4 b_x_applyLight(in vec4 baseColor, in vec3 normal, in vec4 glossiness) {\n  int numLights = int(u_numLights);\n  vec3 ambientColor = u_ambientLight * baseColor.rgb;\n  vec3 eyeVector = normalize(v_eyeVector);\n  vec3 diffuse = vec3(0.0);\n  bool hasGlossiness = glossiness.a > 0.0;\n  bool hasSpecularColor = length(glossiness.rgb) > 0.0;\n  for(int i = 0; i < 4; i++) {\n    if(i >= numLights)\n      break;\n    vec3 lightDirection = normalize(u_lightPosition[i].xyz - v_position);\n    float lambertian = max(dot(lightDirection, normal), 0.0);\n    if(lambertian > 0.0) {\n      diffuse += u_lightColor[i].rgb * baseColor.rgb * lambertian;\n      if(hasGlossiness) {\n        vec3 halfVector = normalize(lightDirection + eyeVector);\n        float specularWeight = pow(max(dot(halfVector, normal), 0.0), glossiness.a);\n        vec3 specularColor = hasSpecularColor ? glossiness.rgb : u_lightColor[i].rgb;\n        diffuse += specularColor * specularWeight * lambertian;\n      }\n    }\n  }\n  return vec4(ambientColor + diffuse, baseColor.a);\n}\nvoid main() {\n  vec4 material = u_baseColor.r >= 0.0 ? u_baseColor : a_x_applyMaterial(u_baseColor);\n  bool lightsEnabled = (u_flatShading == 0.0) && (u_numLights > 0.0 || length(u_ambientLight) > 0.0);\n  vec3 normal = normalize(v_normal);\n  vec4 glossiness = u_glossiness.x < 0.0 ? a_x_applyMaterial(u_glossiness) : u_glossiness;\n  vec4 color = lightsEnabled ? b_x_applyLight(material, normalize(v_normal), glossiness) : material;\n  gl_FragColor = color;\n  gl_FragColor.a *= u_opacity;\n}", [], []);
module.exports = shaders;
},{"glslify":51,"glslify/simple-adapter.js":52}],137:[function(require,module,exports){
'use strict';
var famous = require('famous');

famous.domRenderers = require('famous/dom-renderers');

module.exports = famous;

},{"famous":45,"famous/dom-renderers":40}],138:[function(require,module,exports){
'use strict';

window.FamousPlatform = require('famous-creative/scaffolding/FamousPlatform');

},{"famous-creative/scaffolding/FamousPlatform":137}]},{},[138])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29tcG9uZW50cy9BbGlnbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9jb21wb25lbnRzL0NhbWVyYS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9jb21wb25lbnRzL0dlc3R1cmVIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvbXBvbmVudHMvTW91bnRQb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9jb21wb25lbnRzL09wYWNpdHkuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29tcG9uZW50cy9PcmlnaW4uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29tcG9uZW50cy9Qb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9jb21wb25lbnRzL1JvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvbXBvbmVudHMvU2NhbGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29tcG9uZW50cy9TaXplLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvbXBvbmVudHMvVUlFdmVudEhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29tcG9uZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL0NoYW5uZWwuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29yZS9DbG9jay5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL0Rpc3BhdGNoLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvcmUvRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29yZS9GYW1vdXNFbmdpbmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29yZS9Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvcmUvU2NlbmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvY29yZS9TaXplLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvcmUvVHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2NvcmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmFibGVzL0RPTUVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmFibGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2RvbS1yZW5kZXJlcnMvRE9NUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9FbGVtZW50Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9NYXRoLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2RvbS1yZW5kZXJlcnMvZXZlbnRzL0NvbXBvc2l0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvRXZlbnRNYXAuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvRm9jdXNFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9kb20tcmVuZGVyZXJzL2V2ZW50cy9JbnB1dEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2RvbS1yZW5kZXJlcnMvZXZlbnRzL0tleWJvYXJkRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvTW91c2VFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9kb20tcmVuZGVyZXJzL2V2ZW50cy9Ub3VjaEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2RvbS1yZW5kZXJlcnMvZXZlbnRzL1VJRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvV2hlZWxFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9kb20tcmVuZGVyZXJzL2V2ZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9kb20tcmVuZGVyZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL2VuZ2luZS9Db250YWluZXJFbmdpbmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZW5naW5lL0VuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9lbmdpbmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvZW5naW5lL25vdy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9tYXRoL01hdDMzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL21hdGgvUXVhdGVybmlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9tYXRoL1ZlYzIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvbWF0aC9WZWMzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL21hdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZ2xzbGlmeS9zaW1wbGUtYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9waHlzaWNzL0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvUGh5c2ljc0VuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9waHlzaWNzL2JvZGllcy9Cb3guanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9ib2RpZXMvQ29udmV4Qm9keUZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9ib2RpZXMvUGFydGljbGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9ib2RpZXMvU3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvYm9kaWVzL1dhbGwuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9jb25zdHJhaW50cy9BbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9waHlzaWNzL2NvbnN0cmFpbnRzL0JhbGxBbmRTb2NrZXQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9jb25zdHJhaW50cy9Db2xsaXNpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9jb25zdHJhaW50cy9Db25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvY29uc3RyYWludHMvQ3VydmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9jb25zdHJhaW50cy9EaXJlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9jb25zdHJhaW50cy9EaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9waHlzaWNzL2NvbnN0cmFpbnRzL0hpbmdlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvY29uc3RyYWludHMvY29sbGlzaW9uL0FBQkIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9jb25zdHJhaW50cy9jb2xsaXNpb24vQnJ1dGVGb3JjZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9waHlzaWNzL2NvbnN0cmFpbnRzL2NvbGxpc2lvbi9Db250YWN0TWFuaWZvbGQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9jb25zdHJhaW50cy9jb2xsaXNpb24vQ29udmV4Q29sbGlzaW9uRGV0ZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvY29uc3RyYWludHMvY29sbGlzaW9uL1N3ZWVwQW5kUHJ1bmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9mb3JjZXMvRHJhZy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9waHlzaWNzL2ZvcmNlcy9Gb3JjZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9waHlzaWNzL2ZvcmNlcy9HcmF2aXR5MUQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9mb3JjZXMvR3Jhdml0eTNELmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvZm9yY2VzL1JvdGF0aW9uYWxEcmFnLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvZm9yY2VzL1JvdGF0aW9uYWxTcHJpbmcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcGh5c2ljcy9mb3JjZXMvU3ByaW5nLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BoeXNpY3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvcG9seWZpbGxzL2FuaW1hdGlvbkZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3BvbHlmaWxscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9yZW5kZXJlcnMvQ29tcG9zaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9yZW5kZXJlcnMvQ29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy9yZW5kZXJlcnMvVUlNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3JlbmRlcmVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy90cmFuc2l0aW9ucy9DdXJ2ZXMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvdHJhbnNpdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvdXRpbGl0aWVzL0NhbGxiYWNrU3RvcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvdXRpbGl0aWVzL0NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3V0aWxpdGllcy9LZXlDb2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy91dGlsaXRpZXMvT2JqZWN0TWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy91dGlsaXRpZXMvY2xhbXAuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvdXRpbGl0aWVzL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3V0aWxpdGllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy91dGlsaXRpZXMva2V5VmFsdWVUb0FycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy91dGlsaXRpZXMvbG9hZFVSTC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy91dGlsaXRpZXMvc3RyaXAuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvdXRpbGl0aWVzL3ZlbmRvclByZWZpeC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1nZW9tZXRyaWVzL0R5bmFtaWNHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1nZW9tZXRyaWVzL0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLWdlb21ldHJpZXMvR2VvbWV0cnlIZWxwZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtZ2VvbWV0cmllcy9PQkpMb2FkZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtZ2VvbWV0cmllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1nZW9tZXRyaWVzL3ByaW1pdGl2ZXMvQm94LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLWdlb21ldHJpZXMvcHJpbWl0aXZlcy9DaXJjbGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtZ2VvbWV0cmllcy9wcmltaXRpdmVzL0N5bGluZGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLWdlb21ldHJpZXMvcHJpbWl0aXZlcy9HZW9kZXNpY1NwaGVyZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1nZW9tZXRyaWVzL3ByaW1pdGl2ZXMvSWNvc2FoZWRyb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtZ2VvbWV0cmllcy9wcmltaXRpdmVzL1BhcmFtZXRyaWNDb25lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLWdlb21ldHJpZXMvcHJpbWl0aXZlcy9QbGFuZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1nZW9tZXRyaWVzL3ByaW1pdGl2ZXMvU3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLWdlb21ldHJpZXMvcHJpbWl0aXZlcy9UZXRyYWhlZHJvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1nZW9tZXRyaWVzL3ByaW1pdGl2ZXMvVG9ydXMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtZ2VvbWV0cmllcy9wcmltaXRpdmVzL1RyaWFuZ2xlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLW1hdGVyaWFscy9NYXRlcmlhbC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1tYXRlcmlhbHMvVGV4dHVyZVJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLW1hdGVyaWFscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJhYmxlcy9NZXNoLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXJlbmRlcmFibGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXJlbmRlcmFibGVzL2xpZ2h0cy9BbWJpZW50TGlnaHQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyYWJsZXMvbGlnaHRzL0xpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXJlbmRlcmFibGVzL2xpZ2h0cy9Qb2ludExpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXJlbmRlcmVycy9CdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL0J1ZmZlclJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXJlbmRlcmVycy9EZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvUHJvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvVGV4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvVGV4dHVyZU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL25vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL2NvbXBpbGVNYXRlcmlhbC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvY3JlYXRlQ2hlY2tlcmJvYXJkLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXJlbmRlcmVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMtY3JlYXRpdmUvbm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvcmFkaXhTb3J0LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy1jcmVhdGl2ZS9ub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXNoYWRlcnMvaW5kZXguanMiLCIvVXNlcnMvam9yZGFuUGFwYWxlby9Qcm9qZWN0cy9jcmVhdGl2ZS9mYy1jb250ZW50L2Jtdy9ub2RlX21vZHVsZXMvZmFtb3VzLWNyZWF0aXZlL3NjYWZmb2xkaW5nL0ZhbW91c1BsYXRmb3JtLmpzIiwiL1VzZXJzL2pvcmRhblBhcGFsZW8vUHJvamVjdHMvY3JlYXRpdmUvZmMtY29udGVudC9ibXcvc3JjL2ZhbW91c1BsYXRmb3JtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3huQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzUyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQSxZQUFZLENBQUM7QUFDYixJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRS9CLE1BQU0sQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7O0FBRXRELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOzs7QUNMeEIsWUFBWSxDQUFDOztBQUViLE1BQU0sQ0FBQyxjQUFjLEdBQUcsT0FBTyxDQUFDLDRDQUE0QyxDQUFDLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi9Qb3NpdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBBbGlnblxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IG5vZGUgTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBBbGlnbiBjb21wb25lbnRcbiAqL1xuXG5mdW5jdGlvbiBBbGlnbihub2RlKSB7XG4gICAgUG9zaXRpb24uY2FsbCh0aGlzLCBub2RlKTtcblxuICAgIHZhciBpbml0aWFsID0gbm9kZS5nZXRBbGlnbigpO1xuXG4gICAgdGhpcy5feC5zZXQoaW5pdGlhbFswXSk7XG4gICAgdGhpcy5feS5zZXQoaW5pdGlhbFsxXSk7XG4gICAgdGhpcy5fei5zZXQoaW5pdGlhbFsyXSk7XG59XG5cbkFsaWduLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQWxpZ24nO1xufTtcblxuQWxpZ24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb3NpdGlvbi5wcm90b3R5cGUpO1xuQWxpZ24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWxpZ247XG5cbkFsaWduLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRBbGlnbih0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuQWxpZ24ucHJvdG90eXBlLm9uVXBkYXRlID0gQWxpZ24ucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGlnbjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNsYXNzIENhbWVyYVxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge1JlbmRlck5vZGV9IFJlbmRlck5vZGUgdG8gd2hpY2ggdGhlIGluc3RhbmNlIG9mIENhbWVyYSB3aWxsIGJlIGEgY29tcG9uZW50IG9mXG4gKi9cbmZ1bmN0aW9uIENhbWVyYShub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IDA7XG4gICAgdGhpcy5fbmVhciA9IDA7XG4gICAgdGhpcy5fZmFyID0gMDtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgIHRoaXMuX3ZpZXdEaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLnNldEZsYXQoKTtcbn1cblxuQ2FtZXJhLkZSVVNUVU1fUFJPSkVDVElPTiA9IDA7XG5DYW1lcmEuUElOSE9MRV9QUk9KRUNUSU9OID0gMTtcbkNhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTiA9IDI7XG5cbkNhbWVyYS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0NhbWVyYSc7XG59O1xuXG5DYW1lcmEucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICAgIHByb2plY3Rpb25UeXBlOiB0aGlzLl9wcm9qZWN0aW9uVHlwZSxcbiAgICAgICAgZm9jYWxEZXB0aDogdGhpcy5fZm9jYWxEZXB0aCxcbiAgICAgICAgbmVhcjogdGhpcy5fbmVhcixcbiAgICAgICAgZmFyOiB0aGlzLl9mYXJcbiAgICB9O1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMudG9TdHJpbmcoKSA9PT0gc3RhdGUuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuc2V0KHN0YXRlLnByb2plY3Rpb25UeXBlLCBzdGF0ZS5mb2NhbERlcHRoLCBzdGF0ZS5uZWFyLCBzdGF0ZS5mYXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQodHlwZSwgZGVwdGgsIG5lYXIsIGZhcikge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSB0eXBlO1xuICAgIHRoaXMuX2ZvY2FsRGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLl9uZWFyID0gbmVhcjtcbiAgICB0aGlzLl9mYXIgPSBmYXI7XG59O1xuXG5DYW1lcmEucHJvdG90eXBlLnNldERlcHRoID0gZnVuY3Rpb24gc2V0RGVwdGgoZGVwdGgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3Byb2plY3Rpb25UeXBlID0gQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTjtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5fbmVhciA9IDA7XG4gICAgdGhpcy5fZmFyID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5zZXRGcnVzdHVtID0gZnVuY3Rpb24gc2V0RnJ1c3R1bShuZWFyLCBmYXIpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3Byb2plY3Rpb25UeXBlID0gQ2FtZXJhLkZSVVNUVU1fUFJPSkVDVElPTjtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gMDtcbiAgICB0aGlzLl9uZWFyID0gbmVhcjtcbiAgICB0aGlzLl9mYXIgPSBmYXI7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkNhbWVyYS5wcm90b3R5cGUuc2V0RmxhdCA9IGZ1bmN0aW9uIHNldEZsYXQoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gMDtcbiAgICB0aGlzLl9uZWFyID0gMDtcbiAgICB0aGlzLl9mYXIgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5DYW1lcmEucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoKSB7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHBhdGggPSB0aGlzLl9ub2RlLmdldExvY2F0aW9uKCk7XG5cbiAgICB0aGlzLl9ub2RlXG4gICAgICAgIC5zZW5kRHJhd0NvbW1hbmQoJ1dJVEgnKVxuICAgICAgICAuc2VuZERyYXdDb21tYW5kKHBhdGgpO1xuXG4gICAgaWYgKHRoaXMuX3BlcnNwZWN0aXZlRGlydHkpIHtcbiAgICAgICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJvamVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ2FtZXJhLkZSVVNUVU1fUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnRlJVU1RVTV9QUk9KRUNUSU9OJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fbmVhcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fZmFyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnUElOSE9MRV9QUk9KRUNUSU9OJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fZm9jYWxEZXB0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnT1JUSE9HUkFQSElDX1BST0pFQ1RJT04nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl92aWV3RGlydHkpIHtcbiAgICAgICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ0NIQU5HRV9WSUVXX1RSQU5TRk9STScpO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzBdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzNdKTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs1XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzddKTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzhdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs5XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTBdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxMV0pO1xuXG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTJdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxM10pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzE0XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTVdKTtcbiAgICB9XG59O1xuXG5cbkNhbWVyYS5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiBvblRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgYSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICBkZXQgPSAxLyhiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDYpO1xuXG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmE7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tTdG9yZSA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9DYWxsYmFja1N0b3JlJyk7XG52YXIgVmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMicpO1xuXG52YXIgVkVDX1JFR0lTVEVSID0gbmV3IFZlYzIoKTtcblxudmFyIGdlc3R1cmVzID0ge2RyYWc6IHRydWUsIHRhcDogdHJ1ZSwgcm90YXRlOiB0cnVlLCBwaW5jaDogdHJ1ZX07XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIG1hbmFnZSBnZXN0dXJlIGV2ZW50cy4gV2lsbCB0cmFjayAncGluY2gnLCAncm90YXRlJywgJ3RhcCcsIGFuZCAnZHJhZycgZXZlbnRzLCBvbiBhblxuICogYXMtcmVxdWVzdGVkIGJhc2lzLlxuICpcbiAqIEBjbGFzcyBHZXN0dXJlSGFuZGxlclxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBub2RlIFRoZSBub2RlIHdpdGggd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGhhbmRsZXIuXG4gKiBAcGFyYW0ge09iamVjdFtdfSBldmVudHMgQW4gYXJyYXkgb2YgZXZlbnQgb2JqZWN0cyBzcGVjaWZ5aW5nIC5ldmVudCBhbmQgLmNhbGxiYWNrIHByb3BlcnRpZXMuXG4gKi9cblxuZnVuY3Rpb24gR2VzdHVyZUhhbmRsZXIgKG5vZGUsIGV2ZW50cykge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5pZCA9IG5vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xuXG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IENhbGxiYWNrU3RvcmUoKTtcblxuICAgIHRoaXMubGFzdDEgPSBuZXcgVmVjMigpO1xuICAgIHRoaXMubGFzdDIgPSBuZXcgVmVjMigpO1xuXG4gICAgdGhpcy5kZWx0YTEgPSBuZXcgVmVjMigpO1xuICAgIHRoaXMuZGVsdGEyID0gbmV3IFZlYzIoKTtcblxuICAgIHRoaXMudmVsb2NpdHkxID0gbmV3IFZlYzIoKTtcbiAgICB0aGlzLnZlbG9jaXR5MiA9IG5ldyBWZWMyKCk7XG5cbiAgICB0aGlzLmRpc3QgPSAwO1xuICAgIHRoaXMuZGlmZjEyID0gbmV3IFZlYzIoKTtcblxuICAgIHRoaXMuY2VudGVyID0gbmV3IFZlYzIoKTtcbiAgICB0aGlzLmNlbnRlckRlbHRhID0gbmV3IFZlYzIoKTtcbiAgICB0aGlzLmNlbnRlclZlbG9jaXR5ID0gbmV3IFZlYzIoKTtcblxuICAgIHRoaXMucG9pbnRlcjEgPSB7XG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLmxhc3QxLFxuICAgICAgICBkZWx0YTogdGhpcy5kZWx0YTEsXG4gICAgICAgIHZlbG9jaXR5OiB0aGlzLnZlbG9jaXR5MSxcbiAgICB9O1xuXG4gICAgdGhpcy5wb2ludGVyMiA9IHtcbiAgICAgICAgcG9zaXRpb246IHRoaXMubGFzdDIsXG4gICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhMixcbiAgICAgICAgdmVsb2NpdHk6IHRoaXMudmVsb2NpdHkyLFxuICAgIH07XG5cbiAgICB0aGlzLmV2ZW50ID0ge1xuICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIHBvaW50ZXJzOiBbXSxcbiAgICAgICAgY2VudGVyOiB0aGlzLmNlbnRlcixcbiAgICAgICAgY2VudGVyRGVsdGE6IHRoaXMuY2VudGVyRGVsdGEsXG4gICAgICAgIGNlbnRlclZlbG9jaXR5OiB0aGlzLmNlbnRlclZlbG9jaXR5LFxuICAgICAgICBwb2ludHM6IDAsXG4gICAgICAgIGN1cnJlbnQ6IDBcbiAgICB9O1xuXG4gICAgdGhpcy50cmFja2VkUG9pbnRlcklEcyA9IFstMSwgLTFdO1xuICAgIHRoaXMudGltZU9mUG9pbnRlciA9IDA7XG4gICAgdGhpcy5tdWx0aVRhcCA9IDA7XG5cbiAgICB0aGlzLm1pY2UgPSBbXTtcblxuICAgIHRoaXMuZ2VzdHVyZXMgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRyYWNrZWRHZXN0dXJlcyA9IHt9O1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm9uKGV2ZW50c1tpXSwgZXZlbnRzW2ldLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuYWRkVUlFdmVudCgndG91Y2hzdGFydCcpO1xuICAgIG5vZGUuYWRkVUlFdmVudCgnbW91c2Vkb3duJyk7XG4gICAgbm9kZS5hZGRVSUV2ZW50KCd0b3VjaG1vdmUnKTtcbiAgICBub2RlLmFkZFVJRXZlbnQoJ21vdXNlbW92ZScpO1xuICAgIG5vZGUuYWRkVUlFdmVudCgndG91Y2hlbmQnKTtcbiAgICBub2RlLmFkZFVJRXZlbnQoJ21vdXNldXAnKTtcbiAgICBub2RlLmFkZFVJRXZlbnQoJ21vdXNlbGVhdmUnKTtcbn1cblxuR2VzdHVyZUhhbmRsZXIucHJvdG90eXBlLm9uUmVjZWl2ZSA9IGZ1bmN0aW9uIG9uUmVjZWl2ZSAoZXYsIHBheWxvYWQpIHtcbiAgICBzd2l0Y2goZXYpIHtcbiAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICBfcHJvY2Vzc1BvaW50ZXJTdGFydC5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgICBfcHJvY2Vzc1BvaW50ZXJNb3ZlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICAgIF9wcm9jZXNzUG9pbnRlckVuZC5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vdXNlbGVhdmUnOlxuICAgICAgICAgICAgX3Byb2Nlc3NNb3VzZUxlYXZlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbkdlc3R1cmVIYW5kbGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnR2VzdHVyZUhhbmRsZXInO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBldiBUaGUgZXZlbnQgb2JqZWN0IG9yIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2suXG4gKi9cbkdlc3R1cmVIYW5kbGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2LCBjYikge1xuICAgIHZhciBnZXN0dXJlID0gZXYuZXZlbnQgfHwgZXY7XG4gICAgaWYgKGdlc3R1cmVzW2dlc3R1cmVdKSB7XG4gICAgICAgIHRoaXMudHJhY2tlZEdlc3R1cmVzW2dlc3R1cmVdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuICAgICAgICBpZiAoZXYuZXZlbnQpIHRoaXMub3B0aW9uc1tnZXN0dXJlXSA9IGV2O1xuICAgICAgICB0aGlzLl9ldmVudHMub24oZ2VzdHVyZSwgY2IpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVHJpZ2dlciBnZXN0dXJlcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlcXVlc3RlZCwgaWYgdGhleSBvY2N1cmVkLlxuICpcbiAqIEBtZXRob2QgdHJpZ2dlckdlc3R1cmVzXG4gKi9cbkdlc3R1cmVIYW5kbGVyLnByb3RvdHlwZS50cmlnZ2VyR2VzdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMuZXZlbnQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZ2VzdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGdlc3R1cmUgPSB0aGlzLmdlc3R1cmVzW2ldO1xuICAgICAgICBzd2l0Y2ggKGdlc3R1cmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdwaW5jaCc6XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQucG9pbnRzID09PSAyKSB0aGlzLnRyaWdnZXIoZ2VzdHVyZSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0YXAnOlxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLnN0YXR1cyA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0cyA9IHRoaXMub3B0aW9ucy50YXAucG9pbnRzIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLm11bHRpVGFwID49IHB0cyAmJiBwYXlsb2FkLnBvaW50cyA+PSBwdHMpIHRoaXMudHJpZ2dlcihnZXN0dXJlLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHRoaXMudHJpZ2dlcihnZXN0dXJlLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihnZXN0dXJlLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVHJpZ2dlciB0aGUgY2FsbGJhY2sgYXNzb2NpYXRlZCB3aXRoIGFuIGV2ZW50LCBwYXNzaW5nIGluIGEgcGF5bG9hZC5cbiAqXG4gKiBAbWV0aG9kIHRyaWdnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldiBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFRoZSBldmVudCBwYXlsb2FkLlxuICovXG5HZXN0dXJlSGFuZGxlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fZXZlbnRzLnRyaWdnZXIoZXYsIHBheWxvYWQpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzIHVwIHRvIHRoZSBmaXJzdCB0d28gdG91Y2gvbW91c2UgbW92ZSBldmVudHMuIEV4aXQgb3V0IGlmIHRoZSBmaXJzdCB0d28gcG9pbnRzIGFyZSBhbHJlYWR5IGJlaW5nIHRyYWNrZWQuXG4gKlxuICogQG1ldGhvZCBfcHJvY2Vzc1BvaW50ZXJTdGFydFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9wcm9jZXNzUG9pbnRlclN0YXJ0KGUpIHtcbiAgICB2YXIgdDtcbiAgICBpZiAoIWUudGFyZ2V0VG91Y2hlcykge1xuICAgICAgICB0aGlzLm1pY2VbMF0gPSBlO1xuICAgICAgICB0ID0gdGhpcy5taWNlO1xuICAgICAgICBlLmlkZW50aWZpZXIgPSAxO1xuICAgIH1cbiAgICBlbHNlIHQgPSBlLnRhcmdldFRvdWNoZXM7XG5cbiAgICBpZiAodFswXSAmJiB0WzFdICYmIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPT09IHRbMF0uaWRlbnRpZmllciAmJiB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID09PSB0WzFdLmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnQudGltZSA9IERhdGUubm93KCk7XG5cbiAgICB2YXIgdGhyZXNob2xkO1xuICAgIHZhciBpZDtcblxuICAgIGlmICh0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdICE9PSB0WzBdLmlkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzLnRhcCkge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKHRoaXMub3B0aW9ucy50YXAgJiYgdGhpcy5vcHRpb25zLnRhcC50aHJlc2hvbGQpIHx8IDI1MDtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50LnRpbWUgLSB0aGlzLnRpbWVPZlBvaW50ZXIgPCB0aHJlc2hvbGQpIHRoaXMuZXZlbnQudGFwcysrO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmV2ZW50LnRhcHMgPSAxO1xuICAgICAgICAgICAgdGhpcy50aW1lT2ZQb2ludGVyID0gdGhpcy5ldmVudC50aW1lO1xuICAgICAgICAgICAgdGhpcy5tdWx0aVRhcCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMTtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludHMgPSAxO1xuICAgICAgICBpZCA9IHRbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9IGlkO1xuXG4gICAgICAgIHRoaXMubGFzdDEuc2V0KHRbMF0ucGFnZVgsIHRbMF0ucGFnZVkpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5MS5jbGVhcigpO1xuICAgICAgICB0aGlzLmRlbHRhMS5jbGVhcigpO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50ZXJzLnB1c2godGhpcy5wb2ludGVyMSk7XG4gICAgfVxuICAgIGlmICh0WzFdICYmIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gIT09IHRbMV0uaWRlbnRpZmllcikge1xuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMudGFwKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAodGhpcy5vcHRpb25zLnRhcCAmJiB0aGlzLm9wdGlvbnMudGFwLnRocmVzaG9sZCkgfHwgMjUwO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnQudGltZSAtIHRoaXMudGltZU9mUG9pbnRlciA8IHRocmVzaG9sZCkgdGhpcy5tdWx0aVRhcCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMjtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludHMgPSAyO1xuICAgICAgICBpZCA9IHRbMV0uaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSA9IGlkO1xuXG4gICAgICAgIHRoaXMubGFzdDIuc2V0KHRbMV0ucGFnZVgsIHRbMV0ucGFnZVkpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5Mi5jbGVhcigpO1xuICAgICAgICB0aGlzLmRlbHRhMi5jbGVhcigpO1xuXG4gICAgICAgIFZlYzIuYWRkKHRoaXMubGFzdDEsIHRoaXMubGFzdDIsIHRoaXMuY2VudGVyKS5zY2FsZSgwLjUpO1xuICAgICAgICB0aGlzLmNlbnRlckRlbHRhLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2VudGVyVmVsb2NpdHkuY2xlYXIoKTtcblxuICAgICAgICBWZWMyLnN1YnRyYWN0KHRoaXMubGFzdDIsIHRoaXMubGFzdDEsIHRoaXMuZGlmZjEyKTtcbiAgICAgICAgdGhpcy5kaXN0ID0gdGhpcy5kaWZmMTIubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzLnBpbmNoKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlID0gdGhpcy5ldmVudC5zY2FsZSB8fCAxO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZURlbHRhID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVWZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzLnJvdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbiA9IHRoaXMuZXZlbnQucm90YXRpb24gfHwgMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25EZWx0YSA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uVmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucHVzaCh0aGlzLnBvaW50ZXIyKTtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50LnN0YXR1cyA9ICdzdGFydCc7XG4gICAgaWYgKHRoaXMuZXZlbnQucG9pbnRzID09PSAxKSB7XG4gICAgICAgIHRoaXMuY2VudGVyLmNvcHkodGhpcy5sYXN0MSk7XG4gICAgICAgIHRoaXMuY2VudGVyRGVsdGEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jZW50ZXJWZWxvY2l0eS5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMucGluY2gpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZURlbHRhID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVWZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzLnJvdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uRGVsdGEgPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvblZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXJHZXN0dXJlcygpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdXAgdG8gdGhlIGZpcnN0IHR3byB0b3VjaC9tb3VzZSBtb3ZlIGV2ZW50cy5cbiAqXG4gKiBAbWV0aG9kIF9wcm9jZXNzUG9pbnRlck1vdmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfcHJvY2Vzc1BvaW50ZXJNb3ZlKGUpIHtcbiAgICB2YXIgdDtcbiAgICBpZiAoIWUudGFyZ2V0VG91Y2hlcykge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnQuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICB0aGlzLm1pY2VbMF0gPSBlO1xuICAgICAgICB0ID0gdGhpcy5taWNlO1xuICAgICAgICBlLmlkZW50aWZpZXIgPSAxO1xuICAgIH1cbiAgICBlbHNlIHQgPSBlLnRhcmdldFRvdWNoZXM7XG5cbiAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XG4gICAgdmFyIGR0ID0gdGltZSAtIHRoaXMuZXZlbnQudGltZTtcbiAgICBpZiAoZHQgPT09IDApIHJldHVybjtcbiAgICB2YXIgaW52RHQgPSAxMDAwIC8gZHQ7XG4gICAgdGhpcy5ldmVudC50aW1lID0gdGltZTtcblxuICAgIHRoaXMuZXZlbnQuY3VycmVudCA9IDE7XG4gICAgdGhpcy5ldmVudC5wb2ludHMgPSAxO1xuICAgIGlmICh0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdID09PSB0WzBdLmlkZW50aWZpZXIpIHtcbiAgICAgICAgVkVDX1JFR0lTVEVSLnNldCh0WzBdLnBhZ2VYLCB0WzBdLnBhZ2VZKTtcbiAgICAgICAgVmVjMi5zdWJ0cmFjdChWRUNfUkVHSVNURVIsIHRoaXMubGFzdDEsIHRoaXMuZGVsdGExKTtcbiAgICAgICAgVmVjMi5zY2FsZSh0aGlzLmRlbHRhMSwgaW52RHQsIHRoaXMudmVsb2NpdHkxKTtcbiAgICAgICAgdGhpcy5sYXN0MS5jb3B5KFZFQ19SRUdJU1RFUik7XG5cbiAgICB9XG4gICAgaWYgKHRbMV0pIHtcbiAgICAgICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMjtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludHMgPSAyO1xuICAgICAgICBWRUNfUkVHSVNURVIuc2V0KHRbMV0ucGFnZVgsIHRbMV0ucGFnZVkpO1xuICAgICAgICBWZWMyLnN1YnRyYWN0KFZFQ19SRUdJU1RFUiwgdGhpcy5sYXN0MiwgdGhpcy5kZWx0YTIpO1xuICAgICAgICBWZWMyLnNjYWxlKHRoaXMuZGVsdGEyLCBpbnZEdCwgdGhpcy52ZWxvY2l0eTIpO1xuICAgICAgICB0aGlzLmxhc3QyLmNvcHkoVkVDX1JFR0lTVEVSKTtcblxuICAgICAgICBWZWMyLmFkZCh0aGlzLmxhc3QxLCB0aGlzLmxhc3QyLCBWRUNfUkVHSVNURVIpLnNjYWxlKDAuNSk7XG4gICAgICAgIFZlYzIuc3VidHJhY3QoVkVDX1JFR0lTVEVSLCB0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXJEZWx0YSk7XG4gICAgICAgIFZlYzIuYWRkKHRoaXMudmVsb2NpdHkxLCB0aGlzLnZlbG9jaXR5MiwgdGhpcy5jZW50ZXJWZWxvY2l0eSkuc2NhbGUoMC41KTtcbiAgICAgICAgdGhpcy5jZW50ZXIuY29weShWRUNfUkVHSVNURVIpO1xuXG4gICAgICAgIFZlYzIuc3VidHJhY3QodGhpcy5sYXN0MiwgdGhpcy5sYXN0MSwgVkVDX1JFR0lTVEVSKTtcblxuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMucm90YXRlKSB7XG4gICAgICAgICAgICB2YXIgZG90ID0gVkVDX1JFR0lTVEVSLmRvdCh0aGlzLmRpZmYxMik7XG4gICAgICAgICAgICB2YXIgY3Jvc3MgPSBWRUNfUkVHSVNURVIuY3Jvc3ModGhpcy5kaWZmMTIpO1xuICAgICAgICAgICAgdmFyIHRoZXRhID0gLU1hdGguYXRhbjIoY3Jvc3MsIGRvdCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uICs9IHRoZXRhO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbkRlbHRhID0gdGhldGE7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uVmVsb2NpdHkgPSB0aGV0YSAqIGludkR0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpc3QgPSBWRUNfUkVHSVNURVIubGVuZ3RoKCk7XG4gICAgICAgIHZhciBzY2FsZSA9IGRpc3QgLyB0aGlzLmRpc3Q7XG4gICAgICAgIHRoaXMuZGlmZjEyLmNvcHkoVkVDX1JFR0lTVEVSKTtcbiAgICAgICAgdGhpcy5kaXN0ID0gZGlzdDtcblxuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMucGluY2gpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGUgKj0gc2NhbGU7XG4gICAgICAgICAgICBzY2FsZSAtPSAxLjA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlRGVsdGEgPSBzY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVWZWxvY2l0eSA9IHNjYWxlICogaW52RHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50LnN0YXR1cyA9ICdtb3ZlJztcbiAgICBpZiAodGhpcy5ldmVudC5wb2ludHMgPT09IDEpIHtcbiAgICAgICAgdGhpcy5jZW50ZXIuY29weSh0aGlzLmxhc3QxKTtcbiAgICAgICAgdGhpcy5jZW50ZXJEZWx0YS5jb3B5KHRoaXMuZGVsdGExKTtcbiAgICAgICAgdGhpcy5jZW50ZXJWZWxvY2l0eS5jb3B5KHRoaXMudmVsb2NpdHkxKTtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzLnBpbmNoKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlID0gMTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVEZWx0YSA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlVmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlcy5yb3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbkRlbHRhID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25WZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyR2VzdHVyZXMoKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHVwIHRvIHRoZSBmaXJzdCB0d28gdG91Y2gvbW91c2UgZW5kIGV2ZW50cy4gRXhpdCBvdXQgaWYgdGhlIHR3byBwb2ludHMgYmVpbmcgdHJhY2tlZCBhcmUgc3RpbGwgYWN0aXZlLlxuICpcbiAqIEBtZXRob2QgX3Byb2Nlc3NQb2ludGVyRW5kXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX3Byb2Nlc3NQb2ludGVyRW5kKGUpIHtcbiAgICB2YXIgdDtcbiAgICBpZiAoIWUudGFyZ2V0VG91Y2hlcykge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnQuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICB0aGlzLm1pY2UucG9wKCk7XG4gICAgICAgIHQgPSB0aGlzLm1pY2U7XG4gICAgfVxuICAgIGVsc2UgdCA9IGUudGFyZ2V0VG91Y2hlcztcblxuICAgIGlmICh0WzBdICYmIHRbMV0gJiYgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9PT0gdFswXS5pZGVudGlmaWVyICYmIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gPT09IHRbMV0uaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpZDtcblxuICAgIHRoaXMuZXZlbnQuc3RhdHVzID0gJ2VuZCc7XG4gICAgaWYgKCF0WzBdKSB7XG4gICAgICAgIHRoaXMuZXZlbnQuY3VycmVudCA9IDA7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPSAtMTtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSA9IC0xO1xuICAgICAgICB0aGlzLnRyaWdnZXJHZXN0dXJlcygpO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50ZXJzLnBvcCgpO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50ZXJzLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYodGhpcy50cmFja2VkUG9pbnRlcklEc1swXSAhPT0gdFswXS5pZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPSAtMTtcbiAgICAgICAgaWQgPSB0WzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPSBpZDtcblxuICAgICAgICB0aGlzLmxhc3QxLnNldCh0WzBdLnBhZ2VYLCB0WzBdLnBhZ2VZKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eTEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5kZWx0YTEuY2xlYXIoKTtcbiAgICB9XG4gICAgaWYgKCF0WzFdKSB7XG4gICAgICAgIHRoaXMuZXZlbnQuY3VycmVudCA9IDE7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gPSAtMTtcbiAgICAgICAgdGhpcy50cmlnZ2VyR2VzdHVyZXMoKTtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludHMgPSAxO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50ZXJzLnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdICE9PSB0WzFdLmlkZW50aWZpZXIpIHtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSA9IC0xO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50cyA9IDI7XG4gICAgICAgIGlkID0gdFsxXS5pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID0gaWQ7XG5cbiAgICAgICAgdGhpcy5sYXN0Mi5zZXQodFsxXS5wYWdlWCwgdFsxXS5wYWdlWSk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVsdGEyLmNsZWFyKCk7XG5cbiAgICAgICAgVmVjMi5hZGQodGhpcy5sYXN0MSwgdGhpcy5sYXN0MiwgdGhpcy5jZW50ZXIpLnNjYWxlKDAuNSk7XG4gICAgICAgIHRoaXMuY2VudGVyRGVsdGEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jZW50ZXJWZWxvY2l0eS5jbGVhcigpO1xuXG4gICAgICAgIFZlYzIuc3VidHJhY3QodGhpcy5sYXN0MiwgdGhpcy5sYXN0MSwgdGhpcy5kaWZmMTIpO1xuICAgICAgICB0aGlzLmRpc3QgPSB0aGlzLmRpZmYxMi5sZW5ndGgoKTtcbiAgICB9XG59XG5cbi8qKlxuICogVHJlYXRzIGEgbW91c2VsZWF2ZSBldmVudCBhcyBhIGdlc3R1cmUgZW5kLlxuICpcbiAqIEBtZXRob2QgX3Byb2Nlc3NNb3VzZUxlYXZlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJvY2Vzc01vdXNlTGVhdmUoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnQuY3VycmVudCkge1xuICAgICAgICB0aGlzLmV2ZW50LnN0YXR1cyA9ICdlbmQnO1xuICAgICAgICB0aGlzLmV2ZW50LmN1cnJlbnQgPSAwO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdID0gLTE7XG4gICAgICAgIHRoaXMudHJpZ2dlckdlc3R1cmVzKCk7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucG9wKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlc3R1cmVIYW5kbGVyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi9Qb3NpdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBNb3VudFBvaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gZGlzcGF0Y2ggTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBNb3VudFBvaW50IGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBNb3VudFBvaW50KG5vZGUpIHtcbiAgICBQb3NpdGlvbi5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgdmFyIGluaXRpYWwgPSBub2RlLmdldE1vdW50UG9pbnQoKTtcblxuICAgIHRoaXMuX3guc2V0KGluaXRpYWxbMF0pO1xuICAgIHRoaXMuX3kuc2V0KGluaXRpYWxbMV0pO1xuICAgIHRoaXMuX3ouc2V0KGluaXRpYWxbMl0pO1xufVxuXG5Nb3VudFBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnTW91bnRQb2ludCc7XG59O1xuXG5Nb3VudFBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9zaXRpb24ucHJvdG90eXBlKTtcbk1vdW50UG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91bnRQb2ludDtcblxuTW91bnRQb2ludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX25vZGUuc2V0TW91bnRQb2ludCh0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuTW91bnRQb2ludC5wcm90b3R5cGUub25VcGRhdGUgPSBNb3VudFBvaW50LnByb3RvdHlwZS51cGRhdGU7XG5cbm1vZHVsZS5leHBvcnRzID0gTW91bnRQb2ludDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUcmFuc2l0aW9uYWJsZSA9IHJlcXVpcmUoJy4uL3RyYW5zaXRpb25zL1RyYW5zaXRpb25hYmxlJyk7XG5cblxuLyoqXG4gKiBAY2xhc3MgT3BhY2l0eVxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkIGZyb20gY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZSBvZiB0aGUgT3BhY2l0eSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gT3BhY2l0eShub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl92YWx1ZSA9IG5ldyBUcmFuc2l0aW9uYWJsZSgxKTtcblxuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbn1cblxuT3BhY2l0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ09wYWNpdHknO1xufTtcblxuLyoqXG4qXG4qIFJldHJpZXZlcyBzdGF0ZSBvZiBPcGFjaXR5XG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7T2JqZWN0fSBjb250YWlucyBjb21wb25lbnQga2V5IHdoaWNoIGhvbGRzIHRoZSBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciBcbiogYW5kIHZhbHVlIGtleSB3aGljaCBjb250YWlucyB0aGUgbnVtZXJpYyB2YWx1ZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlOiB0aGlzLl92YWx1ZS5nZXQoKVxuICAgIH07XG59O1xuXG4vKipcbipcbiogU2V0dGVyIGZvciBPcGFjaXR5IHN0YXRlXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGNvbnRhaW5zIGNvbXBvbmVudCBrZXksIHdoaWNoIGhvbGRzIHN0cmluZ2lmaWVkIGNvbnN0cnVjdG9yLCBhbmQgYSB2YWx1ZSBrZXksIHdoaWNoIGNvbnRhaW5zIGEgbnVtZXJpYyB2YWx1ZSB1c2VkIHRvIHNldCBvcGFjaXR5IGlmIHRoZSBjb25zdHJ1Y3RvciB2YWx1ZSBtYXRjaGVzXG4qIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2V0IGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy50b1N0cmluZygpID09PSB2YWx1ZS5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5zZXQodmFsdWUudmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4qXG4qIFNldHRlciBmb3IgT3BhY2l0eSB3aXRoIGNhbGxiYWNrXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHVzZWQgdG8gc2V0IE9wYWNpdHlcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb2xsb3dpbmcgT3BhY2l0eSBzZXRcbiogQGNoYWluYWJsZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUuc2V0KHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbipcbiogR2V0dGVyIGZvciBPcGFjaXR5XG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7TnVtYmVyfVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUuZ2V0KCk7XG59O1xuXG4vKipcbipcbiogU3RvcHMgT3BhY2l0eSB0cmFuc2l0aW9uXG4qXG4qIEBtZXRob2RcbiogQGNoYWluYWJsZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0KCkge1xuICAgIHRoaXMuX3ZhbHVlLmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKXtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUuaXNBY3RpdmUoKTtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRPcGFjaXR5KHRoaXMuX3ZhbHVlLmdldCgpKTtcbiAgICBpZiAodGhpcy5fdmFsdWUuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5PcGFjaXR5LnByb3RvdHlwZS5vblVwZGF0ZSA9IE9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGFjaXR5O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi9Qb3NpdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBPcmlnaW5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZCBmcm9tIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGUgb2YgdGhlIE9yaWdpbiBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gT3JpZ2luKG5vZGUpIHtcbiAgICBQb3NpdGlvbi5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgdmFyIGluaXRpYWwgPSBub2RlLmdldE9yaWdpbigpO1xuXG4gICAgdGhpcy5feC5zZXQoaW5pdGlhbFswXSk7XG4gICAgdGhpcy5feS5zZXQoaW5pdGlhbFsxXSk7XG4gICAgdGhpcy5fei5zZXQoaW5pdGlhbFsyXSk7XG59XG5cbk9yaWdpbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ09yaWdpbic7XG59O1xuXG5PcmlnaW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb3NpdGlvbi5wcm90b3R5cGUpO1xuT3JpZ2luLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yaWdpbjtcblxuT3JpZ2luLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRPcmlnaW4odGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cbk9yaWdpbi5wcm90b3R5cGUub25VcGRhdGUgPSBPcmlnaW4ucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcmlnaW47XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCcuLi90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZScpO1xuXG4vKipcbiAqIEBjbGFzcyBQb3NpdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkIGZyb20gY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZSBvZiB0aGUgUG9zaXRpb24gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIFBvc2l0aW9uKG5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9pZCA9IG5vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xuICBcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgXG4gICAgdmFyIGluaXRpYWxQb3NpdGlvbiA9IG5vZGUuZ2V0UG9zaXRpb24oKTtcblxuICAgIHRoaXMuX3ggPSBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFBvc2l0aW9uWzBdKTtcbiAgICB0aGlzLl95ID0gbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxQb3NpdGlvblsxXSk7XG4gICAgdGhpcy5feiA9IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUG9zaXRpb25bMl0pO1xufVxuXG5Qb3NpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1Bvc2l0aW9uJztcbn07XG5cbi8qKlxuKlxuKiBHZXRzIG9iamVjdCBjb250YWluaW5nIHN0cmluZ2lmaWVkIGNvbnN0cnVjdG9yLCB4LCB5LCB6IGNvb3JkaW5hdGVzXG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7T2JqZWN0fVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudDogdGhpcy50b1N0cmluZygpLFxuICAgICAgICB4OiB0aGlzLl94LmdldCgpLFxuICAgICAgICB5OiB0aGlzLl95LmdldCgpLFxuICAgICAgICB6OiB0aGlzLl96LmdldCgpXG4gICAgfTtcbn07XG5cbi8qKlxuKlxuKiBTZXR0ZXIgZm9yIHBvc2l0aW9uIGNvb3JkaW5hdGVzXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtPYmplY3R9IHN0YXRlIE9iamVjdCAtLSBjb21wb25lbnQ6IHN0cmluZ2lmaWVkIGNvbnN0cnVjdG9yLCB4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyXG4qIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMudG9TdHJpbmcoKSA9PT0gc3RhdGUuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuc2V0KHN0YXRlLngsIHN0YXRlLnksIHN0YXRlLnopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4qXG4qIEdldHRlciBmb3IgWCBwb3NpdGlvblxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge051bWJlcn1cbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3guZ2V0KCk7XG59O1xuXG4vKipcbipcbiogR2V0dGVyIGZvciBZIHBvc2l0aW9uXG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7TnVtYmVyfVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5feS5nZXQoKTtcbn07XG5cbi8qKlxuKlxuKiBHZXR0ZXIgZm9yIFogcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtOdW1iZXJ9XG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldFogPSBmdW5jdGlvbiBnZXRaKCkge1xuICAgIHJldHVybiB0aGlzLl96LmdldCgpO1xufTtcblxuLyoqXG4qXG4qIEdldHRlciBmb3IgYW55IGFjdGl2ZSBjb29yZGluYXRlc1xuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3guaXNBY3RpdmUoKSB8fCB0aGlzLl95LmlzQWN0aXZlKCkgfHwgdGhpcy5fei5pc0FjdGl2ZSgpO1xufTtcblxuUG9zaXRpb24ucHJvdG90eXBlLl9jaGVja1VwZGF0ZSA9IGZ1bmN0aW9uIF9jaGVja1VwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMuX2lkKTtcbiAgICBlbHNlIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbn07XG5cblxuUG9zaXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRQb3NpdGlvbih0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuLyoqIFxuKlxuKiBJZiB0cnVlLCBjb21wb25lbnQgaXMgdG8gYmUgdXBkYXRlZCBvbiBuZXh0IGVuZ2luZSB0aWNrXG4qXG4qIEBtZXRob2RcbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUub25VcGRhdGUgPSBQb3NpdGlvbi5wcm90b3R5cGUudXBkYXRlO1xuXG4vKiogXG4qXG4qIFNldHRlciBmb3IgWCBwb3NpdGlvblxuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7TnVtYmVyfSB2YWwgdXNlZCB0byBzZXQgeCBjb29yZGluYXRlXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgaGFzaFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHNldHRpbmcgWFxuKiBAY2hhaW5hYmxlXG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiBzZXRYKHZhbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5feC5zZXQodmFsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogXG4qXG4qIFNldHRlciBmb3IgWSBwb3NpdGlvblxuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7TnVtYmVyfSB2YWwgdXNlZCB0byBzZXQgeSBjb29yZGluYXRlXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgaGFzaFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHNldHRpbmcgWVxuKiBAY2hhaW5hYmxlXG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiBzZXRZKHZhbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5feS5zZXQodmFsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogXG4qXG4qIFNldHRlciBmb3IgWiBwb3NpdGlvblxuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7TnVtYmVyfSB2YWwgdXNlZCB0byBzZXQgeiBjb29yZGluYXRlXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgaGFzaFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHNldHRpbmcgWlxuKiBAY2hhaW5hYmxlXG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldFogPSBmdW5jdGlvbiBzZXRaKHZhbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fei5zZXQodmFsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuKlxuKiBTZXR0ZXIgZm9yIFhZWiBwb3NpdGlvbiB3aXRoIGNhbGxiYWNrXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtOdW1iZXJ9IHggdXNlZCB0byBzZXQgeCBjb29yZGluYXRlXG4qIEBwYXJhbSB7TnVtYmVyfSB5IHVzZWQgdG8gc2V0IHkgY29vcmRpbmF0ZVxuKiBAcGFyYW0ge051bWJlcn0geiB1c2VkIHRvIHNldCB6IGNvb3JkaW5hdGVcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgc2V0dGluZyBlYWNoIGNvb3JkaW5hdGVcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBpZiAoeCAhPSBudWxsKSB0aGlzLl94LnNldCh4LCBvcHRpb25zLCB4Q2FsbGJhY2spO1xuICAgIGlmICh5ICE9IG51bGwpIHRoaXMuX3kuc2V0KHksIG9wdGlvbnMsIHlDYWxsYmFjayk7XG4gICAgaWYgKHogIT0gbnVsbCkgdGhpcy5fei5zZXQoeiwgb3B0aW9ucywgekNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qXG4qIFN0b3BzIHRyYW5zaXRpb24gb2YgUG9zaXRpb24gY29tcG9uZW50XG4qXG4qIEBtZXRob2RcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICB0aGlzLl94LmhhbHQoKTtcbiAgICB0aGlzLl95LmhhbHQoKTtcbiAgICB0aGlzLl96LmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9zaXRpb247XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9zaXRpb24gPSByZXF1aXJlKCcuL1Bvc2l0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIFJvdGF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gZGlzcGF0Y2ggTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBSb3RhdGlvbiBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gUm90YXRpb24obm9kZSkge1xuICAgIFBvc2l0aW9uLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG5vZGUuZ2V0Um90YXRpb24oKTtcblxuICAgIHZhciB4ID0gaW5pdGlhbFswXTtcbiAgICB2YXIgeSA9IGluaXRpYWxbMV07XG4gICAgdmFyIHogPSBpbml0aWFsWzJdO1xuICAgIHZhciB3ID0gaW5pdGlhbFszXTtcblxuICAgIHZhciB4eCA9IHggKiB4O1xuICAgIHZhciB5eSA9IHkgKiB5O1xuICAgIHZhciB6eiA9IHogKiB6O1xuXG4gICAgdmFyIHR5ID0gMiAqICh4ICogeiArIHkgKiB3KTtcbiAgICB0eSA9IHR5IDwgLTEgPyAtMSA6IHR5ID4gMSA/IDEgOiB0eTtcblxuICAgIHZhciByeCA9IE1hdGguYXRhbjIoMiAqICh4ICogdyAtIHkgKiB6KSwgMSAtIDIgKiAoeHggKyB5eSkpO1xuICAgIHZhciByeSA9IE1hdGguYXNpbih0eSk7XG4gICAgdmFyIHJ6ID0gTWF0aC5hdGFuMigyICogKHogKiB3IC0geCAqIHkpLCAxIC0gMiAqICh5eSArIHp6KSk7XG5cbiAgICB0aGlzLl94LnNldChyeCk7XG4gICAgdGhpcy5feS5zZXQocnkpO1xuICAgIHRoaXMuX3ouc2V0KHJ6KTtcbn1cblxuUm90YXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdSb3RhdGlvbic7XG59O1xuXG5Sb3RhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uLnByb3RvdHlwZSk7XG5Sb3RhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbjtcblxuUm90YXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9ub2RlLnNldFJvdGF0aW9uKHRoaXMuX3guZ2V0KCksIHRoaXMuX3kuZ2V0KCksIHRoaXMuX3ouZ2V0KCkpO1xuICAgIHRoaXMuX2NoZWNrVXBkYXRlKCk7XG59O1xuXG5Sb3RhdGlvbi5wcm90b3R5cGUub25VcGRhdGUgPSBSb3RhdGlvbi5wcm90b3R5cGUudXBkYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi9Qb3NpdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBTY2FsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkIGZyb20gY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZSBvZiB0aGUgU2NhbGUgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIFNjYWxlKG5vZGUpIHtcbiAgICBQb3NpdGlvbi5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIHRoaXMuX3guc2V0KDEpO1xuICAgIHRoaXMuX3kuc2V0KDEpO1xuICAgIHRoaXMuX3ouc2V0KDEpO1xufVxuXG5TY2FsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NjYWxlJztcbn07XG5cblNjYWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9zaXRpb24ucHJvdG90eXBlKTtcblNjYWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjYWxlO1xuXG5TY2FsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX25vZGUuc2V0U2NhbGUodGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cblNjYWxlLnByb3RvdHlwZS5vblVwZGF0ZSA9IFNjYWxlLnByb3RvdHlwZS51cGRhdGU7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCcuLi90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZScpO1xuXG4vKipcbiAqIFNpemUgY29tcG9uZW50IHVzZWQgZm9yIG1hbmFnaW5nIHRoZSBzaXplIG9mIHRoZSB1bmRlcmx5aW5nIFJlbmRlckNvbnRleHQuXG4gKiBTdXBwb3J0cyBhYnNvbHV0ZSBhbmQgcmVsYXRpdmUgKHByb3BvcnRpb25hbCBhbmQgZGlmZmVyZW50aWFsKSBzaXppbmcuXG4gKlxuICogQGNsYXNzIFNpemVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gbm9kZSBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZCBmcm9tXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRpbmcgUmVuZGVyTm9kZSBvZiB0aGUgU2l6ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gU2l6ZShub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgaW5pdGlhbFByb3BvcnRpb25hbFNpemUgPSBub2RlLmdldFByb3BvcnRpb25hbFNpemUoKTtcbiAgICB2YXIgaW5pdGlhbERpZmZlcmVudGlhbFNpemUgPSBub2RlLmdldERpZmZlcmVudGlhbFNpemUoKTtcbiAgICB2YXIgaW5pdGlhbEFic29sdXRlU2l6ZSA9IG5vZGUuZ2V0QWJzb2x1dGVTaXplKCk7XG5cbiAgICB0aGlzLl9wcm9wb3J0aW9uYWwgPSB7XG4gICAgICAgIHg6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUHJvcG9ydGlvbmFsU2l6ZVswXSksXG4gICAgICAgIHk6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUHJvcG9ydGlvbmFsU2l6ZVsxXSksXG4gICAgICAgIHo6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUHJvcG9ydGlvbmFsU2l6ZVsyXSlcbiAgICB9O1xuICAgIHRoaXMuX2RpZmZlcmVudGlhbCA9IHtcbiAgICAgICAgeDogbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxEaWZmZXJlbnRpYWxTaXplWzBdKSxcbiAgICAgICAgeTogbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxEaWZmZXJlbnRpYWxTaXplWzFdKSxcbiAgICAgICAgejogbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxEaWZmZXJlbnRpYWxTaXplWzJdKVxuICAgIH07XG4gICAgdGhpcy5fYWJzb2x1dGUgPSB7XG4gICAgICAgIHg6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsQWJzb2x1dGVTaXplWzBdKSxcbiAgICAgICAgeTogbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxBYnNvbHV0ZVNpemVbMV0pLFxuICAgICAgICB6OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbEFic29sdXRlU2l6ZVsyXSlcbiAgICB9O1xufVxuXG5TaXplLlJFTEFUSVZFID0gMDtcblNpemUuQUJTT0xVVEUgPSAxO1xuU2l6ZS5SRU5ERVIgPSAyO1xuU2l6ZS5ERUZBVUxUID0gU2l6ZS5SRUxBVElWRTtcblxuU2l6ZS5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uIHNldE1vZGUoeCwgeSwgeikge1xuICAgIHRoaXMuX25vZGUuc2V0U2l6ZU1vZGUoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5TaXplLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU2l6ZSc7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIGFic29sdXRlU2l6ZVZhbHVlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgY3VycmVudCB0eXBlIG9mIHNpemluZyBiZWluZyBhcHBsaWVkICgnYWJzb2x1dGUnKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbXBvbmVudCBjb21wb25lbnQgbmFtZSAoJ1NpemUnKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gKiBAcHJvcGVydHkge251bWJlcn0gelxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgcmVsYXRpdmVTaXplVmFsdWVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBjdXJyZW50IHR5cGUgb2Ygc2l6aW5nIGJlaW5nIGFwcGxpZWQgKCdyZWxhdGl2ZScpXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29tcG9uZW50IGNvbXBvbmVudCBuYW1lICgnU2l6ZScpXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGlmZmVyZW50aWFsXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlmZmVyZW50aWFsLnhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaWZmZXJlbnRpYWwueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpZmZlcmVudGlhbC56XG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcG9ydGlvbmFsXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvcG9ydGlvbmFsLnhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9wb3J0aW9uYWwueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb3BvcnRpb25hbC56XG4gKi9cblxuLyoqXG4qIFJldHVybnMgc2VyaWFsaXplZCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIGdldFZhbHVlXG4qXG4qIEByZXR1cm4ge2Fic29sdXRlU2l6ZVZhbHVlfHJlbGF0aXZlU2l6ZVZhbHVlfVxuKi9cblNpemUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZU1vZGU6IHRoaXMuX25vZGUudmFsdWUuc2l6ZU1vZGUsXG4gICAgICAgIGFic29sdXRlOiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9hYnNvbHV0ZS54LmdldCgpLFxuICAgICAgICAgICAgeTogdGhpcy5fYWJzb2x1dGUueS5nZXQoKSxcbiAgICAgICAgICAgIHo6IHRoaXMuX2Fic29sdXRlLnouZ2V0KClcbiAgICAgICAgfSxcbiAgICAgICAgZGlmZmVyZW50aWFsOiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9kaWZmZXJlbnRpYWwueC5nZXQoKSxcbiAgICAgICAgICAgIHk6IHRoaXMuX2RpZmZlcmVudGlhbC55LmdldCgpLFxuICAgICAgICAgICAgejogdGhpcy5fZGlmZmVyZW50aWFsLnouZ2V0KClcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcG9ydGlvbmFsOiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9wcm9wb3J0aW9uYWwueC5nZXQoKSxcbiAgICAgICAgICAgIHk6IHRoaXMuX3Byb3BvcnRpb25hbC55LmdldCgpLFxuICAgICAgICAgICAgejogdGhpcy5fcHJvcG9ydGlvbmFsLnouZ2V0KClcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiogVXBkYXRlcyBzdGF0ZSBvZiBjb21wb25lbnQuXG4qXG4qIEBtZXRob2Qgc2V0VmFsdWVcbipcbiogQHBhcmFtIHthYnNvbHV0ZVNpemVWYWx1ZXxyZWxhdGl2ZVNpemVWYWx1ZX0gc3RhdGUgc3RhdGUgZW5jb2RlZCBpbiBzYW1lXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCBhcyBzdGF0ZSByZXRyaWV2ZWRcbiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3VnaCBgZ2V0VmFsdWVgXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW4gaW5kaWNhdGluZ1xuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGV0aGVyIHRoZSBuZXcgc3RhdGUgaGFzXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZW4gYXBwbGllZFxuKi9cblNpemUucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy50b1N0cmluZygpID09PSBzdGF0ZS5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5zZXRNb2RlLmFwcGx5KHRoaXMsIHN0YXRlLnNpemVNb2RlKTtcbiAgICAgICAgaWYgKHN0YXRlLmFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFic29sdXRlKHN0YXRlLmFic29sdXRlLngsIHN0YXRlLmFic29sdXRlLnksIHN0YXRlLmFic29sdXRlLnopO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5kaWZmZXJlbnRpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWJzb2x1dGUoc3RhdGUuZGlmZmVyZW50aWFsLngsIHN0YXRlLmRpZmZlcmVudGlhbC55LCBzdGF0ZS5kaWZmZXJlbnRpYWwueik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnByb3BvcnRpb25hbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBYnNvbHV0ZShzdGF0ZS5wcm9wb3J0aW9uYWwueCwgc3RhdGUucHJvcG9ydGlvbmFsLnksIHN0YXRlLnByb3BvcnRpb25hbC56KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TaXplLnByb3RvdHlwZS5faXNBY3RpdmUgPSBmdW5jdGlvbiBfaXNBY3RpdmUodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnguaXNBY3RpdmUoKSB8fCB0eXBlLnkuaXNBY3RpdmUoKSB8fCB0eXBlLnouaXNBY3RpdmUoKTtcbn07XG5cblNpemUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKXtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9pc0FjdGl2ZSh0aGlzLl9hYnNvbHV0ZSkgfHxcbiAgICAgICAgdGhpcy5faXNBY3RpdmUodGhpcy5fcHJvcG9ydGlvbmFsKSB8fFxuICAgICAgICB0aGlzLl9pc0FjdGl2ZSh0aGlzLl9kaWZmZXJlbnRpYWwpXG4gICAgKTtcbn07XG5cblNpemUucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoKSB7XG4gICAgdmFyIGFicyA9IHRoaXMuX2Fic29sdXRlO1xuICAgIHRoaXMuX25vZGUuc2V0QWJzb2x1dGVTaXplKFxuICAgICAgICBhYnMueC5nZXQoKSxcbiAgICAgICAgYWJzLnkuZ2V0KCksXG4gICAgICAgIGFicy56LmdldCgpXG4gICAgKTtcbiAgICB2YXIgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb25hbDtcbiAgICB2YXIgZGlmZiA9IHRoaXMuX2RpZmZlcmVudGlhbDtcbiAgICB0aGlzLl9ub2RlLnNldFByb3BvcnRpb25hbFNpemUoXG4gICAgICAgIHByb3AueC5nZXQoKSxcbiAgICAgICAgcHJvcC55LmdldCgpLFxuICAgICAgICBwcm9wLnouZ2V0KClcbiAgICApO1xuICAgIHRoaXMuX25vZGUuc2V0RGlmZmVyZW50aWFsU2l6ZShcbiAgICAgICAgZGlmZi54LmdldCgpLFxuICAgICAgICBkaWZmLnkuZ2V0KCksXG4gICAgICAgIGRpZmYuei5nZXQoKVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMuX2lkKTtcbiAgICBlbHNlIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbn07XG5cblxuLyoqXG4qIEFwcGxpZXMgYWJzb2x1dGUgc2l6ZS5cbipcbiogQG1ldGhvZCBzZXRBYnNvbHV0ZVxuKiBAY2hhaW5hYmxlXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4geC1kaXJlY3Rpb24gKHdpZHRoKVxuKiBAcGFyYW0ge051bWJlcn0geSB1c2VkIHRvIHNldCBhYnNvbHV0ZSBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiogQHJldHVybiB7U2l6ZX0gdGhpc1xuKi9cblNpemUucHJvdG90eXBlLnNldEFic29sdXRlID0gZnVuY3Rpb24gc2V0QWJzb2x1dGUoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgYWJzID0gdGhpcy5fYWJzb2x1dGU7XG4gICAgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICBhYnMueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBhYnMueS5zZXQoeSwgb3B0aW9ucywgeUNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHogIT0gbnVsbCkge1xuICAgICAgICBhYnMuei5zZXQoeiwgb3B0aW9ucywgekNhbGxiYWNrKTtcbiAgICB9XG59O1xuXG4vKipcbiogQXBwbGllcyBwcm9wb3J0aW9uYWwgc2l6ZS5cbipcbiogQG1ldGhvZCBzZXRQcm9wb3J0aW9uYWxcbiogQGNoYWluYWJsZVxuKlxuKiBAcGFyYW0ge051bWJlcn0geCB1c2VkIHRvIHNldCBwcm9wb3J0aW9uYWwgc2l6ZSBpbiB4LWRpcmVjdGlvbiAod2lkdGgpXG4qIEBwYXJhbSB7TnVtYmVyfSB5IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHotZGlyZWN0aW9uIChkZXB0aClcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZVxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucyBoYXZlIGJlZW4gY29tcGxldGVkXG4qIEByZXR1cm4ge1NpemV9IHRoaXNcbiovXG5TaXplLnByb3RvdHlwZS5zZXRQcm9wb3J0aW9uYWwgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWwoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb25hbDtcbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIHByb3AueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBwcm9wLnkuc2V0KHksIG9wdGlvbnMsIHlDYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC56LnNldCh6LCBvcHRpb25zLCB6Q2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBBcHBsaWVzIGRpZmZlcmVudGlhbCBzaXplIHRvIFNpemUgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIHNldERpZmZlcmVudGlhbFxuKiBAY2hhaW5hYmxlXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGRpZmZlcmVudGlhbCBzaXplIGluIHgtZGlyZWN0aW9uICh3aWR0aClcbiogQHBhcmFtIHtOdW1iZXJ9IHkgdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4geS1kaXJlY3Rpb24gKGhlaWdodClcbiogQHBhcmFtIHtOdW1iZXJ9IHogdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiovXG5TaXplLnByb3RvdHlwZS5zZXREaWZmZXJlbnRpYWwgPSBmdW5jdGlvbiBzZXREaWZmZXJlbnRpYWwoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IHRoaXMuX2RpZmZlcmVudGlhbDtcbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBkaWZmLnkuc2V0KHksIG9wdGlvbnMsIHlDYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgZGlmZi56LnNldCh6LCBvcHRpb25zLCB6Q2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBSZXRyaWV2ZXMgdGhlIGNvbXB1dGVkIHNpemUgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBSZW5kZXJDb250ZXh0LlxuKlxuKiBAbWV0aG9kIGdldFxuKlxuKiBAcmV0dXJuIHtOdW1iZXJbXX0gc2l6ZSB0aHJlZSBkaW1lbnNpb25hbCBjb21wdXRlZCBzaXplXG4qL1xuU2l6ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5nZXRTaXplKCk7XG59O1xuXG4vKipcbiAqIEhhbHRzIGFsbCBjdXJyZW50bHkgYWN0aXZlIHNpemUgdHJhbnNpdGlvbnMuXG4gKlxuICogQG1ldGhvZCBoYWx0XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7U2l6ZX0gdGhpc1xuICovXG5TaXplLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCAoKSB7XG4gICAgdGhpcy5fcHJvcG9ydGlvbmFsLnguaGFsdCgpO1xuICAgIHRoaXMuX3Byb3BvcnRpb25hbC55LmhhbHQoKTtcbiAgICB0aGlzLl9wcm9wb3J0aW9uYWwuei5oYWx0KCk7XG4gICAgdGhpcy5fZGlmZmVyZW50aWFsLnguaGFsdCgpO1xuICAgIHRoaXMuX2RpZmZlcmVudGlhbC55LmhhbHQoKTtcbiAgICB0aGlzLl9kaWZmZXJlbnRpYWwuei5oYWx0KCk7XG4gICAgdGhpcy5fYWJzb2x1dGUueC5oYWx0KCk7XG4gICAgdGhpcy5fYWJzb2x1dGUueS5oYWx0KCk7XG4gICAgdGhpcy5fYWJzb2x1dGUuei5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpemU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCcuLi90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZScpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcblxudmFyIFFfUkVHSVNURVIgPSBuZXcgUXVhdGVybmlvbigpO1xudmFyIFEyX1JFR0lTVEVSID0gbmV3IFF1YXRlcm5pb24oKTtcblxuZnVuY3Rpb24gVmVjM1RyYW5zaXRpb25hYmxlKHgsIHksIHosIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMueCA9IG5ldyBUcmFuc2l0aW9uYWJsZSh4KTtcbiAgICB0aGlzLnkgPSBuZXcgVHJhbnNpdGlvbmFibGUoeSk7XG4gICAgdGhpcy56ID0gbmV3IFRyYW5zaXRpb25hYmxlKHopO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHt4OiB4LCB5OiB5LCB6OiB6fTtcbn1cblxuVmVjM1RyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdGhpcy5fdmFsdWVzLnggPSB0aGlzLnguZ2V0KCk7XG4gICAgdGhpcy5fdmFsdWVzLnkgPSB0aGlzLnkuZ2V0KCk7XG4gICAgdGhpcy5fdmFsdWVzLnogPSB0aGlzLnouZ2V0KCk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcztcbn07XG5cblZlYzNUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHgsIHksIHosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5kaXJ0eSgpO1xuXG4gICAgdmFyIGNiWCA9IG51bGw7XG4gICAgdmFyIGNiWSA9IG51bGw7XG4gICAgdmFyIGNiWiA9IG51bGw7XG5cbiAgICBpZiAoeiAhPSBudWxsKSBjYlogPSBjYWxsYmFjaztcbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIGNiWSA9IGNhbGxiYWNrO1xuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkgY2JYID0gY2FsbGJhY2s7XG5cbiAgICBpZiAoeCAhPSBudWxsKSB0aGlzLnguc2V0KHgsIG9wdGlvbnMsIGNiWCk7XG4gICAgaWYgKHkgIT0gbnVsbCkgdGhpcy55LnNldCh5LCBvcHRpb25zLCBjYlkpO1xuICAgIGlmICh6ICE9IG51bGwpIHRoaXMuei5zZXQoeiwgb3B0aW9ucywgY2JaKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuVmVjM1RyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnguaXNBY3RpdmUoKSB8fCB0aGlzLnkuaXNBY3RpdmUoKSB8fCB0aGlzLnouaXNBY3RpdmUoKTtcbn07XG5cblZlYzNUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLngucGF1c2UoKTtcbiAgICB0aGlzLnkucGF1c2UoKTtcbiAgICB0aGlzLnoucGF1c2UoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzNUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHRoaXMueC5yZXN1bWUoKTtcbiAgICB0aGlzLnkucmVzdW1lKCk7XG4gICAgdGhpcy56LnJlc3VtZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuVmVjM1RyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICB0aGlzLnguaGFsdCgpO1xuICAgIHRoaXMueS5oYWx0KCk7XG4gICAgdGhpcy56LmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzNUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbiBkaXJ0eSgpIHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zZm9ybS5fZGlydHkpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5fdHJhbnNmb3JtLl9pZCk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5fZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBRdWF0VHJhbnNpdGlvbmFibGUoeCwgeSwgeiwgdywgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fZnJvbnQgPSAwO1xuICAgIHRoaXMuX2VuZCA9IDA7XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLl90ID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuICAgIHRoaXMuX2Zyb21RID0gbmV3IFF1YXRlcm5pb24odywgeCwgeSwgeik7XG4gICAgdGhpcy5fdG9RID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICB0aGlzLl9xID0gbmV3IFF1YXRlcm5pb24odywgeCwgeSwgeik7XG59XG5cblF1YXRUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciB0ID0gdGhpcy5fdC5nZXQoKTtcbiAgICB2YXIgdywgeCwgeSwgejtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICB3aGlsZSAodCA+PSB0aGlzLl9mcm9udCArIDEpIHtcbiAgICAgICAgdGhpcy5fZnJvbnQrKztcbiAgICAgICAgdyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHggPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB5ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgeiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX3Euc2V0KHcsIHgsIHksIHopO1xuICAgICAgICB0aGlzLl9mcm9tUS5zZXQodywgeCwgeSwgeik7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggIT09IDApIHRoaXMuX3RvUS5zZXQocXVldWVbMF0sIHF1ZXVlWzFdLCBxdWV1ZVsyXSwgcXVldWVbM10pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoICE9PSAwKSB0aGlzLl9mcm9tUS5zbGVycCh0aGlzLl90b1EsIHQgLSB0aGlzLl9mcm9udCwgdGhpcy5fcSk7XG4gICAgcmV0dXJuIHRoaXMuX3E7XG59O1xuXG5RdWF0VHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh4LCB5LCB6LCB3LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fdHJhbnNmb3JtLl9kaXJ0eSkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl90cmFuc2Zvcm0uX2lkKTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLl9kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB0aGlzLl90b1Euc2V0KHcsIHgsIHksIHopO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2godywgeCwgeSwgeik7XG4gICAgdGhpcy5fZW5kKys7XG4gICAgdGhpcy5fdC5zZXQodGhpcy5fZW5kLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5RdWF0VHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3QuaXNBY3RpdmUoKTtcbn07XG5cblF1YXRUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLl90LnBhdXNlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5RdWF0VHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICB0aGlzLl90LnJlc3VtZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuUXVhdFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuX3QucmVzZXQoMCk7XG4gICAgdGhpcy5fcXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcm9udCA9IDA7XG4gICAgdGhpcy5fZW5kID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLm9yaWdpbiA9IG51bGw7XG4gICAgdGhpcy5tb3VudFBvaW50ID0gbnVsbDtcbiAgICB0aGlzLmFsaWduID0gbnVsbDtcbiAgICB0aGlzLnNjYWxlID0gbnVsbDtcbiAgICB0aGlzLnBvc2l0aW9uID0gbnVsbDtcbiAgICB0aGlzLnJvdGF0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1RyYW5zZm9ybSc7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4gJiYgdGhpcy5vcmlnaW4uZ2V0KCksXG4gICAgICAgIG1vdW50UG9pbnQ6IHRoaXMubW91bnRQb2ludCAmJiB0aGlzLm1vdW50UG9pbnQuZ2V0KCksXG4gICAgICAgIGFsaWduOiB0aGlzLmFsaWduICYmIHRoaXMuYWxpZ24uZ2V0KCksXG4gICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlICYmIHRoaXMuc2NhbGUuZ2V0KCksXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uICYmIHRoaXMucG9zaXRpb24uZ2V0KCksXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uICYmIHRoaXMucm90YXRpb24uZ2V0KClcbiAgICB9O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMudG9TdHJpbmcoKSA9PT0gc3RhdGUuY29tcG9uZW50KSB7XG4gICAgICAgIHN0YXRlLm9yaWdpbiAmJiB0aGlzLnNldE9yaWdpbihzdGF0ZS5vcmlnaW4ueCwgc3RhdGUub3JpZ2luLnksIHN0YXRlLm9yaWdpbi56KTtcbiAgICAgICAgc3RhdGUubW91bnRQb2ludCAmJiB0aGlzLnNldE1vdW50UG9pbnQoc3RhdGUubW91bnRQb2ludC54LCBzdGF0ZS5tb3VudFBvaW50LnksIHN0YXRlLm1vdW50UG9pbnQueik7XG4gICAgICAgIHN0YXRlLmFsaWduICYmIHRoaXMuc2V0QWxpZ24oc3RhdGUuYWxpZ24ueCwgc3RhdGUuYWxpZ24ueSwgc3RhdGUuYWxpZ24ueik7XG4gICAgICAgIHN0YXRlLnNjYWxlICYmIHRoaXMuc2V0U2NhbGUoc3RhdGUuc2NhbGUueCwgc3RhdGUuc2NhbGUueSwgc3RhdGUuc2NhbGUueik7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uICYmIHRoaXMuc2V0UG9zaXRpb24oc3RhdGUucG9zaXRpb24ueCwgc3RhdGUucG9zaXRpb24ueSwgc3RhdGUucG9zaXRpb24ueik7XG4gICAgICAgIHN0YXRlLnJvdGF0aW9uICYmIHRoaXMuc2V0Um90YXRpb24oc3RhdGUucm90YXRpb24ueCwgc3RhdGUucm90YXRpb24ueSwgc3RhdGUucm90YXRpb24ueiwgc3RhdGUucm90YXRpb24udyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldE9yaWdpbiA9IGZ1bmN0aW9uIHNldE9yaWdpbih4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5vcmlnaW4pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldE9yaWdpbigpO1xuICAgICAgICB0aGlzLm9yaWdpbiA9IG5ldyBWZWMzVHJhbnNpdGlvbmFibGUodlswXSwgdlsxXSwgdlsyXSwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMub3JpZ2luLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldE1vdW50UG9pbnQgPSBmdW5jdGlvbiBzZXRNb3VudFBvaW50KHgsIHksIHosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLm1vdW50UG9pbnQpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldE1vdW50UG9pbnQoKTtcbiAgICAgICAgdGhpcy5tb3VudFBvaW50ID0gbmV3IFZlYzNUcmFuc2l0aW9uYWJsZSh2WzBdLCB2WzFdLCB2WzJdLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5tb3VudFBvaW50LnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldEFsaWduID0gZnVuY3Rpb24gc2V0QWxpZ24oeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuYWxpZ24pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldEFsaWduKCk7XG4gICAgICAgIHRoaXMuYWxpZ24gPSBuZXcgVmVjM1RyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFsaWduLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuc2NhbGUpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldFNjYWxlKCk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjM1RyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjM1RyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnBvc2l0aW9uLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wb3NpdGlvbikge1xuICAgICAgICB2YXIgdiA9IHRoaXMuX25vZGUuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzVHJhbnNpdGlvbmFibGUodlswXSwgdlsxXSwgdlsyXSwgdGhpcyk7XG4gICAgfVxuICAgIHZhciBwID0gdGhpcy5wb3NpdGlvbjtcbiAgICB2YXIgeHEgPSBwLnguX3F1ZXVlO1xuICAgIHZhciB5cSA9IHAueS5fcXVldWU7XG4gICAgdmFyIHpxID0gcC56Ll9xdWV1ZTtcbiAgICB2YXIgeEVuZCA9IHggPT0gbnVsbCA/IG51bGwgOiB4ICsgKHhxLmxlbmd0aCA+IDAgPyB4cVt4cS5sZW5ndGggLSA0XSA6IHAueC5fZW5kKTtcbiAgICB2YXIgeUVuZCA9IHkgPT0gbnVsbCA/IG51bGwgOiB5ICsgKHlxLmxlbmd0aCA+IDAgPyB5cVt5cS5sZW5ndGggLSA0XSA6IHAueS5fZW5kKTtcbiAgICB2YXIgekVuZCA9IHogPT0gbnVsbCA/IG51bGwgOiB6ICsgKHpxLmxlbmd0aCA+IDAgPyB6cVt6cS5sZW5ndGggLSA0XSA6IHAuei5fZW5kKTtcbiAgICB0aGlzLnBvc2l0aW9uLnNldCh4RW5kLCB5RW5kLCB6RW5kLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gc2V0Um90YXRpb24oeCwgeSwgeiwgdywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucm90YXRpb24pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldFJvdGF0aW9uKCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgUXVhdFRyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgcSA9IFFfUkVHSVNURVI7XG4gICAgaWYgKHR5cGVvZiB3ID09PSAnbnVtYmVyJykge1xuICAgICAgICBxLnNldCh3LCB4LCB5LCB6KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHEuZnJvbUV1bGVyKHgsIHksIHopO1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB3O1xuICAgIH1cbiAgICB0aGlzLnJvdGF0aW9uLnNldChxLngsIHEueSwgcS56LCBxLncsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHksIHosIHcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5fbm9kZS5nZXRSb3RhdGlvbigpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gbmV3IFF1YXRUcmFuc2l0aW9uYWJsZSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5yb3RhdGlvbi5fcXVldWU7XG4gICAgdmFyIGxlbiA9IHRoaXMucm90YXRpb24uX3F1ZXVlLmxlbmd0aDtcbiAgICB2YXIgcmVmZXJlbmNlUTtcbiAgICBpZiAobGVuICE9PSAwKSB7XG4gICAgICAgIHJlZmVyZW5jZVEgPSBRMl9SRUdJU1RFUi5zZXQocXVldWVbbGVuIC0gNF0sIHF1ZXVlW2xlbiAtIDNdLCBxdWV1ZVtsZW4gLSAyXSwgcXVldWVbbGVuIC0gMV0pO1xuICAgIH1cbiAgICBlbHNlIHJlZmVyZW5jZVEgPSBRMl9SRUdJU1RFUi5jb3B5KHRoaXMucm90YXRpb24uX3EpO1xuXG4gICAgdmFyIHJvdFEgPSBRX1JFR0lTVEVSO1xuICAgIGlmICh0eXBlb2YgdyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcm90US5zZXQodywgeCwgeSwgeik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByb3RRLmZyb21FdWxlcih4LCB5LCB6KTtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdztcbiAgICB9XG5cbiAgICB2YXIgcSA9IHJlZmVyZW5jZVEubXVsdGlwbHkocm90USk7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQocS54LCBxLnksIHEueiwgcS53LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuICAgIHZhciBjO1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgaWYgKChjID0gdGhpcy5vcmlnaW4pICYmIGMuX2RpcnR5KSB7XG4gICAgICAgIG5vZGUuc2V0T3JpZ2luKGMueC5nZXQoKSwgYy55LmdldCgpLCBjLnouZ2V0KCkpO1xuICAgICAgICBjLl9kaXJ0eSA9IGMuaXNBY3RpdmUoKTtcbiAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgYy5fZGlydHk7XG4gICAgfVxuICAgIGlmICgoYyA9IHRoaXMubW91bnRQb2ludCkgJiYgYy5fZGlydHkpIHtcbiAgICAgICAgbm9kZS5zZXRNb3VudFBvaW50KGMueC5nZXQoKSwgYy55LmdldCgpLCBjLnouZ2V0KCkpO1xuICAgICAgICBjLl9kaXJ0eSA9IGMuaXNBY3RpdmUoKTtcbiAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgYy5fZGlydHk7XG4gICAgfVxuICAgIGlmICgoYyA9IHRoaXMuYWxpZ24pICYmIGMuX2RpcnR5KSB7XG4gICAgICAgIG5vZGUuc2V0QWxpZ24oYy54LmdldCgpLCBjLnkuZ2V0KCksIGMuei5nZXQoKSk7XG4gICAgICAgIGMuX2RpcnR5ID0gYy5pc0FjdGl2ZSgpO1xuICAgICAgICBpc0RpcnR5ID0gaXNEaXJ0eSB8fCBjLl9kaXJ0eTtcbiAgICB9XG4gICAgaWYgKChjID0gdGhpcy5zY2FsZSkgJiYgYy5fZGlydHkpIHtcbiAgICAgICAgbm9kZS5zZXRTY2FsZShjLnguZ2V0KCksIGMueS5nZXQoKSwgYy56LmdldCgpKTtcbiAgICAgICAgYy5fZGlydHkgPSBjLmlzQWN0aXZlKCk7XG4gICAgICAgIGlzRGlydHkgPSBpc0RpcnR5IHx8IGMuX2RpcnR5O1xuICAgIH1cbiAgICBpZiAoKGMgPSB0aGlzLnBvc2l0aW9uKSAmJiBjLl9kaXJ0eSkge1xuICAgICAgICBub2RlLnNldFBvc2l0aW9uKGMueC5nZXQoKSwgYy55LmdldCgpLCBjLnouZ2V0KCkpO1xuICAgICAgICBjLl9kaXJ0eSA9IGMuaXNBY3RpdmUoKTtcbiAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgYy5fZGlydHk7XG4gICAgfVxuICAgIGlmICgoYyA9IHRoaXMucm90YXRpb24pICYmIGMuX2RpcnR5KSB7XG4gICAgICAgIGMuZ2V0KCk7XG4gICAgICAgIG5vZGUuc2V0Um90YXRpb24oYy5fcS54LCBjLl9xLnksIGMuX3EueiwgYy5fcS53KTtcbiAgICAgICAgYy5fZGlydHkgPSBjLmlzQWN0aXZlKCk7XG4gICAgICAgIGlzRGlydHkgPSBpc0RpcnR5IHx8IGMuX2RpcnR5O1xuICAgIH1cbiAgICBpZiAoaXNEaXJ0eSkgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgZWxzZSB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5vblVwZGF0ZSA9IFRyYW5zZm9ybS5wcm90b3R5cGUuY2xlYW47XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrU3RvcmUgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvQ2FsbGJhY2tTdG9yZScpO1xuXG4vKipcbiAqIENvbXBvbmVudCB0byBtYW5hZ2UgRE9NIGV2ZW50cy4gV2hlbiByZWdpc3RlcmluZyBhbiBldmVudCwgdGhlIHVzZXIgbWF5IHNwZWNpZnkgLm1ldGhvZHMgYW5kXG4gKiAucHJvcGVydGllcyB0byBwcmVwcm9jZXNzIHRoZSBldmVudCBvYmplY3QuXG4gKlxuICogQGNsYXNzIFVJRXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIFRoZSBkaXNwYXRjaCB3aXRoIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBoYW5kbGVyLlxuICogQHBhcmFtIHtPYmplY3RbXX0gZXZlbnRzIEFuIGFycmF5IG9mIGV2ZW50IG9iamVjdHMgc3BlY2lmeWluZyAuZXZlbnQgYW5kIC5jYWxsYmFjayBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBVSUV2ZW50SGFuZGxlciAoZGlzcGF0Y2gsIGV2ZW50cykge1xuICAgIHRoaXMuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgQ2FsbGJhY2tTdG9yZSgpO1xuXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm9uKGV2ZW50c1tpXSwgZXZlbnRzW2ldLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVUlFdmVudEhhbmRsZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdVSUV2ZW50SGFuZGxlcic7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBhbiBldmVudC5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGV2IFRoZSBldmVudCBvYmplY3Qgb3IgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjay5cbiAqL1xuVUlFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXYsIGNiKSB7XG4gICAgdmFyIHJlbmRlcmFibGVzID0gdGhpcy5kaXNwYXRjaC5nZXRSZW5kZXJhYmxlcygpO1xuICAgIHZhciBldmVudE5hbWUgPSBldi5ldmVudCB8fCBldjtcbiAgICB2YXIgbWV0aG9kcyA9IGV2Lm1ldGhvZHM7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBldi5wcm9wZXJ0aWVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZW5kZXJhYmxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAocmVuZGVyYWJsZXNbaV0ub24pIHJlbmRlcmFibGVzW2ldLm9uKGV2ZW50TmFtZSwgbWV0aG9kcywgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cy5vbihldmVudE5hbWUsIGNiKTtcbiAgICB0aGlzLmRpc3BhdGNoLnJlZ2lzdGVyVGFyZ2V0ZWRFdmVudChldmVudE5hbWUsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMsIGV2ZW50TmFtZSkpO1xufTtcblxuLyoqXG4gKiBEZXJlZ2lzdGVyIGEgY2FsbGJhY2sgZnJvbSBhbiBldmVudC5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXYgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2suXG4gKi9cblVJRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXYsIGNiKSB7XG4gICAgdGhpcy5fZXZlbnRzLm9mZihldiwgY2IpO1xuICAgIHRoaXMuZGlzcGF0Y2guZGVyZWdpc3Rlckdsb2JhbEV2ZW50KGV2LCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCBldikpO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIHRoZSBjYWxsYmFjayBhc3NvY2lhdGVkIHdpdGggYW4gZXZlbnQsIHBhc3NpbmcgaW4gYSBwYXlsb2FkLlxuICpcbiAqIEBtZXRob2QgdHJpZ2dlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgVGhlIGV2ZW50IHBheWxvYWQuXG4gKi9cblVJRXZlbnRIYW5kbGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXYsIHBheWxvYWQpIHtcbiAgICB0aGlzLl9ldmVudHMudHJpZ2dlcihldiwgcGF5bG9hZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVJRXZlbnRIYW5kbGVyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQWxpZ246IHJlcXVpcmUoJy4vQWxpZ24nKSxcbiAgICBDYW1lcmE6IHJlcXVpcmUoJy4vQ2FtZXJhJyksXG4gICAgR2VzdHVyZUhhbmRsZXI6IHJlcXVpcmUoJy4vR2VzdHVyZUhhbmRsZXInKSxcbiAgICBNb3VudFBvaW50OiByZXF1aXJlKCcuL01vdW50UG9pbnQnKSxcbiAgICBPcGFjaXR5OiByZXF1aXJlKCcuL09wYWNpdHknKSxcbiAgICBPcmlnaW46IHJlcXVpcmUoJy4vT3JpZ2luJyksXG4gICAgUG9zaXRpb246IHJlcXVpcmUoJy4vUG9zaXRpb24nKSxcbiAgICBSb3RhdGlvbjogcmVxdWlyZSgnLi9Sb3RhdGlvbicpLFxuICAgIFNjYWxlOiByZXF1aXJlKCcuL1NjYWxlJyksXG4gICAgU2l6ZTogcmVxdWlyZSgnLi9TaXplJyksXG4gICAgVHJhbnNmb3JtOiByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIFVJRXZlbnRIYW5kbGVyOiByZXF1aXJlKCcuL1VJRXZlbnRIYW5kbGVyJylcbn07XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoYW5uZWxzIGFyZSBiZWluZyB1c2VkIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBVSSBUaHJlYWQgd2hlbiBydW5uaW5nIGluXG4gKiBhIFdlYiBXb3JrZXIgb3Igd2l0aCB0aGUgVGhyZWFkTWFuYWdlci8gQ29tcG9zdGlvciB3aGVuIHJ1bm5pbmcgaW4gc2luZ2xlXG4gKiB0aHJlYWRlZCBtb2RlIChubyBXZWIgV29ya2VyKS5cbiAqXG4gKiBAY2xhc3MgQ2hhbm5lbFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENoYW5uZWwoKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdyAhPT0gc2VsZikge1xuICAgICAgICB0aGlzLl9lbnRlcldvcmtlck1vZGUoKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi4gU3Vic2NyaWJlcyBmb3IgYG1lc3NhZ2VgIGV2ZW50IGFuZCByb3V0ZXMgYWxsXG4gKiBmdXR1cmUgYHNlbmRNZXNzYWdlYCBtZXNzYWdlcyB0byB0aGUgTWFpbiBUaHJlYWQgKFwiVUkgVGhyZWFkXCIpLlxuICogXG4gKiBQcmltYXJpbHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqIFxuICogQG1ldGhvZCAgX2VudGVyV29ya2VyTW9kZVxuICogQHByaXZhdGVcbiAqLyBcbkNoYW5uZWwucHJvdG90eXBlLl9lbnRlcldvcmtlck1vZGUgPSBmdW5jdGlvbiBfZW50ZXJXb3JrZXJNb2RlKCkge1xuICAgIHRoaXMuX3dvcmtlck1vZGUgPSB0cnVlO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gb25tZXNzYWdlKGV2KSB7XG4gICAgICAgIF90aGlzLm9uTWVzc2FnZShldi5kYXRhKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogTWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IGBGYW1vdXNgLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn0gQXNzaWduZWQgbWV0aG9kIHdpbGwgYmUgaW52b2tlZCBmb3IgZXZlcnkgcmVjZWl2ZWQgbWVzc2FnZS5cbiAqL1xuQ2hhbm5lbC5wcm90b3R5cGUub25NZXNzYWdlID0gbnVsbDtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIFRocmVhZE1hbmFnZXIuXG4gKlxuICogQHBhcmFtICB7QW55fSAgICBtZXNzYWdlIEFyYml0cmFyeSBtZXNzYWdlIG9iamVjdC5cbiAqL1xuQ2hhbm5lbC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiBzZW5kTWVzc2FnZSAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl93b3JrZXJNb2RlKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNZWFudCB0byBiZSBvdmVycmlkZW4gYnkgdGhlIFRocmVhZE1hbmFnZXIgd2hlbiBydW5uaW5nIGluIHRoZSBVSSBUaHJlYWQuXG4gKiBVc2VkIGZvciBwcmVzZXJ2aW5nIEFQSSBjb21wYXRpYmlsaXR5IHdpdGggV2ViIFdvcmtlcnMuXG4gKiBXaGVuIHJ1bm5pbmcgaW4gV2ViIFdvcmtlciBtb2RlLCB0aGlzIHByb3BlcnR5IHdvbid0IGJlIG11dGF0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtGdW5jdGlvbn0gICAgIEFzc2lnbmVkIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgZm9yIGV2ZXJ5IG1lc3NhZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgIHBvc3RlZCBieSBgZmFtb3VzLWNvcmVgXG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLm9ubWVzc2FnZSA9IG51bGw7XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtYW5hZ2VyIG9mIHRoaXMgY2hhbm5lbCAodGhlIGBGYW1vdXNgIHNpbmdsZXRvbikgYnlcbiAqIGludm9raW5nIGBvbk1lc3NhZ2VgLlxuICogVXNlZCBmb3IgcHJlc2VydmluZyBBUEkgY29tcGF0aWJpbGl0eSB3aXRoIFdlYiBXb3JrZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAYWxpYXMgb25NZXNzYWdlXG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gcG9zdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbm5lbDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXF1aXZhbGVudCBvZiBhbiBFbmdpbmUgaW4gdGhlIFdvcmtlciBUaHJlYWQuIFVzZWQgdG8gc3luY2hyb25pemUgYW5kIG1hbmFnZVxuICogdGltZSBhY3Jvc3MgZGlmZmVyZW50IFRocmVhZHMuXG4gKlxuICogQGNsYXNzICBDbG9ja1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDbG9jayAoKSB7XG4gICAgdGhpcy5fdGltZSA9IDA7XG4gICAgdGhpcy5fZnJhbWUgPSAwO1xuICAgIHRoaXMuX3RpbWVyUXVldWUgPSBbXTtcbiAgICB0aGlzLl91cGRhdGluZ0luZGV4ID0gMDtcblxuICAgIHRoaXMuX3NjYWxlID0gMTtcbiAgICB0aGlzLl9zY2FsZWRUaW1lID0gdGhpcy5fdGltZTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nLlxuICogVXNlZnVsIGZvciBzbG93LW1vdGlvbiBvciBmYXN0LWZvcndhcmQgZWZmZWN0cy5cbiAqIFxuICogYDFgIG1lYW5zIG5vIHRpbWUgc2NhbGluZyAoXCJyZWFsdGltZVwiKSxcbiAqIGAyYCBtZWFucyB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nIHR3aWNlIGFzIGZhc3QsXG4gKiBgMC41YCBtZWFucyB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nIHR3byB0aW1lcyBzbG93ZXIgdGhhbiB0aGUgXCJhY3R1YWxcIlxuICogdGltZSBhdCB3aGljaCB0aGUgQ2xvY2sgaXMgYmVpbmcgdXBkYXRlZCB2aWEgYC5zdGVwYC5cbiAqXG4gKiBJbml0YWxseSB0aGUgY2xvY2sgdGltZSBpcyBub3QgYmVpbmcgc2NhbGVkIChmYWN0b3IgYDFgKS5cbiAqIFxuICogQG1ldGhvZCAgc2V0U2NhbGVcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlICAgIFRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nLlxuICovXG5DbG9jay5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiBzZXRTY2FsZSAoc2NhbGUpIHtcbiAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kICBnZXRTY2FsZVxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlICAgIFRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nLlxuICovXG5DbG9jay5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lLlxuICpcbiAqIEBtZXRob2QgIHN0ZXBcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIGhpZ2ggcmVzb2x1dGlvbiB0aW1zdGFtcCB1c2VkIGZvciBpbnZva2luZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRlYCBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICogQHJldHVybiB7Q2xvY2t9ICAgICAgIHRoaXNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgdGhpcy5fZnJhbWUrKztcblxuICAgIHRoaXMuX3NjYWxlZFRpbWUgPSB0aGlzLl9zY2FsZWRUaW1lICsgKHRpbWUgLSB0aGlzLl90aW1lKSp0aGlzLl9zY2FsZTtcbiAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGltZXJRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fdGltZXJRdWV1ZVtpXSh0aGlzLl9zY2FsZWRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdGltZXJRdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludGVybmFsIGNsb2NrIHRpbWUuXG4gKlxuICogQG1ldGhvZCAgbm93XG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uIG5vdyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjYWxlZFRpbWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludGVybmFsIGNsb2NrIHRpbWUuXG4gKlxuICogQG1ldGhvZCAgZ2V0VGltZVxuICogQGRlcHJlY2F0ZWQgVXNlICNub3cgaW5zdGVhZFxuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGVgIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5nZXRUaW1lID0gQ2xvY2sucHJvdG90eXBlLm5vdztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZnJhbWVzIGVsYXBzZWQgc28gZmFyLlxuICpcbiAqIEBtZXRob2QgZ2V0RnJhbWVcbiAqIFxuICogQHJldHVybiB7TnVtYmVyfSBmcmFtZXNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLmdldEZyYW1lID0gZnVuY3Rpb24gZ2V0RnJhbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZS5cbiAqIEFmdGVyIGEgc2V0IGR1cmF0aW9uIGhhcyBwYXNzZWQsIGl0IGV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBhbmRcbiAqIHJlbW92ZXMgaXQgYXMgYSBsaXN0ZW5lciB0byAncHJlcmVuZGVyJy5cbiAqXG4gKiBAbWV0aG9kIHNldFRpbWVvdXRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBydW4gYWZ0ZXIgYSBzcGVjaWZpZWQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSBtaWxsaXNlY29uZHMgZnJvbSBub3cgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGltZXIgZnVuY3Rpb24gdXNlZCBmb3IgQ2xvY2sjY2xlYXJUaW1lclxuICovXG5DbG9jay5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVsYXkpIHtcbiAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgc3RhcnRlZEF0ID0gdGhpcy5fdGltZTtcbiAgICB2YXIgdGltZXIgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lIC0gc3RhcnRlZEF0ID49IGRlbGF5KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5fdGltZXJRdWV1ZS5wdXNoKHRpbWVyKTtcbiAgICByZXR1cm4gdGltZXI7XG59O1xuXG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZS5cbiAqICBBZnRlciBhIHNldCBkdXJhdGlvbiBoYXMgcGFzc2VkLCBpdCBleGVjdXRlcyB0aGUgZnVuY3Rpb24gYW5kXG4gKiAgcmVzZXRzIHRoZSBleGVjdXRpb24gdGltZS5cbiAqXG4gKiBAbWV0aG9kIHNldEludGVydmFsXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgcnVuIGFmdGVyIGEgc3BlY2lmaWVkIGR1cmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gaW50ZXJ2YWwgdG8gZXhlY3V0ZSBmdW5jdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGltZXIgZnVuY3Rpb24gdXNlZCBmb3IgQ2xvY2sjY2xlYXJUaW1lclxuICovXG5DbG9jay5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChjYWxsYmFjaywgZGVsYXkpIHtcbiAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgc3RhcnRlZEF0ID0gdGhpcy5fdGltZTtcbiAgICB2YXIgdGltZXIgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lIC0gc3RhcnRlZEF0ID49IGRlbGF5KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBwYXJhbXMpO1xuICAgICAgICAgICAgc3RhcnRlZEF0ID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl90aW1lclF1ZXVlLnB1c2godGltZXIpO1xuICAgIHJldHVybiB0aW1lcjtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBwcmV2aW91c2x5IHZpYSBgQ2xvY2sjc2V0VGltZW91dGAgb3IgYENsb2NrI3NldEludGVydmFsYFxuICogcmVnaXN0ZXJlZCBjYWxsYmFjayBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgY2xlYXJUaW1lclxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgIHByZXZpb3VzbHkgYnkgYENsb2NrI3NldFRpbWVvdXRgIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBDbG9jayNzZXRJbnRlcnZhbGAgcmV0dXJuZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm4ge0Nsb2NrfSAgICAgICAgICAgICAgdGhpc1xuICovXG5DbG9jay5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX3RpbWVyUXVldWUuaW5kZXhPZih0aW1lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl90aW1lclF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9jaztcblxuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNoaW50IC1XMDc5ICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogRGlzcGF0Y2ggc2hvdWxkIGJlIGdlbmVyYWxpemVkIHNvIHRoYXQgaXQgY2FuIHdvcmsgb24gYW55IE5vZGVcbi8vIG5vdCBqdXN0IENvbnRleHRzLlxuXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbi8qKlxuICogVGhlIERpc3BhdGNoIGNsYXNzIGlzIHVzZWQgdG8gcHJvcG9nYXRlIGV2ZW50cyBkb3duIHRoZVxuICogc2NlbmUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtDb250ZXh0fSBDb250ZXh0IG9uIHdoaWNoIGl0IG9wZXJhdGVzXG4gKi9cbmZ1bmN0aW9uIERpc3BhdGNoIChjb250ZXh0KSB7XG5cbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBFcnJvcignRGlzcGF0Y2ggbmVlZHMgdG8gYmUgaW5zdGFudGlhdGVkIG9uIGEgbm9kZScpO1xuICAgIFxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0OyAvLyBBIHJlZmVyZW5jZSB0byB0aGUgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiB3aGljaCB0aGUgZGlzcGF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVyYXRlc1xuXG4gICAgdGhpcy5fcXVldWUgPSBbXTsgLy8gVGhlIHF1ZXVlIGlzIHVzZWQgZm9yIHR3byBwdXJwb3Nlc1xuICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIEl0IGlzIHVzZWQgdG8gbGlzdCBpbmRpY2llcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICBOb2RlcyBwYXRoIHdoaWNoIGFyZSB0aGVuIHVzZWQgdG8gbG9va3VwXG4gICAgICAgICAgICAgICAgICAgICAgLy8gICAgYSBub2RlIGluIHRoZSBzY2VuZSBncmFwaC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBJdCBpcyB1c2VkIHRvIGFzc2lzdCBkaXNwYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHN1Y2ggdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBkbyBhIGJyZWFkdGggZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0cmF2ZXJzYWwgb2YgdGhlIHNjZW5lIGdyYXBoLlxufVxuXG4vKipcbiAqIGxvb2t1cE5vZGUgdGFrZXMgYSBwYXRoIGFuZCByZXR1cm5zIHRoZSBub2RlIGF0IHRoZSBsb2NhdGlvbiBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBwYXRoLCBpZiBvbmUgZXhpc3RzLiBJZiBub3QsIGl0IHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgbG9jYXRpb24gb2YgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG4gKiBcbiAqIEByZXR1cm4ge05vZGUgfCB1bmRlZmluZWR9IFRoZSBub2RlIGF0IHRoZSByZXF1ZXN0ZWQgcGF0aFxuICovXG5EaXNwYXRjaC5wcm90b3R5cGUubG9va3VwTm9kZSA9IGZ1bmN0aW9uIGxvb2t1cE5vZGUgKGxvY2F0aW9uKSB7XG4gICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKCdsb29rdXBOb2RlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBwYXRoJyk7XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuX3F1ZXVlO1xuXG4gICAgX3NwbGl0VG8obG9jYXRpb24sIHBhdGgpO1xuICAgIFxuICAgIGlmIChwYXRoWzBdICE9PSB0aGlzLl9jb250ZXh0LmdldFNlbGVjdG9yKCkpIHJldHVybiB2b2lkIDA7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jb250ZXh0LmdldENoaWxkcmVuKCk7XG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBpID0gMTtcbiAgICBwYXRoWzBdID0gdGhpcy5fY29udGV4dDtcblxuICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltwYXRoW2ldXTtcbiAgICAgICAgcGF0aFtpXSA9IGNoaWxkO1xuICAgICAgICBpZiAoY2hpbGQpIGNoaWxkcmVuID0gY2hpbGQuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZWxzZSByZXR1cm4gdm9pZCAwO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqXG4gKiBkaXNwYXRjaCB0YWtlcyBhbiBldmVudCBuYW1lIGFuZCBhIHBheWxvYWQgYW5kIGRpc3BhdGNoZXMgaXQgdG8gdGhlXG4gKiBlbnRpcmUgc2NlbmUgZ3JhcGggYmVsb3cgdGhlIG5vZGUgdGhhdCB0aGUgZGlzcGF0Y2hlciBpcyBvbi4gVGhlIG5vZGVzXG4gKiByZWNlaXZlIHRoZSBldmVudHMgaW4gYSBicmVhZHRoIGZpcnN0IHRyYXZlcnNhbCwgbWVhbmluZyB0aGF0IHBhcmVudHNcbiAqIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIHRoZSBldmVudCBiZWZvcmUgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7QW55fSBwYXlsb2FkXG4gKi9cbkRpc3BhdGNoLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoIChldmVudCwgcGF5bG9hZCkge1xuICAgIGlmICghZXZlbnQpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2ggcmVxdWlyZXMgYW4gZXZlbnQgbmFtZSBhcyBpdFxcJ3MgZmlyc3QgYXJndW1lbnQnKTtcblxuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpdGVtO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNoaWxkcmVuO1xuXG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBxdWV1ZS5wdXNoKHRoaXMuX2NvbnRleHQpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGl0ZW0ub25SZWNlaXZlKSBpdGVtLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG4gICAgICAgIGNoaWxkcmVuID0gaXRlbS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSBxdWV1ZS5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGRpc3BhdGNoVUlldmVudCB0YWtlcyBhIHBhdGgsIGFuIGV2ZW50IG5hbWUsIGFuZCBhIHBheWxvYWQgYW5kIGRpc3BhdGNoZXMgdGhlbSBpblxuICogYSBtYW5uZXIgYW5vbG9nb3VzIHRvIERPTSBidWJibGluZy4gSXQgZmlyc3QgdHJhdmVyc2VzIGRvd24gdG8gdGhlIG5vZGUgc3BlY2lmaWVkIGF0XG4gKiB0aGUgcGF0aC4gVGhhdCBub2RlIHJlY2VpdmVzIHRoZSBldmVudCBmaXJzdCwgYW5kIHRoZW4gZXZlcnkgYW5jZXN0b3IgcmVjZWl2ZXMgdGhlIGV2ZW50XG4gKiB1bnRpbCB0aGUgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIHBhdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtBbnl9IHRoZSBwYXlsb2FkXG4gKi9cbkRpc3BhdGNoLnByb3RvdHlwZS5kaXNwYXRjaFVJRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaFVJRXZlbnQgKHBhdGgsIGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXRoKSB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BhdGNoVUlFdmVudCBuZWVkcyBhIHZhbGlkIHBhdGggdG8gZGlzcGF0Y2ggdG8nKTtcbiAgICBpZiAoIWV2ZW50KSB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BhdGNoVUlFdmVudCBuZWVkcyBhbiBldmVudCBuYW1lIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQnKTtcblxuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBub2RlO1xuICAgIFxuICAgIEV2ZW50LmNhbGwocGF5bG9hZCk7XG4gICAgcGF5bG9hZC5ub2RlID0gdGhpcy5sb29rdXBOb2RlKHBhdGgpOyAvLyBBZnRlciB0aGlzIGNhbGwsIHRoZSBwYXRoIGlzIGxvYWRlZCBpbnRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGxvb2tVcCBub2RlIGRvZXNuJ3QgY2xlYXIgdGhlIHF1ZXVlIGFmdGVyIHRoZSBsb29rdXApXG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUgPSBxdWV1ZS5wb3AoKTsgLy8gcG9wIG5vZGVzIG9mZiBvZiB0aGUgcXVldWUgdG8gbW92ZSB1cCB0aGUgYW5jZXN0b3IgY2hhaW4uXG4gICAgICAgIGlmIChub2RlLm9uUmVjZWl2ZSkgbm9kZS5vblJlY2VpdmUoZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICBpZiAocGF5bG9hZC5wcm9wYWdhdGlvblN0b3BwZWQpIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogX3NwbGl0VG8gaXMgYSBwcml2YXRlIG1ldGhvZCB3aGljaCB0YWtlcyBhIHBhdGggYW5kIHNwbGl0cyBpdCBhdCBldmVyeSAnLydcbiAqIHB1c2hpbmcgdGhlIHJlc3VsdCBpbnRvIHRoZSBzdXBwbGllZCBhcnJheS4gVGhpcyBpcyBhIGRlc3RydWN0aXZlIGNoYW5nZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHRoZSBzcGVjaWZpZWQgcGF0aFxuICogQHBhcmFtIHtBcnJheX0gdGhlIGFycmF5IHRvIHdoaWNoIHRoZSByZXN1bHQgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqL1xuZnVuY3Rpb24gX3NwbGl0VG8gKHN0cmluZywgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IDA7IC8vIGNsZWFycyB0aGUgYXJyYXkgZmlyc3QuXG4gICAgdmFyIGxhc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmdbaV0gPT09ICcvJykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nLnN1YnN0cmluZyhsYXN0LCBpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSAtIGxhc3QgPiAwKSB0YXJnZXQucHVzaChzdHJpbmcuc3Vic3RyaW5nKGxhc3QsIGkpKTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2g7XG5cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIEV2ZW50IGNsYXNzIGFkZHMgdGhlIHN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbmFsaXR5XG4gKiB0byB0aGUgVUlFdmVudHMgd2l0aGluIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRcbiAqL1xuZnVuY3Rpb24gRXZlbnQgKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG59XG5cbi8qKlxuICogc3RvcFByb3BhZ2F0aW9uIGVuZHMgdGhlIGJ1YmJsaW5nIG9mIHRoZSBldmVudCBpbiB0aGVcbiAqIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbiAoKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2xvY2sgPSByZXF1aXJlKCcuL0Nsb2NrJyk7XG52YXIgU2NlbmUgPSByZXF1aXJlKCcuL1NjZW5lJyk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4vQ2hhbm5lbCcpO1xudmFyIFVJTWFuYWdlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy9VSU1hbmFnZXInKTtcbnZhciBDb21wb3NpdG9yID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL0NvbXBvc2l0b3InKTtcbnZhciBFbmdpbmUgPSByZXF1aXJlKCcuLi9lbmdpbmUvRW5naW5lJyk7XG5cbnZhciBFTkdJTkVfU1RBUlQgPSBbJ0VOR0lORScsICdTVEFSVCddO1xudmFyIEVOR0lORV9TVE9QID0gWydFTkdJTkUnLCAnU1RPUCddO1xudmFyIFRJTUVfVVBEQVRFID0gWydUSU1FJywgbnVsbF07XG5cbi8qKlxuICogRmFtb3VzIGhhcyB0d28gcmVzcG9uc2liaWxpdGllcywgb25lIHRvIGFjdCBhcyB0aGUgaGlnaGVzdCBsZXZlbFxuICogdXBkYXRlciBhbmQgYW5vdGhlciB0byBzZW5kIG1lc3NhZ2VzIG92ZXIgdG8gdGhlIHJlbmRlcmVycy4gSXQgaXNcbiAqIGEgc2luZ2xldG9uLlxuICovXG5mdW5jdGlvbiBGYW1vdXNFbmdpbmUoKSB7XG4gICAgdGhpcy5fdXBkYXRlUXVldWUgPSBbXTsgLy8gVGhlIHVwZGF0ZVF1ZXVlIGlzIGEgcGxhY2Ugd2hlcmUgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gcGxhY2UgdGhlbXNlbHZlcyBpbiBvcmRlciB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgb24gdGhlIGZyYW1lLlxuXG4gICAgdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlID0gW107IC8vIHRoZSBuZXh0VXBkYXRlUXVldWUgaXMgdXNlZCB0byBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGZvciB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIGluZmluaXRlIGxvb3BzIHdoZXJlIGR1cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiB1cGRhdGUgYSBub2RlIGNvbnRpbnVvdXNseSBwdXRzIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIGluIHRoZSB1cGRhdGUgcXVldWUuXG5cbiAgICB0aGlzLl9zY2VuZXMgPSB7fTsgLy8gYSBoYXNoIG9mIGFsbCBvZiB0aGUgc2NlbmVzJ3MgdGhhdCB0aGUgRmFtb3VzRW5naW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgcmVzcG9uc2libGUgZm9yLlxuXG4gICAgdGhpcy5fbWVzc2FnZXMgPSBUSU1FX1VQREFURTsgICAvLyBhIHF1ZXVlIG9mIGFsbCBvZiB0aGUgZHJhdyBjb21tYW5kcyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCB0byB0aGUgdGhlIHJlbmRlcmVycyB0aGlzIGZyYW1lLlxuXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTsgLy8gd2hlbiB0aGUgZmFtb3VzIGlzIHVwZGF0aW5nIHRoaXMgaXMgdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgcmVxdWVzdHMgZm9yIHVwZGF0ZXMgd2lsbCBnZXQgcHV0IGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHRVcGRhdGVRdWV1ZVxuXG4gICAgdGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2soKTsgLy8gYSBjbG9jayB0byBrZWVwIHRyYWNrIG9mIHRpbWUgZm9yIHRoZSBzY2VuZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYXBoLlxuXG4gICAgdGhpcy5fY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG4gICAgdGhpcy5fY2hhbm5lbC5vbk1lc3NhZ2UgPSB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKTtcbn1cblxuXG4vKipcbiAqIEBtZXRob2QgaW5pdFxuICogQGNoYWluYWJsZVxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbXBvc2l0b3IgPSBvcHRpb25zICYmIG9wdGlvbnMuY29tcG9zaXRvciB8fCBuZXcgQ29tcG9zaXRvcigpO1xuICAgIHRoaXMuZW5naW5lID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuZ2luZSB8fCBuZXcgRW5naW5lKCk7XG4gICAgdGhpcy51aU1hbmFnZXIgPSBuZXcgVUlNYW5hZ2VyKHRoaXMuZ2V0Q2hhbm5lbCgpLCB0aGlzLmNvbXBvc2l0b3IsIHRoaXMuZW5naW5lKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRDaGFubmVsXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsICAgICBUaGUgY2hhbm5lbCB0byBiZSB1c2VkIGZvciBjb21tdW5pY2F0aW5nIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGBVSU1hbmFnZXJgLyBgQ29tcG9zaXRvcmAuXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuc2V0Q2hhbm5lbCA9IGZ1bmN0aW9uIHNldENoYW5uZWwoY2hhbm5lbCkge1xuICAgIHRoaXMuX2NoYW5uZWwgPSBjaGFubmVsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldENoYW5uZWxcbiAqXG4gKiBAcmV0dXJuIHtDaGFubmVsfSBjaGFubmVsICAgIFRoZSBjaGFubmVsIHRvIGJlIHVzZWQgZm9yIGNvbW11bmljYXRpbmcgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYFVJTWFuYWdlcmAvIGBDb21wb3NpdG9yYC5cbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5nZXRDaGFubmVsID0gZnVuY3Rpb24gZ2V0Q2hhbm5lbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5uZWw7XG59O1xuXG4vKipcbiAqIF91cGRhdGUgaXMgdGhlIGJvZHkgb2YgdGhlIHVwZGF0ZSBsb29wLiBUaGUgZnJhbWUgY29uc2lzdHMgb2ZcbiAqIHB1bGxpbmcgaW4gYXBwZW5kaW5nIHRoZSBuZXh0VXBkYXRlUXVldWUgdG8gdGhlIGN1cnJlbnRVcGRhdGUgcXVldWVcbiAqIHRoZW4gbW92aW5nIHRocm91Z2ggdGhlIHVwZGF0ZVF1ZXVlIGFuZCBjYWxsaW5nIG9uVXBkYXRlIHdpdGggdGhlIGN1cnJlbnRcbiAqIHRpbWUgb24gYWxsIG5vZGVzLiBXaGlsZSBfdXBkYXRlIGlzIGNhbGxlZCBfaW5VcGRhdGUgaXMgc2V0IHRvIHRydWUgYW5kXG4gKiBhbGwgcmVxdWVzdHMgdG8gYmUgcGxhY2VkIGluIHRoZSB1cGRhdGUgcXVldWUgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlXG4gKiBuZXh0VXBkYXRlUXVldWUuXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUgKCkge1xuICAgIHRoaXMuX2luVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgdGltZSA9IHRoaXMuX2Nsb2NrLm5vdygpO1xuICAgIHZhciBuZXh0UXVldWUgPSB0aGlzLl9uZXh0VXBkYXRlUXVldWU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fdXBkYXRlUXVldWU7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB0aGlzLl9tZXNzYWdlc1sxXSA9IHRpbWU7XG5cbiAgICB3aGlsZSAobmV4dFF1ZXVlLmxlbmd0aCkgcXVldWUudW5zaGlmdChuZXh0UXVldWUucG9wKCkpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblVwZGF0ZSkgaXRlbS5vblVwZGF0ZSh0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pblVwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiByZXF1ZXN0VXBkYXRlcyB0YWtlcyBhIGNsYXNzIHRoYXQgaGFzIGFuIG9uVXBkYXRlIG1ldGhvZCBhbmQgcHV0cyBpdFxuICogaW50byB0aGUgdXBkYXRlUXVldWUgdG8gYmUgdXBkYXRlZCBhdCB0aGUgbmV4dCBmcmFtZS5cbiAqIElmIEZhbW91c0VuZ2luZSBpcyBjdXJyZW50bHkgaW4gYW4gdXBkYXRlLCByZXF1ZXN0VXBkYXRlXG4gKiBwYXNzZXMgaXRzIGFyZ3VtZW50IHRvIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBhbiBvblVwZGF0ZSBtZXRob2RcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZSAocmVxdWVzdGVyKSB7XG4gICAgaWYgKCFyZXF1ZXN0ZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdyZXF1ZXN0VXBkYXRlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBjbGFzcyB0byBiZSB1cGRhdGVkJ1xuICAgICAgICApO1xuXG4gICAgaWYgKHRoaXMuX2luVXBkYXRlKSB0aGlzLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHJlcXVlc3Rlcik7XG4gICAgZWxzZSB0aGlzLl91cGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG4vKipcbiAqIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrIGlzIHJlcXVlc3RzIGFuIHVwZGF0ZSBvbiB0aGUgbmV4dCBmcmFtZS5cbiAqIElmIEZhbW91c0VuZ2luZSBpcyBub3QgY3VycmVudGx5IGluIGFuIHVwZGF0ZSB0aGFuIGl0IGlzIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50XG4gKiB0byByZXF1ZXN0VXBkYXRlLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIHdoZXJlXG4gKiBhIGNsYXNzIGlzIHVwZGF0ZWQgb24gdGhlIGZyYW1lIGJ1dCBuZWVkcyB0byBiZSB1cGRhdGVkIGFnYWluIG5leHQgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIGFuIG9uVXBkYXRlIG1ldGhvZFxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgKHJlcXVlc3Rlcikge1xuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG4vKipcbiAqIHBvc3RNZXNzYWdlIHNlbmRzIGEgbWVzc2FnZSBxdWV1ZSBpbnRvIEZhbW91c0VuZ2luZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIGludGVycHJldGVkIGFuZCBzZW50IGludG8gdGhlIHNjZW5lIGdyYXBoXG4gKiBhcyBldmVudHMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFuIGFycmF5IG9mIGNvbW1hbmRzLlxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlIChtZXNzYWdlcykge1xuICAgIGlmICghbWVzc2FnZXMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvbk1lc3NhZ2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBtZXNzYWdlcydcbiAgICAgICAgKTtcblxuICAgIHZhciBjb21tYW5kO1xuXG4gICAgd2hpbGUgKG1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29tbWFuZCA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAnV0lUSCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVXaXRoKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ZSQU1FJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZyYW1lKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNlaXZlZCB1bmtub3duIGNvbW1hbmQ6ICcgKyBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogaGFuZGxlV2l0aCBpcyBhIG1ldGhvZCB0aGF0IHRha2VzIGFuIGFycmF5IG9mIG1lc3NhZ2VzIGZvbGxvd2luZyB0aGVcbiAqIFdJVEggY29tbWFuZC4gSXQnbGwgdGhlbiBpc3N1ZSB0aGUgbmV4dCBjb21tYW5kcyB0byB0aGUgcGF0aCBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBXSVRIIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgbWVzc2FnZXMuXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuaGFuZGxlV2l0aCA9IGZ1bmN0aW9uIGhhbmRsZVdpdGggKG1lc3NhZ2VzKSB7XG4gICAgdmFyIHBhdGggPSBtZXNzYWdlcy5zaGlmdCgpO1xuICAgIHZhciBjb21tYW5kID0gbWVzc2FnZXMuc2hpZnQoKTtcblxuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlICdUUklHR0VSJzogLy8gdGhlIFRSSUdHRVIgY29tbWFuZCBzZW5kcyBhIFVJRXZlbnQgdG8gdGhlIHNwZWNpZmllZCBwYXRoXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgZXYgPSBtZXNzYWdlcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICB0aGlzLmdldENvbnRleHQocGF0aCkuZ2V0RGlzcGF0Y2goKS5kaXNwYXRjaFVJRXZlbnQocGF0aCwgdHlwZSwgZXYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2VpdmVkIHVua25vd24gY29tbWFuZDogJyArIGNvbW1hbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogaGFuZGxlRnJhbWUgaXMgY2FsbGVkIHdoZW4gdGhlIHJlbmRlcmVycyBpc3N1ZSBhIEZSQU1FIGNvbW1hbmQgdG9cbiAqIEZhbW91c0VuZ2luZS4gRmFtb3VzRW5naW5lIHdpbGwgdGhlbiBzdGVwIHVwZGF0aW5nIHRoZSBzY2VuZSBncmFwaCB0byB0aGUgY3VycmVudCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIG1lc3NhZ2VzLlxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmhhbmRsZUZyYW1lID0gZnVuY3Rpb24gaGFuZGxlRnJhbWUgKG1lc3NhZ2VzKSB7XG4gICAgaWYgKCFtZXNzYWdlcykgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVGcmFtZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIG1lc3NhZ2VzJyk7XG4gICAgaWYgKCFtZXNzYWdlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignRlJBTUUgbXVzdCBiZSBzZW50IHdpdGggYSB0aW1lJyk7XG5cbiAgICB0aGlzLnN0ZXAobWVzc2FnZXMuc2hpZnQoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIHN0ZXAgdXBkYXRlcyB0aGUgY2xvY2sgYW5kIHRoZSBzY2VuZSBncmFwaCBhbmQgdGhlbiBzZW5kcyB0aGUgZHJhdyBjb21tYW5kc1xuICogdGhhdCBhY2N1bXVsYXRlZCBpbiB0aGUgdXBkYXRlIHRvIHRoZSByZW5kZXJlcnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnQgZW5naW5lIHRpbWVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gc3RlcCAodGltZSkge1xuICAgIGlmICh0aW1lID09IG51bGwpIHRocm93IG5ldyBFcnJvcignc3RlcCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgdGltZScpO1xuXG4gICAgdGhpcy5fY2xvY2suc3RlcCh0aW1lKTtcbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIGlmICh0aGlzLl9tZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5zZW5kTWVzc2FnZSh0aGlzLl9tZXNzYWdlcyk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLmxlbmd0aCA9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIHJldHVybnMgdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHBhdGguIFRoZSBjb250ZXh0IGlzIGxvb2tlZCB1cCBieSB0aGUgc2VsZWN0b3JcbiAqIHBvcnRpb24gb2YgdGhlIHBhdGggYW5kIGlzIGxpc3RlZCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nIHRvIHRoZSBmaXJzdFxuICogJy8nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGUgcGF0aCB0byBsb29rIHVwIHRoZSBjb250ZXh0IGZvci5cbiAqXG4gKiBAcmV0dXJuIHtDb250ZXh0IHwgVW5kZWZpbmVkfSB0aGUgY29udGV4dCBpZiBmb3VuZCwgZWxzZSB1bmRlZmluZWQuXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQgKHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgdGhyb3cgbmV3IEVycm9yKCdnZXRDb250ZXh0IG11c3QgYmUgY2FsbGVkIHdpdGggYSBzZWxlY3RvcicpO1xuXG4gICAgdmFyIGluZGV4ID0gc2VsZWN0b3IuaW5kZXhPZignLycpO1xuICAgIHNlbGVjdG9yID0gaW5kZXggPT09IC0xID8gc2VsZWN0b3IgOiBzZWxlY3Rvci5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NjZW5lc1tzZWxlY3Rvcl07XG59O1xuXG4vKipcbiAqIHJldHVybnMgdGhlIGluc3RhbmNlIG9mIGNsb2NrIHdpdGhpbiBmYW1vdXMuXG4gKlxuICogQHJldHVybiB7Q2xvY2t9IEZhbW91c0VuZ2luZSdzIGNsb2NrXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuZ2V0Q2xvY2sgPSBmdW5jdGlvbiBnZXRDbG9jayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb2NrO1xufTtcblxuLyoqXG4gKiBxdWV1ZXMgYSBtZXNzYWdlIHRvIGJlIHRyYW5zZmVyZWQgdG8gdGhlIHJlbmRlcmVycy5cbiAqXG4gKiBAcGFyYW0ge0FueX0gRHJhdyBDb21tYW5kXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uIG1lc3NhZ2UgKGNvbW1hbmQpIHtcbiAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKGNvbW1hbmQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2NlbmUgdW5kZXIgd2hpY2ggYSBzY2VuZSBncmFwaCBjb3VsZCBiZSBidWlsdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYSBkb20gc2VsZWN0b3IgZm9yIHdoZXJlIHRoZSBzY2VuZSBzaG91bGQgYmUgcGxhY2VkXG4gKlxuICogQHJldHVybiB7U2NlbmV9IGEgbmV3IGluc3RhbmNlIG9mIFNjZW5lLlxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmNyZWF0ZVNjZW5lID0gZnVuY3Rpb24gY3JlYXRlU2NlbmUgKHNlbGVjdG9yKSB7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnYm9keSc7XG5cbiAgICBpZiAodGhpcy5fc2NlbmVzW3NlbGVjdG9yXSkgdGhpcy5fc2NlbmVzW3NlbGVjdG9yXS5kaXNtb3VudCgpO1xuICAgIHRoaXMuX3NjZW5lc1tzZWxlY3Rvcl0gPSBuZXcgU2NlbmUoc2VsZWN0b3IsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9zY2VuZXNbc2VsZWN0b3JdO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdGhlIGVuZ2luZSBydW5uaW5nIGluIHRoZSBNYWluLVRocmVhZC5cbiAqIFRoaXMgZWZmZWN0cyAqKmV2ZXJ5KiogdXBkYXRlYWJsZSBtYW5hZ2VkIGJ5IHRoZSBFbmdpbmUuXG4gKlxuICogQGNoYWluYWJsZVxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnN0YXJ0RW5naW5lID0gZnVuY3Rpb24gc3RhcnRFbmdpbmUgKCkge1xuICAgIHRoaXMuX2NoYW5uZWwuc2VuZE1lc3NhZ2UoRU5HSU5FX1NUQVJUKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RvcHMgdGhlIGVuZ2luZSBydW5uaW5nIGluIHRoZSBNYWluLVRocmVhZC5cbiAqIFRoaXMgZWZmZWN0cyAqKmV2ZXJ5KiogdXBkYXRlYWJsZSBtYW5hZ2VkIGJ5IHRoZSBFbmdpbmUuXG4gKlxuICogQGNoYWluYWJsZVxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnN0b3BFbmdpbmUgPSBmdW5jdGlvbiBzdG9wRW5naW5lICgpIHtcbiAgICB0aGlzLl9jaGFubmVsLnNlbmRNZXNzYWdlKEVOR0lORV9TVE9QKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEZhbW91c0VuZ2luZSgpO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNoaW50IC1XMDc5ICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG52YXIgU2l6ZSA9IHJlcXVpcmUoJy4vU2l6ZScpO1xuXG52YXIgVFJBTlNGT1JNX1BST0NFU1NPUiA9IG5ldyBUcmFuc2Zvcm0oKTtcbnZhciBTSVpFX1BST0NFU1NPUiA9IG5ldyBTaXplKCk7XG5cbnZhciBJREVOVCA9IFtcbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5dO1xuXG52YXIgT05FUyA9IFsxLCAxLCAxXTtcbnZhciBRVUFUID0gWzAsIDAsIDAsIDFdO1xuXG4vKipcbiAqIE5vZGVzIGRlZmluZSBoaWVyYXJjaHkgYW5kIGdlb21ldHJpY2FsIHRyYW5zZm9ybWF0aW9ucy4gVGhleSBjYW4gYmUgbW92ZWRcbiAqICh0cmFuc2xhdGVkKSwgc2NhbGVkIGFuZCByb3RhdGVkLlxuICpcbiAqIEEgTm9kZSBpcyBlaXRoZXIgbW91bnRlZCBvciB1bm1vdW50ZWQuIFVubW91bnRlZCBub2RlcyBhcmUgZGV0YWNoZWQgZnJvbSB0aGVcbiAqIHNjZW5lIGdyYXBoLiBVbm1vdW50ZWQgbm9kZXMgaGF2ZSBubyBwYXJlbnQgbm9kZSwgd2hpbGUgZWFjaCBtb3VudGVkIG5vZGUgaGFzXG4gKiBleGFjdGx5IG9uZSBwYXJlbnQuIE5vZGVzIGhhdmUgYW4gYXJiaXRhcnkgbnVtYmVyIG9mIGNoaWxkcmVuLCB3aGljaCBjYW4gYmVcbiAqIGR5bmFtaWNhbGx5IGFkZGVkIHVzaW5nIEB7QGxpbmsgYWRkQ2hpbGR9LlxuICpcbiAqIEVhY2ggTm9kZXMgaGF2ZSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGBjb21wb25lbnRzYC4gVGhvc2UgY29tcG9uZW50cyBjYW5cbiAqIHNlbmQgYGRyYXdgIGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlciBvciBtdXRhdGUgdGhlIG5vZGUgaXRzZWxmLCBpbiB3aGljaCBjYXNlXG4gKiB0aGV5IGRlZmluZSBiZWhhdmlvciBpbiB0aGUgbW9zdCBleHBsaWNpdCB3YXkuIENvbXBvbmVudHMgdGhhdCBzZW5kIGBkcmF3YFxuICogY29tbWFuZHMgYWFyZSBjb25zaWRlcmVkIGByZW5kZXJhYmxlc2AuIEZyb20gdGhlIG5vZGUncyBwZXJzcGVjdGl2ZSwgdGhlcmUgaXNcbiAqIG5vIGRpc3RpbmN0aW9uIGJldHdlZW4gbm9kZXMgdGhhdCBzZW5kIGRyYXcgY29tbWFuZHMgYW5kIG5vZGVzIHRoYXQgZGVmaW5lXG4gKiBiZWhhdmlvci5cbiAqXG4gKiBCZWNhdXNlIG9mIHRoZSBmYWN0IHRoYXQgTm9kZXMgdGhlbXNlbGYgYXJlIHZlcnkgdW5vcGluaW90ZWQgKHRoZXkgZG9uJ3RcbiAqIFwicmVuZGVyXCIgdG8gYW55dGhpbmcpLCB0aGV5IGFyZSBvZnRlbiBiZWluZyBzdWJjbGFzc2VkIGluIG9yZGVyIHRvIGFkZCBlLmcuXG4gKiBjb21wb25lbnRzIGF0IGluaXRpYWxpemF0aW9uIHRvIHRoZW0uIEJlY2F1c2Ugb2YgdGhpcyBmbGV4aWJpbGl0eSwgdGhleSBtaWdodFxuICogYXMgd2VsbCBoYXZlIGJlZW4gY2FsbGVkIGBFbnRpdGllc2AuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGNyZWF0ZSB0aHJlZSBkZXRhY2hlZCAodW5tb3VudGVkKSBub2Rlc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKCk7XG4gKiB2YXIgY2hpbGQxID0gbmV3IE5vZGUoKTtcbiAqIHZhciBjaGlsZDIgPSBuZXcgTm9kZSgpO1xuICpcbiAqIC8vIGJ1aWxkIGFuIHVubW91bnRlZCBzdWJ0cmVlIChwYXJlbnQgaXMgc3RpbGwgZGV0YWNoZWQpXG4gKiBwYXJlbnQuYWRkQ2hpbGQoY2hpbGQxKTtcbiAqIHBhcmVudC5hZGRDaGlsZChjaGlsZDIpO1xuICpcbiAqIC8vIG1vdW50IHBhcmVudCBieSBhZGRpbmcgaXQgdG8gdGhlIGNvbnRleHRcbiAqIHZhciBjb250ZXh0ID0gRmFtb3VzLmNyZWF0ZUNvbnRleHQoXCJib2R5XCIpO1xuICogY29udGV4dC5hZGRDaGlsZChwYXJlbnQpO1xuICpcbiAqIEBjbGFzcyBOb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTm9kZSAoKSB7XG4gICAgdGhpcy5fY2FsY3VsYXRlZFZhbHVlcyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KElERU5UKSxcbiAgICAgICAgc2l6ZTogbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIH07XG5cbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlID0gW107XG4gICAgdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlID0gW107XG5cbiAgICB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlciA9IG51bGw7XG5cbiAgICB0aGlzLl9sYXN0RXVsZXJYID0gMDtcbiAgICB0aGlzLl9sYXN0RXVsZXJZID0gMDtcbiAgICB0aGlzLl9sYXN0RXVsZXJaID0gMDtcbiAgICB0aGlzLl9sYXN0RXVsZXIgPSBmYWxzZTtcblxuICAgIHRoaXMudmFsdWUgPSBuZXcgTm9kZS5TcGVjKCk7XG59XG5cbk5vZGUuUkVMQVRJVkVfU0laRSA9IFNpemUuUkVMQVRJVkU7XG5Ob2RlLkFCU09MVVRFX1NJWkUgPSBTaXplLkFCU09MVVRFO1xuTm9kZS5SRU5ERVJfU0laRSA9IFNpemUuUkVOREVSO1xuTm9kZS5ERUZBVUxUX1NJWkUgPSBTaXplLkRFRkFVTFQ7XG5cbi8qKlxuICogQSBOb2RlIHNwZWMgaG9sZHMgdGhlIFwiZGF0YVwiIGFzc29jaWF0ZWQgd2l0aCBhIE5vZGUuXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGxvY2F0aW9uIHBhdGggdG8gdGhlIG5vZGUgKGUuZy4gXCJib2R5LzAvMVwiKVxuICogQHByb3BlcnR5IHtPYmplY3R9IHNob3dTdGF0ZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBzaG93U3RhdGUubW91bnRlZFxuICogQHByb3BlcnR5IHtCb29sZWFufSBzaG93U3RhdGUuc2hvd25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzaG93U3RhdGUub3BhY2l0eVxuICogQHByb3BlcnR5IHtPYmplY3R9IG9mZnNldHNcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBvZmZzZXRzLm1vdW50UG9pbnRcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBvZmZzZXRzLmFsaWduXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gb2Zmc2V0cy5vcmlnaW5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB2ZWN0b3JzXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gdmVjdG9ycy5wb3NpdGlvblxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHZlY3RvcnMucm90YXRpb25cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSB2ZWN0b3JzLnNjYWxlXG4gKiBAcHJvcGVydHkge09iamVjdH0gc2l6ZVxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHNpemUuc2l6ZU1vZGVcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBzaXplLnByb3BvcnRpb25hbFxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHNpemUuZGlmZmVyZW50aWFsXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gc2l6ZS5hYnNvbHV0ZVxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHNpemUucmVuZGVyXG4gKi9cbk5vZGUuU3BlYyA9IGZ1bmN0aW9uIFNwZWMgKCkge1xuICAgIHRoaXMubG9jYXRpb24gPSBudWxsO1xuICAgIHRoaXMuc2hvd1N0YXRlID0ge1xuICAgICAgICBtb3VudGVkOiBmYWxzZSxcbiAgICAgICAgc2hvd246IGZhbHNlLFxuICAgICAgICBvcGFjaXR5OiAxXG4gICAgfTtcbiAgICB0aGlzLm9mZnNldHMgPSB7XG4gICAgICAgIG1vdW50UG9pbnQ6IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIGFsaWduOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICBvcmlnaW46IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICB9O1xuICAgIHRoaXMudmVjdG9ycyA9IHtcbiAgICAgICAgcG9zaXRpb246IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIHJvdGF0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFFVQVQpLFxuICAgICAgICBzY2FsZTogbmV3IEZsb2F0MzJBcnJheShPTkVTKVxuICAgIH07XG4gICAgdGhpcy5zaXplID0ge1xuICAgICAgICBzaXplTW9kZTogbmV3IEZsb2F0MzJBcnJheShbU2l6ZS5SRUxBVElWRSwgU2l6ZS5SRUxBVElWRSwgU2l6ZS5SRUxBVElWRV0pLFxuICAgICAgICBwcm9wb3J0aW9uYWw6IG5ldyBGbG9hdDMyQXJyYXkoT05FUyksXG4gICAgICAgIGRpZmZlcmVudGlhbDogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgYWJzb2x1dGU6IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIHJlbmRlcjogbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIH07XG4gICAgdGhpcy5VSUV2ZW50cyA9IFtdO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIG5vZGUncyBsb2NhdGlvbiBpbiB0aGUgc2NlbmUgZ3JhcGggaGllcmFyY2h5LlxuICogQSBsb2NhdGlvbiBvZiBgYm9keS8wLzFgIGNhbiBiZSBpbnRlcnByZXRlZCBhcyB0aGUgZm9sbG93aW5nIHNjZW5lIGdyYXBoXG4gKiBoaWVyYXJjaHkgKGlnbm9yaW5nIHNpYmxpbmdzIG9mIGFuY2VzdG9ycyBhbmQgYWRkaXRpb25hbCBjaGlsZCBub2Rlcyk6XG4gKlxuICogYENvbnRleHQ6Ym9keWAgLT4gYE5vZGU6MGAgLT4gYE5vZGU6MWAsIHdoZXJlIGBOb2RlOjFgIGlzIHRoZSBub2RlIHRoZVxuICogYGdldExvY2F0aW9uYCBtZXRob2QgaGFzIGJlZW4gaW52b2tlZCBvbi5cbiAqXG4gKiBAbWV0aG9kIGdldExvY2F0aW9uXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBsb2NhdGlvbiAocGF0aCksIGUuZy4gYGJvZHkvMC8xYFxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sb2NhdGlvbjtcbn07XG5cbi8qKlxuICogQGFsaWFzIGdldElkXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldElkID0gTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb247XG5cbi8qKlxuICogRGlzcGF0Y2hlcyB0aGUgZXZlbnQgb24gdGhlIG5vZGUgYnkgcmVjdXJzaXZlbHkgdHJhdmVyc2luZyB0aGUgc2NlbmUgZ3JhcGhcbiAqIHVwd2FyZHMuXG4gKlxuICogQG1ldGhvZCBlbWl0XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBldmVudCAgIEV2ZW50IHR5cGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWQgRXZlbnQgb2JqZWN0IHRvIGJlIGRpc3BhdGNoZWQuXG4gKi9cbk5vZGUucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0IChldmVudCwgcGF5bG9hZCkge1xuICAgIHZhciBwID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAvLyB0aGUgY29udGV4dCBpcyBpdHMgb3duIGFuY2VzdG9yXG4gICAgd2hpbGUgKHAgIT09IChwID0gcC5nZXRQYXJlbnQoKSkpO1xuICAgIHAuZ2V0RGlzcGF0Y2goKS5kaXNwYXRjaChldmVudCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUSElTIFdJTEwgQkUgREVQUklDQVRFRFxuTm9kZS5wcm90b3R5cGUuc2VuZERyYXdDb21tYW5kID0gZnVuY3Rpb24gc2VuZERyYXdDb21tYW5kIChtZXNzYWdlKSB7XG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlci5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIHRoZSBOb2RlLCBpbmNsdWRpbmcgYWxsIHByZXZpb3VzbHkgYWRkZWQgY29tcG9uZW50cy5cbiAqXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSAgICAgU2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZSwgaW5jbHVkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgICB2YXIgbnVtYmVyT2ZDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgbnVtYmVyT2ZDb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBsb2NhdGlvbjogdGhpcy52YWx1ZS5sb2NhdGlvbixcbiAgICAgICAgc3BlYzogdGhpcy52YWx1ZSxcbiAgICAgICAgY29tcG9uZW50czogbmV3IEFycmF5KG51bWJlck9mQ29tcG9uZW50cyksXG4gICAgICAgIGNoaWxkcmVuOiBuZXcgQXJyYXkobnVtYmVyT2ZDaGlsZHJlbilcbiAgICB9O1xuXG4gICAgZm9yICg7IGkgPCBudW1iZXJPZkNoaWxkcmVuIDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0gJiYgdGhpcy5fY2hpbGRyZW5baV0uZ2V0VmFsdWUpXG4gICAgICAgICAgICB2YWx1ZS5jaGlsZHJlbltpXSA9IHRoaXMuX2NoaWxkcmVuW2ldLmdldFZhbHVlKCk7XG5cbiAgICBmb3IgKGkgPSAwIDsgaSA8IG51bWJlck9mQ29tcG9uZW50cyA7IGkrKylcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNbaV0gJiYgdGhpcy5fY29tcG9uZW50c1tpXS5nZXRWYWx1ZSlcbiAgICAgICAgICAgIHZhbHVlLmNvbXBvbmVudHNbaV0gPSB0aGlzLl9jb21wb25lbnRzW2ldLmdldFZhbHVlKCk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gQHtAbGluayBnZXRWYWx1ZX0sIGJ1dCByZXR1cm5zIHRoZSBhY3R1YWwgXCJjb21wdXRlZFwiIHZhbHVlLiBFLmcuXG4gKiBhIHByb3BvcnRpb25hbCBzaXplIG9mIDAuNSBtaWdodCByZXNvbHZlIGludG8gYSBcImNvbXB1dGVkXCIgc2l6ZSBvZiAyMDBweFxuICogKGFzc3VtaW5nIHRoZSBwYXJlbnQgaGFzIGEgd2lkdGggb2YgNDAwcHgpLlxuICpcbiAqIEBtZXRob2QgZ2V0Q29tcHV0ZWRWYWx1ZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gICAgIFNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGUsIGluY2x1ZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4sIGV4Y2x1ZGluZyBjb21wb25lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRDb21wdXRlZFZhbHVlID0gZnVuY3Rpb24gZ2V0Q29tcHV0ZWRWYWx1ZSAoKSB7XG4gICAgdmFyIG51bWJlck9mQ2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICB2YXIgdmFsdWUgPSB7XG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLnZhbHVlLmxvY2F0aW9uLFxuICAgICAgICBjb21wdXRlZFZhbHVlczogdGhpcy5fY2FsY3VsYXRlZFZhbHVlcyxcbiAgICAgICAgY2hpbGRyZW46IG5ldyBBcnJheShudW1iZXJPZkNoaWxkcmVuKVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBudW1iZXJPZkNoaWxkcmVuIDsgaSsrKVxuICAgICAgICB2YWx1ZS5jaGlsZHJlbltpXSA9IHRoaXMuX2NoaWxkcmVuW2ldLmdldENvbXB1dGVkVmFsdWUoKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0Q2hpbGRyZW5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48Tm9kZT59ICAgQW4gYXJyYXkgb2YgY2hpbGRyZW4uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZS4gVW5tb3VudGVkIG5vZGVzIGRvIG5vdCBoYXZlIGFcbiAqIHBhcmVudCBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0UGFyZW50XG4gKlxuICogQHJldHVybiB7Tm9kZX0gICAgICAgUGFyZW50IG5vZGUuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIHRoZSBAe0BsaW5rIHVwZGF0ZX0gZnVuY3Rpb24gb2YgdGhlIG5vZGUgdG8gYmUgaW52b2tlZCBvbiB0aGUgbmV4dFxuICogZnJhbWUgKGlmIG5vIHVwZGF0ZSBkdXJpbmcgdGhpcyBmcmFtZSBoYXMgYmVlbiBzY2hlZHVsZWQgYWxyZWFkeSkuXG4gKiBJZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgYmVpbmcgdXBkYXRlZCAod2hpY2ggbWVhbnMgb25lIG9mIHRoZSByZXF1ZXN0ZXJzXG4gKiBpbnZva2VkIHJlcXVlc3RzVXBkYXRlIHdoaWxlIGJlaW5nIHVwZGF0ZWQgaXRzZWxmKSwgYW4gdXBkYXRlIHdpbGwgYmVcbiAqIHNjaGVkdWxlZCBvbiB0aGUgbmV4dCBmcmFtZS5cbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RVcGRhdGVcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlcXVlc3RlciAgIElmIHRoZSByZXF1ZXN0ZXIgaGFzIGFuIGBvblVwZGF0ZWAgbWV0aG9kLCBpdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGludm9rZWQgZHVyaW5nIHRoZSBuZXh0IHVwZGF0ZSBwaGFzZSBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbm9kZS5cbiAqL1xuTm9kZS5wcm90b3R5cGUucmVxdWVzdFVwZGF0ZSA9IGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGUgKHJlcXVlc3Rlcikge1xuICAgIGlmICh0aGlzLl9pblVwZGF0ZSB8fCAhdGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2socmVxdWVzdGVyKTtcbiAgICB0aGlzLl91cGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlcyBhbiB1cGRhdGUgb24gdGhlIG5leHQgdGljay4gU2ltaWxhcmlseSB0byBAe0BsaW5rIHJlcXVlc3RVcGRhdGV9LFxuICogYHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrYCBzY2hlZHVsZXMgdGhlIG5vZGUncyBgb25VcGRhdGVgIGZ1bmN0aW9uIHRvIGJlXG4gKiBpbnZva2VkIG9uIHRoZSBmcmFtZSBhZnRlciB0aGUgbmV4dCBpbnZvY2F0aW9uIG9uIHRoZSBub2RlJ3Mgb25VcGRhdGUgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0VXBkYXRlT25OZXh0VGlja1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gcmVxdWVzdGVyICAgSWYgdGhlIHJlcXVlc3RlciBoYXMgYW4gYG9uVXBkYXRlYCBtZXRob2QsIGl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgaW52b2tlZCBkdXJpbmcgdGhlIG5leHQgdXBkYXRlIHBoYXNlIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayA9IGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrIChyZXF1ZXN0ZXIpIHtcbiAgICB0aGlzLl9uZXh0VXBkYXRlUXVldWUucHVzaChyZXF1ZXN0ZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgY29udGV4dCBoYXMgYmVlbiBjcmVhdGVkIHVzaW5nIEB7QGxpbmsgRmFtb3VzLmNyZWF0ZUNvbnRleHR9LCB0aGVcbiAqIEB7QGxpbmsgRmFtb3VzfSBzaW5nbGV0b24gd2lsbCBiZSB0aGUgZ2xvYmFsIHVwZGF0ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRVcGRhdGVyXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZ2xvYmFsIHVwZGF0ZXIuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFVwZGF0ZXIgPSBmdW5jdGlvbiBnZXRVcGRhdGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFsVXBkYXRlcjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIG1vdW50ZWQuIFVubW91bnRlZCBub2RlcyBhcmUgZGV0YWNoZWQgZnJvbSB0aGUgc2NlbmVcbiAqIGdyYXBoLlxuICpcbiAqIEBtZXRob2QgaXNNb3VudGVkXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgQm9vbGVhbiBpbmRpY2F0aW5nIHdlYXRoZXIgdGhlIG5vZGUgaXMgbW91bnRlZCBvciBub3QuXG4gKi9cbk5vZGUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2hvd1N0YXRlLm1vdW50ZWQ7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyB2aXNpYmxlIChcInNob3duXCIpLlxuICpcbiAqIEBtZXRob2QgaXNTaG93blxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3ZWF0aGVyIHRoZSBub2RlIGlzIHZpc2libGVcbiAqICAgICAgICAgICAgICAgICAgICAgIChcInNob3duXCIpIG9yIG5vdC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuaXNTaG93biA9IGZ1bmN0aW9uIGlzU2hvd24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNob3dTdGF0ZS5zaG93bjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHJlbGF0aXZlIG9wYWNpdHkuXG4gKiBUaGUgb3BhY2l0eSBuZWVkcyB0byBiZSB3aXRoaW4gWzAsIDFdLCB3aGVyZSAwIGluZGljYXRlcyBhIGNvbXBsZXRlbHlcbiAqIHRyYW5zcGFyZW50LCB0aGVyZWZvcmUgaW52aXNpYmxlIG5vZGUsIHdoZXJlYXMgYW4gb3BhY2l0eSBvZiAxIG1lYW5zIHRoZVxuICogbm9kZSBpcyBjb21wbGV0ZWx5IHNvbGlkLlxuICpcbiAqIEBtZXRob2QgZ2V0T3BhY2l0eVxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBSZWxhdGl2ZSBvcGFjaXR5IG9mIHRoZSBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2hvd1N0YXRlLm9wYWNpdHk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyBwcmV2aW91c2x5IHNldCBtb3VudCBwb2ludC5cbiAqXG4gKiBAbWV0aG9kIGdldE1vdW50UG9pbnRcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBtb3VudCBwb2ludC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIGdldE1vdW50UG9pbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLm9mZnNldHMubW91bnRQb2ludDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IGFsaWduLlxuICpcbiAqIEBtZXRob2QgZ2V0QWxpZ25cbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBhbGlnbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0QWxpZ24gPSBmdW5jdGlvbiBnZXRBbGlnbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUub2Zmc2V0cy5hbGlnbjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IG9yaWdpbi5cbiAqXG4gKiBAbWV0aG9kIGdldE9yaWdpblxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gICBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIG9yaWdpbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5vZmZzZXRzLm9yaWdpbjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IHBvc2l0aW9uLlxuICpcbiAqIEBtZXRob2QgZ2V0UG9zaXRpb25cbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudmVjdG9ycy5wb3NpdGlvbjtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0Um90YXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnZlY3RvcnMucm90YXRpb247XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uIGdldFNjYWxlICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS52ZWN0b3JzLnNjYWxlO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0U2l6ZU1vZGUgPSBmdW5jdGlvbiBnZXRTaXplTW9kZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5zaXplTW9kZTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFByb3BvcnRpb25hbFNpemUgPSBmdW5jdGlvbiBnZXRQcm9wb3J0aW9uYWxTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5zaXplLnByb3BvcnRpb25hbDtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldERpZmZlcmVudGlhbFNpemUgPSBmdW5jdGlvbiBnZXREaWZmZXJlbnRpYWxTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5zaXplLmRpZmZlcmVudGlhbDtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldEFic29sdXRlU2l6ZSA9IGZ1bmN0aW9uIGdldEFic29sdXRlU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5hYnNvbHV0ZTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFJlbmRlclNpemUgPSBmdW5jdGlvbiBnZXRSZW5kZXJTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5zaXplLnJlbmRlcjtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlZFZhbHVlcy5zaXplO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0VHJhbnNmb3JtICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlZFZhbHVlcy50cmFuc2Zvcm07XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRVSUV2ZW50cyA9IGZ1bmN0aW9uIGdldFVJRXZlbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5VSUV2ZW50cztcbn07XG5cbk5vZGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGNoaWxkKSB7XG4gICAgdmFyIGluZGV4ID0gY2hpbGQgPyB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSA6IC0xO1xuICAgIGNoaWxkID0gY2hpbGQgPyBjaGlsZCA6IG5ldyBOb2RlKCk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzLmxlbmd0aCA/IHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcy5wb3AoKSA6IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW5baW5kZXhdID0gY2hpbGQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKCkgJiYgY2hpbGQub25Nb3VudCkge1xuICAgICAgICAgICAgdmFyIG15SWQgPSB0aGlzLmdldElkKCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRJZCA9IG15SWQgKyAnLycgKyBpbmRleDtcbiAgICAgICAgICAgIGNoaWxkLm9uTW91bnQodGhpcywgY2hpbGRJZCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbk5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGNoaWxkKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgdmFyIGFkZGVkID0gaW5kZXggIT09IC0xO1xuICAgIGlmIChhZGRlZCkge1xuICAgICAgICB0aGlzLl9mcmVlZENoaWxkSW5kaWNpZXMucHVzaChpbmRleCk7XG5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW5baW5kZXhdID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiBjaGlsZC5vbkRpc21vdW50KVxuICAgICAgICAgICAgY2hpbGQub25EaXNtb3VudCgpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkZWQ7XG59O1xuXG4vKipcbiAqIEVhY2ggY29tcG9uZW50IGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgcGVyIG5vZGUuXG4gKlxuICogQG1ldGhvZCBhZGRDb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50ICAgIEFuIGNvbXBvbmVudCB0byBiZSBhZGRlZC5cbiAqIEByZXR1cm4ge051bWJlcn0gaW5kZXggICAgICAgVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBjb21wb25lbnQgaGFzIGJlZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZC4gSW5kaWNlcyBhcmVuJ3QgbmVjZXNzYXJpbHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc2VjdXRpdmUuXG4gKi9cbk5vZGUucHJvdG90eXBlLmFkZENvbXBvbmVudCA9IGZ1bmN0aW9uIGFkZENvbXBvbmVudCAoY29tcG9uZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fY29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpbmRleCA9IHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMubGVuZ3RoID8gdGhpcy5fZnJlZWRDb21wb25lbnRJbmRpY2llcy5wb3AoKSA6IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IGNvbXBvbmVudDtcblxuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiBjb21wb25lbnQub25Nb3VudClcbiAgICAgICAgICAgIGNvbXBvbmVudC5vbk1vdW50KHRoaXMsIGluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5pc1Nob3duKCkgJiYgY29tcG9uZW50Lm9uU2hvdylcbiAgICAgICAgICAgIGNvbXBvbmVudC5vblNob3coKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgIGdldENvbXBvbmVudFxuICogIFxuICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAgIEluZGV4IGF0IHdoaWNoIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gcmVnc2l0ZXJlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICh1c2luZyBgTm9kZSNhZGRDb21wb25lbnRgKS5cbiAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICBUaGUgY29tcG9uZW50IHJlZ2lzdGVyZWQgYXQgdGhlIHBhc3NlZCBpbiBpbmRleCAoaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbnkpLlxuICovIFxuTm9kZS5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0Q29tcG9uZW50IChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW2luZGV4XTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgdmlhIEB7QGxpbmsgYWRkQ29tcG9uZW50fSBhZGRlZCBjb21wb25lbnQuXG4gKlxuICogQG1ldGhvZCByZW1vdmVDb21wb25lbnRcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbXBvbmVudCAgIEFuIGNvbXBvbmVudCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gYWRkZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmcgQHtAbGluayBhZGRDb21wb25lbnR9LlxuICovXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVDb21wb25lbnQgPSBmdW5jdGlvbiByZW1vdmVDb21wb25lbnQgKGNvbXBvbmVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2NvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5fZnJlZWRDb21wb25lbnRJbmRpY2llcy5wdXNoKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93bigpICYmIGNvbXBvbmVudC5vbkhpZGUpXG4gICAgICAgICAgICBjb21wb25lbnQub25IaWRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKCkgJiYgY29tcG9uZW50Lm9uRGlzbW91bnQpXG4gICAgICAgICAgICBjb21wb25lbnQub25EaXNtb3VudCgpO1xuXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn07XG5cbk5vZGUucHJvdG90eXBlLmFkZFVJRXZlbnQgPSBmdW5jdGlvbiBhZGRVSUV2ZW50IChldmVudE5hbWUpIHtcbiAgICB2YXIgVUlFdmVudHMgPSB0aGlzLmdldFVJRXZlbnRzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICB2YXIgYWRkZWQgPSBVSUV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgIT09IC0xO1xuICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgVUlFdmVudHMucHVzaChldmVudE5hbWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQub25BZGRVSUV2ZW50KSBjb21wb25lbnQub25BZGRVSUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlICYmIHRoaXMuX2dsb2JhbFVwZGF0ZXIpKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIucmVxdWVzdFVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX3ZlY09wdGlvbmFsU2V0ID0gZnVuY3Rpb24gX3ZlY09wdGlvbmFsU2V0ICh2ZWMsIGluZGV4LCB2YWwpIHtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmVjW2luZGV4XSAhPT0gdmFsKSB7XG4gICAgICAgIHZlY1tpbmRleF0gPSB2YWw7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cgKCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB0aGlzLnZhbHVlLnNob3dTdGF0ZS5zaG93biA9IHRydWU7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25TaG93KSBpdGVtLm9uU2hvdygpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50U2hvdykgaXRlbS5vblBhcmVudFNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLnNob3duID0gZmFsc2U7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25IaWRlKSBpdGVtLm9uSGlkZSgpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50SGlkZSkgaXRlbS5vblBhcmVudEhpZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRBbGlnbiA9IGZ1bmN0aW9uIHNldEFsaWduICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLm9mZnNldHMuYWxpZ247XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBpZiAoeiAhPSBudWxsKSBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCAoeiAtIDAuNSkpIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25BbGlnbkNoYW5nZSkgaXRlbS5vbkFsaWduQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIHNldE1vdW50UG9pbnQgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUub2Zmc2V0cy5tb3VudFBvaW50O1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgaWYgKHogIT0gbnVsbCkgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMiwgKHogLSAwLjUpKSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uTW91bnRQb2ludENoYW5nZSkgaXRlbS5vbk1vdW50UG9pbnRDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRPcmlnaW4gPSBmdW5jdGlvbiBzZXRPcmlnaW4gKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUub2Zmc2V0cy5vcmlnaW47XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBpZiAoeiAhPSBudWxsKSBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCAoeiAtIDAuNSkpIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25PcmlnaW5DaGFuZ2UpIGl0ZW0ub25PcmlnaW5DaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24gKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUudmVjdG9ycy5wb3NpdGlvbjtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25Qb3NpdGlvbkNoYW5nZSkgaXRlbS5vblBvc2l0aW9uQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIHNldFJvdGF0aW9uICh4LCB5LCB6LCB3KSB7XG4gICAgdmFyIHF1YXQgPSB0aGlzLnZhbHVlLnZlY3RvcnMucm90YXRpb247XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuICAgIHZhciBxeCwgcXksIHF6LCBxdztcblxuICAgIGlmICh3ICE9IG51bGwpIHtcbiAgICAgICAgcXggPSB4O1xuICAgICAgICBxeSA9IHk7XG4gICAgICAgIHF6ID0gejtcbiAgICAgICAgcXcgPSB3O1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXJYID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdEV1bGVyWSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RFdWxlclogPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsIHx8IHogPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RFdWxlcikge1xuICAgICAgICAgICAgICAgIHggPSB4ID09IG51bGwgPyB0aGlzLl9sYXN0RXVsZXJYIDogeDtcbiAgICAgICAgICAgICAgICB5ID0geSA9PSBudWxsID8gdGhpcy5fbGFzdEV1bGVyWSA6IHk7XG4gICAgICAgICAgICAgICAgeiA9IHogPT0gbnVsbCA/IHRoaXMuX2xhc3RFdWxlclogOiB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwID0gLTIgKiAocXVhdFsxXSAqIHF1YXRbMl0gLSBxdWF0WzNdICogcXVhdFswXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3ApID4gKDEgLSBOdW1iZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geSA9PSBudWxsID8gTWF0aC5QSSAqIDAuNSAqIHNwIDogeTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHggPT0gbnVsbCA/IE1hdGguYXRhbjIoLXF1YXRbMF0gKiBxdWF0WzJdICsgcXVhdFszXSAqIHF1YXRbMV0sIDAuNSAtIHF1YXRbMV0gKiBxdWF0WzFdIC0gcXVhdFsyXSAqIHF1YXRbMl0pIDogeDtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHogPT0gbnVsbCA/IDAgOiB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkgPT0gbnVsbCA/IE1hdGguYXNpbihzcCkgOiB5O1xuICAgICAgICAgICAgICAgICAgICB4ID0geCA9PSBudWxsID8gTWF0aC5hdGFuMihxdWF0WzBdICogcXVhdFsyXSArIHF1YXRbM10gKiBxdWF0WzFdLCAwLjUgLSBxdWF0WzBdICogcXVhdFswXSAtIHF1YXRbMV0gKiBxdWF0WzFdKSA6IHg7XG4gICAgICAgICAgICAgICAgICAgIHogPSB6ID09IG51bGwgPyBNYXRoLmF0YW4yKHF1YXRbMF0gKiBxdWF0WzFdICsgcXVhdFszXSAqIHF1YXRbMl0sIDAuNSAtIHF1YXRbMF0gKiBxdWF0WzBdIC0gcXVhdFsyXSAqIHF1YXRbMl0pIDogejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHggPSB4ICogMC41O1xuICAgICAgICB2YXIgaHkgPSB5ICogMC41O1xuICAgICAgICB2YXIgaHogPSB6ICogMC41O1xuXG4gICAgICAgIHZhciBzeCA9IE1hdGguc2luKGh4KTtcbiAgICAgICAgdmFyIHN5ID0gTWF0aC5zaW4oaHkpO1xuICAgICAgICB2YXIgc3ogPSBNYXRoLnNpbihoeik7XG4gICAgICAgIHZhciBjeCA9IE1hdGguY29zKGh4KTtcbiAgICAgICAgdmFyIGN5ID0gTWF0aC5jb3MoaHkpO1xuICAgICAgICB2YXIgY3ogPSBNYXRoLmNvcyhoeik7XG5cbiAgICAgICAgdmFyIHN5c3ogPSBzeSAqIHN6O1xuICAgICAgICB2YXIgY3lzeiA9IGN5ICogc3o7XG4gICAgICAgIHZhciBzeWN6ID0gc3kgKiBjejtcbiAgICAgICAgdmFyIGN5Y3ogPSBjeSAqIGN6O1xuXG4gICAgICAgIHF4ID0gc3ggKiBjeWN6ICsgY3ggKiBzeXN6O1xuICAgICAgICBxeSA9IGN4ICogc3ljeiAtIHN4ICogY3lzejtcbiAgICAgICAgcXogPSBjeCAqIGN5c3ogKyBzeCAqIHN5Y3o7XG4gICAgICAgIHF3ID0gY3ggKiBjeWN6IC0gc3ggKiBzeXN6O1xuXG4gICAgICAgIHRoaXMuX2xhc3RFdWxlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xhc3RFdWxlclggPSB4O1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXJZID0geTtcbiAgICAgICAgdGhpcy5fbGFzdEV1bGVyWiA9IHo7XG4gICAgfVxuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQocXVhdCwgMCwgcXgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldChxdWF0LCAxLCBxeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHF1YXQsIDIsIHF6KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQocXVhdCwgMywgcXcpIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSBxdWF0WzBdO1xuICAgICAgICB5ID0gcXVhdFsxXTtcbiAgICAgICAgeiA9IHF1YXRbMl07XG4gICAgICAgIHcgPSBxdWF0WzNdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUm90YXRpb25DaGFuZ2UpIGl0ZW0ub25Sb3RhdGlvbkNoYW5nZSh4LCB5LCB6LCB3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUudmVjdG9ycy5zY2FsZTtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25TY2FsZUNoYW5nZSkgaXRlbS5vblNjYWxlQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIHNldE9wYWNpdHkgKHZhbCkge1xuICAgIGlmICh2YWwgIT09IHRoaXMudmFsdWUuc2hvd1N0YXRlLm9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5zaG93U3RhdGUub3BhY2l0eSA9IHZhbDtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25PcGFjaXR5Q2hhbmdlKSBpdGVtLm9uT3BhY2l0eUNoYW5nZSh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzaXplIG1vZGUgYmVpbmcgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIG5vZGVzIGZpbmFsIHdpZHRoLCBoZWlnaHRcbiAqIGFuZCBkZXB0aC5cbiAqIFNpemUgbW9kZXMgYXJlIGEgd2F5IHRvIGRlZmluZSB0aGUgd2F5IHRoZSBub2RlJ3Mgc2l6ZSBpcyBiZWluZyBjYWxjdWxhdGVkLlxuICogU2l6ZSBtb2RlcyBhcmUgZW51bXMgc2V0IG9uIHRoZSBAe0BsaW5rIFNpemV9IGNvbnN0cnVjdG9yIChhbmQgYWxpYXNlZCBvblxuICogdGhlIE5vZGUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBub2RlLnNldFNpemVNb2RlKE5vZGUuUkVMQVRJVkVfU0laRSwgTm9kZS5BQlNPTFVURV9TSVpFLCBOb2RlLkFCU09MVVRFX1NJWkUpO1xuICogLy8gSW5zdGVhZCBvZiBudWxsLCBhbnkgcHJvcG9yaW9uYWwgaGVpZ2h0IG9yIGRlcHRoIGNhbiBiZSBwYXNzZWQgaW4sIHNpbmNlXG4gKiAvLyBpdCB3b3VsZCBiZSBpZ25vcmVkIGluIGFueSBjYXNlLlxuICogbm9kZS5zZXRQcm9wb3J0aW9uYWxTaXplKDAuNSwgbnVsbCwgbnVsbCk7XG4gKiBub2RlLnNldEFic29sdXRlU2l6ZShudWxsLCAxMDAsIDIwMCk7XG4gKlxuICogQG1ldGhvZCBzZXRTaXplTW9kZVxuICpcbiAqIEBwYXJhbSB7U2l6ZU1vZGV9IHggICAgVGhlIHNpemUgbW9kZSBiZWluZyB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgc2l6ZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICB4IGRpcmVjdGlvbiAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7U2l6ZU1vZGV9IHkgICAgVGhlIHNpemUgbW9kZSBiZWluZyB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgc2l6ZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICB5IGRpcmVjdGlvbiAoXCJoZWlnaHRcIikuXG4gKiBAcGFyYW0ge1NpemVNb2RlfSB6ICAgIFRoZSBzaXplIG1vZGUgYmVpbmcgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIHNpemUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgeiBkaXJlY3Rpb24gKFwiZGVwdGhcIikuXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFNpemVNb2RlID0gZnVuY3Rpb24gc2V0U2l6ZU1vZGUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUuc2l6ZS5zaXplTW9kZTtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG4gICAgXG4gICAgaWYgKHggIT0gbnVsbCkgcHJvcG9nYXRlID0gdGhpcy5fcmVzb2x2ZVNpemVNb2RlKHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBpZiAoeSAhPSBudWxsKSBwcm9wb2dhdGUgPSB0aGlzLl9yZXNvbHZlU2l6ZU1vZGUodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIGlmICh6ICE9IG51bGwpIHByb3BvZ2F0ZSA9IHRoaXMuX3Jlc29sdmVTaXplTW9kZSh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uU2l6ZU1vZGVDaGFuZ2UpIGl0ZW0ub25TaXplTW9kZUNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQSBwcm90ZWN0ZWQgbWV0aG9kIHRoYXQgcmVzb2x2ZXMgc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBvZiBzaXplIG1vZGVcbiAqIHRvIG51bWVyaWMgdmFsdWVzIGFuZCBhcHBsaWVzIHRoZW0uXG4gKlxuICogQG1ldGhvZCBfcmVzb2x2ZVNpemVNb2RlXG4gKlxuICogQHJldHVybiB7Qm9vbH0gd2hldGhlciBvciBub3QgdGhlIHNpemVtb2RlIGhhcyBiZWVuIGNoYW5nZWQgZm9yIHRoaXMgaW5kZXguXG4gKi9cbk5vZGUucHJvdG90eXBlLl9yZXNvbHZlU2l6ZU1vZGUgPSBmdW5jdGlvbiBfcmVzb2x2ZVNpemVNb2RlICh2ZWMsIGluZGV4LCB2YWwpIHtcbiAgICBpZiAodmFsLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgc3dpdGNoICh2YWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAncmVsYXRpdmUnOlxuICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYywgaW5kZXgsIDApO1xuICAgICAgICAgICAgY2FzZSAnYWJzb2x1dGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMsIGluZGV4LCAxKTtcbiAgICAgICAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYywgaW5kZXgsIDIpO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNpemUgbW9kZTogJyArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSByZXR1cm4gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjLCBpbmRleCwgdmFsKTtcbn07XG5cbi8qKlxuICogQSBwcm9wb3J0aW9uYWwgc2l6ZSBkZWZpbmVzIHRoZSBub2RlJ3MgZGltZW5zaW9ucyByZWxhdGl2ZSB0byBpdHMgcGFyZW50c1xuICogZmluYWwgc2l6ZS5cbiAqIFByb3BvcnRpb25hbCBzaXplcyBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgWzAsIDFdLlxuICpcbiAqIEBtZXRob2Qgc2V0UHJvcG9ydGlvbmFsU2l6ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4ICAgIHgtU2l6ZSBpbiBwaXhlbHMgKFwid2lkdGhcIikuXG4gKiBAcGFyYW0ge051bWJlcn0geSAgICB5LVNpemUgaW4gcGl4ZWxzIChcImhlaWdodFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6ICAgIHotU2l6ZSBpbiBwaXhlbHMgKFwiZGVwdGhcIikuXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFByb3BvcnRpb25hbFNpemUgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWxTaXplICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnNpemUucHJvcG9ydGlvbmFsO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblByb3BvcnRpb25hbFNpemVDaGFuZ2UpIGl0ZW0ub25Qcm9wb3J0aW9uYWxTaXplQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaWZmZXJlbnRpYWwgc2l6aW5nIGNhbiBiZSB1c2VkIHRvIGFkZCBvciBzdWJ0cmFjdCBhbiBhYnNvbHV0ZSBzaXplIGZyb20gYVxuICogb3RoZXJ3aXNlIHByb3BvcnRpb25hbGx5IHNpemVkIG5vZGUuXG4gKiBFLmcuIGEgZGlmZmVyZW50aWFsIHdpZHRoIG9mIGAtMTBgIGFuZCBhIHByb3BvcnRpb25hbCB3aWR0aCBvZiBgMC41YCBpc1xuICogYmVpbmcgaW50ZXJwcmV0ZWQgYXMgc2V0dGluZyB0aGUgbm9kZSdzIHNpemUgdG8gNTAlIG9mIGl0cyBwYXJlbnQncyB3aWR0aFxuICogKm1pbnVzKiAxMCBwaXhlbHMuXG4gKlxuICogQG1ldGhvZCBzZXREaWZmZXJlbnRpYWxTaXplXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgeC1TaXplIHRvIGJlIGFkZGVkIHRvIHRoZSByZWxhdGl2ZWx5IHNpemVkIG5vZGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgIHktU2l6ZSB0byBiZSBhZGRlZCB0byB0aGUgcmVsYXRpdmVseSBzaXplZCBub2RlIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogICAgei1TaXplIHRvIGJlIGFkZGVkIHRvIHRoZSByZWxhdGl2ZWx5IHNpemVkIG5vZGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0RGlmZmVyZW50aWFsU2l6ZSA9IGZ1bmN0aW9uIHNldERpZmZlcmVudGlhbFNpemUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUuc2l6ZS5kaWZmZXJlbnRpYWw7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSkgaXRlbS5vbkRpZmZlcmVudGlhbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG5vZGVzIHNpemUgaW4gcGl4ZWxzLCBpbmRlcGVuZGVudCBvZiBpdHMgcGFyZW50LlxuICpcbiAqIEBtZXRob2Qgc2V0QWJzb2x1dGVTaXplXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgeC1TaXplIGluIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgIHktU2l6ZSBpbiBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogICAgei1TaXplIGluIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0QWJzb2x1dGVTaXplID0gZnVuY3Rpb24gc2V0QWJzb2x1dGVTaXplICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnNpemUuYWJzb2x1dGU7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uQWJzb2x1dGVTaXplQ2hhbmdlKSBpdGVtLm9uQWJzb2x1dGVTaXplQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3RyYW5zZm9ybUNoYW5nZWQgPSBmdW5jdGlvbiBfdHJhbnNmb3JtQ2hhbmdlZCAodHJhbnNmb3JtKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblRyYW5zZm9ybUNoYW5nZSkgaXRlbS5vblRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50VHJhbnNmb3JtQ2hhbmdlKSBpdGVtLm9uUGFyZW50VHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX3NpemVDaGFuZ2VkID0gZnVuY3Rpb24gX3NpemVDaGFuZ2VkIChzaXplKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblNpemVDaGFuZ2UpIGl0ZW0ub25TaXplQ2hhbmdlKHNpemUpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50U2l6ZUNoYW5nZSkgaXRlbS5vblBhcmVudFNpemVDaGFuZ2Uoc2l6ZSk7XG4gICAgfVxufTtcblxuLy8gREVQUklDQVRFXG5Ob2RlLnByb3RvdHlwZS5nZXRGcmFtZSA9IGZ1bmN0aW9uIGdldEZyYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFsVXBkYXRlci5nZXRGcmFtZSgpO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjb21wb25lbnRzIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGlzXG4gKiBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0Q29tcG9uZW50c1xuICpcbiAqIEByZXR1cm4ge0FycmF5fSBsaXN0IG9mIGNvbXBvbmVudHMuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRDb21wb25lbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cztcbn07XG5cbi8qKlxuICogRW50ZXJzIHRoZSBub2RlJ3MgdXBkYXRlIHBoYXNlIHdoaWxlIHVwZGF0aW5nIGl0cyBvd24gc3BlYyBhbmQgdXBkYXRpbmcgaXRzIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgICAgaGlnaC1yZXNvbHV0aW9uIHRpbXN0YW1wLCB1c3VhbGx5IHJldHJpZXZlZCB1c2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICovXG5Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHRpbWUpe1xuICAgIHRoaXMuX2luVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgbmV4dFF1ZXVlID0gdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3VwZGF0ZVF1ZXVlO1xuICAgIHZhciBpdGVtO1xuXG4gICAgd2hpbGUgKG5leHRRdWV1ZS5sZW5ndGgpIHF1ZXVlLnVuc2hpZnQobmV4dFF1ZXVlLnBvcCgpKTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2NvbXBvbmVudHNbcXVldWUuc2hpZnQoKV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25VcGRhdGUpIGl0ZW0ub25VcGRhdGUodGltZSk7XG4gICAgfVxuXG4gICAgdmFyIG15U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIHZhciBteVRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgdmFyIHBhcmVudFNpemUgPSBwYXJlbnQuZ2V0U2l6ZSgpO1xuICAgIHZhciBwYXJlbnRUcmFuc2Zvcm0gPSBwYXJlbnQuZ2V0VHJhbnNmb3JtKCk7XG4gICAgdmFyIHNpemVDaGFuZ2VkID0gU0laRV9QUk9DRVNTT1IuZnJvbVNwZWNXaXRoUGFyZW50KHBhcmVudFNpemUsIHRoaXMsIG15U2l6ZSk7XG5cbiAgICB2YXIgdHJhbnNmb3JtQ2hhbmdlZCA9IFRSQU5TRk9STV9QUk9DRVNTT1IuZnJvbVNwZWNXaXRoUGFyZW50KHBhcmVudFRyYW5zZm9ybSwgdGhpcy52YWx1ZSwgbXlTaXplLCBwYXJlbnRTaXplLCBteVRyYW5zZm9ybSk7XG4gICAgaWYgKHRyYW5zZm9ybUNoYW5nZWQpIHRoaXMuX3RyYW5zZm9ybUNoYW5nZWQobXlUcmFuc2Zvcm0pO1xuICAgIGlmIChzaXplQ2hhbmdlZCkgdGhpcy5fc2l6ZUNoYW5nZWQobXlTaXplKTtcblxuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgICAgIC8vIGxhc3QgdXBkYXRlXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUubG9jYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9nbG9iYWxVcGRhdGVyID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fbmV4dFVwZGF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9nbG9iYWxVcGRhdGVyLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1vdW50cyB0aGUgbm9kZSBhbmQgdGhlcmVmb3JlIGl0cyBzdWJ0cmVlIGJ5IHNldHRpbmcgaXQgYXMgYSBjaGlsZCBvZiB0aGVcbiAqIHBhc3NlZCBpbiBwYXJlbnQuXG4gKlxuICogQG1ldGhvZCBtb3VudFxuICpcbiAqIEBwYXJhbSAge05vZGV9IHBhcmVudCAgICBwYXJlbnQgbm9kZVxuICogQHBhcmFtICB7U3RyaW5nfSBteUlkICAgIHBhdGggdG8gbm9kZSAoZS5nLiBgYm9keS8wLzFgKVxuICovXG5Ob2RlLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChwYXJlbnQsIG15SWQpIHtcbiAgICBpZiAodGhpcy5pc01vdW50ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIgPSBwYXJlbnQuZ2V0VXBkYXRlcigpO1xuICAgIHRoaXMudmFsdWUubG9jYXRpb24gPSBteUlkO1xuICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLm1vdW50ZWQgPSB0cnVlO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25Nb3VudCkgaXRlbS5vbk1vdW50KHRoaXMsIGkpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxpc3QgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblBhcmVudE1vdW50KSBpdGVtLm9uUGFyZW50TW91bnQodGhpcywgbXlJZCwgaSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUodHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERpc21vdW50cyAoZGV0YWNoZXMpIHRoZSBub2RlIGZyb20gdGhlIHNjZW5lIGdyYXBoIGJ5IHJlbW92aW5nIGl0IGFzIGFcbiAqIGNoaWxkIG9mIGl0cyBwYXJlbnQuXG4gKlxuICogQG1ldGhvZCBkaXNtb3VudFxuICovXG5Ob2RlLnByb3RvdHlwZS5kaXNtb3VudCA9IGZ1bmN0aW9uIGRpc21vdW50ICgpIHtcbiAgICBpZiAoIXRoaXMuaXNNb3VudGVkKCkpIHJldHVybjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLm1vdW50ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX3BhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uRGlzbW91bnQpIGl0ZW0ub25EaXNtb3VudCgpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxpc3QgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblBhcmVudERpc21vdW50KSBpdGVtLm9uUGFyZW50RGlzbW91bnQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBieSB0aGUgcGFyZW50IGFzIHNvb24gYXMgdGhlIHBhcmVudCBpc1xuICogYmVpbmcgbW91bnRlZC5cbiAqXG4gKiBAbWV0aG9kIG9uUGFyZW50TW91bnRcbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBwYXJlbnQgICAgICAgIFRoZSBwYXJlbnQgbm9kZS5cbiAqIEBwYXJhbSAge1N0cmluZ30gcGFyZW50SWQgICAgVGhlIHBhcmVudCBpZCAocGF0aCB0byBwYXJlbnQpLlxuICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAgICAgICBJZCB0aGUgbm9kZSBzaG91bGQgYmUgbW91bnRlZCB0by5cbiAqL1xuTm9kZS5wcm90b3R5cGUub25QYXJlbnRNb3VudCA9IGZ1bmN0aW9uIG9uUGFyZW50TW91bnQgKHBhcmVudCwgcGFyZW50SWQsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubW91bnQocGFyZW50LCBwYXJlbnRJZCArICcvJyArIGluZGV4KTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBieSB0aGUgcGFyZW50IGFzIHNvb24gYXMgdGhlIHBhcmVudCBpcyBiZWluZ1xuICogdW5tb3VudGVkLlxuICpcbiAqIEBtZXRob2Qgb25QYXJlbnREaXNtb3VudFxuICovXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudERpc21vdW50ID0gZnVuY3Rpb24gb25QYXJlbnREaXNtb3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzbW91bnQoKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCBpbiBvcmRlciB0byBkaXNwYXRjaCBhbiBldmVudCB0byB0aGUgbm9kZSBhbmQgYWxsIGl0c1xuICogY29tcG9uZW50cy4gTm90ZSB0aGF0IHRoaXMgZG9lc24ndCByZWN1cnNlIHRoZSBzdWJ0cmVlLlxuICpcbiAqIEBtZXRob2QgcmVjZWl2ZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgIFRoZSBldmVudCB0eXBlIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0gIHtPYmplY3R9IGV2ICAgICBUaGUgZXZlbnQgcGF5bG9hZCBvYmplY3QgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuTm9kZS5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIHJlY2VpdmUgKHR5cGUsIGV2KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25SZWNlaXZlKSBpdGVtLm9uUmVjZWl2ZSh0eXBlLCBldik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG5Ob2RlLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzID0gZnVuY3Rpb24gX3JlcXVlc3RVcGRhdGVXaXRob3V0QXJncyAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vblVwZGF0ZSA9IE5vZGUucHJvdG90eXBlLnVwZGF0ZTtcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRTaG93ID0gTm9kZS5wcm90b3R5cGUuc2hvdztcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRIaWRlID0gTm9kZS5wcm90b3R5cGUuaGlkZTtcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRUcmFuc2Zvcm1DaGFuZ2UgPSBOb2RlLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzO1xuXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudFNpemVDaGFuZ2UgPSBOb2RlLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzO1xuXG5Ob2RlLnByb3RvdHlwZS5vblNob3cgPSBOb2RlLnByb3RvdHlwZS5zaG93O1xuXG5Ob2RlLnByb3RvdHlwZS5vbkhpZGUgPSBOb2RlLnByb3RvdHlwZS5oaWRlO1xuXG5Ob2RlLnByb3RvdHlwZS5vbk1vdW50ID0gTm9kZS5wcm90b3R5cGUubW91bnQ7XG5cbk5vZGUucHJvdG90eXBlLm9uRGlzbW91bnQgPSBOb2RlLnByb3RvdHlwZS5kaXNtb3VudDtcblxuTm9kZS5wcm90b3R5cGUub25SZWNlaXZlID0gTm9kZS5wcm90b3R5cGUucmVjZWl2ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNoaW50IC1XMDc5ICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERpc3BhdGNoID0gcmVxdWlyZSgnLi9EaXNwYXRjaCcpO1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBTaXplID0gcmVxdWlyZSgnLi9TaXplJyk7XG5cbi8qKlxuICogU2NlbmUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgc2NlbmUgZ3JhcGguIEl0IGlzIGl0J3Mgb3duXG4gKiBwYXJlbnQgYW5kIHByb3ZpZGVzIHRoZSBnbG9iYWwgdXBkYXRlciB0byB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICogQGNsYXNzIFNjZW5lXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgYSBzdHJpbmcgd2hpY2ggaXMgYSBkb20gc2VsZWN0b3JcbiAqICAgICAgICAgICAgICAgICBzaWduaWZ5aW5nIHdoaWNoIGRvbSBlbGVtZW50IHRoZSBjb250ZXh0XG4gKiAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIHNldCB1cG9uXG4gKiBAcGFyYW0ge0ZhbW91c30gYSBjbGFzcyB3aGljaCBjb25mb3JtcyB0byBGYW1vdXMnIGludGVyZmFjZVxuICogICAgICAgICAgICAgICAgIGl0IG5lZWRzIHRvIGJlIGFibGUgdG8gc2VuZCBtZXRob2RzIHRvXG4gKiAgICAgICAgICAgICAgICAgdGhlIHJlbmRlcmVycyBhbmQgdXBkYXRlIG5vZGVzIGluIHRoZSBzY2VuZSBncmFwaFxuICovXG5mdW5jdGlvbiBTY2VuZSAoc2VsZWN0b3IsIHVwZGF0ZXIpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ1NjZW5lIG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCBhIERPTSBzZWxlY3RvcicpO1xuICAgIGlmICghdXBkYXRlcikgdGhyb3cgbmV3IEVycm9yKCdTY2VuZSBuZWVkcyB0byBiZSBjcmVhdGVkIHdpdGggYSBjbGFzcyBsaWtlIEZhbW91cycpO1xuXG4gICAgTm9kZS5jYWxsKHRoaXMpOyAgICAgICAgIC8vIFNjZW5lIGluaGVyaXRzIGZyb20gbm9kZVxuXG4gICAgdGhpcy5fdXBkYXRlciA9IHVwZGF0ZXI7IC8vIFRoZSB1cGRhdGVyIHRoYXQgd2lsbCBib3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgbWVzc2FnZXMgdG8gdGhlIHJlbmRlcmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdXBkYXRlIGRpcnR5IG5vZGVzIFxuXG4gICAgdGhpcy5fZGlzcGF0Y2ggPSBuZXcgRGlzcGF0Y2godGhpcyk7IC8vIGluc3RhbnRpYXRlcyBhIGRpc3BhdGNoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc2VuZCBldmVudHMgdG8gdGhlIHNjZW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYXBoIGJlbG93IHRoaXMgY29udGV4dFxuICAgIFxuICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7IC8vIHJlZmVyZW5jZSB0byB0aGUgRE9NIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBlbGVtbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBkb20gdGhhdCB0aGlzIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmhhYml0c1xuXG4gICAgdGhpcy5vbk1vdW50KHRoaXMsIHNlbGVjdG9yKTsgLy8gTW91bnQgdGhlIGNvbnRleHQgdG8gaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGl0IGlzIGl0cyBvd24gcGFyZW50KVxuICAgIFxuICAgIHRoaXMuX3VwZGF0ZXIgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGEgcmVxdWVzdCBmb3IgdGhlIGRvbVxuICAgICAgICAubWVzc2FnZSgnTkVFRF9TSVpFX0ZPUicpICAvLyBzaXplIG9mIHRoZSBjb250ZXh0IHNvIHRoYXRcbiAgICAgICAgLm1lc3NhZ2Uoc2VsZWN0b3IpOyAgICAgICAgLy8gdGhlIHNjZW5lIGdyYXBoIGhhcyBhIHRvdGFsIHNpemVcblxuICAgIHRoaXMuc2hvdygpOyAvLyB0aGUgY29udGV4dCBiZWdpbnMgc2hvd24gKGl0J3MgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBkb20pXG5cbn1cblxuLy8gU2NlbmUgaW5oZXJpdHMgZnJvbSBub2RlXG5TY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcblNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjZW5lO1xuXG4vKipcbiAqIFNjZW5lIGdldFVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJucyB0aGUgcGFzc2VkIGluIHVwZGF0ZXJcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXN9IHRoZSB1cGRhdGVyIGZvciB0aGlzIFNjZW5lXG4gKi9cblNjZW5lLnByb3RvdHlwZS5nZXRVcGRhdGVyID0gZnVuY3Rpb24gZ2V0VXBkYXRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZXI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlbGVjdG9yIHRoYXQgdGhlIGNvbnRleHQgd2FzIGluc3RhbnRpYXRlZCB3aXRoXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBkb20gc2VsZWN0b3JcbiAqL1xuU2NlbmUucHJvdG90eXBlLmdldFNlbGVjdG9yID0gZnVuY3Rpb24gZ2V0U2VsZWN0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rvcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGlzcGF0Y2hlciBvZiB0aGUgY29udGV4dC4gVXNlZCB0byBzZW5kIGV2ZW50c1xuICogdG8gdGhlIG5vZGVzIGluIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcmV0dXJuIHtEaXNwYXRjaH0gdGhlIFNjZW5lJ3MgRGlzcGF0Y2hcbiAqL1xuU2NlbmUucHJvdG90eXBlLmdldERpc3BhdGNoID0gZnVuY3Rpb24gZ2V0RGlzcGF0Y2ggKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgYW4gZXZlbnQuIElmIHRoZSBldmVudCBpcyAnQ09OVEVYVF9SRVNJWkUnIGl0IHNldHMgdGhlIHNpemUgb2YgdGhlIHNjZW5lXG4gKiBncmFwaCB0byB0aGUgcGF5bG9hZCwgd2hpY2ggbXVzdCBiZSBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGF0IGxlYXN0XG4gKiBsZW5ndGggdGhyZWUgcmVwcmVzZW50aW5nIHRoZSBwaXhlbCBzaXplIGluIDMgZGltZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxuICovXG5TY2VuZS5wcm90b3R5cGUub25SZWNlaXZlID0gZnVuY3Rpb24gb25SZWNlaXZlIChldmVudCwgcGF5bG9hZCkge1xuICAgIC8vIFRPRE86IEluIHRoZSBmdXR1cmUgdGhlIGRvbSBlbGVtZW50IHRoYXQgdGhlIGNvbnRleHQgaXMgYXR0YWNoZWQgdG9cbiAgICAvLyBzaG91bGQgaGF2ZSBhIHJlcHJlc2VudGF0aW9uIGFzIGEgY29tcG9uZW50LiBJdCB3b3VsZCBiZSByZW5kZXIgc2l6ZWRcbiAgICAvLyBhbmQgdGhlIGNvbnRleHQgd291bGQgcmVjZWl2ZSBpdHMgc2l6ZSB0aGUgc2FtZSB3YXkgdGhhdCBhbnkgcmVuZGVyIHNpemVcbiAgICAvLyBjb21wb25lbnQgcmVjZWl2ZXMgaXRzIHNpemUuXG4gICAgaWYgKGV2ZW50ID09PSAnQ09OVEVYVF9SRVNJWkUnKSB7XG4gICAgICAgIFxuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPCAyKSBcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0NPTlRFWFRfUkVTSVpFXFwncyBwYXlsb2FkIG5lZWRzIHRvIGJlIGF0IGxlYXN0IGEgcGFpcicgK1xuICAgICAgICAgICAgICAgICAgICAnIG9mIHBpeGVsIHNpemVzJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNldFNpemVNb2RlKFNpemUuQUJTT0xVVEUsIFNpemUuQUJTT0xVVEUsIFNpemUuQUJTT0xVVEUpO1xuICAgICAgICB0aGlzLnNldEFic29sdXRlU2l6ZShwYXlsb2FkWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWzJdID8gcGF5bG9hZFsyXSA6IDApO1xuXG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2VuZTtcblxuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgU2l6ZSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcHJvY2Vzc2luZyBTaXplIGZyb20gYSBub2RlXG4gKiBAY29uc3RydWN0b3Ige1NpemV9XG4gKi9cbmZ1bmN0aW9uIFNpemUgKCkge1xuICAgIHRoaXMuX3NpemUgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xufVxuXG4vLyBhbiBlbnVtZXJhdGlvbiBvZiB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIHNpemUgbW9kZXNcblNpemUuUkVMQVRJVkUgPSAwO1xuU2l6ZS5BQlNPTFVURSA9IDE7XG5TaXplLlJFTkRFUiA9IDI7XG5TaXplLkRFRkFVTFQgPSBTaXplLlJFTEFUSVZFO1xuXG4vKipcbiAqIGZyb21TcGVjV2l0aFBhcmVudCB0YWtlcyB0aGUgcGFyZW50IG5vZGUncyBzaXplLCB0aGUgdGFyZ2V0IG5vZGVzIHNwZWMsXG4gKiBhbmQgYSB0YXJnZXQgYXJyYXkgdG8gd3JpdGUgdG8uIFVzaW5nIHRoZSBub2RlJ3Mgc2l6ZSBtb2RlIGl0IGNhbGN1bGF0ZXMgXG4gKiBhIGZpbmFsIHNpemUgZm9yIHRoZSBub2RlIGZyb20gdGhlIG5vZGUncyBzcGVjLiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90XG4gKiB0aGUgZmluYWwgc2l6ZSBoYXMgY2hhbmdlZCBmcm9tIGl0cyBsYXN0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmVudCBub2RlJ3MgY2FsY3VsYXRlZCBzaXplXG4gKiBAcGFyYW0ge05vZGUuU3BlY30gdGhlIHRhcmdldCBub2RlJ3Mgc3BlY1xuICogQHBhcmFtIHtBcnJheX0gYW4gYXJyYXkgdG8gd3JpdGUgdGhlIHJlc3VsdCB0b1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNpemUgb2YgdGhlIG5vZGUgaGFzIGNoYW5nZWQuXG4gKi9cblNpemUucHJvdG90eXBlLmZyb21TcGVjV2l0aFBhcmVudCA9IGZ1bmN0aW9uIGZyb21TcGVjV2l0aFBhcmVudCAocGFyZW50U2l6ZSwgbm9kZSwgdGFyZ2V0KSB7XG4gICAgdmFyIHNwZWMgPSBub2RlLmdldFZhbHVlKCkuc3BlYztcbiAgICB2YXIgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgIHZhciBtb2RlID0gc3BlYy5zaXplLnNpemVNb2RlO1xuICAgIHZhciBwcmV2O1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IDMgOyBpKyspIHtcbiAgICAgICAgc3dpdGNoIChtb2RlW2ldKSB7XG4gICAgICAgICAgICBjYXNlIFNpemUuUkVMQVRJVkU6XG4gICAgICAgICAgICAgICAgcHJldiA9IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBwYXJlbnRTaXplW2ldICogc3BlYy5zaXplLnByb3BvcnRpb25hbFtpXSArIHNwZWMuc2l6ZS5kaWZmZXJlbnRpYWxbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNpemUuQUJTT0xVVEU6XG4gICAgICAgICAgICAgICAgcHJldiA9IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBzcGVjLnNpemUuYWJzb2x1dGVbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNpemUuUkVOREVSOlxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbiA7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50c1tqXS5nZXRSZW5kZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjb21wb25lbnRzW2pdLmdldFJlbmRlclNpemUoKVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSB0YXJnZXRbaV0gPCBjYW5kaWRhdGUgfHwgdGFyZ2V0W2ldID09PSAwID8gY2FuZGlkYXRlIDogdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IHByZXYgIT09IHRhcmdldFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpemU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSB0cmFuc2Zvcm0gY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIGNhbGN1bGF0aW5nIHRoZSB0cmFuc2Zvcm0gb2YgYSBwYXJ0aWN1bGFyXG4gKiBub2RlIGZyb20gdGhlIGRhdGEgb24gdGhlIG5vZGUgYW5kIGl0cyBwYXJlbnRcbiAqXG4gKiBAY29uc3RydWN0b3Ige1RyYW5zZm9ybX1cbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtICgpIHtcbiAgICB0aGlzLl9tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGNhbGN1bGF0ZWQgdHJhbnNmb3JtXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGEgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xufTtcblxuLyoqXG4gKiBVc2VzIHRoZSBwYXJlbnQgdHJhbnNmb3JtLCB0aGUgbm9kZSdzIHNwZWMsIHRoZSBub2RlJ3Mgc2l6ZSwgYW5kIHRoZSBwYXJlbnQncyBzaXplXG4gKiB0byBjYWxjdWxhdGUgYSBmaW5hbCB0cmFuc2Zvcm0gZm9yIHRoZSBub2RlLiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zZm9ybSBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0aGUgcGFyZW50IG1hdHJpeFxuICogQHBhcmFtIHtOb2RlLlNwZWN9IHRoZSB0YXJnZXQgbm9kZSdzIHNwZWNcbiAqIEBwYXJhbSB7QXJyYXl9IHRoZSBzaXplIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ge0FycmF5fSB0aGUgc2l6ZSBvZiB0aGUgcGFyZW50XG4gKiBAcGFyYW0ge0FycmF5fSB0aGUgdGFyZ2V0IGFycmF5IHRvIHdyaXRlIHRoZSByZXN1bHRpbmcgdHJhbnNmb3JtIHRvXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIHRyYW5zZm9ybSBjaGFuZ2VkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZnJvbVNwZWNXaXRoUGFyZW50ID0gZnVuY3Rpb24gZnJvbVNwZWNXaXRoUGFyZW50IChwYXJlbnRNYXRyaXgsIHNwZWMsIG15U2l6ZSwgcGFyZW50U2l6ZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0ID8gdGFyZ2V0IDogdGhpcy5fbWF0cml4O1xuXG4gICAgLy8gbG9jYWwgY2FjaGUgb2YgZXZlcnl0aGluZ1xuICAgIHZhciB0MDAgICAgICAgICA9IHRhcmdldFswXTtcbiAgICB2YXIgdDAxICAgICAgICAgPSB0YXJnZXRbMV07XG4gICAgdmFyIHQwMiAgICAgICAgID0gdGFyZ2V0WzJdO1xuICAgIHZhciB0MTAgICAgICAgICA9IHRhcmdldFs0XTtcbiAgICB2YXIgdDExICAgICAgICAgPSB0YXJnZXRbNV07XG4gICAgdmFyIHQxMiAgICAgICAgID0gdGFyZ2V0WzZdO1xuICAgIHZhciB0MjAgICAgICAgICA9IHRhcmdldFs4XTtcbiAgICB2YXIgdDIxICAgICAgICAgPSB0YXJnZXRbOV07XG4gICAgdmFyIHQyMiAgICAgICAgID0gdGFyZ2V0WzEwXTtcbiAgICB2YXIgdDMwICAgICAgICAgPSB0YXJnZXRbMTJdO1xuICAgIHZhciB0MzEgICAgICAgICA9IHRhcmdldFsxM107XG4gICAgdmFyIHQzMiAgICAgICAgID0gdGFyZ2V0WzE0XTtcbiAgICB2YXIgcDAwICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMF07XG4gICAgdmFyIHAwMSAgICAgICAgID0gcGFyZW50TWF0cml4WzFdO1xuICAgIHZhciBwMDIgICAgICAgICA9IHBhcmVudE1hdHJpeFsyXTtcbiAgICB2YXIgcDEwICAgICAgICAgPSBwYXJlbnRNYXRyaXhbNF07XG4gICAgdmFyIHAxMSAgICAgICAgID0gcGFyZW50TWF0cml4WzVdO1xuICAgIHZhciBwMTIgICAgICAgICA9IHBhcmVudE1hdHJpeFs2XTtcbiAgICB2YXIgcDIwICAgICAgICAgPSBwYXJlbnRNYXRyaXhbOF07XG4gICAgdmFyIHAyMSAgICAgICAgID0gcGFyZW50TWF0cml4WzldO1xuICAgIHZhciBwMjIgICAgICAgICA9IHBhcmVudE1hdHJpeFsxMF07XG4gICAgdmFyIHAzMCAgICAgICAgID0gcGFyZW50TWF0cml4WzEyXTtcbiAgICB2YXIgcDMxICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTNdO1xuICAgIHZhciBwMzIgICAgICAgICA9IHBhcmVudE1hdHJpeFsxNF07XG4gICAgdmFyIHBvc1ggICAgICAgID0gc3BlYy52ZWN0b3JzLnBvc2l0aW9uWzBdO1xuICAgIHZhciBwb3NZICAgICAgICA9IHNwZWMudmVjdG9ycy5wb3NpdGlvblsxXTtcbiAgICB2YXIgcG9zWiAgICAgICAgPSBzcGVjLnZlY3RvcnMucG9zaXRpb25bMl07XG4gICAgdmFyIHJvdFggICAgICAgID0gc3BlYy52ZWN0b3JzLnJvdGF0aW9uWzBdO1xuICAgIHZhciByb3RZICAgICAgICA9IHNwZWMudmVjdG9ycy5yb3RhdGlvblsxXTtcbiAgICB2YXIgcm90WiAgICAgICAgPSBzcGVjLnZlY3RvcnMucm90YXRpb25bMl07XG4gICAgdmFyIHJvdFcgICAgICAgID0gc3BlYy52ZWN0b3JzLnJvdGF0aW9uWzNdO1xuICAgIHZhciBzY2FsZVggICAgICA9IHNwZWMudmVjdG9ycy5zY2FsZVswXTtcbiAgICB2YXIgc2NhbGVZICAgICAgPSBzcGVjLnZlY3RvcnMuc2NhbGVbMV07XG4gICAgdmFyIHNjYWxlWiAgICAgID0gc3BlYy52ZWN0b3JzLnNjYWxlWzJdO1xuICAgIHZhciBhbGlnblggICAgICA9IHNwZWMub2Zmc2V0cy5hbGlnblswXSAqIHBhcmVudFNpemVbMF07XG4gICAgdmFyIGFsaWduWSAgICAgID0gc3BlYy5vZmZzZXRzLmFsaWduWzFdICogcGFyZW50U2l6ZVsxXTtcbiAgICB2YXIgYWxpZ25aICAgICAgPSBzcGVjLm9mZnNldHMuYWxpZ25bMl0gKiBwYXJlbnRTaXplWzJdO1xuICAgIHZhciBtb3VudFBvaW50WCA9IHNwZWMub2Zmc2V0cy5tb3VudFBvaW50WzBdICogbXlTaXplWzBdO1xuICAgIHZhciBtb3VudFBvaW50WSA9IHNwZWMub2Zmc2V0cy5tb3VudFBvaW50WzFdICogbXlTaXplWzFdO1xuICAgIHZhciBtb3VudFBvaW50WiA9IHNwZWMub2Zmc2V0cy5tb3VudFBvaW50WzJdICogbXlTaXplWzJdO1xuICAgIHZhciBvcmlnaW5YICAgICA9IHNwZWMub2Zmc2V0cy5vcmlnaW5bMF0gKiBteVNpemVbMF07XG4gICAgdmFyIG9yaWdpblkgICAgID0gc3BlYy5vZmZzZXRzLm9yaWdpblsxXSAqIG15U2l6ZVsxXTtcbiAgICB2YXIgb3JpZ2luWiAgICAgPSBzcGVjLm9mZnNldHMub3JpZ2luWzJdICogbXlTaXplWzJdO1xuXG4gICAgdmFyIHd4ID0gcm90VyAqIHJvdFg7XG4gICAgdmFyIHd5ID0gcm90VyAqIHJvdFk7XG4gICAgdmFyIHd6ID0gcm90VyAqIHJvdFo7XG4gICAgdmFyIHh4ID0gcm90WCAqIHJvdFg7XG4gICAgdmFyIHl5ID0gcm90WSAqIHJvdFk7XG4gICAgdmFyIHp6ID0gcm90WiAqIHJvdFo7XG4gICAgdmFyIHh5ID0gcm90WCAqIHJvdFk7XG4gICAgdmFyIHh6ID0gcm90WCAqIHJvdFo7XG4gICAgdmFyIHl6ID0gcm90WSAqIHJvdFo7XG5cbiAgICB2YXIgcnMwID0gKDEgLSAyICogKHl5ICsgenopKSAqIHNjYWxlWDtcbiAgICB2YXIgcnMxID0gKDIgKiAoeHkgKyB3eikpICogc2NhbGVYO1xuICAgIHZhciByczIgPSAoMiAqICh4eiAtIHd5KSkgKiBzY2FsZVg7XG4gICAgdmFyIHJzMyA9ICgyICogKHh5IC0gd3opKSAqIHNjYWxlWTtcbiAgICB2YXIgcnM0ID0gKDEgLSAyICogKHh4ICsgenopKSAqIHNjYWxlWTtcbiAgICB2YXIgcnM1ID0gKDIgKiAoeXogKyB3eCkpICogc2NhbGVZO1xuICAgIHZhciByczYgPSAoMiAqICh4eiArIHd5KSkgKiBzY2FsZVo7XG4gICAgdmFyIHJzNyA9ICgyICogKHl6IC0gd3gpKSAqIHNjYWxlWjtcbiAgICB2YXIgcnM4ID0gKDEgLSAyICogKHh4ICsgeXkpKSAqIHNjYWxlWjtcblxuICAgIHZhciB0eCA9IGFsaWduWCArIHBvc1ggLSBtb3VudFBvaW50WCArIG9yaWdpblggLSAocnMwICogb3JpZ2luWCArIHJzMyAqIG9yaWdpblkgKyByczYgKiBvcmlnaW5aKTtcbiAgICB2YXIgdHkgPSBhbGlnblkgKyBwb3NZIC0gbW91bnRQb2ludFkgKyBvcmlnaW5ZIC0gKHJzMSAqIG9yaWdpblggKyByczQgKiBvcmlnaW5ZICsgcnM3ICogb3JpZ2luWik7XG4gICAgdmFyIHR6ID0gYWxpZ25aICsgcG9zWiAtIG1vdW50UG9pbnRaICsgb3JpZ2luWiAtIChyczIgKiBvcmlnaW5YICsgcnM1ICogb3JpZ2luWSArIHJzOCAqIG9yaWdpblopO1xuXG4gICAgdGFyZ2V0WzBdID0gcDAwICogcnMwICsgcDEwICogcnMxICsgcDIwICogcnMyO1xuICAgIHRhcmdldFsxXSA9IHAwMSAqIHJzMCArIHAxMSAqIHJzMSArIHAyMSAqIHJzMjtcbiAgICB0YXJnZXRbMl0gPSBwMDIgKiByczAgKyBwMTIgKiByczEgKyBwMjIgKiByczI7XG4gICAgdGFyZ2V0WzNdID0gMDtcbiAgICB0YXJnZXRbNF0gPSBwMDAgKiByczMgKyBwMTAgKiByczQgKyBwMjAgKiByczU7XG4gICAgdGFyZ2V0WzVdID0gcDAxICogcnMzICsgcDExICogcnM0ICsgcDIxICogcnM1O1xuICAgIHRhcmdldFs2XSA9IHAwMiAqIHJzMyArIHAxMiAqIHJzNCArIHAyMiAqIHJzNTtcbiAgICB0YXJnZXRbN10gPSAwO1xuICAgIHRhcmdldFs4XSA9IHAwMCAqIHJzNiArIHAxMCAqIHJzNyArIHAyMCAqIHJzODtcbiAgICB0YXJnZXRbOV0gPSBwMDEgKiByczYgKyBwMTEgKiByczcgKyBwMjEgKiByczg7XG4gICAgdGFyZ2V0WzEwXSA9IHAwMiAqIHJzNiArIHAxMiAqIHJzNyArIHAyMiAqIHJzODtcbiAgICB0YXJnZXRbMTFdID0gMDtcbiAgICB0YXJnZXRbMTJdID0gcDAwICogdHggKyBwMTAgKiB0eSArIHAyMCAqIHR6ICsgcDMwO1xuICAgIHRhcmdldFsxM10gPSBwMDEgKiB0eCArIHAxMSAqIHR5ICsgcDIxICogdHogKyBwMzE7XG4gICAgdGFyZ2V0WzE0XSA9IHAwMiAqIHR4ICsgcDEyICogdHkgKyBwMjIgKiB0eiArIHAzMjtcbiAgICB0YXJnZXRbMTVdID0gMTtcblxuICAgIHJldHVybiB0MDAgIT09IHRhcmdldFswXSB8fFxuICAgICAgICB0MDEgIT09IHRhcmdldFsxXSB8fFxuICAgICAgICB0MDIgIT09IHRhcmdldFsyXSB8fFxuICAgICAgICB0MTAgIT09IHRhcmdldFs0XSB8fFxuICAgICAgICB0MTEgIT09IHRhcmdldFs1XSB8fFxuICAgICAgICB0MTIgIT09IHRhcmdldFs2XSB8fFxuICAgICAgICB0MjAgIT09IHRhcmdldFs4XSB8fFxuICAgICAgICB0MjEgIT09IHRhcmdldFs5XSB8fFxuICAgICAgICB0MjIgIT09IHRhcmdldFsxMF0gfHxcbiAgICAgICAgdDMwICE9PSB0YXJnZXRbMTJdIHx8XG4gICAgICAgIHQzMSAhPT0gdGFyZ2V0WzEzXSB8fFxuICAgICAgICB0MzIgIT09IHRhcmdldFsxNF07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2xvY2s6IHJlcXVpcmUoJy4vQ2xvY2snKSxcbiAgICBFdmVudDogcmVxdWlyZSgnLi9FdmVudCcpLFxuICAgIFNjZW5lOiByZXF1aXJlKCcuL1NjZW5lJyksXG4gICAgRmFtb3VzRW5naW5lOiByZXF1aXJlKCcuL0ZhbW91c0VuZ2luZScpLFxuICAgIERpc3BhdGNoOiByZXF1aXJlKCcuL0Rpc3BhdGNoJyksXG4gICAgTm9kZTogcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgU2l6ZTogcmVxdWlyZSgnLi9TaXplJyksXG4gICAgVHJhbnNmb3JtOiByZXF1aXJlKCcuL1RyYW5zZm9ybScpXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tTdG9yZSA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9DYWxsYmFja1N0b3JlJyk7XG5cbnZhciBSRU5ERVJfU0laRSA9IDI7XG5cbi8qKlxuICogQSBET01FbGVtZW50IGlzIGEgcmVuZGVyYWJsZSB0aGF0IGNhbiBiZSBhZGRlZCBqdXN0IGxpa2UgYSBcIm5vcm1hbFwiXG4gKiBjb21wb25lbnQgdG8gYSBub2RlIHVzaW5nIGBhZGRDb21wb25lbnRgLlxuICogUmVuZGVyYWJsZXMgc2VuZCBkcmF3IGNvbW1hbmRzIHRvIHRoZSBub2RlIHRoZXkgYXJlIGF0dGFjaGVkIHRvLlxuICogVGhvc2UgY29tbWFuZHMgdGhlbiBnZXQgaW50ZXJwcmV0ZWQgYnkgdGhlIGBET01SZW5kZXJlcmAgaW4gdGhlIE1haW4gdGhyZWFkXG4gKiB0byBidWlsZCB0aGUgYWN0dWFsIERPTSByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAY2xhc3MgRE9NRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlICAgICAgICAgICAgICAgICAgIFRoZSBlbnRpdHkgdG8gd2hpY2ggdGhlIGBET01FbGVtZW50YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmFibGUgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgIEluaXRpYWwgb3B0aW9ucyB1c2VkIGZvciBpbnN0YW50aWF0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIE5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9wZXJ0aWVzICAgQ1NTIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYWN0dWFsIERPTUVsZW1lbnQgb24gdGhlIGluaXRpYWwgZHJhdy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF0dHJpYnV0ZXMgICBFbGVtZW50IGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYWN0dWFsIERPTUVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5pZCAgICAgICAgICAgU3RyaW5nIHRvIGJlIGFwcGxpZWQgYXMgJ2lkJyBvZiB0aGUgYWN0dWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRE9NRWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNvbnRlbnQgICAgICBTdHJpbmcgdG8gYmUgYXBwbGllZCBhcyB0aGUgY29udGVudCBvZiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWwgRE9NRWxlbWVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jdXRvdXQgICAgICBTcGVjaWZpZXMgdGhlIHByZXNlbmNlIG9mIGEgJ2N1dG91dCcgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2ViR0wgY2FudmFzIG92ZXIgdGhpcyBlbGVtZW50IHdoaWNoIGFsbG93c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBET00gYW5kIFdlYkdMIGxheWVyaW5nLiAgT24gYnkgZGVmYXVsdC5cbiAqL1xuZnVuY3Rpb24gRE9NRWxlbWVudCAobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKCdET01FbGVtZW50IG11c3QgYmUgaW5zdGFudGlhdGVkIG9uIGEgbm9kZScpO1xuXG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3JlbmRlclNpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSBmYWxzZTtcblxuICAgIHRoaXMuX2NoYW5nZVF1ZXVlID0gW107XG5cbiAgICB0aGlzLl9VSUV2ZW50cyA9IG5vZGUuZ2V0VUlFdmVudHMoKS5zbGljZSgwKTtcbiAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgdGhpcy5fcmVxdWVzdGluZ0V2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fc3R5bGVzID0ge307XG5cbiAgICB0aGlzLnNldFByb3BlcnR5KCdkaXNwbGF5Jywgbm9kZS5pc1Nob3duKCkgPyAnbm9uZScgOiAnYmxvY2snKTtcbiAgICB0aGlzLm9uT3BhY2l0eUNoYW5nZShub2RlLmdldE9wYWNpdHkoKSk7XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLkRFRkFVTFRfUFJPUEVSVElFUykge1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5KHByb3BlcnR5LCB0aGlzLkRFRkFVTFRfUFJPUEVSVElFU1twcm9wZXJ0eV0pO1xuICAgIH1cblxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLl9jb250ZW50ID0gJyc7XG5cbiAgICB0aGlzLl90YWdOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLnRhZ05hbWUgPyBvcHRpb25zLnRhZ05hbWUgOiAnZGl2JztcbiAgICB0aGlzLl9pZCA9IG5vZGUgPyBub2RlLmFkZENvbXBvbmVudCh0aGlzKSA6IG51bGw7XG5cbiAgICB0aGlzLl9yZW5kZXJTaXplID0gWzAsIDAsIDBdO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IENhbGxiYWNrU3RvcmUoKTtcblxuXG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm47XG5cbiAgICB2YXIgaTtcbiAgICB2YXIga2V5O1xuXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NlcylcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMuY2xhc3Nlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc2VzW2ldKTtcblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpXG4gICAgICAgIGZvciAoa2V5IGluIG9wdGlvbnMuYXR0cmlidXRlcylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2tleV0pO1xuXG4gICAgaWYgKG9wdGlvbnMucHJvcGVydGllcylcbiAgICAgICAgZm9yIChrZXkgaW4gb3B0aW9ucy5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eShrZXksIG9wdGlvbnMucHJvcGVydGllc1trZXldKTtcblxuICAgIGlmIChvcHRpb25zLmlkKSB0aGlzLnNldElkKG9wdGlvbnMuaWQpO1xuICAgIGlmIChvcHRpb25zLmNvbnRlbnQpIHRoaXMuc2V0Q29udGVudChvcHRpb25zLmNvbnRlbnQpO1xuICAgIGlmIChvcHRpb25zLmN1dG91dCA9PT0gZmFsc2UpIHRoaXMuc2V0Q3V0b3V0U3RhdGUob3B0aW9ucy5jdXRvdXQpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIHN0YXRlIG9mIHRoZSBET01FbGVtZW50LiBUaGlzIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgYnlcbiAqIEB7QGxpbmsgTm9kZSNnZXRWYWx1ZX0gaW4gb3JkZXIgdG8gc2VyaWFsaXplIHRoZSBub2RlIGFuZCBwb3NzaWJseSBlbnRpcmVcbiAqIHNjZW5lIGdyYXBoIGhpZXJhcmNoaWVzLlxuICpcbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBzZXJpYWxpemVkIGNvbXBvbmVudC5cbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NlczogdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgc3R5bGVzOiB0aGlzLl9zdHlsZXMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuX2NvbnRlbnQsXG4gICAgICAgIGlkOiB0aGlzLl9hdHRyaWJ1dGVzLmlkLFxuICAgICAgICB0YWdOYW1lOiB0aGlzLl90YWdOYW1lXG4gICAgfTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyBhbiB1cGRhdGUgb2NjdXJzLiBUaGlzIGFsbG93c1xuICogdGhlIERPTUVsZW1lbnQgcmVuZGVyYWJsZSB0byBkeW5hbWljYWxseSByZWFjdCB0byBzdGF0ZSBjaGFuZ2VzIG9uIHRoZSBOb2RlLlxuICpcbiAqIFRoaXMgZmx1c2hlcyB0aGUgaW50ZXJuYWwgZHJhdyBjb21tYW5kIHF1ZXVlIGJ5IHNlbmRpbmcgaW5kaXZpZHVhbCBjb21tYW5kc1xuICogdG8gdGhlIG5vZGUgdXNpbmcgYHNlbmREcmF3Q29tbWFuZGAuXG4gKlxuICogQG1ldGhvZCBvblVwZGF0ZVxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fY2hhbmdlUXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuICAgIGlmIChsZW4gJiYgbm9kZSkge1xuICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZCgnV0lUSCcpO1xuICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZChub2RlLmdldExvY2F0aW9uKCkpO1xuXG4gICAgICAgIHdoaWxlIChsZW4tLSkgbm9kZS5zZW5kRHJhd0NvbW1hbmQocXVldWUuc2hpZnQoKSk7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0UmVuZGVyU2l6ZSkge1xuICAgICAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ0RPTV9SRU5ERVJfU0laRScpO1xuICAgICAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQobm9kZS5nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RSZW5kZXJTaXplID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2Qgd2hpY2ggc2V0cyB0aGUgcGFyZW50IG9mIHRoZSBlbGVtZW50IGluIHRoZSBET01cbiAqIGhpZXJhcmNoeS5cbiAqXG4gKiBAbWV0aG9kIF9zZXRQYXJlbnRcbiAqIEBwcm90ZWN0ZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBvZiB0aGUgcGFyZW50XG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLl9zZXRQYXJlbnQgPSBmdW5jdGlvbiBfc2V0UGFyZW50IChwYXRoKSB7XG4gICAgaWYgKHRoaXMuX25vZGUpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fbm9kZS5nZXRMb2NhdGlvbigpO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IHBhdGggfHwgbG9jYXRpb24uaW5kZXhPZihwYXRoKSA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBnaXZlbiBwYXRoIGlzblxcJ3QgYW4gYW5jZXN0b3InKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGF0aDtcbiAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdfc2V0UGFyZW50IGNhbGxlZCBvbiBhbiBFbGVtZW50IHRoYXQgaXNuXFwndCBpbiB0aGUgc2NlbmUgZ3JhcGgnKTtcbn07XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2Qgd2hpY2ggYWRkcyBhIGNoaWxkIG9mIHRoZSBlbGVtZW50IGluIHRoZSBET01cbiAqIGhpZXJhcmNoeS5cbiAqXG4gKiBAbWV0aG9kIF9hZGRDaGlsZFxuICogQHByb3RlY3RlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIG9mIHRoZSBjaGlsZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5fYWRkQ2hpbGQgPSBmdW5jdGlvbiBfYWRkQ2hpbGQgKHBhdGgpIHtcbiAgICBpZiAodGhpcy5fbm9kZSkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSB0aGlzLl9ub2RlLmdldExvY2F0aW9uKCk7XG4gICAgICAgIGlmIChwYXRoID09PSBsb2NhdGlvbiB8fCBwYXRoLmluZGV4T2YobG9jYXRpb24pID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIHBhdGggaXNuXFwndCBhIGRlc2NlbmRlbnQnKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuLmluZGV4T2YocGF0aCkgPT09IC0xKSB0aGlzLl9jaGlsZHJlbi5wdXNoKHBhdGgpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIHBhdGggaXMgYWxyZWFkeSBhIGNoaWxkIG9mIHRoaXMgZWxlbWVudCcpO1xuICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ19hZGRDaGlsZCBjYWxsZWQgb24gYW4gRWxlbWVudCB0aGF0IGlzblxcJ3QgaW4gdGhlIHNjZW5lIGdyYXBoJyk7XG59O1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHdoaWNoIHJldHVybnMgdGhlIHBhdGggb2YgdGhlIHBhcmVudCBvZiB0aGlzIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIF9nZXRQYXJlbnRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuX2dldFBhcmVudCA9IGZ1bmN0aW9uIF9nZXRQYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG59O1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHdoaWNoIHJldHVybnMgYW4gYXJyYXkgb2YgcGF0aHMgb2YgdGhlIGNoaWxkcmVuIGVsZW1lbnRzXG4gKiBvZiB0aGlzIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIF9nZXRDaGlsZHJlblxuICogQHByb3RlY3RlZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5fZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBfZ2V0Q2hpbGRyZW4gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIE5vZGUgYXMgc29vbiBhcyB0aGUgbm9kZSAob3IgYW55IG9mIGl0c1xuICogYW5jZXN0b3JzKSBpcyBiZWluZyBtb3VudGVkLlxuICpcbiAqIEBtZXRob2Qgb25Nb3VudFxuICpcbiAqIEBwYXJhbSAge05vZGV9IG5vZGUgICAgICBQYXJlbnQgbm9kZSB0byB3aGljaCB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBhZGRlZC5cbiAqIEBwYXJhbSAge1N0cmluZ30gaWQgICAgICBQYXRoIGF0IHdoaWNoIHRoZSBjb21wb25lbnQgKG9yIG5vZGUpIGlzIGJlaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZWQuIFRoZSBwYXRoIGlzIGJlaW5nIHNldCBvbiB0aGUgYWN0dWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgRE9NRWxlbWVudCBhcyBhIGBkYXRhLWZhLXBhdGhgLWF0dHJpYnV0ZS5cbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25Nb3VudCA9IGZ1bmN0aW9uIG9uTW91bnQgKG5vZGUsIGlkKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBpZDtcbiAgICB0aGlzLl9VSUV2ZW50cyA9IG5vZGUuZ2V0VUlFdmVudHMoKS5zbGljZSgwKTtcbiAgICB0aGlzLmRyYXcoKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGF0YS1mYS1wYXRoJywgbm9kZS5nZXRMb2NhdGlvbigpKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIE5vZGUgYXMgc29vbiBhcyB0aGUgbm9kZSBpcyBiZWluZyBkaXNtb3VudGVkXG4gKiBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgZGlzbW91bnRpbmcgb25lIG9mIGl0cyBhbmNlc3RvcnMpLlxuICpcbiAqIEBtZXRob2Qgb25EaXNtb3VudFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vbkRpc21vdW50ID0gZnVuY3Rpb24gb25EaXNtb3VudCAoKSB7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmEtcGF0aCcsICcnKTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIHRoZSBET01FbGVtZW50IGlzIGJlaW5nIHNob3duLlxuICogVGhpcyByZXN1bHRzIGludG8gdGhlIERPTUVsZW1lbnQgc2V0dGluZyB0aGUgYGRpc3BsYXlgIHByb3BlcnR5IHRvIGBibG9ja2BcbiAqIGFuZCB0aGVyZWZvcmUgdmlzdWFsbHkgc2hvd2luZyB0aGUgY29ycmVzcG9uZGluZyBET01FbGVtZW50IChhZ2FpbikuXG4gKlxuICogQG1ldGhvZCBvblNob3dcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25TaG93ID0gZnVuY3Rpb24gb25TaG93ICgpIHtcbiAgICB0aGlzLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgdGhlIERPTUVsZW1lbnQgaXMgYmVpbmcgaGlkZGVuLlxuICogVGhpcyByZXN1bHRzIGludG8gdGhlIERPTUVsZW1lbnQgc2V0dGluZyB0aGUgYGRpc3BsYXlgIHByb3BlcnR5IHRvIGBub25lYFxuICogYW5kIHRoZXJlZm9yZSB2aXN1YWxseSBoaWRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgRE9NRWxlbWVudCAoYWdhaW4pLlxuICpcbiAqIEBtZXRob2Qgb25IaWRlXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uSGlkZSA9IGZ1bmN0aW9uIG9uSGlkZSAoKSB7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgV2ViR0wgJ2N1dG91dCcgZm9yIHRoaXMgZWxlbWVudCwgd2hpY2ggYWZmZWN0c1xuICogaG93IHRoZSBlbGVtZW50IGlzIGxheWVyZWQgd2l0aCBXZWJHTCBvYmplY3RzIGluIHRoZSBzY2VuZS5cbiAqXG4gKiBAbWV0aG9kIHNldEN1dG91dFN0YXRlXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB1c2VzQ3V0b3V0ICBUaGUgcHJlc2VuY2Ugb2YgYSBXZWJHTCAnY3V0b3V0JyBmb3IgdGhpcyBlbGVtZW50LlxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRDdXRvdXRTdGF0ZSA9IGZ1bmN0aW9uIHNldEN1dG91dFN0YXRlICh1c2VzQ3V0b3V0KSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfQ1VUT1VUX1NUQVRFJywgdXNlc0N1dG91dCk7XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyB0aGUgdHJhbnNmb3JtIG1hdHJpeCBhc3NvY2lhdGVkXG4gKiB3aXRoIHRoZSBub2RlIGNoYW5nZXMuXG4gKiBUaGUgRE9NRWxlbWVudCB3aWxsIHJlYWN0IHRvIHRyYW5zZm9ybSBjaGFuZ2VzIGJ5IHNlbmRpbmcgYENIQU5HRV9UUkFOU0ZPUk1gXG4gKiBjb21tYW5kcyB0byB0aGUgYERPTVJlbmRlcmVyYC5cbiAqXG4gKiBAbWV0aG9kIG9uVHJhbnNmb3JtQ2hhbmdlXG4gKlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSB0cmFuc2Zvcm0gICAgIFRoZSBmaW5hbCB0cmFuc2Zvcm0gbWF0cml4LlxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHJhbnNmb3JtQ2hhbmdlICh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdDSEFOR0VfVFJBTlNGT1JNJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyYW5zZm9ybS5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHRyYW5zZm9ybVtpXSk7XG5cbiAgICB0aGlzLm9uVXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgaXRzIGNvbXB1dGVkIHNpemUgY2hhbmdlcy5cbiAqXG4gKiBAbWV0aG9kIG9uU2l6ZUNoYW5nZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge0Zsb2F0MzJBcnJheX0gc2l6ZSAgICAgIEFic29sdXRlLCBwaXhlbCBzaXplLlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNpemVDaGFuZ2UgPSBmdW5jdGlvbiBvblNpemVDaGFuZ2UgKHNpemUpIHtcbiAgICB2YXIgc2l6ZU1vZGUgPSB0aGlzLl9ub2RlLmdldFNpemVNb2RlKCk7XG4gICAgdmFyIHNpemVkWCA9IHNpemVNb2RlWzBdICE9PSBSRU5ERVJfU0laRTtcbiAgICB2YXIgc2l6ZWRZID0gc2l6ZU1vZGVbMV0gIT09IFJFTkRFUl9TSVpFO1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZClcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQ0hBTkdFX1NJWkUnLFxuICAgICAgICAgICAgc2l6ZWRYID8gc2l6ZVswXSA6IHNpemVkWCxcbiAgICAgICAgICAgIHNpemVkWSA/IHNpemVbMV0gOiBzaXplZFkpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgaXRzIG9wYWNpdHkgY2hhbmdlcy5cbiAqXG4gKiBAbWV0aG9kIG9uT3BhY2l0eUNoYW5nZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gb3BhY2l0eSAgICAgIFRoZSBuZXcgb3BhY2l0eSwgYXMgYSBzY2FsYXIgZnJvbSAwIHRvIDEuXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGlzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uT3BhY2l0eUNoYW5nZSA9IGZ1bmN0aW9uIG9uT3BhY2l0eUNoYW5nZSAob3BhY2l0eSkge1xuICAgIHJldHVybiB0aGlzLnNldFByb3BlcnR5KCdvcGFjaXR5Jywgb3BhY2l0eSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgYSBuZXcgVUlFdmVudCBpcyBiZWluZyBhZGRlZC5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIGFuIGBBRERfRVZFTlRfTElTVEVORVJgIGNvbW1hbmQgYmVpbmcgc2VuZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFVJRXZlbnQgICAgIFVJRXZlbnQgdG8gYmUgc3Vic2NyaWJlZCB0byAoZS5nLiBgY2xpY2tgKS5cbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25BZGRVSUV2ZW50ID0gZnVuY3Rpb24gb25BZGRVSUV2ZW50IChVSUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX1VJRXZlbnRzLmluZGV4T2YoVUlFdmVudCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZShVSUV2ZW50KTtcbiAgICAgICAgdGhpcy5fVUlFdmVudHMucHVzaChVSUV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2luRHJhdykge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUoVUlFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGFuIGBBRERfRVZFTlRfTElTVEVORVJgIGNvbW1hbmQgdG8gdGhlIGNvbW1hbmQgcXVldWUuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBVSUV2ZW50IEV2ZW50IHR5cGUgKGUuZy4gYGNsaWNrYClcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIF9zdWJzY3JpYmUgKFVJRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnU1VCU0NSSUJFJywgVUlFdmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIHRoZSB1bmRlcmx5aW5nIHNpemUgbW9kZVxuICogY2hhbmdlcy4gVGhpcyByZXN1bHRzIGludG8gdGhlIHNpemUgYmVpbmcgZmV0Y2hlZCBmcm9tIHRoZSBub2RlIGluXG4gKiBvcmRlciB0byB1cGRhdGUgdGhlIGFjdHVhbCwgcmVuZGVyZWQgc2l6ZS5cbiAqXG4gKiBAbWV0aG9kIG9uU2l6ZU1vZGVDaGFuZ2VcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25TaXplTW9kZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU2l6ZU1vZGVDaGFuZ2UgKHgsIHksIHopIHtcbiAgICBpZiAoeCA9PT0gUkVOREVSX1NJWkUgfHwgeSA9PT0gUkVOREVSX1NJWkUgfHwgeiA9PT0gUkVOREVSX1NJWkUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyU2l6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0UmVuZGVyU2l6ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMub25TaXplQ2hhbmdlKHRoaXMuX25vZGUuZ2V0U2l6ZSgpKTtcbn07XG5cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuZ2V0UmVuZGVyU2l6ZSA9IGZ1bmN0aW9uIGdldFJlbmRlclNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJTaXplO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIERPTUVsZW1lbnQgYnkgc2VuZGluZyB0aGUgYElOSVRfRE9NYCBjb21tYW5kLiBUaGlzIGNyZWF0ZXNcbiAqIG9yIHJlYWxsb2NhdGVzIGEgbmV3IEVsZW1lbnQgaW4gdGhlIGFjdHVhbCBET00gaGllcmFyY2h5LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnSU5JVF9ET00nLCB0aGlzLl90YWdOYW1lKTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5vblRyYW5zZm9ybUNoYW5nZSh0aGlzLl9ub2RlLmdldFRyYW5zZm9ybSgpKTtcbiAgICB0aGlzLm9uU2l6ZUNoYW5nZSh0aGlzLl9ub2RlLmdldFNpemUoKSk7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGlkIGF0dHJpYnV0ZSBvZiB0aGUgRE9NRWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIHNldElkXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkICAgTmV3IGlkIHRvIGJlIHNldC5cbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbiBzZXRJZCAoaWQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXcgY2xhc3MgdG8gdGhlIGludGVybmFsIGNsYXNzIGxpc3Qgb2YgdGhlIHVuZGVybHlpbmcgRWxlbWVudCBpbiB0aGVcbiAqIERPTS5cbiAqXG4gKiBAbWV0aG9kIGFkZENsYXNzXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgIE5ldyBjbGFzcyBuYW1lIHRvIGJlIGFkZGVkLlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9jbGFzc2VzLmluZGV4T2YodmFsdWUpIDwgMCkge1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0FERF9DTEFTUycsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJTaXplZCkgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5EcmF3KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQUREX0NMQVNTJywgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBET01FbGVtZW50J3MgY2xhc3NMaXN0LlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ2xhc3NcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHZhbHVlICAgICAgIENsYXNzIG5hbWUgdG8gYmUgcmVtb3ZlZC5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyAodmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jbGFzc2VzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHRoaXM7XG5cbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdSRU1PVkVfQ0xBU1MnLCB2YWx1ZSk7XG5cbiAgICB0aGlzLl9jbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIERPTUVsZW1lbnQgaGFzIHRoZSBwYXNzZWQgaW4gY2xhc3MuXG4gKlxuICogQG1ldGhvZCAgaGFzQ2xhc3NcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHZhbHVlICAgVGhlIGNsYXNzIG5hbWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBhc3NlZCBpbiBjbGFzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgaXMgaW4gdGhlIERPTUVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9jbGFzc2VzLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBhdHRyaWJ1dGUgb2YgdGhlIERPTUVsZW1lbnQuXG4gKlxuICogQG1ldGhvZCBzZXRBdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgQXR0cmlidXRlIGtleSAoZS5nLiBgc3JjYClcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICBBdHRyaWJ1dGUgdmFsdWUgKGUuZy4gYGh0dHA6Ly9mYW1vLnVzYClcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW25hbWVdICE9PSB2YWx1ZSB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0NIQU5HRV9BVFRSSUJVVEUnLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdFVwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIENTUyBwcm9wZXJ0eS5cbiAqXG4gKiBAbWV0aG9kIHNldFByb3BlcnR5XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgIE5hbWUgb2YgdGhlIENTUyBydWxlIChlLmcuIGBiYWNrZ3JvdW5kLWNvbG9yYCkuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVmFsdWUgb2YgQ1NTIHByb3BlcnR5IChlLmcuIGByZWRgKS5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc3R5bGVzW25hbWVdICE9PSB2YWx1ZSB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQ0hBTkdFX1BST1BFUlRZJywgbmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclNpemVkKSB0aGlzLl9yZXF1ZXN0UmVuZGVyU2l6ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBET01FbGVtZW50LiBUaGlzIGlzIHVzaW5nIGBpbm5lckhUTUxgLCBlc2NhcGluZyB1c2VyXG4gKiBnZW5lcmF0ZWQgY29udGVudCBpcyB0aGVyZWZvcmUgZXNzZW50aWFsIGZvciBzZWN1cml0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbWV0aG9kIHNldENvbnRlbnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCAgICAgQ29udGVudCB0byBiZSBzZXQgdXNpbmcgYC5pbm5lckhUTUwgPSAuLi5gXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50IChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQgIT09IGNvbnRlbnQgfHwgdGhpcy5faW5EcmF3KSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0NIQU5HRV9DT05URU5UJywgY29udGVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyU2l6ZWQpIHRoaXMuX3JlcXVlc3RSZW5kZXJTaXplID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXMgdG8gYSBET01FbGVtZW50IHVzaW5nLlxuICpcbiAqIEBtZXRob2Qgb25cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50ICAgICAgIFRoZSBldmVudCB0eXBlIChlLmcuIGBjbGlja2ApLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyICBIYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gd2hpY2ggdGhlIHBheWxvYWQgZXZlbnQgb2JqZWN0IHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkIGludG8uXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3Mub24oZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBieSB0aGUgTm9kZSB3aGVuZXZlciBhbiBVSUV2ZW50IGlzIGJlaW5nIHJlY2VpdmVkLlxuICogVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgd2F5cyB0byBzdWJzY3JpYmUgZm9yIHRob3NlIGV2ZW50czpcbiAqXG4gKiAxLiBCeSBvdmVycmlkaW5nIHRoZSBvblJlY2VpdmUgbWV0aG9kIChhbmQgcG9zc2libHkgdXNpbmcgYHN3aXRjaGAgaW4gb3JkZXJcbiAqICAgICB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIGRpZmZlcmVudCBldmVudCB0eXBlcykuXG4gKiAyLiBCeSB1c2luZyBAe0BsaW5rIERPTUVsZW1lbnQjb259IGFuZCB1c2luZyB0aGUgYnVpbHQtaW5cbiAqICAgICBAe0BsaW5rQ2FsbGJhY2tTdG9yZX0uXG4gKlxuICogQG1ldGhvZCBvblJlY2VpdmVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50ICAgRXZlbnQgdHlwZSAoZS5nLiBgY2xpY2tgKS5cbiAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZCBFdmVudCBvYmplY3QuXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uUmVjZWl2ZSA9IGZ1bmN0aW9uIG9uUmVjZWl2ZSAoZXZlbnQsIHBheWxvYWQpIHtcbiAgICBpZiAoZXZlbnQgPT09ICdyZXNpemUnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclNpemVbMF0gPSBwYXlsb2FkLnZhbFswXTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU2l6ZVsxXSA9IHBheWxvYWQudmFsWzFdO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5fY2FsbGJhY2tzLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQpO1xufTtcblxuLyoqXG4gKiBUaGUgZHJhdyBmdW5jdGlvbiBpcyBiZWluZyB1c2VkIGluIG9yZGVyIHRvIGFsbG93IG11dGF0aW5nIHRoZSBET01FbGVtZW50XG4gKiBiZWZvcmUgYWN0dWFsbHkgbW91bnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGRyYXdcbiAqIEBwcml2YXRlXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBkcmF3ICgpIHtcbiAgICB2YXIga2V5O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICB0aGlzLl9pbkRyYXcgPSB0cnVlO1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jbGFzc2VzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5fY2xhc3Nlc1tpXSk7XG5cbiAgICBpZiAodGhpcy5fY29udGVudCkgdGhpcy5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpO1xuXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fc3R5bGVzKVxuICAgICAgICBpZiAodGhpcy5fc3R5bGVzW2tleV0pXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KGtleSwgdGhpcy5fc3R5bGVzW2tleV0pO1xuXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fYXR0cmlidXRlcylcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNba2V5XSlcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdGhpcy5fYXR0cmlidXRlc1trZXldKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX1VJRXZlbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIHRoaXMub25BZGRVSUV2ZW50KHRoaXMuX1VJRXZlbnRzW2ldKTtcblxuICAgIHRoaXMuX2luRHJhdyA9IGZhbHNlO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUuREVGQVVMVF9QUk9QRVJUSUVTID0ge1xuICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgJy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbic6ICcwJSAwJScsXG4gICAgJ3RyYW5zZm9ybS1vcmlnaW4nOiAnMCUgMCUnLFxuICAgICctd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgJ2JhY2tmYWNlLXZpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgJy13ZWJraXQtdHJhbnNmb3JtLXN0eWxlJzogJ3ByZXNlcnZlLTNkJyxcbiAgICAndHJhbnNmb3JtLXN0eWxlJzogJ3ByZXNlcnZlLTNkJyxcbiAgICAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJzogJ3RyYW5zcGFyZW50JyxcbiAgICAncG9pbnRlci1ldmVudHMnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgnOiAnMScsXG4gICAgJ2JveC1zaXppbmcnOiAnYm9yZGVyLWJveCcsXG4gICAgJy1tb3otYm94LXNpemluZyc6ICdib3JkZXItYm94JyxcbiAgICAnLXdlYmtpdC1ib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUVsZW1lbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBET01FbGVtZW50OiByZXF1aXJlKCcuL0RPTUVsZW1lbnQnKVxufTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVsZW1lbnRDYWNoZSA9IHJlcXVpcmUoJy4vRWxlbWVudENhY2hlJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4vTWF0aCcpO1xudmFyIHZlbmRvclByZWZpeCA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy92ZW5kb3JQcmVmaXgnKTtcbnZhciBldmVudE1hcCA9IHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50TWFwJyk7XG5cbnZhciBUUkFOU0ZPUk0gPSBudWxsO1xuXG4vKipcbiAqIERPTVJlbmRlcmVyIGlzIGEgY2xhc3MgcmVzcG9uc2libGUgZm9yIGFkZGluZyBlbGVtZW50c1xuICogdG8gdGhlIERPTSBhbmQgd3JpdGluZyB0byB0aG9zZSBlbGVtZW50cy5cbiAqIFRoZXJlIGlzIGEgRE9NUmVuZGVyZXIgcGVyIGNvbnRleHQsIHJlcHJlc2VudGVkIGFzIGFuXG4gKiBlbGVtZW50IGFuZCBhIHNlbGVjdG9yLiBJdCBpcyBpbnN0YW50aWF0ZWQgaW4gdGhlXG4gKiBjb250ZXh0IGNsYXNzLlxuICpcbiAqIEBjbGFzcyBET01SZW5kZXJlclxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIHNlbGVjdG9yIG9mIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtDb21wb3NpdG9yfVxuICovXG5mdW5jdGlvbiBET01SZW5kZXJlciAoZWxlbWVudCwgc2VsZWN0b3IsIGNvbXBvc2l0b3IpIHtcbiAgICBUUkFOU0ZPUk0gPSBUUkFOU0ZPUk0gfHwgdmVuZG9yUHJlZml4KCd0cmFuc2Zvcm0nKTtcbiAgICB0aGlzLl9jb21wb3NpdG9yID0gY29tcG9zaXRvcjsgLy8gYSByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2l0b3JcblxuICAgIHRoaXMuX3RhcmdldCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRoYXQgdGhlIFJlbmRlcmVyIGlzIG9wZXJhdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwb25cblxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB0YXJnZXRcblxuICAgIHRoaXMuX3BhdGggPSBudWxsOyAvLyBhIHJlZ2lzdGVyIGZvciBob2xkaW5nIHRoZSBwYXRoIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZWdpc3RlciBtdXN0IGJlIHNldCBmaXJzdCwgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4sIHRhcmdldCwgYW5kIHBhcmVudCBhcmUgYWxsIGxvb2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAvLyB1cCBmcm9tIHRoYXQuXG5cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdOyAvLyBhIHJlZ2lzdGVyIGZvciBob2xkaW5nIHRoZSBjaGlsZHJlbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHRhcmdldC5cblxuICAgIHRoaXMuX3Jvb3QgPSBuZXcgRWxlbWVudENhY2hlKGVsZW1lbnQsIHNlbGVjdG9yKTsgLy8gdGhlIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBkb20gdHJlZSB0aGF0IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlcmVyIGlzIHJlc3BvbnNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JcblxuICAgIHRoaXMuX2JvdW5kVHJpZ2dlckV2ZW50ID0gdGhpcy5fdHJpZ2dlckV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcblxuICAgIHRoaXMuX2VsZW1lbnRzW3NlbGVjdG9yXSA9IHRoaXMuX3Jvb3Q7XG5cbiAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgIHRoaXMuX1ZQdHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuXG4gICAgdGhpcy5fc2l6ZSA9IFtudWxsLCBudWxsXTtcbn1cblxuXG4vKipcbiAqIEF0dGFjaGVzIGFuIEV2ZW50TGlzdGVuZXIgdG8gdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXNzZWQgaW4gcGF0aC5cbiAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uIG9uIGFsbCBzdWJzZXF1ZW50IGV2ZW50cyBpZlxuICogYHByZXZlbnREZWZhdWx0YCBpcyB0cnV0aHkuXG4gKiBBbGwgaW5jb21pbmcgZXZlbnRzIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBjb21wb3NpdG9yIGJ5IGludm9raW5nIHRoZVxuICogYHNlbmRFdmVudGAgbWV0aG9kLlxuICogRGVsZWdhdGVzIGV2ZW50cyBpZiBwb3NzaWJsZSBieSBhdHRhY2hpbmcgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb250ZXh0LlxuICpcbiAqIEBtZXRob2QgIHN1YnNjcmliZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCAgICAgICAgICAgIFBhdGggdW5pcXVlbHkgZGVzY3JpYmluZyB0aGUgbG9jYXRpb24gb2YgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50IGluIHRoZSBzY2VuZSBncmFwaC5cbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgICAgICAgICAgIERPTSBldmVudCB0eXBlIChlLmcuIGNsaWNrLCBtb3VzZW92ZXIpLlxuICogQHBhcmFtICB7Qm9vbGVhbn0gcHJldmVudERlZmF1bHQgV2hldGhlciBvciBub3QgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZCBiZSBwcmV2ZW50ZWQuXG4gKi8gXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKHR5cGUsIHByZXZlbnREZWZhdWx0KSB7XG4gICAgLy8gVE9ETyBwcmV2ZW50RGVmYXVsdCBzaG91bGQgYmUgYSBzZXBhcmF0ZSBjb21tYW5kXG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgXG4gICAgdGhpcy5fdGFyZ2V0LnByZXZlbnREZWZhdWx0W3R5cGVdID0gcHJldmVudERlZmF1bHQ7XG4gICAgdGhpcy5fdGFyZ2V0LnN1YnNjcmliZVt0eXBlXSA9IHRydWU7XG4gICAgXG4gICAgaWYgKFxuICAgICAgICAhdGhpcy5fdGFyZ2V0Lmxpc3RlbmVyc1t0eXBlXSAmJiAhdGhpcy5fcm9vdC5saXN0ZW5lcnNbdHlwZV1cbiAgICApIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50TWFwW3R5cGVdWzFdID8gdGhpcy5fcm9vdCA6IHRoaXMuX3RhcmdldDtcbiAgICAgICAgdGFyZ2V0Lmxpc3RlbmVyc1t0eXBlXSA9IHRoaXMuX2JvdW5kVHJpZ2dlckV2ZW50O1xuICAgICAgICB0YXJnZXQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuX2JvdW5kVHJpZ2dlckV2ZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGJlIGFkZGVkIHVzaW5nIGBhZGRFdmVudExpc3RlbmVyYCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NRWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kICBfdHJpZ2dlckV2ZW50XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge0V2ZW50fSBldiAgRE9NIEV2ZW50IHBheWxvYWQuXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5fdHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gX3RyaWdnZXJFdmVudChldikge1xuICAgIC8vIFVzZSBldi5wYXRoLCB3aGljaCBpcyBhbiBhcnJheSBvZiBFbGVtZW50cyAocG9seWZpbGxlZCBpZiBuZWVkZWQpLlxuICAgIHZhciBldlBhdGggPSBldi5wYXRoID8gZXYucGF0aCA6IF9nZXRQYXRoKGV2KTtcbiAgICAvLyBGaXJzdCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCBoYXMgYWN0dWFsbHlcbiAgICAvLyBiZWVuIGVtaXR0ZWQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldlBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gU2tpcCBub2RlcyB0aGF0IGRvbid0IGhhdmUgYSBkYXRhc2V0IHByb3BlcnR5IG9yIGRhdGEtZmEtcGF0aFxuICAgICAgICAvLyBhdHRyaWJ1dGUuXG4gICAgICAgIGlmICghZXZQYXRoW2ldLmRhdGFzZXQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgcGF0aCA9IGV2UGF0aFtpXS5kYXRhc2V0LmZhUGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3AgZnVydGhlciBldmVudCBwcm9wb2dhdGlvbiBhbmQgcGF0aCB0cmF2ZXJzYWwgYXMgc29vbiBhcyB0aGVcbiAgICAgICAgLy8gZmlyc3QgRWxlbWVudENhY2hlIHN1YnNjcmliaW5nIGZvciB0aGUgZW1pdHRlZCBldmVudCBoYXMgYmVlbiBmb3VuZC5cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRzW3BhdGhdLnN1YnNjcmliZVtldi50eXBlXSkge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgcHJldmVudERlZmF1bHQuIFRoaXMgbmVlZHMgZm9ydGhlciBjb25zaWRlcmF0aW9uIGFuZFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG9wdGlvbmFsLiBFdmVudHVhbGx5IHRoaXMgc2hvdWxkIGJlIGEgc2VwYXJhdGUgY29tbWFuZC9cbiAgICAgICAgICAgIC8vIG1ldGhvZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50c1twYXRoXS5wcmV2ZW50RGVmYXVsdFtldi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBOb3JtYWxpemVkRXZlbnRDb25zdHJ1Y3RvciA9IGV2ZW50TWFwW2V2LnR5cGVdWzBdO1xuXG4gICAgICAgICAgICAvLyBGaW5hbGx5IHNlbmQgdGhlIGV2ZW50IHRvIHRoZSBXb3JrZXIgVGhyZWFkIHRocm91Z2ggdGhlXG4gICAgICAgICAgICAvLyBjb21wb3NpdG9yLlxuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRvci5zZW5kRXZlbnQocGF0aCwgZXYudHlwZSwgbmV3IE5vcm1hbGl6ZWRFdmVudENvbnN0cnVjdG9yKGV2KSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIGdldFNpemVPZiBnZXRzIHRoZSBkb20gc2l6ZSBvZiBhIHBhcnRpY3VsYXIgZmFtby51cyBlbGVtZW50XG4gKlxuICogQG1ldGhvZCBnZXRTaXplT2ZcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGEgdmVjMyBvZiB0aGUgb2Zmc2V0IHNpemUgb2YgdGhlIGRvbSBlbGVtZW50XG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaXplT2YgPSBmdW5jdGlvbiBnZXRTaXplT2YgKHBhdGgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRzW3BhdGhdO1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuXG4gICAgdmFyIHJlcyA9IHt2YWw6IGVsZW1lbnQuc2l6ZX07XG4gICAgdGhpcy5fY29tcG9zaXRvci5zZW5kRXZlbnQocGF0aCwgJ3Jlc2l6ZScsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRQYXRoIChldikge1xuICAgIC8vIFRPRE8gbW92ZSBpbnRvIF90cmlnZ2VyRXZlbnQsIGF2b2lkIG9iamVjdCBhbGxvY2F0aW9uXG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgbm9kZSA9IGV2LnRhcmdldDtcbiAgICB3aGlsZSAobm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgc2l6ZSBvZiB0aGUgY29udGV4dCBieSBxdWVyeWluZyB0aGUgRE9NIGZvciBgb2Zmc2V0V2lkdGhgIGFuZFxuICogYG9mZnNldEhlaWdodGAuXG4gKlxuICogQG1ldGhvZCAgZ2V0U2l6ZVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSAgT2Zmc2V0IHNpemUuXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSAoKSB7XG4gICAgdGhpcy5fc2l6ZVswXSA9IHRoaXMuX3Jvb3QuZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLl9zaXplWzFdID0gdGhpcy5fcm9vdC5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5fZ2V0U2l6ZSA9IERPTVJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaXplO1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHJldHJpZXZlZCBkcmF3IGNvbW1hbmRzLiBEcmF3IGNvbW1hbmRzIG9ubHkgcmVmZXIgdG8gdGhlXG4gKiBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgYHRyYW5zZm9ybWAgcHJvcGVydHkuXG4gKlxuICogQG1ldGhvZCAgZHJhd1xuICpcbiAqIEBwYXJhbSAge3R5cGV9IHJlbmRlclN0YXRlIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJuIHt0eXBlfSAgICAgICAgICAgICBkZXNjcmlwdGlvblxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIGRyYXcgKHJlbmRlclN0YXRlKSB7XG4gICAgaWYgKHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlRGlydHkpIHtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzBdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsyXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzJdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzNdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bM107XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs0XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzRdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzVdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNV07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs2XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs3XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzddO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bOF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs4XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs5XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzldO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEwXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEwXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV07XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMl07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTNdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTNdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzE0XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzE0XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNV07XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlclN0YXRlLnZpZXdEaXJ0eSB8fCByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5KSB7XG4gICAgICAgIG1hdGgubXVsdGlwbHkodGhpcy5fVlB0cmFuc2Zvcm0sIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm0sIHJlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLl9yb290LmVsZW1lbnQuc3R5bGVbVFJBTlNGT1JNXSA9IHRoaXMuX3N0cmluZ2lmeU1hdHJpeCh0aGlzLl9WUHRyYW5zZm9ybSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB1c2VkIGZvciBlbnN1cmluZyB0aGF0IGEgcGF0aCBpcyBjdXJyZW50bHkgbG9hZGVkLlxuICpcbiAqIEBtZXRob2QgIF9hc3NlclBhdGhMb2FkZWRcbiAqIEBwcml2YXRlXG4gKlxuICogQHRocm93cyAgVGhyb3dzIGFuIGVycm9yIGlmIG5vIHBhdGggaXMgbG9hZGVkLlxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2Fzc2VydFBhdGhMb2FkZWQgPSBmdW5jdGlvbiBfYXNzZXJQYXRoTG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdGgpIHRocm93IG5ldyBFcnJvcigncGF0aCBub3QgbG9hZGVkJyk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB1c2VkIGZvciBlbnN1cmluZyB0aGF0IGEgcGFyZW50IGlzIGN1cnJlbnRseSBsb2FkZWQuXG4gKlxuICogQG1ldGhvZCAgX2Fzc2VyUGF0aExvYWRlZFxuICogQHByaXZhdGVcbiAqXG4gKiBAdGhyb3dzICBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gcGFyZW50IGlzIGxvYWRlZC5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRQYXJlbnRMb2FkZWQgPSBmdW5jdGlvbiBfYXNzZXJ0UGFyZW50TG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudCkgdGhyb3cgbmV3IEVycm9yKCdwYXJlbnQgbm90IGxvYWRlZCcpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdXNlZCBmb3IgZW5zdXJpbmcgdGhhdCBjaGlsZHJlbiBhcmUgY3VycmVudGx5XG4gKiBsb2FkZWQuXG4gKlxuICogQG1ldGhvZCAgX2Fzc2VyUGF0aExvYWRlZFxuICogQHByaXZhdGVcbiAqXG4gKiBAdGhyb3dzICBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gY2hpbHJlbiBhcmUgbG9hZGVkLlxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2Fzc2VydENoaWxkcmVuTG9hZGVkID0gZnVuY3Rpb24gX2Fzc2VydENoaWxkcmVuTG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSB0aHJvdyBuZXcgRXJyb3IoJ2NoaWxkcmVuIG5vdCBsb2FkZWQnKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGVuc3VyaW5nIHRoYXQgYSB0YXJnZXQgaXMgY3VycmVudGx5IGxvYWRlZC5cbiAqXG4gKiBAbWV0aG9kICBfYXNzZXJ0VGFyZ2V0TG9hZGVkXG4gKlxuICogQHRocm93cyAgVGhyb3dzIGFuIGVycm9yIGlmIG5vIHRhcmdldCBpcyBjdXJyZW50bHkgbG9hZGVkLlxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2Fzc2VydFRhcmdldExvYWRlZCA9IGZ1bmN0aW9uIF9hc3NlcnRUYXJnZXRMb2FkZWQgKCkge1xuICAgIGlmICghdGhpcy5fdGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoJ05vIHRhcmdldCBsb2FkZWQnKTtcbn07XG5cbi8qKlxuICogRmluZHMgYW5kIHNldHMgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudGx5IGxvYWRlZCBlbGVtZW50IChwYXRoKS5cbiAqXG4gKiBAbWV0aG9kICBmaW5kUGFyZW50XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnRDYWNoZX0gICBQYXJlbnQgZWxlbWVudC5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmZpbmRQYXJlbnQgPSBmdW5jdGlvbiBmaW5kUGFyZW50ICgpIHtcbiAgICB0aGlzLl9hc3NlcnRQYXRoTG9hZGVkKCk7XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFyIHBhcmVudDtcblxuICAgIHdoaWxlICghcGFyZW50ICYmIHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9lbGVtZW50c1twYXRoXTtcbiAgICB9XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHJldHVybiBwYXJlbnQ7XG59O1xuXG5cbi8qKlxuICogRmluZHMgYWxsIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50bHkgbG9hZGVkIGVsZW1lbnQuXG4gKlxuICogQG1ldGhvZCBmaW5kQ2hpbGRyZW5cbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IFthcnJheV0gIE91dHB1dC1BcnJheSB1c2VkIGZvciB3cml0aW5nIHRvIChzdWJzZXF1ZW50bHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRpbmcgY2hpbGRyZW4pLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIFJlc3VsdFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuZmluZENoaWxkcmVuID0gZnVuY3Rpb24gZmluZENoaWxkcmVuIChhcnJheSkge1xuICAgIC8vIFRPRE8gT3B0aW1pemUgbWUuXG4gICAgdGhpcy5fYXNzZXJ0UGF0aExvYWRlZCgpO1xuXG4gICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoICsgJy8nO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fZWxlbWVudHMpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuO1xuICAgIGFycmF5ID0gYXJyYXkgPyBhcnJheSA6IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGtleXNbaV0uaW5kZXhPZihwYXRoKSA9PT0gLTEgfHwga2V5c1tpXSA9PT0gcGF0aCkga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGVsc2UgaSsrO1xuICAgIH1cbiAgICB2YXIgY3VycmVudFBhdGg7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAoaSA9IDAgOyBpIDwga2V5cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgY3VycmVudFBhdGggPSBrZXlzW2ldO1xuICAgICAgICBmb3IgKGogPSAwIDsgaiA8IGtleXMubGVuZ3RoIDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gaiAmJiBrZXlzW2pdLmluZGV4T2YoY3VycmVudFBhdGgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGtleXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gdGhpcy5fZWxlbWVudHNba2V5c1tpXV07XG5cbiAgICByZXR1cm4gYXJyYXk7XG59O1xuXG5cbi8qKlxuICogVXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIHRhcmdldCBsb2FkZWQgdW5kZXIgdGhlIGN1cnJlbnQgcGF0aC5cbiAqXG4gKiBAbWV0aG9kICBmaW5kVGFyZ2V0XG4gKlxuICogQHJldHVybiB7RWxlbWVudENhY2hlfHVuZGVmaW5lZH0gICAgIEVsZW1lbnQgbG9hZGVkIHVuZGVyIGRlZmluZWQgcGF0aC5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmZpbmRUYXJnZXQgPSBmdW5jdGlvbiBmaW5kVGFyZ2V0ICgpIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9lbGVtZW50c1t0aGlzLl9wYXRoXTtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xufTtcblxuXG4vKipcbiAqIExvYWRzIHRoZSBwYXNzZWQgaW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kICBsb2FkUGF0aFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCAgICBQYXRoIHRvIGJlIGxvYWRlZC5cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBMb2FkZWQgcGF0aFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUubG9hZFBhdGggPSBmdW5jdGlvbiBsb2FkUGF0aCAocGF0aCkge1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIHJldHVybiB0aGlzLl9wYXRoO1xufTtcblxuXG4vKipcbiAqIEluc2VydHMgYSBET01FbGVtZW50IGF0IHRoZSBjdXJyZW50bHkgbG9hZGVkIHBhdGgsIGFzc3VtaW5nIG5vIHRhcmdldCBpc1xuICogbG9hZGVkLiBPbmx5IG9uZSBET01FbGVtZW50IGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggZWFjaCBwYXRoLlxuICpcbiAqIEBtZXRob2QgIGluc2VydEVsXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0YWdOYW1lICAgICBUYWcgbmFtZSAoY2FwaXRhbGl6YXRpb24gd2lsbCBiZSBub3JtYWxpemVkKS5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmluc2VydEVsID0gZnVuY3Rpb24gaW5zZXJ0RWwgKHRhZ05hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3RhcmdldCB8fFxuICAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblxuICAgICAgICB0aGlzLmZpbmRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5maW5kQ2hpbGRyZW4oKTtcblxuICAgICAgICB0aGlzLl9hc3NlcnRQYXJlbnRMb2FkZWQoKTtcbiAgICAgICAgdGhpcy5fYXNzZXJ0Q2hpbGRyZW5Mb2FkZWQoKTtcblxuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0KSB0aGlzLl9wYXJlbnQuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl90YXJnZXQuZWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbmV3IEVsZW1lbnRDYWNoZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpLCB0aGlzLl9wYXRoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50LmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fdGFyZ2V0LmVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9lbGVtZW50c1t0aGlzLl9wYXRoXSA9IHRoaXMuX3RhcmdldDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY2hpbGRyZW5baV0uZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyBhIHByb3BlcnR5IG9uIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kICBzZXRQcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAgICBQcm9wZXJ0eSBuYW1lIChlLmcuIGJhY2tncm91bmQsIGNvbG9yLCBmb250KVxuICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZSAgIFByb3BydHkgdmFsdWUgKGUuZy4gYmxhY2ssIDIwcHgpXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5IChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnN0eWxlW25hbWVdID0gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudGx5IGxvYWRlZCB0YXJnZXQuXG4gKiBSZW1vdmVzIGFueSBleHBsaWNpdCBzaXppbmcgY29uc3RyYWludHMgd2hlbiBwYXNzZWQgaW4gYGZhbHNlYFxuICogKFwidHJ1ZS1zaXppbmdcIikuXG4gKlxuICogQG1ldGhvZCAgc2V0U2l6ZVxuICpcbiAqIEBwYXJhbSAge051bWJlcnxmYWxzZX0gd2lkdGggICBXaWR0aCB0byBiZSBzZXQuXG4gKiBAcGFyYW0gIHtOdW1iZXJ8ZmFsc2V9IGhlaWdodCAgSGVpZ2h0IHRvIGJlIHNldC5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgXG4gICAgdGhpcy5zZXRXaWR0aCh3aWR0aCk7XG4gICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0KTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgXG4gICAgdmFyIGNvbnRlbnRXcmFwcGVyID0gdGhpcy5fdGFyZ2V0LmNvbnRlbnQ7XG4gICAgXG4gICAgaWYgKHdpZHRoID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRXaWR0aCA9IHRydWU7XG4gICAgICAgIGlmIChjb250ZW50V3JhcHBlcikgY29udGVudFdyYXBwZXIuc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgd2lkdGggPSBjb250ZW50V3JhcHBlciA/IGNvbnRlbnRXcmFwcGVyLm9mZnNldFdpZHRoIDogMDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmV4cGxpY2l0V2lkdGggPSBmYWxzZTtcbiAgICAgICAgaWYgKGNvbnRlbnRXcmFwcGVyKSBjb250ZW50V3JhcHBlci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX3RhcmdldC5zaXplWzBdID0gd2lkdGg7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIFxuICAgIHZhciBjb250ZW50V3JhcHBlciA9IHRoaXMuX3RhcmdldC5jb250ZW50O1xuICAgIFxuICAgIGlmIChoZWlnaHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5leHBsaWNpdEhlaWdodCA9IHRydWU7XG4gICAgICAgIGlmIChjb250ZW50V3JhcHBlcikgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgIGhlaWdodCA9IGNvbnRlbnRXcmFwcGVyID8gY29udGVudFdyYXBwZXIub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNvbnRlbnRXcmFwcGVyKSBjb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl90YXJnZXQuc2l6ZVsxXSA9IGhlaWdodDtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIGN1cnJlbnRseSBsb2FkZWQgdGFyZ2V0LlxuICpcbiAqIEBtZXRob2QgIHNldEF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAgICBBdHRyaWJ1dGUgbmFtZSAoZS5nLiBocmVmKVxuICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZSAgIEF0dHJpYnV0ZSB2YWx1ZSAoZS5nLiBodHRwOi8vZmFtby51cylcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgaW5uZXJIVE1MYCBjb250ZW50IG9mIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kICBzZXRDb250ZW50XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBjb250ZW50ICAgICBDb250ZW50IHRvIGJlIHNldCBhcyBgaW5uZXJIVE1MYC5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50IChjb250ZW50KSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5maW5kQ2hpbGRyZW4oKTtcbiAgICBcbiAgICBpZiAoIXRoaXMuX3RhcmdldC5jb250ZW50KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5jb250ZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmNvbnRlbnQsXG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5maXJzdENoaWxkXG4gICAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX3RhcmdldC5jb250ZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgXG4gICAgdGhpcy5zZXRTaXplKFxuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRXaWR0aCA/IGZhbHNlIDogdGhpcy5fdGFyZ2V0LnNpemVbMF0sXG4gICAgICAgIHRoaXMuX3RhcmdldC5leHBsaWNpdEhlaWdodCA/IGZhbHNlIDogdGhpcy5fdGFyZ2V0LnNpemVbMV1cbiAgICApO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIHBhc3NlZCBpbiB0cmFuc2Zvcm0gbWF0cml4ICh3b3JsZCBzcGFjZSkuIEludmVydHMgdGhlIHBhcmVudCdzIHdvcmxkXG4gKiB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZCAgc2V0TWF0cml4XG4gKlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBbdHJhbnNmb3JtXSAgIFdvcmxkIHRyYW5zZm9ybS5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldE1hdHJpeCA9IGZ1bmN0aW9uIHNldE1hdHJpeCAodHJhbnNmb3JtKSB7XG4gICAgLy8gVE9ETyBEb24ndCBtdWx0aXBseSBtYXRyaWNzIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLmZpbmRQYXJlbnQoKTtcbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLl90YXJnZXQud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBpZiAodHJhbnNmb3JtKVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSAxNiA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkID8gY2hhbmdlZCA6IHdvcmxkVHJhbnNmb3JtW2ldID09PSB0cmFuc2Zvcm1baV07XG4gICAgICAgICAgICB3b3JsZFRyYW5zZm9ybVtpXSA9IHRyYW5zZm9ybVtpXTtcbiAgICAgICAgfVxuICAgIGVsc2UgY2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICBtYXRoLmludmVydCh0aGlzLl90YXJnZXQuaW52ZXJ0ZWRQYXJlbnQsIHRoaXMuX3BhcmVudC53b3JsZFRyYW5zZm9ybSk7XG4gICAgICAgIG1hdGgubXVsdGlwbHkodGhpcy5fdGFyZ2V0LmZpbmFsVHJhbnNmb3JtLCB0aGlzLl90YXJnZXQuaW52ZXJ0ZWRQYXJlbnQsIHdvcmxkVHJhbnNmb3JtKTtcblxuICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGEgdGVtcG9yYXJ5IGZpeCBmb3IgZHJhdyBjb21tYW5kc1xuICAgICAgICAvLyBjb21pbmcgaW4gb3V0IG9mIG9yZGVyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZmluZENoaWxkcmVuKFtdKTtcbiAgICAgICAgdmFyIHByZXZpb3VzUGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICAgIHZhciBwcmV2aW91c1RhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICB0aGlzLl9wYXRoID0gdGhpcy5fdGFyZ2V0LnBhdGg7XG4gICAgICAgICAgICB0aGlzLnNldE1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdGggPSBwcmV2aW91c1BhdGg7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHByZXZpb3VzVGFyZ2V0O1xuICAgIH1cblxuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnN0eWxlW1RSQU5TRk9STV0gPSB0aGlzLl9zdHJpbmdpZnlNYXRyaXgodGhpcy5fdGFyZ2V0LmZpbmFsVHJhbnNmb3JtKTtcbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGNsYXNzTGlzdCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBsb2FkZWQgdGFyZ2V0LlxuICpcbiAqIEBtZXRob2QgIGFkZENsYXNzXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBkb21DbGFzcyAgICBDbGFzcyBuYW1lIHRvIGJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRhcmdldC5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MgKGRvbUNsYXNzKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChkb21DbGFzcyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGNsYXNzTGlzdCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBsb2FkZWRcbiAqIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kICByZW1vdmVDbGFzc1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZG9tQ2xhc3MgICAgQ2xhc3MgbmFtZSB0byBiZSByZW1vdmVkIGZyb20gY3VycmVudGx5IGxvYWRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChkb21DbGFzcykge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZG9tQ2xhc3MpO1xufTtcblxuXG4vKipcbiAqIFN0cmluZ2lmaWVzIHRoZSBwYXNzZWQgaW4gbWF0cml4IGZvciBzZXR0aW5nIHRoZSBgdHJhbnNmb3JtYCBwcm9wZXJ0eS5cbiAqXG4gKiBAbWV0aG9kICBfc3RyaW5naWZ5TWF0cml4XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBtICAgIE1hdHJpeCBhcyBhbiBhcnJheSBvciBhcnJheS1saWtlIG9iamVjdC5cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIFN0cmluZ2lmaWVkIG1hdHJpeCBhcyBgbWF0cml4M2RgLXByb3BlcnR5LlxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX3N0cmluZ2lmeU1hdHJpeCA9IGZ1bmN0aW9uIF9zdHJpbmdpZnlNYXRyaXgobSkge1xuICAgIHZhciByID0gJ21hdHJpeDNkKCc7XG5cbiAgICByICs9IChtWzBdIDwgMC4wMDAwMDEgJiYgbVswXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVswXSArICcsJztcbiAgICByICs9IChtWzFdIDwgMC4wMDAwMDEgJiYgbVsxXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxXSArICcsJztcbiAgICByICs9IChtWzJdIDwgMC4wMDAwMDEgJiYgbVsyXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsyXSArICcsJztcbiAgICByICs9IChtWzNdIDwgMC4wMDAwMDEgJiYgbVszXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVszXSArICcsJztcbiAgICByICs9IChtWzRdIDwgMC4wMDAwMDEgJiYgbVs0XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs0XSArICcsJztcbiAgICByICs9IChtWzVdIDwgMC4wMDAwMDEgJiYgbVs1XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs1XSArICcsJztcbiAgICByICs9IChtWzZdIDwgMC4wMDAwMDEgJiYgbVs2XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs2XSArICcsJztcbiAgICByICs9IChtWzddIDwgMC4wMDAwMDEgJiYgbVs3XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs3XSArICcsJztcbiAgICByICs9IChtWzhdIDwgMC4wMDAwMDEgJiYgbVs4XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs4XSArICcsJztcbiAgICByICs9IChtWzldIDwgMC4wMDAwMDEgJiYgbVs5XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs5XSArICcsJztcbiAgICByICs9IChtWzEwXSA8IDAuMDAwMDAxICYmIG1bMTBdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEwXSArICcsJztcbiAgICByICs9IChtWzExXSA8IDAuMDAwMDAxICYmIG1bMTFdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzExXSArICcsJztcbiAgICByICs9IChtWzEyXSA8IDAuMDAwMDAxICYmIG1bMTJdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEyXSArICcsJztcbiAgICByICs9IChtWzEzXSA8IDAuMDAwMDAxICYmIG1bMTNdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEzXSArICcsJztcbiAgICByICs9IChtWzE0XSA8IDAuMDAwMDAxICYmIG1bMTRdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzE0XSArICcsJztcblxuICAgIHIgKz0gbVsxNV0gKyAnKSc7XG4gICAgcmV0dXJuIHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVJlbmRlcmVyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gaWRlbnRpdHkgbWF0cml4LlxuICovIFxudmFyIGlkZW50ID0gW1xuICAgIDEsIDAsIDAsIDAsXG4gICAgMCwgMSwgMCwgMCxcbiAgICAwLCAwLCAxLCAwLFxuICAgIDAsIDAsIDAsIDFcbl07XG5cbi8qKlxuICogRWxlbWVudENhY2hlIGlzIGJlaW5nIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgYW4gZWxlbWVudCdzIERPTSBFbGVtZW50LFxuICogcGF0aCwgd29ybGQgdHJhbnNmb3JtLCBpbnZlcnRlZCBwYXJlbnQsIGZpbmFsIHRyYW5zZm9ybSAoYXMgYmVpbmcgdXNlZCBmb3JcbiAqIHNldHRpbmcgdGhlIGFjdHVhbCBgdHJhbnNmb3JtYC1wcm9wZXJ0eSkgYW5kIHBvc3QgcmVuZGVyIHNpemUgKGZpbmFsIHNpemUgYXNcbiAqIGJlaW5nIHJlbmRlcmVkIHRvIHRoZSBET00pLlxuICogXG4gKiBAY2xhc3MgICBFbGVtZW50Q2FjaGVcbiAqICBcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgICAgRE9NRWxlbWVudFxuICogQHBhcmFtICB7U3RyaW5nfSBwYXRoICAgICAgICBQYXRoIHVzZWQgZm9yIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoZSBsb2NhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gKi8gXG5mdW5jdGlvbiBFbGVtZW50Q2FjaGUgKGVsZW1lbnQsIHBhdGgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSBuZXcgSW50MTZBcnJheSgzKTtcbiAgICB0aGlzLmV4cGxpY2l0SGVpZ2h0ID0gZmFsc2U7XG4gICAgdGhpcy5leHBsaWNpdFdpZHRoID0gZmFsc2U7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBGbG9hdDMyQXJyYXkoaWRlbnQpO1xuICAgIHRoaXMuaW52ZXJ0ZWRQYXJlbnQgPSBuZXcgRmxvYXQzMkFycmF5KGlkZW50KTtcbiAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShpZGVudCk7XG4gICAgdGhpcy5wb3N0UmVuZGVyU2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0ge307XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50Q2FjaGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpbnZlcnQgKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBtdWx0aXBseSAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLFxuICAgICAgICBiNCA9IGJbNF0sIGI1ID0gYls1XSwgYjYgPSBiWzZdLCBiNyA9IGJbN10sXG4gICAgICAgIGI4ID0gYls4XSwgYjkgPSBiWzldLCBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV0sXG4gICAgICAgIGIxMiA9IGJbMTJdLCBiMTMgPSBiWzEzXSwgYjE0ID0gYlsxNF0sIGIxNSA9IGJbMTVdO1xuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgb3V0MCwgb3V0MSwgb3V0Miwgb3V0MztcblxuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDEgPT09IG91dFsxXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09PSBvdXRbM107XG5cbiAgICBvdXRbMF0gPSBvdXQwO1xuICAgIG91dFsxXSA9IG91dDE7XG4gICAgb3V0WzJdID0gb3V0MjtcbiAgICBvdXRbM10gPSBvdXQzO1xuXG4gICAgYjAgPSBiNDsgYjEgPSBiNTsgYjIgPSBiNjsgYjMgPSBiNztcbiAgICBvdXQwID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dDEgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0MiA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXQzID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgP1xuICAgICAgICAgICAgICBjaGFuZ2VkIDogb3V0MCA9PT0gb3V0WzRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09PSBvdXRbNV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPT09IG91dFs2XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MyA9PT0gb3V0WzddO1xuXG4gICAgb3V0WzRdID0gb3V0MDtcbiAgICBvdXRbNV0gPSBvdXQxO1xuICAgIG91dFs2XSA9IG91dDI7XG4gICAgb3V0WzddID0gb3V0MztcblxuICAgIGIwID0gYjg7IGIxID0gYjk7IGIyID0gYjEwOyBiMyA9IGIxMTtcbiAgICBvdXQwID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dDEgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0MiA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXQzID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgP1xuICAgICAgICAgICAgICBjaGFuZ2VkIDogb3V0MCA9PT0gb3V0WzhdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09PSBvdXRbOV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPT09IG91dFsxMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDMgPT09IG91dFsxMV07XG5cbiAgICBvdXRbOF0gPSBvdXQwO1xuICAgIG91dFs5XSA9IG91dDE7XG4gICAgb3V0WzEwXSA9IG91dDI7XG4gICAgb3V0WzExXSA9IG91dDM7XG5cbiAgICBiMCA9IGIxMjsgYjEgPSBiMTM7IGIyID0gYjE0OyBiMyA9IGIxNTtcbiAgICBvdXQwID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dDEgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0MiA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXQzID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgP1xuICAgICAgICAgICAgICBjaGFuZ2VkIDogb3V0MCA9PT0gb3V0WzEyXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MSA9PT0gb3V0WzEzXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzE0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MyA9PT0gb3V0WzE1XTtcblxuICAgIG91dFsxMl0gPSBvdXQwO1xuICAgIG91dFsxM10gPSBvdXQxO1xuICAgIG91dFsxNF0gPSBvdXQyO1xuICAgIG91dFsxNV0gPSBvdXQzO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbXVsdGlwbHk6IG11bHRpcGx5LFxuICAgIGludmVydDogaW52ZXJ0XG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuZnVuY3Rpb24gQ29tcG9zaXRpb25FdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgQ29tcG9zaXRpb25FdmVudEluaXQgY29tcG9zaXRpb25FdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgQ29tcG9zaXRpb25FdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgRE9NU3RyaW5nIGRhdGE7XG4gICAgLy8gfTtcblxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG4gICAgdGhpcy5kYXRhID0gZXYuZGF0YTtcbn1cblxuQ29tcG9zaXRpb25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlKTtcbkNvbXBvc2l0aW9uRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcG9zaXRpb25FdmVudDtcblxuQ29tcG9zaXRpb25FdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdDb21wb3NpdGlvbkV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRpb25FdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlLCBvcHRpb25hbCBFdmVudEluaXQgZXZlbnRJbml0RGljdCksXG4gICAgLy8gIEV4cG9zZWQ9V2luZG93LFdvcmtlcl1cbiAgICAvLyBpbnRlcmZhY2UgRXZlbnQge1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyB0eXBlO1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIEV2ZW50VGFyZ2V0PyB0YXJnZXQ7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgRXZlbnRUYXJnZXQ/IGN1cnJlbnRUYXJnZXQ7XG5cbiAgICAvLyAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IE5PTkUgPSAwO1xuICAgIC8vICAgY29uc3QgdW5zaWduZWQgc2hvcnQgQ0FQVFVSSU5HX1BIQVNFID0gMTtcbiAgICAvLyAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IEFUX1RBUkdFVCA9IDI7XG4gICAgLy8gICBjb25zdCB1bnNpZ25lZCBzaG9ydCBCVUJCTElOR19QSEFTRSA9IDM7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgc2hvcnQgZXZlbnRQaGFzZTtcblxuICAgIC8vICAgdm9pZCBzdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvLyAgIHZvaWQgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBib29sZWFuIGJ1YmJsZXM7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgYm9vbGVhbiBjYW5jZWxhYmxlO1xuICAgIC8vICAgdm9pZCBwcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIGJvb2xlYW4gZGVmYXVsdFByZXZlbnRlZDtcblxuICAgIC8vICAgW1VuZm9yZ2VhYmxlXSByZWFkb25seSBhdHRyaWJ1dGUgYm9vbGVhbiBpc1RydXN0ZWQ7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgRE9NVGltZVN0YW1wIHRpbWVTdGFtcDtcblxuICAgIC8vICAgdm9pZCBpbml0RXZlbnQoRE9NU3RyaW5nIHR5cGUsIGJvb2xlYW4gYnViYmxlcywgYm9vbGVhbiBjYW5jZWxhYmxlKTtcbiAgICAvLyB9O1xuXG4gICAgdGhpcy50eXBlID0gZXYudHlwZTtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBldi5kZWZhdWx0UHJldmVudGVkO1xuICAgIHRoaXMudGltZVN0YW1wID0gZXYudGltZVN0YW1wO1xufVxuXG5FdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbiAvKmpzaGludCAtVzA3OSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9Db21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG52YXIgRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vRm9jdXNFdmVudCcpO1xudmFyIElucHV0RXZlbnQgPSByZXF1aXJlKCcuL0lucHV0RXZlbnQnKTtcbnZhciBLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9LZXlib2FyZEV2ZW50Jyk7XG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vTW91c2VFdmVudCcpO1xudmFyIFRvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1RvdWNoRXZlbnQnKTtcbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG52YXIgV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vV2hlZWxFdmVudCcpO1xuXG52YXIgRXZlbnRNYXAgPSB7XG4gICAgLy8gVUkgRXZlbnRzIChodHRwOi8vd3d3LnczLm9yZy9UUi91aWV2ZW50cy8pXG4gICAgYWJvcnQgICAgICAgICAgICAgICAgICAgICAgICAgIDogW0V2ZW50LCBmYWxzZV0sXG4gICAgYmVmb3JlaW5wdXQgICAgICAgICAgICAgICAgICAgIDogW0lucHV0RXZlbnQsIHRydWVdLFxuICAgIGJsdXIgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtGb2N1c0V2ZW50LCBmYWxzZV0sXG4gICAgY2xpY2sgICAgICAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgIGNvbXBvc2l0aW9uZW5kICAgICAgICAgICAgICAgICA6IFtDb21wb3NpdGlvbkV2ZW50LCB0cnVlXSxcbiAgICBjb21wb3NpdGlvbnN0YXJ0ICAgICAgICAgICAgICAgOiBbQ29tcG9zaXRpb25FdmVudCwgdHJ1ZV0sXG4gICAgY29tcG9zaXRpb251cGRhdGUgICAgICAgICAgICAgIDogW0NvbXBvc2l0aW9uRXZlbnQsIHRydWVdLFxuICAgIGRibGNsaWNrICAgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICBmb2N1cyAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbRm9jdXNFdmVudCwgZmFsc2VdLFxuICAgIGZvY3VzaW4gICAgICAgICAgICAgICAgICAgICAgICA6IFtGb2N1c0V2ZW50LCB0cnVlXSxcbiAgICBmb2N1c291dCAgICAgICAgICAgICAgICAgICAgICAgOiBbRm9jdXNFdmVudCwgdHJ1ZV0sXG4gICAgaW5wdXQgICAgICAgICAgICAgICAgICAgICAgICAgIDogW0lucHV0RXZlbnQsIHRydWVdLFxuICAgIGtleWRvd24gICAgICAgICAgICAgICAgICAgICAgICA6IFtLZXlib2FyZEV2ZW50LCB0cnVlXSxcbiAgICBrZXl1cCAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbS2V5Ym9hcmRFdmVudCwgdHJ1ZV0sXG4gICAgbG9hZCAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW0V2ZW50LCBmYWxzZV0sXG4gICAgbW91c2Vkb3duICAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgIG1vdXNlZW50ZXIgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCBmYWxzZV0sXG4gICAgbW91c2VsZWF2ZSAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIGZhbHNlXSxcblxuICAgIC8vIGJ1YmJsZXMsIGJ1dCB3aWxsIGJlIHRyaWdnZXJlZCB2ZXJ5IGZyZXF1ZW50bHlcbiAgICBtb3VzZW1vdmUgICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgZmFsc2VdLFxuXG4gICAgbW91c2VvdXQgICAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgIG1vdXNlb3ZlciAgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICBtb3VzZXVwICAgICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgcmVzaXplICAgICAgICAgICAgICAgICAgICAgICAgIDogW1VJRXZlbnQsIGZhbHNlXSxcblxuICAgIC8vIG1pZ2h0IGJ1YmJsZVxuICAgIHNjcm9sbCAgICAgICAgICAgICAgICAgICAgICAgICA6IFtVSUV2ZW50LCBmYWxzZV0sXG4gICAgXG4gICAgc2VsZWN0ICAgICAgICAgICAgICAgICAgICAgICAgIDogW0V2ZW50LCB0cnVlXSxcbiAgICB1bmxvYWQgICAgICAgICAgICAgICAgICAgICAgICAgOiBbRXZlbnQsIGZhbHNlXSxcbiAgICB3aGVlbCAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbV2hlZWxFdmVudCwgdHJ1ZV0sXG5cbiAgICAvLyBUb3VjaCBFdmVudHMgRXh0ZW5zaW9uIChodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMtZXh0ZW5zaW9ucy8pXG4gICAgdG91Y2hjYW5jZWwgICAgICAgICAgICAgICAgICAgIDogW1RvdWNoRXZlbnQsIHRydWVdLFxuICAgIHRvdWNoZW5kICAgICAgICAgICAgICAgICAgICAgICA6IFtUb3VjaEV2ZW50LCB0cnVlXSxcbiAgICB0b3VjaG1vdmUgICAgICAgICAgICAgICAgICAgICAgOiBbVG91Y2hFdmVudCwgdHJ1ZV0sXG4gICAgdG91Y2hzdGFydCAgICAgICAgICAgICAgICAgICAgIDogW1RvdWNoRXZlbnQsIHRydWVdXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TWFwO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuZnVuY3Rpb24gRm9jdXNFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgRm9jdXNFdmVudEluaXQgZm9jdXNFdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgRm9jdXNFdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgRXZlbnRUYXJnZXQ/IHJlbGF0ZWRUYXJnZXQ7XG4gICAgLy8gfTtcblxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG59XG5cbkZvY3VzRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVSUV2ZW50LnByb3RvdHlwZSk7XG5Gb2N1c0V2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZvY3VzRXZlbnQ7XG5cbkZvY3VzRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnRm9jdXNFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvY3VzRXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVUlFdmVudCA9IHJlcXVpcmUoJy4vVUlFdmVudCcpO1xuXG5mdW5jdGlvbiBJbnB1dEV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBJbnB1dEV2ZW50SW5pdCBpbnB1dEV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBJbnB1dEV2ZW50IDogVUlFdmVudCB7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgaW5wdXRUeXBlO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgRE9NU3RyaW5nIGRhdGE7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgaXNDb21wb3Npbmc7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBSYW5nZSAgICAgdGFyZ2V0UmFuZ2U7XG4gICAgLy8gfTtcblxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG4gICAgdGhpcy5pbnB1dFR5cGUgPSBldi5pbnB1dFR5cGU7XG4gICAgdGhpcy5kYXRhID0gZXYuZGF0YTtcbiAgICB0aGlzLmlzQ29tcG9zaW5nID0gZXYuaXNDb21wb3Npbmc7XG4gICAgdGhpcy50YXJnZXRSYW5nZSA9IGV2LnRhcmdldFJhbmdlO1xufVxuXG5JbnB1dEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuSW5wdXRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnB1dEV2ZW50O1xuXG5JbnB1dEV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gJ0lucHV0RXZlbnQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEV2ZW50O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuZnVuY3Rpb24gS2V5Ym9hcmRFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgS2V5Ym9hcmRFdmVudEluaXQga2V5Ym9hcmRFdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICAvLyBLZXlMb2NhdGlvbkNvZGVcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX1NUQU5EQVJEID0gMHgwMDtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX0xFRlQgPSAweDAxO1xuICAgIC8vICAgICBjb25zdCB1bnNpZ25lZCBsb25nIERPTV9LRVlfTE9DQVRJT05fUklHSFQgPSAweDAyO1xuICAgIC8vICAgICBjb25zdCB1bnNpZ25lZCBsb25nIERPTV9LRVlfTE9DQVRJT05fTlVNUEFEID0gMHgwMztcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIERPTVN0cmluZyAgICAga2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgRE9NU3RyaW5nICAgICBjb2RlO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsb2NhdGlvbjtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgY3RybEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgc2hpZnRLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIGFsdEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgbWV0YUtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgcmVwZWF0O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgICAgICBpc0NvbXBvc2luZztcbiAgICAvLyAgICAgYm9vbGVhbiBnZXRNb2RpZmllclN0YXRlIChET01TdHJpbmcga2V5QXJnKTtcbiAgICAvLyB9O1xuICAgIFxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG4gICAgdGhpcy5ET01fS0VZX0xPQ0FUSU9OX1NUQU5EQVJEID0gMHgwMDtcbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fTEVGVCA9IDB4MDE7XG4gICAgdGhpcy5ET01fS0VZX0xPQ0FUSU9OX1JJR0hUID0gMHgwMjtcbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fTlVNUEFEID0gMHgwMztcbiAgICB0aGlzLmtleSA9IGV2LmtleTtcbiAgICB0aGlzLmNvZGUgPSBldi5jb2RlO1xuICAgIHRoaXMubG9jYXRpb24gPSBldi5sb2NhdGlvbjtcbiAgICB0aGlzLmN0cmxLZXkgPSBldi5jdHJsS2V5O1xuICAgIHRoaXMuc2hpZnRLZXkgPSBldi5zaGlmdEtleTtcbiAgICB0aGlzLmFsdEtleSA9IGV2LmFsdEtleTtcbiAgICB0aGlzLm1ldGFLZXkgPSBldi5tZXRhS2V5O1xuICAgIHRoaXMucmVwZWF0ID0gZXYucmVwZWF0O1xuICAgIHRoaXMuaXNDb21wb3NpbmcgPSBldi5pc0NvbXBvc2luZztcbiAgICB0aGlzLmtleUFyZyA9IGV2LmtleUFyZztcbn1cblxuS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlKTtcbktleWJvYXJkRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5Ym9hcmRFdmVudDtcblxuS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdLZXlib2FyZEV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmRFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuIFxuLypqc2hpbnQgLVcwNzkgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVUlFdmVudCA9IHJlcXVpcmUoJy4vVUlFdmVudCcpO1xuXG5mdW5jdGlvbiBNb3VzZUV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBNb3VzZUV2ZW50SW5pdCBtb3VzZUV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBNb3VzZUV2ZW50IDogVUlFdmVudCB7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBsb25nICAgICAgICAgICBzY3JlZW5YO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICAgICAgICAgc2NyZWVuWTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgICAgIGNsaWVudFg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBsb25nICAgICAgICAgICBjbGllbnRZO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgICAgICAgY3RybEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIHNoaWZ0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgICAgICAgYWx0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgICAgICAgbWV0YUtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIHNob3J0ICAgICAgICAgIGJ1dHRvbjtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIEV2ZW50VGFyZ2V0PyAgIHJlbGF0ZWRUYXJnZXQ7XG4gICAgLy8gICAgIC8vIEludHJvZHVjZWQgaW4gdGhpcyBzcGVjaWZpY2F0aW9uXG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSB1bnNpZ25lZCBzaG9ydCBidXR0b25zO1xuICAgIC8vICAgICBib29sZWFuIGdldE1vZGlmaWVyU3RhdGUgKERPTVN0cmluZyBrZXlBcmcpO1xuICAgIC8vIH07XG5cbiAgICBVSUV2ZW50LmNhbGwodGhpcywgZXYpO1xuICAgIHRoaXMuc2NyZWVuWCA9IGV2LnNjcmVlblg7XG4gICAgdGhpcy5zY3JlZW5ZID0gZXYuc2NyZWVuWTtcbiAgICB0aGlzLmNsaWVudFggPSBldi5jbGllbnRYO1xuICAgIHRoaXMuY2xpZW50WSA9IGV2LmNsaWVudFk7XG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZXYuc2hpZnRLZXk7XG4gICAgdGhpcy5hbHRLZXkgPSBldi5hbHRLZXk7XG4gICAgdGhpcy5tZXRhS2V5ID0gZXYubWV0YUtleTtcbiAgICB0aGlzLmJ1dHRvbiA9IGV2LmJ1dHRvbjtcbiAgICB0aGlzLmJ1dHRvbnMgPSBldi5idXR0b25zO1xuXG4gICAgdGhpcy5wYWdlWCA9IGV2LnBhZ2VYO1xuICAgIHRoaXMucGFnZVkgPSBldi5wYWdlWTtcbiAgICB0aGlzLnggPSBldi54O1xuICAgIHRoaXMueSA9IGV2Lnk7XG4gICAgdGhpcy5vZmZzZXRYID0gZXYub2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBldi5vZmZzZXRZO1xufVxuXG5Nb3VzZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuTW91c2VFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3VzZUV2ZW50O1xuXG5Nb3VzZUV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gJ01vdXNlRXZlbnQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUV2ZW50O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxudmFyIEVNUFRZX0FSUkFZID0gW107XG5cbmZ1bmN0aW9uIFRvdWNoKHRvdWNoKSB7XG4gICAgLy8gaW50ZXJmYWNlIFRvdWNoIHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgIGlkZW50aWZpZXI7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldCB0YXJnZXQ7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBzY3JlZW5YO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgc2NyZWVuWTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgIGNsaWVudFg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBjbGllbnRZO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgcGFnZVg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBwYWdlWTtcbiAgICAvLyB9O1xuICAgIFxuICAgIHRoaXMuaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgdGhpcy5zY3JlZW5YID0gdG91Y2guc2NyZWVuWDtcbiAgICB0aGlzLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZO1xuICAgIHRoaXMuY2xpZW50WCA9IHRvdWNoLmNsaWVudFg7XG4gICAgdGhpcy5jbGllbnRZID0gdG91Y2guY2xpZW50WTtcbiAgICB0aGlzLnBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgdGhpcy5wYWdlWSA9IHRvdWNoLnBhZ2VZO1xufVxuXG5mdW5jdGlvbiBjbG9uZVRvdWNoTGlzdCh0b3VjaExpc3QpIHtcbiAgICBpZiAoIXRvdWNoTGlzdCkgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgIC8vIGludGVyZmFjZSBUb3VjaExpc3Qge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsZW5ndGg7XG4gICAgLy8gICAgIGdldHRlciBUb3VjaD8gaXRlbSAodW5zaWduZWQgbG9uZyBpbmRleCk7XG4gICAgLy8gfTtcbiAgICBcbiAgICB2YXIgdG91Y2hMaXN0QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3VjaExpc3RBcnJheVtpXSA9IG5ldyBUb3VjaCh0b3VjaExpc3RbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdG91Y2hMaXN0QXJyYXk7XG59XG5cbmZ1bmN0aW9uIFRvdWNoRXZlbnQoZXYpIHtcbiAgICAvLyBpbnRlcmZhY2UgVG91Y2hFdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgVG91Y2hMaXN0IHRvdWNoZXM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBUb3VjaExpc3QgdGFyZ2V0VG91Y2hlcztcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIFRvdWNoTGlzdCBjaGFuZ2VkVG91Y2hlcztcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICBhbHRLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgbWV0YUtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICBjdHJsS2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgIHNoaWZ0S2V5O1xuICAgIC8vIH07XG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcbiAgICB0aGlzLnRvdWNoZXMgPSBjbG9uZVRvdWNoTGlzdChldi50b3VjaGVzKTtcbiAgICB0aGlzLnRhcmdldFRvdWNoZXMgPSBjbG9uZVRvdWNoTGlzdChldi50YXJnZXRUb3VjaGVzKTtcbiAgICB0aGlzLmNoYW5nZWRUb3VjaGVzID0gY2xvbmVUb3VjaExpc3QoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICAgIHRoaXMuYWx0S2V5ID0gZXYuYWx0S2V5O1xuICAgIHRoaXMubWV0YUtleSA9IGV2Lm1ldGFLZXk7XG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZXYuc2hpZnRLZXk7XG59XG5cblRvdWNoRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVSUV2ZW50LnByb3RvdHlwZSk7XG5Ub3VjaEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvdWNoRXZlbnQ7XG5cblRvdWNoRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnVG91Y2hFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvdWNoRXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbiBcbi8qanNoaW50IC1XMDc5ICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xuXG5mdW5jdGlvbiBVSUV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlLCBvcHRpb25hbCBVSUV2ZW50SW5pdCBldmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgVUlFdmVudCA6IEV2ZW50IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIFdpbmRvdz8gdmlldztcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgZGV0YWlsO1xuICAgIC8vIH07XG5cbiAgICBFdmVudC5jYWxsKHRoaXMsIGV2KTtcbiAgICB0aGlzLmRldGFpbCA9IGV2LmRldGFpbDtcbn1cblxuVUlFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XG5VSUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVJRXZlbnQ7XG5cblVJRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnVUlFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVJRXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2hpbnQgLVcwNzkgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vTW91c2VFdmVudCcpO1xuXG5mdW5jdGlvbiBXaGVlbEV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBXaGVlbEV2ZW50SW5pdCB3aGVlbEV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBXaGVlbEV2ZW50IDogTW91c2VFdmVudCB7XG4gICAgLy8gICAgIC8vIERlbHRhTW9kZUNvZGVcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fREVMVEFfUElYRUwgPSAweDAwO1xuICAgIC8vICAgICBjb25zdCB1bnNpZ25lZCBsb25nIERPTV9ERUxUQV9MSU5FID0gMHgwMTtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fREVMVEFfUEFHRSA9IDB4MDI7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICAgIGRlbHRhWDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgICAgZGVsdGFZO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgICBkZWx0YVo7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSB1bnNpZ25lZCBsb25nIGRlbHRhTW9kZTtcbiAgICAvLyB9O1xuXG4gICAgTW91c2VFdmVudC5jYWxsKHRoaXMsIGV2KTtcbiAgICB0aGlzLkRPTV9ERUxUQV9QSVhFTCA9IDB4MDA7XG4gICAgdGhpcy5ET01fREVMVEFfTElORSA9IDB4MDE7XG4gICAgdGhpcy5ET01fREVMVEFfUEFHRSA9IDB4MDI7XG4gICAgdGhpcy5kZWx0YVggPSBldi5kZWx0YVg7XG4gICAgdGhpcy5kZWx0YVkgPSBldi5kZWx0YVk7XG4gICAgdGhpcy5kZWx0YVogPSBldi5kZWx0YVo7XG4gICAgdGhpcy5kZWx0YU1vZGUgPSBldi5kZWx0YU1vZGU7XG59XG5cbldoZWVsRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb3VzZUV2ZW50LnByb3RvdHlwZSk7XG5XaGVlbEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdoZWVsRXZlbnQ7XG5cbldoZWVsRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnV2hlZWxFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdoZWVsRXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDb21wb3NpdGlvbkV2ZW50OiByZXF1aXJlKCcuL0NvbXBvc2l0aW9uRXZlbnQnKSxcbiAgICBFdmVudDogcmVxdWlyZSgnLi9FdmVudCcpLFxuICAgIEV2ZW50TWFwOiByZXF1aXJlKCcuL0V2ZW50TWFwJyksXG4gICAgRm9jdXNFdmVudDogcmVxdWlyZSgnLi9Gb2N1c0V2ZW50JyksXG4gICAgSW5wdXRFdmVudDogcmVxdWlyZSgnLi9JbnB1dEV2ZW50JyksXG4gICAgS2V5Ym9hcmRFdmVudDogcmVxdWlyZSgnLi9LZXlib2FyZEV2ZW50JyksXG4gICAgTW91c2VFdmVudDogcmVxdWlyZSgnLi9Nb3VzZUV2ZW50JyksXG4gICAgVG91Y2hFdmVudDogcmVxdWlyZSgnLi9Ub3VjaEV2ZW50JyksXG4gICAgVUlFdmVudDogcmVxdWlyZSgnLi9VSUV2ZW50JyksXG4gICAgV2hlZWxFdmVudDogcmVxdWlyZSgnLi9XaGVlbEV2ZW50Jylcbn07XG5cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIERPTVJlbmRlcmVyOiByZXF1aXJlKCcuL0RPTVJlbmRlcmVyJyksXG4gICAgRWxlbWVudENhY2hlOiByZXF1aXJlKCcuL0VsZW1lbnRDYWNoZScpLFxuICAgIEV2ZW50czogcmVxdWlyZSgnLi9ldmVudHMnKSxcbiAgICBNYXRoOiByZXF1aXJlKCcuL01hdGgnKVxufTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3cgPSByZXF1aXJlKCcuL25vdycpO1xuXG4vKipcbiAqIEVuZ2luZSBjbGFzcyB1c2VkIGZvciB1cGRhdGluZyBvYmplY3RzIG9uIGEgZnJhbWUtYnktZnJhbWUuIFN5bmNocm9uaXplcyB0aGVcbiAqIGB1cGRhdGVgIG1ldGhvZCBpbnZvY2F0aW9ucyB0byB0aGUgcmVmcmVzaCByYXRlIG9mIHRoZSBzY3JlZW4uXG4gKiBEb2VzIG5vdCBub3JtYWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbiB0aW1lc3RhbXAgd2hlbiBiZWluZyBjb25zZWN1dGl2ZWx5XG4gKiBzdGFydGVkIGFuZCBzdG9wcGVkLlxuICogXG4gKiBAY2xhc3MgQ29udGFpbmVyRW5naW5lXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29udGFpbmVyRW5naW5lKCkge1xuICAgIHRoaXMuX3VwZGF0ZXMgPSBbXTtcbiAgICB0aGlzLl9zdG9wcGVkQXQgPSBub3coKTtcbiAgICB0aGlzLl9zbGVlcCA9IDA7XG5cbiAgICB0aGlzLnN0YXJ0KCk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgX3RoaXMuX29uV2luZG93TWVzc2FnZShldik7XG4gICAgfSk7XG59XG5cbkNvbnRhaW5lckVuZ2luZS5wcm90b3R5cGUuX29uV2luZG93TWVzc2FnZSA9IGZ1bmN0aW9uIF9vbldpbmRvd01lc3NhZ2UoZXYpIHtcbiAgICBpZiAoXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgJiZcbiAgICAgICAgZXYuZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgJiZcbiAgICAgICAgZXYuZGF0YVswXSA9PT0gJ0ZSQU1FJ1xuICAgICkge1xuICAgICAgICB0aGlzLnN0ZXAoZXYuZGF0YVsxXSAtIHRoaXMuX3NsZWVwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0aGUgQ29udGFpbmVyRW5naW5lLlxuICpcbiAqIEBtZXRob2Qgc3RhcnRcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHJldHVybiB7Q29udGFpbmVyRW5naW5lfSB0aGlzXG4gKi9cbkNvbnRhaW5lckVuZ2luZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9zbGVlcCArPSBub3coKSAtIHRoaXMuX3N0b3BwZWRBdDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RvcHMgdGhlIENvbnRhaW5lckVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kIHN0b3BcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHJldHVybiB7Q29udGFpbmVyRW5naW5lfSB0aGlzXG4gKi9cbkNvbnRhaW5lckVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3BwZWRBdCA9IG5vdygpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIENvbnRhaW5lckVuZ2luZSBpcyBjdXJyZW50bHkgcnVubmluZyBvciBub3QuXG4gKlxuICogQG1ldGhvZCBpc1J1bm5pbmdcbiAqIFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIENvbnRhaW5lckVuZ2luZSBpc1xuICogICAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5IHJ1bm5pbmcgb3Igbm90XG4gKi9cbkNvbnRhaW5lckVuZ2luZS5wcm90b3R5cGUuaXNSdW5uaW5nID0gZnVuY3Rpb24gaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9ydW5uaW5nO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIGFsbCByZWdpc3RlcmVkIG9iamVjdHMuXG4gKlxuICogQG1ldGhvZCBzdGVwXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqIEByZXR1cm4ge0NvbnRhaW5lckVuZ2luZX0gICAgICB0aGlzXG4gKi9cbkNvbnRhaW5lckVuZ2luZS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIHN0ZXAgKHRpbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdXBkYXRlcy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXNbaV0udXBkYXRlKHRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJlcyBhbiB1cGRhdGVhYmxlIG9iamVjdCB3aGljaCBgdXBkYXRlYCBtZXRob2Qgc2hvdWxkIGJlIGludm9rZWQgb25cbiAqIGV2ZXJ5IHBhaW50LCBzdGFydGluZyBvbiB0aGUgbmV4dCBwYWludCAoYXNzdW1pbmcgdGhlIENvbnRhaW5lckVuZ2luZSBpcyBydW5uaW5nKS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtPYmplY3R9IHVwZGF0ZWFibGUgICAgICAgICAgb2JqZWN0IHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSB1cGRhdGVhYmxlLnVwZGF0ZSB1cGRhdGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQgb2JqZWN0XG4gKiBAcmV0dXJuIHtDb250YWluZXJFbmdpbmV9ICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICovXG5Db250YWluZXJFbmdpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh1cGRhdGVhYmxlKSB7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZXMuaW5kZXhPZih1cGRhdGVhYmxlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5wdXNoKHVwZGF0ZWFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVyZWdpc3RlcnMgYW4gdXBkYXRlYWJsZSBvYmplY3QgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nIGB1cGRhdGVgIHRvIGJlXG4gKiBubyBsb25nZXIgdXBkYXRlZC5cbiAqXG4gKiBAbWV0aG9kIG5vTG9uZ2VyVXBkYXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge09iamVjdH0gdXBkYXRlYWJsZSAgICAgICAgICB1cGRhdGVhYmxlIG9iamVjdCBwcmV2aW91c2x5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZCB1c2luZyBgdXBkYXRlYFxuICogQHJldHVybiB7Q29udGFpbmVyRW5naW5lfSAgICAgICAgICAgICAgICAgICAgIHRoaXNcbiAqL1xuQ29udGFpbmVyRW5naW5lLnByb3RvdHlwZS5ub0xvbmdlclVwZGF0ZSA9IGZ1bmN0aW9uIG5vTG9uZ2VyVXBkYXRlKHVwZGF0ZWFibGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl91cGRhdGVzLmluZGV4T2YodXBkYXRlYWJsZSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyRW5naW5lO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBvbHlmaWxscyA9IHJlcXVpcmUoJy4uL3BvbHlmaWxscycpO1xudmFyIHJBRiA9IHBvbHlmaWxscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgY0FGID0gcG9seWZpbGxzLmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4vKipcbiAqIEJvb2xlYW4gY29uc3RhbnQgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBFbmdpbmUgaGFzIGFjY2VzcyB0byB0aGUgZG9jdW1lbnQuXG4gKiBUaGUgZG9jdW1lbnQgaXMgYmVpbmcgdXNlZCBpbiBvcmRlciB0byBzdWJzY3JpYmUgZm9yIHZpc2liaWxpdHljaGFuZ2UgZXZlbnRzXG4gKiB1c2VkIGZvciBub3JtYWxpemluZyB0aGUgRW5naW5lIHRpbWUgd2hlbiBlLmcuIHdoZW4gc3dpdGNoaW5nIHRhYnMuXG4gKiBcbiAqIEBjb25zdGFudFxuICogQHR5cGUge0Jvb2xlYW59XG4gKi8gXG52YXIgRE9DVU1FTlRfQUNDRVNTID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuaWYgKERPQ1VNRU5UX0FDQ0VTUykge1xuICAgIHZhciBWRU5ET1JfSElEREVOLCBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0U7XG5cbiAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBWRU5ET1JfSElEREVOID0gJ2hpZGRlbic7XG4gICAgICAgIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICdtb3pIaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICdtc0hpZGRlbic7XG4gICAgICAgIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBWRU5ET1JfSElEREVOID0gJ3dlYmtpdEhpZGRlbic7XG4gICAgICAgIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICB9XG59XG5cbi8qKlxuICogRW5naW5lIGNsYXNzIHVzZWQgZm9yIHVwZGF0aW5nIG9iamVjdHMgb24gYSBmcmFtZS1ieS1mcmFtZS4gU3luY2hyb25pemVzIHRoZVxuICogYHVwZGF0ZWAgbWV0aG9kIGludm9jYXRpb25zIHRvIHRoZSByZWZyZXNoIHJhdGUgb2YgdGhlIHNjcmVlbi4gTWFuYWdlc1xuICogdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLWxvb3AgYnkgbm9ybWFsaXppbmcgdGhlIHBhc3NlZCBpbiB0aW1lc3RhbXBcbiAqIHdoZW4gc3dpdGNoaW5nIHRhYnMuXG4gKiBcbiAqIEBjbGFzcyBFbmdpbmVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFbmdpbmUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBcbiAgICAvLyBSZWZlcmVuY2VzIHRvIG9iamVjdHMgdG8gYmUgdXBkYXRlZCBvbiBuZXh0IGZyYW1lLlxuICAgIHRoaXMuX3VwZGF0ZXMgPSBbXTtcbiAgICBcbiAgICB0aGlzLl9sb29wZXIgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIF90aGlzLmxvb3AodGltZSk7XG4gICAgfTtcbiAgICB0aGlzLl90aW1lID0gMDtcbiAgICB0aGlzLl9zdG9wcGVkQXQgPSAwO1xuICAgIHRoaXMuX3NsZWVwID0gMDtcbiAgICBcbiAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBiZSByZXN0YXJ0ZWQgd2hlbiB0aGUgdGFiLyB3aW5kb3cgaXNcbiAgICAvLyBiZWluZyBmb2N1c2VkIGFnYWluICh2aXNpYmlsaXR5IGNoYW5nZSkuXG4gICAgdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UgPSB0cnVlO1xuICAgIFxuICAgIC8vIHJlcXVlc3RJZCBhcyByZXR1cm5lZCBieSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnVuY3Rpb247XG4gICAgdGhpcy5fckFGID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLl9zbGVlcERpZmYgPSB0cnVlO1xuICAgIFxuICAgIC8vIFRoZSBlbmdpbmUgaXMgYmVpbmcgc3RhcnRlZCBvbiBpbnN0YW50aWF0aW9uLlxuICAgIC8vIFRPRE8oYWxleGFuZGVyR3VnZWwpXG4gICAgdGhpcy5zdGFydCgpO1xuXG4gICAgLy8gVGhlIEVuZ2luZSBzdXBwb3J0cyBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgKGUuZy4gV29ya2VyKS5cbiAgICBpZiAoRE9DVU1FTlRfQUNDRVNTKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5FbmdpbmUucHJvdG90eXBlLl9vblZpc2liaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiBfb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIGlmIChkb2N1bWVudFtWRU5ET1JfSElEREVOXSkge1xuICAgICAgICB0aGlzLl9vblVuZm9jdXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX29uRm9jdXMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFzIHNvb24gYXMgdGhlIHdpbmRvdy8gdGFiIGlzIGJlaW5nXG4gKiBmb2N1c2VkIGFmdGVyIGEgdmlzaWJpbHRpeSBjaGFuZ2UuXG4gKiBcbiAqIEBtZXRob2QgIF9vbkZvY3VzXG4gKiBAcHJpdmF0ZVxuICovIFxuRW5naW5lLnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uIF9vbkZvY3VzKCkge1xuICAgIGlmICh0aGlzLl9zdGFydE9uVmlzaWJpbGl0eUNoYW5nZSkge1xuICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYXMgc29vbiBhcyB0aGUgd2luZG93LyB0YWIgaXMgYmVpbmdcbiAqIHVuZm9jdXNlZCAoaGlkZGVuKSBhZnRlciBhIHZpc2liaWx0aXkgY2hhbmdlLlxuICogXG4gKiBAbWV0aG9kICBfb25Gb2N1c1xuICogQHByaXZhdGVcbiAqLyBcbkVuZ2luZS5wcm90b3R5cGUuX29uVW5mb2N1cyA9IGZ1bmN0aW9uIF9vblVuZm9jdXMoKSB7XG4gICAgdGhpcy5fc3RvcCgpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdGhlIEVuZ2luZS4gV2hlbiBzd2l0Y2hpbmcgdG8gYSBkaWZmZXJudCB0YWIvIHdpbmRvdyAoY2hhbmdpbmcgdGhlXG4gKiB2aXNpYmlsdGl5KSwgdGhlIGVuZ2luZSB3aWxsIGJlIHJldGFydGVkIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gYSB2aXNpYmxlXG4gKiBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIHN0YXJ0XG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEByZXR1cm4ge0VuZ2luZX0gdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludGVybmFsIHZlcnNpb24gb2Yge0BsaW5rIEVuZ2luZSNzdGFydH0sIG5vdCBhZmZlY3RpbmcgYmVoYXZpb3Igb24gdmlzaWJpbHR5XG4gKiBjaGFuZ2UuXG4gKiBcbiAqIEBtZXRob2QgIF9zdGFydFxuICogQHByaXZhdGVcbiAqLyBcbkVuZ2luZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gX3N0YXJ0KCkge1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3NsZWVwRGlmZiA9IHRydWU7XG4gICAgdGhpcy5fckFGID0gckFGKHRoaXMuX2xvb3Blcik7XG59O1xuXG4vKipcbiAqIFN0b3BzIHRoZSBFbmdpbmUuXG4gKlxuICogQG1ldGhvZCBzdG9wXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEByZXR1cm4ge0VuZ2luZX0gdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludGVybmFsIHZlcnNpb24gb2Yge0BsaW5rIEVuZ2luZSNzdG9wfSwgbm90IGFmZmVjdGluZyBiZWhhdmlvciBvbiB2aXNpYmlsdHlcbiAqIGNoYW5nZS5cbiAqIFxuICogQG1ldGhvZCAgX3N0b3BcbiAqIEBwcml2YXRlXG4gKi8gXG5FbmdpbmUucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gX3N0b3AoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3BwZWRBdCA9IHRoaXMuX3RpbWU7XG5cbiAgICAvLyBCdWcgaW4gb2xkIHZlcnNpb25zIG9mIEZ4LiBFeHBsaWNpdGx5IGNhbmNlbC5cbiAgICBjQUYodGhpcy5fckFGKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBFbmdpbmUgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3Igbm90LlxuICpcbiAqIEBtZXRob2QgaXNSdW5uaW5nXG4gKiBcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBFbmdpbmUgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseSBydW5uaW5nIG9yIG5vdFxuICovXG5FbmdpbmUucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uIGlzUnVubmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVubmluZztcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzLlxuICpcbiAqIEBtZXRob2Qgc3RlcFxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGVgIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKiBAcmV0dXJuIHtFbmdpbmV9ICAgICAgdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgaWYgKHRoaXMuX3NsZWVwRGlmZikge1xuICAgICAgICB0aGlzLl9zbGVlcCArPSB0aW1lIC0gdGhpcy5fc3RvcHBlZEF0O1xuICAgICAgICB0aGlzLl9zbGVlcERpZmYgPSBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gVGhlIHNhbWUgdGltZXRhbXAgd2lsbCBiZSBlbWl0dGVkIGltbWVkaWF0ZWx5IGJlZm9yZSBhbmQgYWZ0ZXIgdmlzaWJpbGl0eVxuICAgIC8vIGNoYW5nZS5cbiAgICB2YXIgbm9ybWFsaXplZFRpbWUgPSB0aW1lIC0gdGhpcy5fc2xlZXA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3VwZGF0ZXMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICB0aGlzLl91cGRhdGVzW2ldLnVwZGF0ZShub3JtYWxpemVkVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXRob2QgYmVpbmcgY2FsbGVkIGJ5IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIG9uIGV2ZXJ5IHBhaW50LiBJbmRpcmVjdGx5XG4gKiByZWN1cnNpdmUgYnkgc2NoZWR1bGluZyBhIGZ1dHVyZSBpbnZvY2F0aW9uIG9mIGl0c2VsZiBvbiB0aGUgbmV4dCBwYWludC5cbiAqXG4gKiBAbWV0aG9kIGxvb3BcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIGhpZ2ggcmVzb2x1dGlvbiB0aW1zdGFtcCB1c2VkIGZvciBpbnZva2luZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRlYCBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICogQHJldHVybiB7RW5naW5lfSAgICAgIHRoaXNcbiAqL1xuRW5naW5lLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gICAgdGhpcy5zdGVwKHRpbWUpO1xuICAgIHRoaXMuX3JBRiA9IHJBRih0aGlzLl9sb29wZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcmVzIGFuIHVwZGF0ZWFibGUgb2JqZWN0IHdoaWNoIGB1cGRhdGVgIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZCBvblxuICogZXZlcnkgcGFpbnQsIHN0YXJ0aW5nIG9uIHRoZSBuZXh0IHBhaW50IChhc3N1bWluZyB0aGUgRW5naW5lIGlzIHJ1bm5pbmcpLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge09iamVjdH0gdXBkYXRlYWJsZSAgICAgICAgICBvYmplY3QgdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtICB7RnVuY3Rpb259IHVwZGF0ZWFibGUudXBkYXRlIHVwZGF0ZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZCBvYmplY3RcbiAqIEByZXR1cm4ge0VuZ2luZX0gICAgICAgICAgICAgICAgICAgICB0aGlzXG4gKi9cbkVuZ2luZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHVwZGF0ZWFibGUpIHtcbiAgICBpZiAodGhpcy5fdXBkYXRlcy5pbmRleE9mKHVwZGF0ZWFibGUpID09PSAtMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVzLnB1c2godXBkYXRlYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXJlZ2lzdGVycyBhbiB1cGRhdGVhYmxlIG9iamVjdCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdXNpbmcgYHVwZGF0ZWAgdG8gYmVcbiAqIG5vIGxvbmdlciB1cGRhdGVkLlxuICpcbiAqIEBtZXRob2Qgbm9Mb25nZXJVcGRhdGVcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSB1cGRhdGVhYmxlICAgICAgICAgIHVwZGF0ZWFibGUgb2JqZWN0IHByZXZpb3VzbHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlcmVkIHVzaW5nIGB1cGRhdGVgXG4gKiBAcmV0dXJuIHtFbmdpbmV9ICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLm5vTG9uZ2VyVXBkYXRlID0gZnVuY3Rpb24gbm9Mb25nZXJVcGRhdGUodXBkYXRlYWJsZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX3VwZGF0ZXMuaW5kZXhPZih1cGRhdGVhYmxlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmdpbmU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFbmdpbmU6IHJlcXVpcmUoJy4vRW5naW5lJyksXG4gICAgQ29udGFpbmVyRW5naW5lOiByZXF1aXJlKCcuL0NvbnRhaW5lckVuZ2luZScpLFxuICAgIG5vdzogcmVxdWlyZSgnLi9ub3cnKVxufTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBEYXRlLm5vdztcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29tcG9uZW50czogcmVxdWlyZSgnLi9jb21wb25lbnRzJyksXG4gICAgY29yZTogcmVxdWlyZSgnLi9jb3JlJyksXG4gICAgZW5naW5lOiByZXF1aXJlKCcuL2VuZ2luZScpLFxuICAgIGRvbVJlbmRlcmFibGVzOiByZXF1aXJlKCcuL2RvbS1yZW5kZXJhYmxlcycpLFxuICAgIGRvbVJlbmRlcmVyczogcmVxdWlyZSgnLi9kb20tcmVuZGVyZXJzJyksXG4gICAgbWF0aDogcmVxdWlyZSgnLi9tYXRoJyksXG4gICAgcGh5c2ljczogcmVxdWlyZSgnLi9waHlzaWNzJyksXG4gICAgcmVuZGVyZXJzOiByZXF1aXJlKCcuL3JlbmRlcmVycycpLFxuICAgIHRyYW5zaXRpb25zOiByZXF1aXJlKCcuL3RyYW5zaXRpb25zJyksXG4gICAgdXRpbGl0aWVzOiByZXF1aXJlKCcuL3V0aWxpdGllcycpLFxuICAgIHdlYmdsUmVuZGVyYWJsZXM6IHJlcXVpcmUoJy4vd2ViZ2wtcmVuZGVyYWJsZXMnKSxcbiAgICB3ZWJnbFJlbmRlcmVyczogcmVxdWlyZSgnLi93ZWJnbC1yZW5kZXJlcnMnKSxcbiAgICB3ZWJnbEdlb21ldHJpZXM6IHJlcXVpcmUoJy4vd2ViZ2wtZ2VvbWV0cmllcycpLFxuICAgIHdlYmdsTWF0ZXJpYWxzOiByZXF1aXJlKCcuL3dlYmdsLW1hdGVyaWFscycpLFxuICAgIHdlYmdsU2hhZGVyczogcmVxdWlyZSgnLi93ZWJnbC1zaGFkZXJzJyksXG4gICAgcG9seWZpbGxzOiByZXF1aXJlKCcuL3BvbHlmaWxscycpXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIDN4MyBudW1lcmljYWwgbWF0cml4LCByZXByZXNlbnRlZCBhcyBhbiBhcnJheS5cbiAqXG4gKiBAY2xhc3MgTWF0MzNcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IHZhbHVlc1xuICovXG5mdW5jdGlvbiBNYXQzMyh2YWx1ZXMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcyB8fCBbMSwwLDAsMCwxLDAsMCwwLDFdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgdmFsdWVzIGluIHRoZSBNYXQzMyBhcyBhbiBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIGdldFxuICogQHJldHVybiB7TnVtYmVyW119IG1hdHJpeCB2YWx1ZXMgYXMgYXJyYXkgb2Ygcm93cy5cbiAqL1xuTWF0MzMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWVzIG9mIHRoZSBjdXJyZW50IE1hdDMzLlxuICpcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcltdfSB2YWx1ZXMgQXJyYXkgb2YgbmluZSBudW1iZXJzIHRvIHNldCBpbiB0aGUgTWF0MzMuXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBvZiB0aGUgaW5wdXQgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXggVGhlIE1hdDMzIHRvIGNvcHkuXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weShtYXRyaXgpIHtcbiAgICB2YXIgQSA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBCID0gbWF0cml4LnZhbHVlcztcblxuICAgIEFbMF0gPSBCWzBdO1xuICAgIEFbMV0gPSBCWzFdO1xuICAgIEFbMl0gPSBCWzJdO1xuICAgIEFbM10gPSBCWzNdO1xuICAgIEFbNF0gPSBCWzRdO1xuICAgIEFbNV0gPSBCWzVdO1xuICAgIEFbNl0gPSBCWzZdO1xuICAgIEFbN10gPSBCWzddO1xuICAgIEFbOF0gPSBCWzhdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRha2UgdGhpcyBNYXQzMyBhcyBBLCBpbnB1dCB2ZWN0b3IgViBhcyBhIGNvbHVtbiB2ZWN0b3IsIGFuZCByZXR1cm4gTWF0MzMgcHJvZHVjdCAoQSkoVikuXG4gKlxuICogQG1ldGhvZCB2ZWN0b3JNdWx0aXBseVxuICogQHBhcmFtIHtWZWMzfSB2IFZlY3RvciB0byByb3RhdGUuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgaW5wdXQgdmVjdG9yIGFmdGVyIG11bHRpcGxpY2F0aW9uLlxuICovXG5NYXQzMy5wcm90b3R5cGUudmVjdG9yTXVsdGlwbHkgPSBmdW5jdGlvbiB2ZWN0b3JNdWx0aXBseSh2LCBvdXRwdXQpIHtcbiAgICB2YXIgTSA9IHRoaXMudmFsdWVzO1xuICAgIHZhciB2MCA9IHYueDtcbiAgICB2YXIgdjEgPSB2Lnk7XG4gICAgdmFyIHYyID0gdi56O1xuXG4gICAgb3V0cHV0LnggPSBNWzBdKnYwICsgTVsxXSp2MSArIE1bMl0qdjI7XG4gICAgb3V0cHV0LnkgPSBNWzNdKnYwICsgTVs0XSp2MSArIE1bNV0qdjI7XG4gICAgb3V0cHV0LnogPSBNWzZdKnYwICsgTVs3XSp2MSArIE1bOF0qdjI7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgcHJvdmlkZWQgTWF0MzMgd2l0aCB0aGUgY3VycmVudCBNYXQzMy4gIFJlc3VsdCBpcyAodGhpcykgKiAobWF0cml4KS5cbiAqXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXggSW5wdXQgTWF0MzMgdG8gbXVsdGlwbHkgb24gdGhlIHJpZ2h0LlxuICogQGNoYWluYWJsZVxuICovXG5NYXQzMy5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgpIHtcbiAgICB2YXIgQSA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBCID0gbWF0cml4LnZhbHVlcztcblxuICAgIHZhciBBMCA9IEFbMF07XG4gICAgdmFyIEExID0gQVsxXTtcbiAgICB2YXIgQTIgPSBBWzJdO1xuICAgIHZhciBBMyA9IEFbM107XG4gICAgdmFyIEE0ID0gQVs0XTtcbiAgICB2YXIgQTUgPSBBWzVdO1xuICAgIHZhciBBNiA9IEFbNl07XG4gICAgdmFyIEE3ID0gQVs3XTtcbiAgICB2YXIgQTggPSBBWzhdO1xuXG4gICAgdmFyIEIwID0gQlswXTtcbiAgICB2YXIgQjEgPSBCWzFdO1xuICAgIHZhciBCMiA9IEJbMl07XG4gICAgdmFyIEIzID0gQlszXTtcbiAgICB2YXIgQjQgPSBCWzRdO1xuICAgIHZhciBCNSA9IEJbNV07XG4gICAgdmFyIEI2ID0gQls2XTtcbiAgICB2YXIgQjcgPSBCWzddO1xuICAgIHZhciBCOCA9IEJbOF07XG5cbiAgICBBWzBdID0gQTAqQjAgKyBBMSpCMyArIEEyKkI2O1xuICAgIEFbMV0gPSBBMCpCMSArIEExKkI0ICsgQTIqQjc7XG4gICAgQVsyXSA9IEEwKkIyICsgQTEqQjUgKyBBMipCODtcbiAgICBBWzNdID0gQTMqQjAgKyBBNCpCMyArIEE1KkI2O1xuICAgIEFbNF0gPSBBMypCMSArIEE0KkI0ICsgQTUqQjc7XG4gICAgQVs1XSA9IEEzKkIyICsgQTQqQjUgKyBBNSpCODtcbiAgICBBWzZdID0gQTYqQjAgKyBBNypCMyArIEE4KkI2O1xuICAgIEFbN10gPSBBNipCMSArIEE3KkI0ICsgQTgqQjc7XG4gICAgQVs4XSA9IEE2KkIyICsgQTcqQjUgKyBBOCpCODtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIHRyYW5zcG9zZVxuICogQGNoYWluYWJsZVxuICovXG5NYXQzMy5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gdHJhbnNwb3NlKCkge1xuICAgIHZhciBNID0gdGhpcy52YWx1ZXM7XG5cbiAgICB2YXIgTTEgPSBNWzFdO1xuICAgIHZhciBNMiA9IE1bMl07XG4gICAgdmFyIE0zID0gTVszXTtcbiAgICB2YXIgTTUgPSBNWzVdO1xuICAgIHZhciBNNiA9IE1bNl07XG4gICAgdmFyIE03ID0gTVs3XTtcblxuICAgIE1bMV0gPSBNMztcbiAgICBNWzJdID0gTTY7XG4gICAgTVszXSA9IE0xO1xuICAgIE1bNV0gPSBNNztcbiAgICBNWzZdID0gTTI7XG4gICAgTVs3XSA9IE01O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBkZXRlcm1pbmFudCBvZiB0aGUgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBnZXREZXRlcm1pbmFudFxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZGV0ZXJtaW5hbnQuXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5nZXREZXRlcm1pbmFudCA9IGZ1bmN0aW9uIGdldERldGVybWluYW50KCkge1xuICAgIHZhciBNID0gdGhpcy52YWx1ZXM7XG5cbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNCA9IE1bNF07XG4gICAgdmFyIE01ID0gTVs1XTtcbiAgICB2YXIgTTYgPSBNWzZdO1xuICAgIHZhciBNNyA9IE1bN107XG4gICAgdmFyIE04ID0gTVs4XTtcblxuICAgIHZhciBkZXQgPSBNWzBdKihNNCpNOCAtIE01Kk03KSAtXG4gICAgICAgICAgICAgIE1bMV0qKE0zKk04IC0gTTUqTTYpICtcbiAgICAgICAgICAgICAgTVsyXSooTTMqTTcgLSBNNCpNNik7XG5cbiAgICByZXR1cm4gZGV0O1xufTtcblxuLyoqXG4gKiBUaGUgaW52ZXJzZSBvZiB0aGUgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBpbnZlcnNlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24gaW52ZXJzZSgpIHtcbiAgICB2YXIgTSA9IHRoaXMudmFsdWVzO1xuXG4gICAgdmFyIE0wID0gTVswXTtcbiAgICB2YXIgTTEgPSBNWzFdO1xuICAgIHZhciBNMiA9IE1bMl07XG4gICAgdmFyIE0zID0gTVszXTtcbiAgICB2YXIgTTQgPSBNWzRdO1xuICAgIHZhciBNNSA9IE1bNV07XG4gICAgdmFyIE02ID0gTVs2XTtcbiAgICB2YXIgTTcgPSBNWzddO1xuICAgIHZhciBNOCA9IE1bOF07XG5cbiAgICB2YXIgZGV0ID0gTTAqKE00Kk04IC0gTTUqTTcpIC1cbiAgICAgICAgICAgICAgTTEqKE0zKk04IC0gTTUqTTYpICtcbiAgICAgICAgICAgICAgTTIqKE0zKk03IC0gTTQqTTYpO1xuXG4gICAgaWYgKE1hdGguYWJzKGRldCkgPCAxZS00MCkgcmV0dXJuIG51bGw7XG5cbiAgICBkZXQgPSAxIC8gZGV0O1xuXG4gICAgTVswXSA9IChNNCpNOCAtIE01Kk03KSAqIGRldDtcbiAgICBNWzNdID0gKC1NMypNOCArIE01Kk02KSAqIGRldDtcbiAgICBNWzZdID0gKE0zKk03IC0gTTQqTTYpICogZGV0O1xuICAgIE1bMV0gPSAoLU0xKk04ICsgTTIqTTcpICogZGV0O1xuICAgIE1bNF0gPSAoTTAqTTggLSBNMipNNikgKiBkZXQ7XG4gICAgTVs3XSA9ICgtTTAqTTcgKyBNMSpNNikgKiBkZXQ7XG4gICAgTVsyXSA9IChNMSpNNSAtIE0yKk00KSAqIGRldDtcbiAgICBNWzVdID0gKC1NMCpNNSArIE0yKk0zKSAqIGRldDtcbiAgICBNWzhdID0gKE0wKk00IC0gTTEqTTMpICogZGV0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgaW5wdXQgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtNYXQzM30gbSBNYXQzMyB0byBjbG9uZS5cbiAqIEByZXR1cm4ge01hdDMzfSBOZXcgY29weSBvZiB0aGUgb3JpZ2luYWwgTWF0MzMuXG4gKi9cbk1hdDMzLmNsb25lID0gZnVuY3Rpb24gY2xvbmUobSkge1xuICAgIHJldHVybiBuZXcgTWF0MzMobS52YWx1ZXMuc2xpY2UoKSk7XG59O1xuXG4vKipcbiAqIFRoZSBpbnZlcnNlIG9mIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIGludmVyc2VcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeCBNYXQzMyB0byBpbnZlcnQuXG4gKiBAcGFyYW0ge01hdDMzfSBvdXRwdXQgTWF0MzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge01hdDMzfSBUaGUgTWF0MzMgYWZ0ZXIgdGhlIGludmVydC5cbiAqL1xuTWF0MzMuaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UobWF0cml4LCBvdXRwdXQpIHtcbiAgICB2YXIgTSA9IG1hdHJpeC52YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IG91dHB1dC52YWx1ZXM7XG5cbiAgICB2YXIgTTAgPSBNWzBdO1xuICAgIHZhciBNMSA9IE1bMV07XG4gICAgdmFyIE0yID0gTVsyXTtcbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNCA9IE1bNF07XG4gICAgdmFyIE01ID0gTVs1XTtcbiAgICB2YXIgTTYgPSBNWzZdO1xuICAgIHZhciBNNyA9IE1bN107XG4gICAgdmFyIE04ID0gTVs4XTtcblxuICAgIHZhciBkZXQgPSBNMCooTTQqTTggLSBNNSpNNykgLVxuICAgICAgICAgICAgICBNMSooTTMqTTggLSBNNSpNNikgK1xuICAgICAgICAgICAgICBNMiooTTMqTTcgLSBNNCpNNik7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IDFlLTQwKSByZXR1cm4gbnVsbDtcblxuICAgIGRldCA9IDEgLyBkZXQ7XG5cbiAgICByZXN1bHRbMF0gPSAoTTQqTTggLSBNNSpNNykgKiBkZXQ7XG4gICAgcmVzdWx0WzNdID0gKC1NMypNOCArIE01Kk02KSAqIGRldDtcbiAgICByZXN1bHRbNl0gPSAoTTMqTTcgLSBNNCpNNikgKiBkZXQ7XG4gICAgcmVzdWx0WzFdID0gKC1NMSpNOCArIE0yKk03KSAqIGRldDtcbiAgICByZXN1bHRbNF0gPSAoTTAqTTggLSBNMipNNikgKiBkZXQ7XG4gICAgcmVzdWx0WzddID0gKC1NMCpNNyArIE0xKk02KSAqIGRldDtcbiAgICByZXN1bHRbMl0gPSAoTTEqTTUgLSBNMipNNCkgKiBkZXQ7XG4gICAgcmVzdWx0WzVdID0gKC1NMCpNNSArIE0yKk0zKSAqIGRldDtcbiAgICByZXN1bHRbOF0gPSAoTTAqTTQgLSBNMSpNMykgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIHRyYW5zcG9zZVxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4IE1hdDMzIHRvIHRyYW5zcG9zZS5cbiAqIEBwYXJhbSB7TWF0MzN9IG91dHB1dCBNYXQzMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7TWF0MzN9IFRoZSBNYXQzMyBhZnRlciB0aGUgdHJhbnNwb3NlLlxuICovXG5NYXQzMy50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4LCBvdXRwdXQpIHtcbiAgICB2YXIgTSA9IG1hdHJpeC52YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IG91dHB1dC52YWx1ZXM7XG5cbiAgICB2YXIgTTAgPSBNWzBdO1xuICAgIHZhciBNMSA9IE1bMV07XG4gICAgdmFyIE0yID0gTVsyXTtcbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNCA9IE1bNF07XG4gICAgdmFyIE01ID0gTVs1XTtcbiAgICB2YXIgTTYgPSBNWzZdO1xuICAgIHZhciBNNyA9IE1bN107XG4gICAgdmFyIE04ID0gTVs4XTtcblxuICAgIHJlc3VsdFswXSA9IE0wO1xuICAgIHJlc3VsdFsxXSA9IE0zO1xuICAgIHJlc3VsdFsyXSA9IE02O1xuICAgIHJlc3VsdFszXSA9IE0xO1xuICAgIHJlc3VsdFs0XSA9IE00O1xuICAgIHJlc3VsdFs1XSA9IE03O1xuICAgIHJlc3VsdFs2XSA9IE0yO1xuICAgIHJlc3VsdFs3XSA9IE01O1xuICAgIHJlc3VsdFs4XSA9IE04O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBwcm92aWRlZCBNYXQzMydzLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXgxIFRoZSBsZWZ0IE1hdDMzLlxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4MiBUaGUgcmlnaHQgTWF0MzMuXG4gKiBAcGFyYW0ge01hdDMzfSBvdXRwdXQgTWF0MzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge01hdDMzfSBUaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi5cbiAqL1xuTWF0MzMuYWRkID0gZnVuY3Rpb24gYWRkKG1hdHJpeDEsIG1hdHJpeDIsIG91dHB1dCkge1xuICAgIHZhciBBID0gbWF0cml4MS52YWx1ZXM7XG4gICAgdmFyIEIgPSBtYXRyaXgyLnZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gb3V0cHV0LnZhbHVlcztcblxuICAgIHZhciBBMCA9IEFbMF07XG4gICAgdmFyIEExID0gQVsxXTtcbiAgICB2YXIgQTIgPSBBWzJdO1xuICAgIHZhciBBMyA9IEFbM107XG4gICAgdmFyIEE0ID0gQVs0XTtcbiAgICB2YXIgQTUgPSBBWzVdO1xuICAgIHZhciBBNiA9IEFbNl07XG4gICAgdmFyIEE3ID0gQVs3XTtcbiAgICB2YXIgQTggPSBBWzhdO1xuXG4gICAgdmFyIEIwID0gQlswXTtcbiAgICB2YXIgQjEgPSBCWzFdO1xuICAgIHZhciBCMiA9IEJbMl07XG4gICAgdmFyIEIzID0gQlszXTtcbiAgICB2YXIgQjQgPSBCWzRdO1xuICAgIHZhciBCNSA9IEJbNV07XG4gICAgdmFyIEI2ID0gQls2XTtcbiAgICB2YXIgQjcgPSBCWzddO1xuICAgIHZhciBCOCA9IEJbOF07XG5cbiAgICByZXN1bHRbMF0gPSBBMCArIEIwO1xuICAgIHJlc3VsdFsxXSA9IEExICsgQjE7XG4gICAgcmVzdWx0WzJdID0gQTIgKyBCMjtcbiAgICByZXN1bHRbM10gPSBBMyArIEIzO1xuICAgIHJlc3VsdFs0XSA9IEE0ICsgQjQ7XG4gICAgcmVzdWx0WzVdID0gQTUgKyBCNTtcbiAgICByZXN1bHRbNl0gPSBBNiArIEI2O1xuICAgIHJlc3VsdFs3XSA9IEE3ICsgQjc7XG4gICAgcmVzdWx0WzhdID0gQTggKyBCODtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBwcm92aWRlZCBNYXQzMydzLlxuICpcbiAqIEBtZXRob2Qgc3VidHJhY3RcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeDEgVGhlIGxlZnQgTWF0MzMuXG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXgyIFRoZSByaWdodCBNYXQzMy5cbiAqIEBwYXJhbSB7TWF0MzN9IG91dHB1dCBNYXQzMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7TWF0MzN9IFRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxuICovXG5NYXQzMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG1hdHJpeDEsIG1hdHJpeDIsIG91dHB1dCkge1xuICAgIHZhciBBID0gbWF0cml4MS52YWx1ZXM7XG4gICAgdmFyIEIgPSBtYXRyaXgyLnZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gb3V0cHV0LnZhbHVlcztcblxuICAgIHZhciBBMCA9IEFbMF07XG4gICAgdmFyIEExID0gQVsxXTtcbiAgICB2YXIgQTIgPSBBWzJdO1xuICAgIHZhciBBMyA9IEFbM107XG4gICAgdmFyIEE0ID0gQVs0XTtcbiAgICB2YXIgQTUgPSBBWzVdO1xuICAgIHZhciBBNiA9IEFbNl07XG4gICAgdmFyIEE3ID0gQVs3XTtcbiAgICB2YXIgQTggPSBBWzhdO1xuXG4gICAgdmFyIEIwID0gQlswXTtcbiAgICB2YXIgQjEgPSBCWzFdO1xuICAgIHZhciBCMiA9IEJbMl07XG4gICAgdmFyIEIzID0gQlszXTtcbiAgICB2YXIgQjQgPSBCWzRdO1xuICAgIHZhciBCNSA9IEJbNV07XG4gICAgdmFyIEI2ID0gQls2XTtcbiAgICB2YXIgQjcgPSBCWzddO1xuICAgIHZhciBCOCA9IEJbOF07XG5cbiAgICByZXN1bHRbMF0gPSBBMCAtIEIwO1xuICAgIHJlc3VsdFsxXSA9IEExIC0gQjE7XG4gICAgcmVzdWx0WzJdID0gQTIgLSBCMjtcbiAgICByZXN1bHRbM10gPSBBMyAtIEIzO1xuICAgIHJlc3VsdFs0XSA9IEE0IC0gQjQ7XG4gICAgcmVzdWx0WzVdID0gQTUgLSBCNTtcbiAgICByZXN1bHRbNl0gPSBBNiAtIEI2O1xuICAgIHJlc3VsdFs3XSA9IEE3IC0gQjc7XG4gICAgcmVzdWx0WzhdID0gQTggLSBCODtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLyoqXG4gKiBNdWx0aXBseSB0aGUgcHJvdmlkZWQgTWF0MzMgTTIgd2l0aCB0aGlzIE1hdDMzLiAgUmVzdWx0IGlzICh0aGlzKSAqIChNMikuXG4gKlxuICogQG1ldGhvZCBtdWx0aXBseVxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4MSBUaGUgbGVmdCBNYXQzMy5cbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeDIgVGhlIHJpZ2h0IE1hdDMzLlxuICogQHBhcmFtIHtNYXQzM30gb3V0cHV0IE1hdDMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtNYXQzM30gdGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uXG4gKi9cbk1hdDMzLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4MSwgbWF0cml4Miwgb3V0cHV0KSB7XG4gICAgdmFyIEEgPSBtYXRyaXgxLnZhbHVlcztcbiAgICB2YXIgQiA9IG1hdHJpeDIudmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSBvdXRwdXQudmFsdWVzO1xuXG4gICAgdmFyIEEwID0gQVswXTtcbiAgICB2YXIgQTEgPSBBWzFdO1xuICAgIHZhciBBMiA9IEFbMl07XG4gICAgdmFyIEEzID0gQVszXTtcbiAgICB2YXIgQTQgPSBBWzRdO1xuICAgIHZhciBBNSA9IEFbNV07XG4gICAgdmFyIEE2ID0gQVs2XTtcbiAgICB2YXIgQTcgPSBBWzddO1xuICAgIHZhciBBOCA9IEFbOF07XG5cbiAgICB2YXIgQjAgPSBCWzBdO1xuICAgIHZhciBCMSA9IEJbMV07XG4gICAgdmFyIEIyID0gQlsyXTtcbiAgICB2YXIgQjMgPSBCWzNdO1xuICAgIHZhciBCNCA9IEJbNF07XG4gICAgdmFyIEI1ID0gQls1XTtcbiAgICB2YXIgQjYgPSBCWzZdO1xuICAgIHZhciBCNyA9IEJbN107XG4gICAgdmFyIEI4ID0gQls4XTtcblxuICAgIHJlc3VsdFswXSA9IEEwKkIwICsgQTEqQjMgKyBBMipCNjtcbiAgICByZXN1bHRbMV0gPSBBMCpCMSArIEExKkI0ICsgQTIqQjc7XG4gICAgcmVzdWx0WzJdID0gQTAqQjIgKyBBMSpCNSArIEEyKkI4O1xuICAgIHJlc3VsdFszXSA9IEEzKkIwICsgQTQqQjMgKyBBNSpCNjtcbiAgICByZXN1bHRbNF0gPSBBMypCMSArIEE0KkI0ICsgQTUqQjc7XG4gICAgcmVzdWx0WzVdID0gQTMqQjIgKyBBNCpCNSArIEE1KkI4O1xuICAgIHJlc3VsdFs2XSA9IEE2KkIwICsgQTcqQjMgKyBBOCpCNjtcbiAgICByZXN1bHRbN10gPSBBNipCMSArIEE3KkI0ICsgQTgqQjc7XG4gICAgcmVzdWx0WzhdID0gQTYqQjIgKyBBNypCNSArIEE4KkI4O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0MzM7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgYXNpbiA9IE1hdGguYXNpbjtcbnZhciBhY29zID0gTWF0aC5hY29zO1xudmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG4vKipcbiAqIEEgdmVjdG9yLWxpa2Ugb2JqZWN0IHVzZWQgdG8gcmVwcmVzZW50IHJvdGF0aW9ucy4gSWYgdGhldGEgaXMgdGhlIGFuZ2xlIG9mXG4gKiByb3RhdGlvbiwgYW5kICh4JywgeScsIHonKSBpcyBhIG5vcm1hbGl6ZWQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgYXhpcyBvZlxuICogcm90YXRpb24sIHRoZW4gdyA9IGNvcyh0aGV0YS8yKSwgeCA9IHNpbih0aGV0YS8yKSp4JywgeSA9IHNpbih0aGV0YS8yKSp5JyxcbiAqIGFuZCB6ID0gc2luKHRoZXRhLzIpKnonLlxuICpcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgdyBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFF1YXRlcm5pb24odywgeCwgeSwgeikge1xuICAgIHRoaXMudyA9IHcgfHwgMTtcbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICAgIHRoaXMueiA9IHogfHwgMDtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBRdWF0ZXJuaW9uIGJ5IGlucHV0IFF1YXRlcm5pb24gcS5cbiAqIExlZnQtaGFuZGVkIG11bHRpcGxpY2F0aW9uLlxuICpcbiAqIEBtZXRob2QgbXVsdGlwbHlcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBUaGUgUXVhdGVybmlvbiB0byBtdWx0aXBseSBieSBvbiB0aGUgcmlnaHQuXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkocSkge1xuICAgIHZhciB4MSA9IHRoaXMueDtcbiAgICB2YXIgeTEgPSB0aGlzLnk7XG4gICAgdmFyIHoxID0gdGhpcy56O1xuICAgIHZhciB3MSA9IHRoaXMudztcbiAgICB2YXIgeDIgPSBxLng7XG4gICAgdmFyIHkyID0gcS55O1xuICAgIHZhciB6MiA9IHEuejtcbiAgICB2YXIgdzIgPSBxLncgfHwgMDtcblxuICAgIHRoaXMudyA9IHcxICogdzIgLSB4MSAqIHgyIC0geTEgKiB5MiAtIHoxICogejI7XG4gICAgdGhpcy54ID0geDEgKiB3MiArIHgyICogdzEgKyB5MiAqIHoxIC0geTEgKiB6MjtcbiAgICB0aGlzLnkgPSB5MSAqIHcyICsgeTIgKiB3MSArIHgxICogejIgLSB4MiAqIHoxO1xuICAgIHRoaXMueiA9IHoxICogdzIgKyB6MiAqIHcxICsgeDIgKiB5MSAtIHgxICogeTI7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBjdXJyZW50IFF1YXRlcm5pb24gYnkgaW5wdXQgUXVhdGVybmlvbiBxIG9uIHRoZSBsZWZ0LCBpLmUuIHEgKiB0aGlzLlxuICogTGVmdC1oYW5kZWQgbXVsdGlwbGljYXRpb24uXG4gKlxuICogQG1ldGhvZCBsZWZ0TXVsdGlwbHlcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBUaGUgUXVhdGVybmlvbiB0byBtdWx0aXBseSBieSBvbiB0aGUgbGVmdC5cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUubGVmdE11bHRpcGx5ID0gZnVuY3Rpb24gbGVmdE11bHRpcGx5KHEpIHtcbiAgICB2YXIgeDEgPSBxLng7XG4gICAgdmFyIHkxID0gcS55O1xuICAgIHZhciB6MSA9IHEuejtcbiAgICB2YXIgdzEgPSBxLncgfHwgMDtcbiAgICB2YXIgeDIgPSB0aGlzLng7XG4gICAgdmFyIHkyID0gdGhpcy55O1xuICAgIHZhciB6MiA9IHRoaXMuejtcbiAgICB2YXIgdzIgPSB0aGlzLnc7XG5cbiAgICB0aGlzLncgPSB3MSp3MiAtIHgxKngyIC0geTEqeTIgLSB6MSp6MjtcbiAgICB0aGlzLnggPSB4MSp3MiArIHgyKncxICsgeTIqejEgLSB5MSp6MjtcbiAgICB0aGlzLnkgPSB5MSp3MiArIHkyKncxICsgeDEqejIgLSB4Mip6MTtcbiAgICB0aGlzLnogPSB6MSp3MiArIHoyKncxICsgeDIqeTEgLSB4MSp5MjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGN1cnJlbnQgUXVhdGVybmlvbiB0byBpbnB1dCBWZWMzIHYsIGFjY29yZGluZyB0b1xuICogdicgPSB+cSAqIHYgKiBxLlxuICpcbiAqIEBtZXRob2Qgcm90YXRlVmVjdG9yXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHJlZmVyZW5jZSBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM30gVGhlIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGUgVmVjMy5cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUucm90YXRlVmVjdG9yID0gZnVuY3Rpb24gcm90YXRlVmVjdG9yKHYsIG91dHB1dCkge1xuICAgIHZhciBjdyA9IHRoaXMudztcbiAgICB2YXIgY3ggPSAtdGhpcy54O1xuICAgIHZhciBjeSA9IC10aGlzLnk7XG4gICAgdmFyIGN6ID0gLXRoaXMuejtcblxuICAgIHZhciB2eCA9IHYueDtcbiAgICB2YXIgdnkgPSB2Lnk7XG4gICAgdmFyIHZ6ID0gdi56O1xuXG4gICAgdmFyIHR3ID0gLWN4ICogdnggLSBjeSAqIHZ5IC0gY3ogKiB2ejtcbiAgICB2YXIgdHggPSB2eCAqIGN3ICsgdnkgKiBjeiAtIGN5ICogdno7XG4gICAgdmFyIHR5ID0gdnkgKiBjdyArIGN4ICogdnogLSB2eCAqIGN6O1xuICAgIHZhciB0eiA9IHZ6ICogY3cgKyB2eCAqIGN5IC0gY3ggKiB2eTtcblxuICAgIHZhciB3ID0gY3c7XG4gICAgdmFyIHggPSAtY3g7XG4gICAgdmFyIHkgPSAtY3k7XG4gICAgdmFyIHogPSAtY3o7XG5cbiAgICBvdXRwdXQueCA9IHR4ICogdyArIHggKiB0dyArIHkgKiB0eiAtIHR5ICogejtcbiAgICBvdXRwdXQueSA9IHR5ICogdyArIHkgKiB0dyArIHR4ICogeiAtIHggKiB0ejtcbiAgICBvdXRwdXQueiA9IHR6ICogdyArIHogKiB0dyArIHggKiB0eSAtIHR4ICogeTtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBJbnZlcnQgdGhlIGN1cnJlbnQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIGludmVydFxuICogQGNoYWluYWJsZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgdGhpcy53ID0gLXRoaXMudztcbiAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgdGhpcy56ID0gLXRoaXMuejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29uanVnYXRlIHRoZSBjdXJyZW50IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBjb25qdWdhdGVcbiAqIEBjaGFpbmFibGVcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlKCkge1xuICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICB0aGlzLnogPSAtdGhpcy56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsZW5ndGggKG5vcm0pIG9mIHRoZSBjdXJyZW50IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBsZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuICAgIHJldHVybiBzcXJ0KHcgKiB3ICsgeCAqIHggKyB5ICogeSArIHogKiB6KTtcbn07XG5cbi8qKlxuICogQWx0ZXIgdGhlIGN1cnJlbnQgUXVhdGVybmlvbiB0byBiZSBvZiB1bml0IGxlbmd0aDtcbiAqXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQGNoYWluYWJsZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG4gICAgdmFyIGxlbmd0aCA9IHNxcnQodyAqIHcgKyB4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybjtcbiAgICBsZW5ndGggPSAxIC8gbGVuZ3RoO1xuICAgIHRoaXMudyAqPSBsZW5ndGg7XG4gICAgdGhpcy54ICo9IGxlbmd0aDtcbiAgICB0aGlzLnkgKj0gbGVuZ3RoO1xuICAgIHRoaXMueiAqPSBsZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdywgeCwgeSwgeiBjb21wb25lbnRzIG9mIHRoZSBjdXJyZW50IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHcsIHggLHksIHopIHtcbiAgICBpZiAodyAhPSBudWxsKSB0aGlzLncgPSB3O1xuICAgIGlmICh4ICE9IG51bGwpIHRoaXMueCA9IHg7XG4gICAgaWYgKHkgIT0gbnVsbCkgdGhpcy55ID0geTtcbiAgICBpZiAoeiAhPSBudWxsKSB0aGlzLnogPSB6O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb3B5IGlucHV0IFF1YXRlcm5pb24gcSBvbnRvIHRoZSBjdXJyZW50IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgVGhlIHJlZmVyZW5jZSBRdWF0ZXJuaW9uLlxuICogQGNoYWluYWJsZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weShxKSB7XG4gICAgdGhpcy53ID0gcS53O1xuICAgIHRoaXMueCA9IHEueDtcbiAgICB0aGlzLnkgPSBxLnk7XG4gICAgdGhpcy56ID0gcS56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgY3VycmVudCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqIEBjaGFpbmFibGVcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLncgPSAxO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnogPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgZG90IHByb2R1Y3QuIENhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBiZXR3ZWVuXG4gKiB0aGUgdHdvIHJvdGF0aW9ucywgYXNzdW1pbmcgYm90aCBRdWF0ZXJuaW9ucyBhcmUgb2YgdW5pdCBsZW5ndGguXG4gKlxuICogQG1ldGhvZCBkb3RcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBUaGUgb3RoZXIgUXVhdGVybmlvbi5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24gZG90KHEpIHtcbiAgICByZXR1cm4gdGhpcy53ICogcS53ICsgdGhpcy54ICogcS54ICsgdGhpcy55ICogcS55ICsgdGhpcy56ICogcS56O1xufTtcblxuLyoqXG4gKiBTcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24uXG4gKlxuICogQG1ldGhvZCBzbGVycFxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFRoZSBmaW5hbCBvcmllbnRhdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0IFRoZSB0d2VlbiBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHB1dCB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuc2xlcnAgPSBmdW5jdGlvbiBzbGVycChxLCB0LCBvdXRwdXQpIHtcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBxdyA9IHEudztcbiAgICB2YXIgcXggPSBxLng7XG4gICAgdmFyIHF5ID0gcS55O1xuICAgIHZhciBxeiA9IHEuejtcblxuICAgIHZhciBvbWVnYTtcbiAgICB2YXIgY29zb21lZ2E7XG4gICAgdmFyIHNpbm9tZWdhO1xuICAgIHZhciBzY2FsZUZyb207XG4gICAgdmFyIHNjYWxlVG87XG5cbiAgICBjb3NvbWVnYSA9IHcgKiBxdyArIHggKiBxeCArIHkgKiBxeSArIHogKiBxejtcbiAgICBpZiAoKDEuMCAtIGNvc29tZWdhKSA+IDFlLTUpIHtcbiAgICAgICAgb21lZ2EgPSBhY29zKGNvc29tZWdhKTtcbiAgICAgICAgc2lub21lZ2EgPSBzaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZUZyb20gPSBzaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub21lZ2E7XG4gICAgICAgIHNjYWxlVG8gPSBzaW4odCAqIG9tZWdhKSAvIHNpbm9tZWdhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVGcm9tID0gMS4wIC0gdDtcbiAgICAgICAgc2NhbGVUbyA9IHQ7XG4gICAgfVxuXG4gICAgb3V0cHV0LncgPSB3ICogc2NhbGVGcm9tICsgcXcgKiBzY2FsZVRvO1xuICAgIG91dHB1dC54ID0geCAqIHNjYWxlRnJvbSArIHF4ICogc2NhbGVUbztcbiAgICBvdXRwdXQueSA9IHkgKiBzY2FsZUZyb20gKyBxeSAqIHNjYWxlVG87XG4gICAgb3V0cHV0LnogPSB6ICogc2NhbGVGcm9tICsgcXogKiBzY2FsZVRvO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBNYXQzMyBtYXRyaXggY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgdG9NYXRyaXhcbiAqIEByZXR1cm4ge1RyYW5zZm9ybX1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudG9NYXRyaXggPSBmdW5jdGlvbiB0b01hdHJpeChvdXRwdXQpIHtcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciB4eCA9IHgqeDtcbiAgICB2YXIgeXkgPSB5Knk7XG4gICAgdmFyIHp6ID0geip6O1xuICAgIHZhciB4eSA9IHgqeTtcbiAgICB2YXIgeHogPSB4Kno7XG4gICAgdmFyIHl6ID0geSp6O1xuXG4gICAgcmV0dXJuIG91dHB1dC5zZXQoW1xuICAgICAgICAxIC0gMiAqICh5eSArIHp6KSwgMiAqICh4eSAtIHcqeiksIDIgKiAoeHogKyB3KnkpLFxuICAgICAgICAyICogKHh5ICsgdyp6KSwgMSAtIDIgKiAoeHggKyB6eiksIDIgKiAoeXogLSB3KngpLFxuICAgICAgICAyICogKHh6IC0gdyp5KSwgMiAqICh5eiArIHcqeCksIDEgLSAyICogKHh4ICsgeXkpXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIFRoZSByb3RhdGlvbiBhbmdsZXMgYWJvdXQgdGhlIHgsIHksIGFuZCB6IGF4ZXMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAqIGN1cnJlbnQgUXVhdGVybmlvbiwgd2hlbiBhcHBsaWVkIGluIHRoZSBaWVggb3JkZXIuXG4gKlxuICogQG1ldGhvZCB0b0V1bGVyXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHB1dCB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0V1bGVyID0gZnVuY3Rpb24gdG9FdWxlcihvdXRwdXQpIHtcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciB4eCA9IHggKiB4O1xuICAgIHZhciB5eSA9IHkgKiB5O1xuICAgIHZhciB6eiA9IHogKiB6O1xuXG4gICAgdmFyIHR5ID0gMiAqICh4ICogeiArIHkgKiB3KTtcbiAgICB0eSA9IHR5IDwgLTEgPyAtMSA6IHR5ID4gMSA/IDEgOiB0eTtcblxuICAgIG91dHB1dC54ID0gYXRhbjIoMiAqICh4ICogdyAtIHkgKiB6KSwgMSAtIDIgKiAoeHggKyB5eSkpO1xuICAgIG91dHB1dC55ID0gYXNpbih0eSk7XG4gICAgb3V0cHV0LnogPSBhdGFuMigyICogKHogKiB3IC0geCAqIHkpLCAxIC0gMiAqICh5eSArIHp6KSk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBUaGUgUXVhdGVybmlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBFdWxlciBhbmdsZXMgeCwgeSwgYW5kIHosXG4gKiBhcHBsaWVkIGluIHRoZSBaWVggb3JkZXIuXG4gKlxuICogQG1ldGhvZCBmcm9tRXVsZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBhbmdsZSBvZiByb3RhdGlvbiBhYm91dCB0aGUgeCBheGlzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGFib3V0IHRoZSB5IGF4aXMuXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgYW5nbGUgb2Ygcm90YXRpb24gYWJvdXQgdGhlIHogYXhpcy5cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gb3V0cHV0IFF1YXRlcm5pb24gaW4gd2hpY2ggdG8gcHV0IHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBUaGUgZXF1aXZhbGVudCBRdWF0ZXJuaW9uLlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5mcm9tRXVsZXIgPSBmdW5jdGlvbiBmcm9tRXVsZXIoeCwgeSwgeikge1xuICAgIHZhciBoeCA9IHggKiAwLjU7XG4gICAgdmFyIGh5ID0geSAqIDAuNTtcbiAgICB2YXIgaHogPSB6ICogMC41O1xuXG4gICAgdmFyIHN4ID0gc2luKGh4KTtcbiAgICB2YXIgc3kgPSBzaW4oaHkpO1xuICAgIHZhciBzeiA9IHNpbihoeik7XG4gICAgdmFyIGN4ID0gY29zKGh4KTtcbiAgICB2YXIgY3kgPSBjb3MoaHkpO1xuICAgIHZhciBjeiA9IGNvcyhoeik7XG5cbiAgICB0aGlzLncgPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XG4gICAgdGhpcy54ID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xuICAgIHRoaXMueSA9IGN4ICogc3kgKiBjeiAtIHN4ICogY3kgKiBzejtcbiAgICB0aGlzLnogPSBjeCAqIGN5ICogc3ogKyBzeCAqIHN5ICogY3o7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWx0ZXIgdGhlIGN1cnJlbnQgUXVhdGVybmlvbiB0byByZWZsZWN0IGEgcm90YXRpb24gb2YgaW5wdXQgYW5nbGUgYWJvdXRcbiAqIGlucHV0IGF4aXMgdi5cbiAqXG4gKiBAbWV0aG9kIG1ha2VGcm9tQW5nbGVBbmRBeGlzXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uLlxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBheGlzIG9mIHJvdGF0aW9uLlxuICogQGNoYWluYWJsZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5mcm9tQW5nbGVBeGlzID0gZnVuY3Rpb24gZnJvbUFuZ2xlQXhpcyhhbmdsZSwgeCwgeSwgeikge1xuICAgIHZhciBsZW4gPSBzcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICB0aGlzLncgPSAxO1xuICAgICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLnogPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgdmFyIGhhbGZUaGV0YSA9IGFuZ2xlICogMC41O1xuICAgICAgICB2YXIgcyA9IHNpbihoYWxmVGhldGEpO1xuICAgICAgICB0aGlzLncgPSBjb3MoaGFsZlRoZXRhKTtcbiAgICAgICAgdGhpcy54ID0gcyAqIHggKiBsZW47XG4gICAgICAgIHRoaXMueSA9IHMgKiB5ICogbGVuO1xuICAgICAgICB0aGlzLnogPSBzICogeiAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBpbnB1dCBRdWF0ZXJuaW9ucy5cbiAqIExlZnQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtIG11bHRpcGxpY2F0aW9uLlxuICpcbiAqIEBtZXRob2QgbXVsdGlwbHlcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcTEgVGhlIGxlZnQgUXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcTIgVGhlIHJpZ2h0IFF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IG91dHB1dCBRdWF0ZXJuaW9uIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBUaGUgcHJvZHVjdCBvZiBtdWx0aXBsaWNhdGlvbi5cbiAqL1xuUXVhdGVybmlvbi5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KHExLCBxMiwgb3V0cHV0KSB7XG4gICAgdmFyIHcxID0gcTEudyB8fCAwO1xuICAgIHZhciB4MSA9IHExLng7XG4gICAgdmFyIHkxID0gcTEueTtcbiAgICB2YXIgejEgPSBxMS56O1xuXG4gICAgdmFyIHcyID0gcTIudyB8fCAwO1xuICAgIHZhciB4MiA9IHEyLng7XG4gICAgdmFyIHkyID0gcTIueTtcbiAgICB2YXIgejIgPSBxMi56O1xuXG4gICAgb3V0cHV0LncgPSB3MSAqIHcyIC0geDEgKiB4MiAtIHkxICogeTIgLSB6MSAqIHoyO1xuICAgIG91dHB1dC54ID0geDEgKiB3MiArIHgyICogdzEgKyB5MiAqIHoxIC0geTEgKiB6MjtcbiAgICBvdXRwdXQueSA9IHkxICogdzIgKyB5MiAqIHcxICsgeDEgKiB6MiAtIHgyICogejE7XG4gICAgb3V0cHV0LnogPSB6MSAqIHcyICsgejIgKiB3MSArIHgyICogeTEgLSB4MSAqIHkyO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgcXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIG5vcm1hbGl6ZWQgcXVhdGVybmlvbi5cbiAqL1xuUXVhdGVybmlvbi5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUocSwgb3V0cHV0KSB7XG4gICAgdmFyIHcgPSBxLnc7XG4gICAgdmFyIHggPSBxLng7XG4gICAgdmFyIHkgPSBxLnk7XG4gICAgdmFyIHogPSBxLno7XG4gICAgdmFyIGxlbmd0aCA9IHNxcnQodyAqIHcgKyB4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybjtcbiAgICBsZW5ndGggPSAxIC8gbGVuZ3RoO1xuICAgIG91dHB1dC53ICo9IGxlbmd0aDtcbiAgICBvdXRwdXQueCAqPSBsZW5ndGg7XG4gICAgb3V0cHV0LnkgKj0gbGVuZ3RoO1xuICAgIG91dHB1dC56ICo9IGxlbmd0aDtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBUaGUgY29uanVnYXRlIG9mIHRoZSBpbnB1dCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgY29uanVnYXRlXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgVGhlIHJlZmVyZW5jZSBRdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBvdXRwdXQgUXVhdGVybmlvbiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIGNvbmp1Z2F0ZSBRdWF0ZXJuaW9uLlxuICovXG5RdWF0ZXJuaW9uLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZShxLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQudyA9IHEudztcbiAgICBvdXRwdXQueCA9IC1xLng7XG4gICAgb3V0cHV0LnkgPSAtcS55O1xuICAgIG91dHB1dC56ID0gLXEuejtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgaW5wdXQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgdGhlIHJlZmVyZW5jZSBRdWF0ZXJuaW9uLlxuICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIGNsb25lZCBRdWF0ZXJuaW9uLlxuICovXG5RdWF0ZXJuaW9uLmNsb25lID0gZnVuY3Rpb24gY2xvbmUocSkge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbihxLncsIHEueCwgcS55LCBxLnopO1xufTtcblxuLyoqXG4gKiBUaGUgZG90IHByb2R1Y3Qgb2YgdGhlIHR3byBpbnB1dCBRdWF0ZXJuaW9ucy5cbiAqXG4gKiBAbWV0aG9kIGRvdFByb2R1Y3RcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcTEgVGhlIGxlZnQgUXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcTIgVGhlIHJpZ2h0IFF1YXRlcm5pb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgdHdvIFF1YXRlcm5pb25zLlxuICovXG5RdWF0ZXJuaW9uLmRvdCA9IGZ1bmN0aW9uIGRvdChxMSwgcTIpIHtcbiAgICByZXR1cm4gcTEudyAqIHEyLncgKyBxMS54ICogcTIueCArIHExLnkgKiBxMi55ICsgcTEueiAqIHEyLno7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1YXRlcm5pb247XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLyoqXG4gKiBBIHR3by1kaW1lbnNpb25hbCB2ZWN0b3IuXG4gKlxuICogQGNsYXNzIFZlYzJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqL1xudmFyIFZlYzIgPSBmdW5jdGlvbih4LCB5KXtcbiAgICBpZiAoeCBpbnN0YW5jZW9mIEFycmF5IHx8IHggaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgdGhpcy54ID0geFswXSB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB4WzFdIHx8IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiB0aGUgY3VycmVudCBWZWMyLlxuICpcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh4LCB5KSB7XG4gICAgaWYgKHggIT0gbnVsbCkgdGhpcy54ID0geDtcbiAgICBpZiAoeSAhPSBudWxsKSB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGlucHV0IHYgdG8gdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtWZWMyfSB2IFRoZSBWZWMyIHRvIGFkZC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHYpIHtcbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBpbnB1dCB2IGZyb20gdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHN1YnRyYWN0XG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVGhlIFZlYzIgdG8gc3VidHJhY3QuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qodikge1xuICAgIHRoaXMueCAtPSB2Lng7XG4gICAgdGhpcy55IC09IHYueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2NhbGUgdGhlIGN1cnJlbnQgVmVjMiBieSBhIHNjYWxhciBvciBWZWMyLlxuICpcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfFZlYzJ9IHMgVGhlIE51bWJlciBvciB2ZWMyIGJ5IHdoaWNoIHRvIHNjYWxlLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHMpIHtcbiAgICBpZiAocyBpbnN0YW5jZW9mIFZlYzIpIHtcbiAgICAgICAgdGhpcy54ICo9IHMueDtcbiAgICAgICAgdGhpcy55ICo9IHMueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggKj0gcztcbiAgICAgICAgdGhpcy55ICo9IHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgdGhlIFZlYzIgY291bnRlci1jbG9ja3dpc2UgYnkgdGhldGEgYWJvdXQgdGhlIHotYXhpcy5cbiAqXG4gKiBAbWV0aG9kIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhIEFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24odGhldGEpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcblxuICAgIHZhciBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XG4gICAgdmFyIHNpblRoZXRhID0gc2luKHRoZXRhKTtcblxuICAgIHRoaXMueCA9IHggKiBjb3NUaGV0YSAtIHkgKiBzaW5UaGV0YTtcbiAgICB0aGlzLnkgPSB4ICogc2luVGhldGEgKyB5ICogY29zVGhldGE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0IG9mIG9mIHRoZSBjdXJyZW50IFZlYzIgd2l0aCB0aGUgaW5wdXQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtOdW1iZXJ9IHYgVGhlIG90aGVyIFZlYzIuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xufTtcblxuLyoqXG4gKiBUaGUgY3Jvc3MgcHJvZHVjdCBvZiBvZiB0aGUgY3VycmVudCBWZWMyIHdpdGggdGhlIGlucHV0IFZlYzIuXG4gKlxuICogQG1ldGhvZCBjcm9zc1xuICogQHBhcmFtIHtOdW1iZXJ9IHYgVGhlIG90aGVyIFZlYzIuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG59O1xuXG4vKipcbiAqIFByZXNlcnZlIHRoZSBtYWduaXR1ZGUgYnV0IGludmVydCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGludmVydFxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgdGhpcy54ICo9IC0xO1xuICAgIHRoaXMueSAqPSAtMTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiBjb21wb25lbnQtd2lzZSB0byB0aGUgY3VycmVudCBWZWMyLlxuICpcbiAqIEBtZXRob2QgbWFwXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBhcHBseS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgdGhpcy54ID0gZm4odGhpcy54KTtcbiAgICB0aGlzLnkgPSBmbih0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgbWFnbml0dWRlIG9mIHRoZSBjdXJyZW50IFZlYzIuXG4gKlxuICogQG1ldGhvZCBsZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuXG4gICAgcmV0dXJuIHNxcnQoeCAqIHggKyB5ICogeSk7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIGlucHV0IG9udG8gdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VmVjMn0gdiBWZWMyIHRvIGNvcHkuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHYpIHtcbiAgICB0aGlzLnggPSB2Lng7XG4gICAgdGhpcy55ID0gdi55O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgY3VycmVudCBWZWMyLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG1hZ25pdHVkZSBvZiB0aGUgY3VycmVudCBWZWMyIGlzIGV4YWN0bHkgMC5cbiAqXG4gKiBAbWV0aG9kIGlzWmVyb1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuVmVjMi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICAgIGlmICh0aGlzLnggIT09IDAgfHwgdGhpcy55ICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVGhlIGFycmF5IGZvcm0gb2YgdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHRvQXJyYXlcbiAqIEByZXR1cm4ge051bWJlcltdfVxuICovXG5WZWMyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55XTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dCBWZWMyLlxuICpcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVGhlIHJlZmVyZW5jZSBWZWMyLlxuICogQHBhcmFtIHtWZWMyfSBvdXRwdXQgVmVjMiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjMn0gVGhlIG5vcm1hbGl6ZSBWZWMyLlxuICovXG5WZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBvdXRwdXQpIHtcbiAgICB2YXIgeCA9IHYueDtcbiAgICB2YXIgeSA9IHYueTtcblxuICAgIHZhciBsZW5ndGggPSBzcXJ0KHggKiB4ICsgeSAqIHkpIHx8IDE7XG4gICAgbGVuZ3RoID0gMSAvIGxlbmd0aDtcbiAgICBvdXRwdXQueCA9IHYueCAqIGxlbmd0aDtcbiAgICBvdXRwdXQueSA9IHYueSAqIGxlbmd0aDtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSBpbnB1dCBWZWMyLlxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEBwYXJhbSB7VmVjMn0gdiBUaGUgVmVjMiB0byBjbG9uZS5cbiAqIEByZXR1cm4ge1ZlYzJ9IFRoZSBjbG9uZWQgVmVjMi5cbiAqL1xuVmVjMi5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKHYpIHtcbiAgICByZXR1cm4gbmV3IFZlYzIodi54LCB2LnkpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGlucHV0IFZlYzIncy5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtWZWMyfSB2MSBUaGUgbGVmdCBWZWMyLlxuICogQHBhcmFtIHtWZWMyfSB2MiBUaGUgcmlnaHQgVmVjMi5cbiAqIEBwYXJhbSB7VmVjMn0gb3V0cHV0IFZlYzIgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzJ9IFRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLlxuICovXG5WZWMyLmFkZCA9IGZ1bmN0aW9uIGFkZCh2MSwgdjIsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdjEueCArIHYyLng7XG4gICAgb3V0cHV0LnkgPSB2MS55ICsgdjIueTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBzZWNvbmQgVmVjMiBmcm9tIHRoZSBmaXJzdC5cbiAqXG4gKiBAbWV0aG9kIHN1YnRyYWN0XG4gKiBAcGFyYW0ge1ZlYzJ9IHYxIFRoZSBsZWZ0IFZlYzIuXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyIFRoZSByaWdodCBWZWMyLlxuICogQHBhcmFtIHtWZWMyfSBvdXRwdXQgVmVjMiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjMn0gVGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uXG4gKi9cblZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCh2MSwgdjIsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdjEueCAtIHYyLng7XG4gICAgb3V0cHV0LnkgPSB2MS55IC0gdjIueTtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgaW5wdXQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVGhlIHJlZmVyZW5jZSBWZWMyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHMgTnVtYmVyIHRvIHNjYWxlIGJ5LlxuICogQHBhcmFtIHtWZWMyfSBvdXRwdXQgVmVjMiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjMn0gVGhlIHJlc3VsdCBvZiB0aGUgc2NhbGluZy5cbiAqL1xuVmVjMi5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHYsIHMsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdi54ICogcztcbiAgICBvdXRwdXQueSA9IHYueSAqIHM7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSBpbnB1dCBWZWMyJ3MuXG4gKlxuICogQG1ldGhvZCBkb3RcbiAqIEBwYXJhbSB7VmVjMn0gdjEgVGhlIGxlZnQgVmVjMi5cbiAqIEBwYXJhbSB7VmVjMn0gdjIgVGhlIHJpZ2h0IFZlYzIuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkb3QgcHJvZHVjdC5cbiAqL1xuVmVjMi5kb3QgPSBmdW5jdGlvbiBkb3QodjEsIHYyKSB7XG4gICAgcmV0dXJuIHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnk7XG59O1xuXG4vKipcbiAqIFRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSBpbnB1dCBWZWMyJ3MuXG4gKlxuICogQG1ldGhvZCBjcm9zc1xuICogQHBhcmFtIHtOdW1iZXJ9IHYgVGhlIGxlZnQgVmVjMi5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2IFRoZSByaWdodCBWZWMyLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgei1jb21wb25lbnQgb2YgdGhlIGNyb3NzIHByb2R1Y3QuXG4gKi9cblZlYzIuY3Jvc3MgPSBmdW5jdGlvbih2MSx2Mikge1xuICAgIHJldHVybiB2MS54ICogdjIueSAtIHYxLnkgKiB2Mi54O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbi8qKlxuICogQSB0aHJlZS1kaW1lbnNpb25hbCB2ZWN0b3IuXG4gKlxuICogQGNsYXNzIFZlYzNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqL1xudmFyIFZlYzMgPSBmdW5jdGlvbih4ICx5LCB6KXtcbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICAgIHRoaXMueiA9IHogfHwgMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHgsIHksIHopIHtcbiAgICBpZiAoeCAhPSBudWxsKSB0aGlzLnggPSB4O1xuICAgIGlmICh5ICE9IG51bGwpIHRoaXMueSA9IHk7XG4gICAgaWYgKHogIT0gbnVsbCkgdGhpcy56ID0gejtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGlucHV0IHYgdG8gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBWZWMzIHRvIGFkZC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHYpIHtcbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG4gICAgdGhpcy56ICs9IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0aGUgaW5wdXQgdiBmcm9tIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBWZWMzIHRvIHN1YnRyYWN0LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHYpIHtcbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgdGhpcy56IC09IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgdGhlIGN1cnJlbnQgVmVjMyBieSB0aGV0YSBjbG9ja3dpc2UgYWJvdXQgdGhlIHggYXhpcy5cbiAqXG4gKiBAbWV0aG9kIHJvdGF0ZVhcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGV0YSBBbmdsZSBieSB3aGljaCB0byByb3RhdGUuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLnJvdGF0ZVggPSBmdW5jdGlvbiByb3RhdGVYKHRoZXRhKSB7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgY29zVGhldGEgPSBjb3ModGhldGEpO1xuICAgIHZhciBzaW5UaGV0YSA9IHNpbih0aGV0YSk7XG5cbiAgICB0aGlzLnkgPSB5ICogY29zVGhldGEgLSB6ICogc2luVGhldGE7XG4gICAgdGhpcy56ID0geSAqIHNpblRoZXRhICsgeiAqIGNvc1RoZXRhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSB0aGUgY3VycmVudCBWZWMzIGJ5IHRoZXRhIGNsb2Nrd2lzZSBhYm91dCB0aGUgeSBheGlzLlxuICpcbiAqIEBtZXRob2Qgcm90YXRlWVxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhIEFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUucm90YXRlWSA9IGZ1bmN0aW9uIHJvdGF0ZVkodGhldGEpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XG4gICAgdmFyIHNpblRoZXRhID0gc2luKHRoZXRhKTtcblxuICAgIHRoaXMueCA9IHogKiBzaW5UaGV0YSArIHggKiBjb3NUaGV0YTtcbiAgICB0aGlzLnogPSB6ICogY29zVGhldGEgLSB4ICogc2luVGhldGE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUm90YXRlIHRoZSBjdXJyZW50IFZlYzMgYnkgdGhldGEgY2xvY2t3aXNlIGFib3V0IHRoZSB6IGF4aXMuXG4gKlxuICogQG1ldGhvZCByb3RhdGVaXG4gKiBAcGFyYW0ge051bWJlcn0gdGhldGEgQW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5yb3RhdGVaID0gZnVuY3Rpb24gcm90YXRlWih0aGV0YSkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuXG4gICAgdmFyIGNvc1RoZXRhID0gY29zKHRoZXRhKTtcbiAgICB2YXIgc2luVGhldGEgPSBzaW4odGhldGEpO1xuXG4gICAgdGhpcy54ID0geCAqIGNvc1RoZXRhIC0geSAqIHNpblRoZXRhO1xuICAgIHRoaXMueSA9IHggKiBzaW5UaGV0YSArIHkgKiBjb3NUaGV0YTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgZG90IHByb2R1Y3Qgb2YgdGhlIGN1cnJlbnQgVmVjMyB3aXRoIGlucHV0IFZlYzMgdi5cbiAqXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBvdGhlciBWZWMzLlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiBkb3Qodikge1xuICAgIHJldHVybiB0aGlzLngqdi54ICsgdGhpcy55KnYueSArIHRoaXMueip2Lno7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgY3VycmVudCBWZWMzIHdpdGggaW5wdXQgVmVjMyB2LlxuICogU3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGNyb3NzXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIG90aGVyIFZlYzMuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24gY3Jvc3Modikge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIHZ4ID0gdi54O1xuICAgIHZhciB2eSA9IHYueTtcbiAgICB2YXIgdnogPSB2Lno7XG5cbiAgICB0aGlzLnggPSB5ICogdnogLSB6ICogdnk7XG4gICAgdGhpcy55ID0geiAqIHZ4IC0geCAqIHZ6O1xuICAgIHRoaXMueiA9IHggKiB2eSAtIHkgKiB2eDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2NhbGUgdGhlIGN1cnJlbnQgVmVjMyBieSBhIHNjYWxhci5cbiAqXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgTnVtYmVyIGJ5IHdoaWNoIHRvIHNjYWxlLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHMpIHtcbiAgICB0aGlzLnggKj0gcztcbiAgICB0aGlzLnkgKj0gcztcbiAgICB0aGlzLnogKj0gcztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcmVzZXJ2ZSB0aGUgbWFnbml0dWRlIGJ1dCBpbnZlcnQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBpbnZlcnRcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICB0aGlzLnogPSAtdGhpcy56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgZnVuY3Rpb24gY29tcG9uZW50LXdpc2UgdG8gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIG1hcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYXBwbHkuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcChmbikge1xuICAgIHRoaXMueCA9IGZuKHRoaXMueCk7XG4gICAgdGhpcy55ID0gZm4odGhpcy55KTtcbiAgICB0aGlzLnogPSBmbih0aGlzLnopO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICByZXR1cm4gc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufTtcblxuLyoqXG4gKiBUaGUgbWFnbml0dWRlIHNxdWFyZWQgb2YgdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGhTcSA9IGZ1bmN0aW9uIGxlbmd0aFNxKCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgaW5wdXQgb250byB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtWZWMzfSB2IFZlYzMgdG8gY29weS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodikge1xuICAgIHRoaXMueCA9IHYueDtcbiAgICB0aGlzLnkgPSB2Lnk7XG4gICAgdGhpcy56ID0gdi56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy56ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgbWFnbml0dWRlIG9mIHRoZSBjdXJyZW50IFZlYzMgaXMgZXhhY3RseSAwLlxuICpcbiAqIEBtZXRob2QgaXNaZXJvXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5WZWMzLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDAgJiYgdGhpcy56ID09PSAwO1xufTtcblxuLyoqXG4gKiBUaGUgYXJyYXkgZm9ybSBvZiB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgdG9BcnJheVxuICogQHJldHVybiB7TnVtYmVyW119XG4gKi9cblZlYzMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XG59O1xuXG4vKipcbiAqIFByZXNlcnZlIHRoZSBvcmllbnRhdGlvbiBidXQgY2hhbmdlIHRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgVmVjMyB0byAxLlxuICpcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBsZW4gPSBzcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeikgfHwgMTtcbiAgICBsZW4gPSAxIC8gbGVuO1xuXG4gICAgdGhpcy54ICo9IGxlbjtcbiAgICB0aGlzLnkgKj0gbGVuO1xuICAgIHRoaXMueiAqPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGx5IHRoZSByb3RhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbnB1dCAodW5pdCkgUXVhdGVybmlvblxuICogdG8gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5Um90YXRpb25cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBVbml0IFF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbiB0byBhcHBseS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuYXBwbHlSb3RhdGlvbiA9IGZ1bmN0aW9uIGFwcGx5Um90YXRpb24ocSkge1xuICAgIHZhciBjdyA9IHEudztcbiAgICB2YXIgY3ggPSAtcS54O1xuICAgIHZhciBjeSA9IC1xLnk7XG4gICAgdmFyIGN6ID0gLXEuejtcblxuICAgIHZhciB2eCA9IHRoaXMueDtcbiAgICB2YXIgdnkgPSB0aGlzLnk7XG4gICAgdmFyIHZ6ID0gdGhpcy56O1xuXG4gICAgdmFyIHR3ID0gLWN4ICogdnggLSBjeSAqIHZ5IC0gY3ogKiB2ejtcbiAgICB2YXIgdHggPSB2eCAqIGN3ICsgdnkgKiBjeiAtIGN5ICogdno7XG4gICAgdmFyIHR5ID0gdnkgKiBjdyArIGN4ICogdnogLSB2eCAqIGN6O1xuICAgIHZhciB0eiA9IHZ6ICogY3cgKyB2eCAqIGN5IC0gY3ggKiB2eTtcblxuICAgIHZhciB3ID0gY3c7XG4gICAgdmFyIHggPSAtY3g7XG4gICAgdmFyIHkgPSAtY3k7XG4gICAgdmFyIHogPSAtY3o7XG5cbiAgICB0aGlzLnggPSB0eCAqIHcgKyB4ICogdHcgKyB5ICogdHogLSB0eSAqIHo7XG4gICAgdGhpcy55ID0gdHkgKiB3ICsgeSAqIHR3ICsgdHggKiB6IC0geCAqIHR6O1xuICAgIHRoaXMueiA9IHR6ICogdyArIHogKiB0dyArIHggKiB0eSAtIHR4ICogeTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGlucHV0IE1hdDMzIHRoZSB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgYXBwbHlNYXRyaXhcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeCBNYXQzMyB0byBhcHBseS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuYXBwbHlNYXRyaXggPSBmdW5jdGlvbiBhcHBseU1hdHJpeChtYXRyaXgpIHtcbiAgICB2YXIgTSA9IG1hdHJpeC5nZXQoKTtcblxuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdGhpcy54ID0gTVswXSp4ICsgTVsxXSp5ICsgTVsyXSp6O1xuICAgIHRoaXMueSA9IE1bM10qeCArIE1bNF0qeSArIE1bNV0qejtcbiAgICB0aGlzLnogPSBNWzZdKnggKyBNWzddKnkgKyBNWzhdKno7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSByZWZlcmVuY2UgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBub3JtYWxpemUgVmVjMy5cbiAqL1xuVmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUodiwgb3V0cHV0KSB7XG4gICAgdmFyIHggPSB2Lng7XG4gICAgdmFyIHkgPSB2Lnk7XG4gICAgdmFyIHogPSB2Lno7XG5cbiAgICB2YXIgbGVuZ3RoID0gc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopIHx8IDE7XG4gICAgbGVuZ3RoID0gMSAvIGxlbmd0aDtcblxuICAgIG91dHB1dC54ID0geCAqIGxlbmd0aDtcbiAgICBvdXRwdXQueSA9IHkgKiBsZW5ndGg7XG4gICAgb3V0cHV0LnogPSB6ICogbGVuZ3RoO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgcm90YXRpb24gdG8gdGhlIGlucHV0IFZlYzMuXG4gKlxuICogQG1ldGhvZCBhcHBseVJvdGF0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHJlZmVyZW5jZSBWZWMzLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFVuaXQgUXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM30gVGhlIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQgVmVjMy5cbiAqL1xuVmVjMy5hcHBseVJvdGF0aW9uID0gZnVuY3Rpb24gYXBwbHlSb3RhdGlvbih2LCBxLCBvdXRwdXQpIHtcbiAgICB2YXIgY3cgPSBxLnc7XG4gICAgdmFyIGN4ID0gLXEueDtcbiAgICB2YXIgY3kgPSAtcS55O1xuICAgIHZhciBjeiA9IC1xLno7XG5cbiAgICB2YXIgdnggPSB2Lng7XG4gICAgdmFyIHZ5ID0gdi55O1xuICAgIHZhciB2eiA9IHYuejtcblxuICAgIHZhciB0dyA9IC1jeCAqIHZ4IC0gY3kgKiB2eSAtIGN6ICogdno7XG4gICAgdmFyIHR4ID0gdnggKiBjdyArIHZ5ICogY3ogLSBjeSAqIHZ6O1xuICAgIHZhciB0eSA9IHZ5ICogY3cgKyBjeCAqIHZ6IC0gdnggKiBjejtcbiAgICB2YXIgdHogPSB2eiAqIGN3ICsgdnggKiBjeSAtIGN4ICogdnk7XG5cbiAgICB2YXIgdyA9IGN3O1xuICAgIHZhciB4ID0gLWN4O1xuICAgIHZhciB5ID0gLWN5O1xuICAgIHZhciB6ID0gLWN6O1xuXG4gICAgb3V0cHV0LnggPSB0eCAqIHcgKyB4ICogdHcgKyB5ICogdHogLSB0eSAqIHo7XG4gICAgb3V0cHV0LnkgPSB0eSAqIHcgKyB5ICogdHcgKyB0eCAqIHogLSB4ICogdHo7XG4gICAgb3V0cHV0LnogPSB0eiAqIHcgKyB6ICogdHcgKyB4ICogdHkgLSB0eCAqIHk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGlucHV0IFZlYzMuXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBWZWMzIHRvIGNsb25lLlxuICogQHJldHVybiB7VmVjM30gVGhlIGNsb25lZCBWZWMzLlxuICovXG5WZWMzLmNsb25lID0gZnVuY3Rpb24gY2xvbmUodikge1xuICAgIHJldHVybiBuZXcgVmVjMyh2LngsIHYueSwgdi56KTtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBpbnB1dCBWZWMzJ3MuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7VmVjM30gdjEgVGhlIGxlZnQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gdjIgVGhlIHJpZ2h0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi5cbiAqL1xuVmVjMy5hZGQgPSBmdW5jdGlvbiBhZGQodjEsIHYyLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQueCA9IHYxLnggKyB2Mi54O1xuICAgIG91dHB1dC55ID0gdjEueSArIHYyLnk7XG4gICAgb3V0cHV0LnogPSB2MS56ICsgdjIuejtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0aGUgc2Vjb25kIFZlYzMgZnJvbSB0aGUgZmlyc3QuXG4gKlxuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxuICovXG5WZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QodjEsIHYyLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQueCA9IHYxLnggLSB2Mi54O1xuICAgIG91dHB1dC55ID0gdjEueSAtIHYyLnk7XG4gICAgb3V0cHV0LnogPSB2MS56IC0gdjIuejtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgaW5wdXQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHJlZmVyZW5jZSBWZWMzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHMgTnVtYmVyIHRvIHNjYWxlIGJ5LlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM30gVGhlIHJlc3VsdCBvZiB0aGUgc2NhbGluZy5cbiAqL1xuVmVjMy5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHYsIHMsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdi54ICogcztcbiAgICBvdXRwdXQueSA9IHYueSAqIHM7XG4gICAgb3V0cHV0LnogPSB2LnogKiBzO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgaW5wdXQgVmVjMydzLlxuICpcbiAqIEBtZXRob2QgZG90UHJvZHVjdFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRvdCBwcm9kdWN0LlxuICovXG5WZWMzLmRvdCA9IGZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgICByZXR1cm4gdjEueCAqIHYyLnggKyB2MS55ICogdjIueSArIHYxLnogKiB2Mi56O1xufTtcblxuLyoqXG4gKiBUaGUgKHJpZ2h0LWhhbmRlZCkgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgaW5wdXQgVmVjMydzLlxuICogdjEgeCB2Mi5cbiAqXG4gKiBAbWV0aG9kIGNyb3NzUHJvZHVjdFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMuY3Jvc3MgPSBmdW5jdGlvbiBjcm9zcyh2MSwgdjIsIG91dHB1dCkge1xuICAgIHZhciB4MSA9IHYxLng7XG4gICAgdmFyIHkxID0gdjEueTtcbiAgICB2YXIgejEgPSB2MS56O1xuICAgIHZhciB4MiA9IHYyLng7XG4gICAgdmFyIHkyID0gdjIueTtcbiAgICB2YXIgejIgPSB2Mi56O1xuXG4gICAgb3V0cHV0LnggPSB5MSAqIHoyIC0gejEgKiB5MjtcbiAgICBvdXRwdXQueSA9IHoxICogeDIgLSB4MSAqIHoyO1xuICAgIG91dHB1dC56ID0geDEgKiB5MiAtIHkxICogeDI7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogVGhlIHByb2plY3Rpb24gb2YgdjEgb250byB2Mi5cbiAqXG4gKiBAbWV0aG9kIHByb2plY3RcbiAqIEBwYXJhbSB7VmVjM30gdjEgVGhlIGxlZnQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gdjIgVGhlIHJpZ2h0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb2plY3QgPSBmdW5jdGlvbiBwcm9qZWN0KHYxLCB2Miwgb3V0cHV0KSB7XG4gICAgdmFyIHgxID0gdjEueDtcbiAgICB2YXIgeTEgPSB2MS55O1xuICAgIHZhciB6MSA9IHYxLno7XG4gICAgdmFyIHgyID0gdjIueDtcbiAgICB2YXIgeTIgPSB2Mi55O1xuICAgIHZhciB6MiA9IHYyLno7XG5cbiAgICB2YXIgc2NhbGUgPSB4MSAqIHgyICsgeTEgKiB5MiArIHoxICogejI7XG4gICAgc2NhbGUgLz0geDIgKiB4MiArIHkyICogeTIgKyB6MiAqIHoyO1xuXG4gICAgb3V0cHV0LnggPSB4MiAqIHNjYWxlO1xuICAgIG91dHB1dC55ID0geTIgKiBzY2FsZTtcbiAgICBvdXRwdXQueiA9IHoyICogc2NhbGU7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWMzO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE1hdDMzOiByZXF1aXJlKCcuL01hdDMzJyksXG4gICAgUXVhdGVybmlvbjogcmVxdWlyZSgnLi9RdWF0ZXJuaW9uJyksXG4gICAgVmVjMjogcmVxdWlyZSgnLi9WZWMyJyksXG4gICAgVmVjMzogcmVxdWlyZSgnLi9WZWMzJylcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gbm9vcFxuXG5mdW5jdGlvbiBub29wKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91IHNob3VsZCBidW5kbGUgeW91ciBjb2RlICcgK1xuICAgICAgJ3VzaW5nIGBnbHNsaWZ5YCBhcyBhIHRyYW5zZm9ybS4nXG4gIClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcHJvZ3JhbWlmeVxuXG5mdW5jdGlvbiBwcm9ncmFtaWZ5KHZlcnRleCwgZnJhZ21lbnQsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGV4OiB2ZXJ0ZXgsIFxuICAgIGZyYWdtZW50OiBmcmFnbWVudCxcbiAgICB1bmlmb3JtczogdW5pZm9ybXMsIFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgfTtcbn1cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MzMgPSByZXF1aXJlKCcuLi9tYXRoL01hdDMzJyk7XG5cbnZhciBPYmplY3RNYW5hZ2VyID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL09iamVjdE1hbmFnZXInKTtcbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIoJ0R5bmFtaWNHZW9tZXRyeScsIER5bmFtaWNHZW9tZXRyeSk7XG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyKCdEeW5hbWljR2VvbWV0cnlGZWF0dXJlJywgRHluYW1pY0dlb21ldHJ5RmVhdHVyZSk7XG52YXIgT01SZXF1ZXN0RHluYW1pY0dlb21ldHJ5RmVhdHVyZSA9IE9iamVjdE1hbmFnZXIucmVxdWVzdER5bmFtaWNHZW9tZXRyeUZlYXR1cmU7XG52YXIgT01GcmVlRHluYW1pY0dlb21ldHJ5RmVhdHVyZSA9IE9iamVjdE1hbmFnZXIuZnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmU7XG5cbnZhciBUUklQTEVfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFRoZSBzbyBjYWxsZWQgdHJpcGxlIHByb2R1Y3QuIFVzZWQgdG8gZmluZCBhIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvICh2MiAtIHYxKSBpbiB0aGUgZGlyZWN0aW9uIG9mIHYzLlxuICogKHYxIHggdjIpIHggdjMuXG4gKlxuICogQG1ldGhvZCB0cmlwbGVQcm9kdWN0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgZmlyc3QgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gdjIgVGhlIHNlY29uZCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MyBUaGUgdGhpcmQgVmVjMy5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSByZXN1bHQgb2YgdGhlIHRyaXBsZSBwcm9kdWN0LlxuICovXG5mdW5jdGlvbiB0cmlwbGVQcm9kdWN0KHYxLCB2MiwgdjMpIHtcbiAgICB2YXIgdiA9IFRSSVBMRV9SRUdJU1RFUjtcblxuICAgIFZlYzMuY3Jvc3ModjEsIHYyLCB2KTtcbiAgICBWZWMzLmNyb3NzKHYsIHYzLCB2KTtcblxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiAqIE9mIGEgc2V0IG9mIHZlcnRpY2VzLCByZXRyaWV2ZXMgdGhlIHZlcnRleCBmdXJ0aGVzdCBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBtZXRob2QgX2h1bGxTdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtWZWMzW119IHZlcnRpY2VzIFRoZSByZWZlcmVuY2Ugc2V0IG9mIFZlYzMncy5cbiAqIEBwYXJhbSB7VmVjM30gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgdmVydGV4IGFuZCBpdHMgaW5kZXggaW4gdGhlIHZlcnRleCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gX2h1bGxTdXBwb3J0KHZlcnRpY2VzLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgZnVydGhlc3Q7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgZG90O1xuICAgIHZhciB2ZXJ0ZXg7XG4gICAgdmFyIGluZGV4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgIGRvdCA9IFZlYzMuZG90KHZlcnRleCwgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRvdCA+IG1heCkge1xuICAgICAgICAgICAgZnVydGhlc3QgPSB2ZXJ0ZXg7XG4gICAgICAgICAgICBtYXggPSBkb3Q7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1cnRoZXN0LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xufVxuXG52YXIgVkVDX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBQT0lOVENIRUNLX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBBT19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgQUJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIEFDX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBBRF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgQkNfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIEJEX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBVc2VkIGludGVybmFsbHkgdG8gcmVwcmVzZW50IHBvbHloZWRyYWwgZmFjZXQgaW5mb3JtYXRpb24uXG4gKlxuICogQGNsYXNzIER5bmFtaWNHZW9tZXRyeUZlYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBUaGUgZGlzdGFuY2Ugb2YgdGhlIGZlYXR1cmUgZnJvbSB0aGUgb3JpZ2luLlxuICogQHBhcmFtIHtWZWMzfSBub3JtYWwgVGhlIFZlYzMgb3J0aG9nb25hbCB0byB0aGUgZmVhdHVyZSwgcG9pbnRpbmcgb3V0IG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHZlcnRleEluZGljZXMgVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIHdoaWNoIGNvbXBvc2UgdGhlIGZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIER5bmFtaWNHZW9tZXRyeUZlYXR1cmUoZGlzdGFuY2UsIG5vcm1hbCwgdmVydGV4SW5kaWNlcykge1xuICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLnZlcnRleEluZGljZXMgPSB2ZXJ0ZXhJbmRpY2VzO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCBvYmplY3RzLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnQgYXJyYXkgYW5hbG9nb3VzIHRvIHRoYXQgdXNlZCBpbiBpbnN0YW50aWF0aW9uLlxuICogQGNoYWluYWJsZVxuICovXG5EeW5hbWljR2VvbWV0cnlGZWF0dXJlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGRpc3RhbmNlLCBub3JtYWwsIHZlcnRleEluZGljZXMpIHtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy52ZXJ0ZXhJbmRpY2VzID0gdmVydGV4SW5kaWNlcztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ3Jvd2luZyBwb2x5aGVkcm9uLiBVc2VkIGluIENvbnZleEh1bGwgYW5kIGluIEdKSytFUEEgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgRHluYW1pY0dlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIER5bmFtaWNHZW9tZXRyeSgpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG4gICAgdGhpcy5udW1WZXJ0aWNlcyA9IDA7XG4gICAgdGhpcy5mZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMubnVtRmVhdHVyZXMgPSAwO1xuICAgIHRoaXMubGFzdFZlcnRleEluZGV4ID0gMDtcblxuICAgIHRoaXMuX0lEUG9vbCA9IHtcbiAgICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgICBmZWF0dXJlczogW11cbiAgICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCBvYmplY3RzLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnQgYXJyYXkgYW5hbG9nb3VzIHRvIHRoYXQgdXNlZCBpbiBpbnN0YW50aWF0aW9uLlxuICogQGNoYWluYWJsZVxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIHRoaXMubnVtVmVydGljZXMgPSAwO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLm51bUZlYXR1cmVzID0gMDtcbiAgICB0aGlzLmxhc3RWZXJ0ZXhJbmRleCA9IDA7XG5cbiAgICB0aGlzLl9JRFBvb2wgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSB2ZXJ0ZXggdG8gdGhlIHBvbHloZWRyb24uXG4gKlxuICogQG1ldGhvZCBhZGRWZXJ0ZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSB2ZXJ0ZXhPYmogT2JqZWN0IHJldHVybmVkIGJ5IHRoZSBzdXBwb3J0IGZ1bmN0aW9uLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmFkZFZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleE9iaikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX0lEUG9vbC52ZXJ0aWNlcy5sZW5ndGggPyB0aGlzLl9JRFBvb2wudmVydGljZXMucG9wKCkgOiB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICB0aGlzLnZlcnRpY2VzW2luZGV4XSA9IHZlcnRleE9iajtcbiAgICB0aGlzLmxhc3RWZXJ0ZXhJbmRleCA9IGluZGV4O1xuICAgIHRoaXMubnVtVmVydGljZXMrKztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgdmVydGV4IGFuZCBwdXNoIGl0cyBsb2NhdGlvbiBpbiB0aGUgdmVydGV4IGFycmF5IHRvIHRoZSBJRFBvb2wgZm9yIGxhdGVyIHVzZS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZVZlcnRleFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSB2ZXJ0ZXggdG8gcmVtb3ZlLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnJlbW92ZVZlcnRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbaW5kZXhdO1xuICAgIHRoaXMudmVydGljZXNbaW5kZXhdID0gbnVsbDtcbiAgICB0aGlzLl9JRFBvb2wudmVydGljZXMucHVzaChpbmRleCk7XG4gICAgdGhpcy5udW1WZXJ0aWNlcy0tO1xuXG4gICAgcmV0dXJuIHZlcnRleDtcbn07XG5cbi8qKlxuICogQWRkIGEgZmVhdHVyZSAoZmFjZXQpIHRvIHRoZSBwb2x5aGVkcm9uLiBVc2VkIGludGVybmFsbHkgaW4gdGhlIHJlc2hhcGluZyBwcm9jZXNzLlxuICpcbiAqIEBtZXRob2QgYWRkRmVhdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIFRoZSBkaXN0YW5jZSBvZiB0aGUgZmVhdHVyZSBmcm9tIHRoZSBvcmlnaW4uXG4gKiBAcGFyYW0ge1ZlYzN9IG5vcm1hbCBUaGUgZmFjZXQgbm9ybWFsLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gdmVydGV4SW5kaWNlcyBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgd2hpY2ggY29tcG9zZSB0aGUgZmVhdHVyZS5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZGlzdGFuY2UsIG5vcm1hbCwgdmVydGV4SW5kaWNlcykge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX0lEUG9vbC5mZWF0dXJlcy5sZW5ndGggPyB0aGlzLl9JRFBvb2wuZmVhdHVyZXMucG9wKCkgOiB0aGlzLmZlYXR1cmVzLmxlbmd0aDtcbiAgICB0aGlzLmZlYXR1cmVzW2luZGV4XSA9IE9NUmVxdWVzdER5bmFtaWNHZW9tZXRyeUZlYXR1cmUoKS5yZXNldChkaXN0YW5jZSwgbm9ybWFsLCB2ZXJ0ZXhJbmRpY2VzKTtcbiAgICB0aGlzLm51bUZlYXR1cmVzKys7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGZlYXR1cmUgYW5kIHB1c2ggaXRzIGxvY2F0aW9uIGluIHRoZSBmZWF0dXJlIGFycmF5IHRvIHRoZSBJRFBvb2wgZm9yIGxhdGVyIHVzZS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUZlYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgZmVhdHVyZSB0byByZW1vdmUuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdmFyIGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVzW2luZGV4XTtcbiAgICB0aGlzLmZlYXR1cmVzW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5fSURQb29sLmZlYXR1cmVzLnB1c2goaW5kZXgpO1xuICAgIHRoaXMubnVtRmVhdHVyZXMtLTtcblxuICAgIE9NRnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmUoZmVhdHVyZSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsYXN0IHZlcnRleCBvYmplY3QgYWRkZWQgdG8gdGhlIGdlb21ldHJ5LlxuICpcbiAqIEBtZXRob2QgZ2V0TGFzdFZlcnRleFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldExhc3RWZXJ0ZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1t0aGlzLmxhc3RWZXJ0ZXhJbmRleF07XG59O1xuXG4vKipcbiAqIE9mIHRoZSBjbG9zZXN0IGZhY2UgdG8gdGhlIG9yaWdpbiwgcmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciBwb2ludGVkIGF3YXkgZnJvbSB0aGUgb3JpZ2luLlxuICpcbiAqIEBtZXRob2QgZ2V0RmVhdHVyZUNsb3Nlc3RUb09yaWdpblxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldEZlYXR1cmVDbG9zZXN0VG9PcmlnaW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIGNsb3Nlc3QgPSBudWxsO1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV07XG4gICAgICAgIGlmICghZmVhdHVyZSkgY29udGludWU7XG4gICAgICAgIGlmIChmZWF0dXJlLmRpc3RhbmNlIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSBmZWF0dXJlLmRpc3RhbmNlO1xuICAgICAgICAgICAgY2xvc2VzdCA9IGZlYXR1cmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3Q7XG59O1xuXG4vKipcbiAqIEFkZHMgZWRnZSBpZiBub3QgYWxyZWFkeSBvbiB0aGUgZnJvbnRpZXIsIHJlbW92ZXMgaWYgdGhlIGVkZ2Ugb3IgaXRzIHJldmVyc2UgYXJlIG9uIHRoZSBmcm9udGllci5cbiAqIFVzZWQgd2hlbiByZXNoYXBpbmcgRHluYW1pY0dlb21ldHJ5J3MuXG4gKlxuICogQG1ldGhvZCBfdmFsaWRhdGVFZGdlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3RbXX0gdmVydGljZXMgVmVjMyByZWZlcmVuY2UgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcltdW119IGZyb250aWVyIEN1cnJlbnQgZWRnZXMgcG90ZW50aWFsbHkgc2VwYXJhdGluZyB0aGUgZmVhdHVyZXMgdG8gcmVtb3ZlIGZyb20gdGhlIHBlcnNpc3RhbnQgc2hhcGUuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgVGhlIGluZGV4IG9mIHRoZSBzdGFydGluZyBWZWMzIG9uIHRoZSBlZGdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBUaGUgaW5kZXggb2YgdGhlIGN1bG1pbmF0aW5nIFZlYzMuXG4gKi9cbmZ1bmN0aW9uIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGUwID0gdmVydGljZXNbc3RhcnRdLnZlcnRleDtcbiAgICB2YXIgZTEgPSB2ZXJ0aWNlc1tlbmRdLnZlcnRleDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnJvbnRpZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBmcm9udGllcltpXTtcbiAgICAgICAgaWYgKCFlZGdlKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHYwID0gdmVydGljZXNbZWRnZVswXV0udmVydGV4O1xuICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1tlZGdlWzFdXS52ZXJ0ZXg7XG4gICAgICAgIGlmICgoZTAgPT09IHYwICYmIChlMSA9PT0gdjEpKSB8fCAoZTAgPT09IHYxICYmIChlMSA9PT0gdjApKSkge1xuICAgICAgICAgICAgZnJvbnRpZXJbaV0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb250aWVyLnB1c2goW3N0YXJ0LCBlbmRdKTtcbn1cblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgbGFzdCAoZXh0ZXJpb3IpIHBvaW50IGFkZGVkIHRvIHRoZSBwb2x5aGVkcm9uLCByZW1vdmVzIGZlYXR1cmVzIGFzIG5lY2Vzc2FyeSBhbmQgcmVkZXRlcm1pbmVzXG4gKiBpdHMgKGNvbnZleCkgc2hhcGUgdG8gaW5jbHVkZSB0aGUgbmV3IHBvaW50IGJ5IGFkZGluZyB0cmlhbmdsZSBmZWF0dXJlcy4gVXNlcyByZWZlcmVuY2VQb2ludCwgYSBwb2ludCBvbiB0aGUgc2hhcGUnc1xuICogaW50ZXJpb3IsIHRvIGVuc3VyZSBmZWF0dXJlIG5vcm1hbHMgcG9pbnQgb3V0d2FyZCwgZWxzZSB0YWtlcyByZWZlcmVuY2VQb2ludCB0byBiZSB0aGUgb3JpZ2luLlxuICpcbiAqIEBtZXRob2QgcmVzaGFwZVxuICogQHBhcmFtIHtWZWMzfSByZWZlcmVuY2VQb2ludCBQb2ludCBrbm93biB0byBiZSBpbiB0aGUgaW50ZXJpb3IsIHVzZWQgdG8gb3JpZW50IGZlYXR1cmUgbm9ybWFscy5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24ocmVmZXJlbmNlUG9pbnQpIHtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0TGFzdFZlcnRleCgpLnZlcnRleDtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIHZhciB2ZXJ0ZXhPbkZlYXR1cmU7XG4gICAgdmFyIGZlYXR1cmVWZXJ0aWNlcztcblxuICAgIHZhciBpLCBqLCBsZW47XG5cbiAgICAvLyBUaGUgcmVtb3ZhbCBvZiBmZWF0dXJlcyBjcmVhdGVzIGEgaG9sZSBpbiB0aGUgcG9seWhlZHJvbiAtLSBmcm9udGllckVkZ2VzIG1haW50YWlucyB0aGUgZWRnZXNcbiAgICAvLyBvZiB0aGlzIGhvbGUsIGVhY2ggb2Ygd2hpY2ggd2lsbCBmb3JtIG9uZSBlZGdlIG9mIGEgbmV3IGZlYXR1cmUgdG8gYmUgY3JlYXRlZFxuICAgIHZhciBmcm9udGllckVkZ2VzID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWZlYXR1cmVzW2ldKSBjb250aW51ZTtcbiAgICAgICAgZmVhdHVyZVZlcnRpY2VzID0gZmVhdHVyZXNbaV0udmVydGV4SW5kaWNlcztcbiAgICAgICAgdmVydGV4T25GZWF0dXJlID0gdmVydGljZXNbZmVhdHVyZVZlcnRpY2VzWzBdXS52ZXJ0ZXg7XG4gICAgICAgIC8vIElmIHBvaW50IGlzICdhYm92ZScgdGhlIGZlYXR1cmUsIHJlbW92ZSB0aGF0IGZlYXR1cmUsIGFuZCBjaGVjayB0byBhZGQgaXRzIGVkZ2VzIHRvIHRoZSBmcm9udGllci5cbiAgICAgICAgaWYgKFZlYzMuZG90KGZlYXR1cmVzW2ldLm5vcm1hbCwgVmVjMy5zdWJ0cmFjdChwb2ludCwgdmVydGV4T25GZWF0dXJlLCBQT0lOVENIRUNLX1JFR0lTVEVSKSkgPiAtMC4wMDEpIHtcbiAgICAgICAgICAgIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyRWRnZXMsIGZlYXR1cmVWZXJ0aWNlc1swXSwgZmVhdHVyZVZlcnRpY2VzWzFdKTtcbiAgICAgICAgICAgIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyRWRnZXMsIGZlYXR1cmVWZXJ0aWNlc1sxXSwgZmVhdHVyZVZlcnRpY2VzWzJdKTtcbiAgICAgICAgICAgIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyRWRnZXMsIGZlYXR1cmVWZXJ0aWNlc1syXSwgZmVhdHVyZVZlcnRpY2VzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZShpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBBID0gcG9pbnQ7XG4gICAgdmFyIGEgPSB0aGlzLmxhc3RWZXJ0ZXhJbmRleDtcbiAgICBmb3IgKGogPSAwLCBsZW4gPSBmcm9udGllckVkZ2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGlmICghZnJvbnRpZXJFZGdlc1tqXSkgY29udGludWU7XG4gICAgICAgIHZhciBiID0gZnJvbnRpZXJFZGdlc1tqXVswXTtcbiAgICAgICAgdmFyIGMgPSBmcm9udGllckVkZ2VzW2pdWzFdO1xuICAgICAgICB2YXIgQiA9IHZlcnRpY2VzW2JdLnZlcnRleDtcbiAgICAgICAgdmFyIEMgPSB2ZXJ0aWNlc1tjXS52ZXJ0ZXg7XG5cbiAgICAgICAgdmFyIEFCID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBBQl9SRUdJU1RFUik7XG4gICAgICAgIHZhciBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgICAgICB2YXIgQUJDID0gVmVjMy5jcm9zcyhBQiwgQUMsIG5ldyBWZWMzKCkpO1xuICAgICAgICBBQkMubm9ybWFsaXplKCk7XG5cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VQb2ludCkge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gVmVjMy5kb3QoQUJDLCBBKTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAgICAgICBBQkMuaW52ZXJ0KCk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZGlzdGFuY2UsIEFCQywgW2EsIGIsIGNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2UgPSBWZWMzLnN1YnRyYWN0KHJlZmVyZW5jZVBvaW50LCBBLCBWRUNfUkVHSVNURVIpO1xuICAgICAgICAgICAgaWYgKFZlYzMuZG90KEFCQywgcmVmZXJlbmNlKSA+IC0wLjAwMSkgQUJDLmludmVydCgpO1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKG51bGwsIEFCQywgW2EsIGIsIGNdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBTaW1wbGV4IGluc3RhbmNlIGNvbnRhaW5zIHRoZSBvcmlnaW4sIHJldHVybnMgdHJ1ZSBvciBmYWxzZS5cbiAqIElmIGZhbHNlLCByZW1vdmVzIGEgcG9pbnQgYW5kLCBhcyBhIHNpZGUgZWZmZWN0LCBjaGFuZ2VzIGlucHV0IGRpcmVjdGlvbiB0byBiZSBib3RoXG4gKiBvcnRob2dvbmFsIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgc2ltcGxleCBhbmQgcG9pbnQgdG93YXJkIHRoZSBvcmlnaW4uXG4gKiBDYWxscyBjYWxsYmFjayBvbiB0aGUgcmVtb3ZlZCBwb2ludC5cbiAqXG4gKiBAbWV0aG9kIHNpbXBsZXhDb250YWluc09yaWdpblxuICogQHBhcmFtIHtWZWMzfSBkaXJlY3Rpb24gVmVjdG9yIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBzZWFyY2ggZGlyZWN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gaW52b2tlZCB3aXRoIHRoZSByZW1vdmVkIHZlcnRleCwgdXNlZCBlLmcuIHRvIGZyZWUgdGhlIHZlcnRleCBvYmplY3RcbiAqIGluIHRoZSBvYmplY3QgbWFuYWdlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSByZXN1bHQgb2YgdGhlIGNvbnRhaW5tZW50IGNoZWNrLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNpbXBsZXhDb250YWluc09yaWdpbiA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgbnVtVmVydGljZXMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5sYXN0VmVydGV4SW5kZXg7XG4gICAgdmFyIGIgPSBhIC0gMTtcbiAgICB2YXIgYyA9IGEgLSAyO1xuICAgIHZhciBkID0gYSAtIDM7XG5cbiAgICBiID0gYiA8IDAgPyBiICsgbnVtVmVydGljZXMgOiBiO1xuICAgIGMgPSBjIDwgMCA/IGMgKyBudW1WZXJ0aWNlcyA6IGM7XG4gICAgZCA9IGQgPCAwID8gZCArIG51bVZlcnRpY2VzIDogZDtcblxuICAgIHZhciBBID0gdGhpcy52ZXJ0aWNlc1thXS52ZXJ0ZXg7XG4gICAgdmFyIEIgPSB0aGlzLnZlcnRpY2VzW2JdLnZlcnRleDtcbiAgICB2YXIgQyA9IHRoaXMudmVydGljZXNbY10udmVydGV4O1xuICAgIHZhciBEID0gdGhpcy52ZXJ0aWNlc1tkXS52ZXJ0ZXg7XG5cbiAgICB2YXIgQU8gPSBWZWMzLnNjYWxlKEEsIC0xLCBBT19SRUdJU1RFUik7XG4gICAgdmFyIEFCID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBBQl9SRUdJU1RFUik7XG4gICAgdmFyIEFDLCBBRCwgQkMsIEJEO1xuICAgIHZhciBBQkMsIEFDRCwgQUJELCBCQ0Q7XG4gICAgdmFyIGRpc3RhbmNlQUJDLCBkaXN0YW5jZUFDRCwgZGlzdGFuY2VBQkQsIGRpc3RhbmNlQkNEO1xuXG4gICAgdmFyIHZlcnRleFRvUmVtb3ZlO1xuXG4gICAgaWYgKG51bVZlcnRpY2VzID09PSA0KSB7XG4gICAgICAgIC8vIFRldHJhaGVkcm9uXG4gICAgICAgIEFDID0gVmVjMy5zdWJ0cmFjdChDLCBBLCBBQ19SRUdJU1RFUik7XG4gICAgICAgIEFEID0gVmVjMy5zdWJ0cmFjdChELCBBLCBBRF9SRUdJU1RFUik7XG5cbiAgICAgICAgQUJDID0gVmVjMy5jcm9zcyhBQiwgQUMsIG5ldyBWZWMzKCkpO1xuICAgICAgICBBQ0QgPSBWZWMzLmNyb3NzKEFDLCBBRCwgbmV3IFZlYzMoKSk7XG4gICAgICAgIEFCRCA9IFZlYzMuY3Jvc3MoQUIsIEFELCBuZXcgVmVjMygpKTtcbiAgICAgICAgQUJDLm5vcm1hbGl6ZSgpO1xuICAgICAgICBBQ0Qubm9ybWFsaXplKCk7XG4gICAgICAgIEFCRC5ub3JtYWxpemUoKTtcbiAgICAgICAgaWYgKFZlYzMuZG90KEFCQywgQUQpID4gMCkgQUJDLmludmVydCgpO1xuICAgICAgICBpZiAoVmVjMy5kb3QoQUNELCBBQikgPiAwKSBBQ0QuaW52ZXJ0KCk7XG4gICAgICAgIGlmIChWZWMzLmRvdChBQkQsIEFDKSA+IDApIEFCRC5pbnZlcnQoKTtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byBjaGVjayBCQ0QgYmVjYXVzZSB3ZSB3b3VsZCBoYXZlIGp1c3QgY2hlY2tlZCB0aGF0IGluIHRoZSBwcmV2aW91cyBpdGVyYXRpb25cbiAgICAgICAgLy8gLS0gd2UgYWRkZWQgQSB0byB0aGUgQkNEIHRyaWFuZ2xlIGJlY2F1c2UgQSB3YXMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luLlxuXG4gICAgICAgIGRpc3RhbmNlQUJDID0gVmVjMy5kb3QoQUJDLCBBTyk7XG4gICAgICAgIGRpc3RhbmNlQUNEID0gVmVjMy5kb3QoQUNELCBBTyk7XG4gICAgICAgIGRpc3RhbmNlQUJEID0gVmVjMy5kb3QoQUJELCBBTyk7XG5cbiAgICAgICAgLy8gTm9ybXMgcG9pbnQgYXdheSBmcm9tIG9yaWdpbiAtPiBvcmlnaW4gaXMgaW5zaWRlIHRldHJhaGVkcm9uXG4gICAgICAgIGlmIChkaXN0YW5jZUFCQyA8IDAuMDAxICYmIGRpc3RhbmNlQUJEIDwgMC4wMDEgJiYgZGlzdGFuY2VBQ0QgPCAwLjAwMSkge1xuICAgICAgICAgICAgQkMgPSBWZWMzLnN1YnRyYWN0KEMsIEIsIEJDX1JFR0lTVEVSKTtcbiAgICAgICAgICAgIEJEID0gVmVjMy5zdWJ0cmFjdChELCBCLCBCRF9SRUdJU1RFUik7XG4gICAgICAgICAgICBCQ0QgPSBWZWMzLmNyb3NzKEJDLCBCRCwgbmV3IFZlYzMoKSk7XG4gICAgICAgICAgICBCQ0Qubm9ybWFsaXplKCk7XG4gICAgICAgICAgICBpZiAoVmVjMy5kb3QoQkNELCBBQikgPD0gMCkgQkNELmludmVydCgpO1xuICAgICAgICAgICAgZGlzdGFuY2VCQ0QgPSAtMSAqIFZlYzMuZG90KEJDRCxCKTtcbiAgICAgICAgICAgIC8vIFByZXAgZmVhdHVyZXMgZm9yIEVQQVxuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKC1kaXN0YW5jZUFCQywgQUJDLCBbYSxiLGNdKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZSgtZGlzdGFuY2VBQ0QsIEFDRCwgW2EsYyxkXSk7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoLWRpc3RhbmNlQUJELCBBQkQsIFthLGQsYl0pO1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKC1kaXN0YW5jZUJDRCwgQkNELCBbYixjLGRdKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpc3RhbmNlQUJDID49IDAuMDAxKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhUb1JlbW92ZSA9IHRoaXMucmVtb3ZlVmVydGV4KGQpO1xuICAgICAgICAgICAgZGlyZWN0aW9uLmNvcHkoQUJDKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXN0YW5jZUFDRCA+PSAwLjAwMSkge1xuICAgICAgICAgICAgdmVydGV4VG9SZW1vdmUgPSB0aGlzLnJlbW92ZVZlcnRleChiKTtcbiAgICAgICAgICAgIGRpcmVjdGlvbi5jb3B5KEFDRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0ZXhUb1JlbW92ZSA9IHRoaXMucmVtb3ZlVmVydGV4KGMpO1xuICAgICAgICAgICAgZGlyZWN0aW9uLmNvcHkoQUJEKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChudW1WZXJ0aWNlcyA9PT0gMykge1xuICAgICAgICAvLyBUcmlhbmdsZVxuICAgICAgICBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgICAgICBWZWMzLmNyb3NzKEFCLCBBQywgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKFZlYzMuZG90KGRpcmVjdGlvbiwgQU8pIDw9IDApIGRpcmVjdGlvbi5pbnZlcnQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIExpbmVcbiAgICAgICAgZGlyZWN0aW9uLmNvcHkodHJpcGxlUHJvZHVjdChBQiwgQU8sIEFCKSk7XG4gICAgfVxuICAgIGlmICh2ZXJ0ZXhUb1JlbW92ZSAmJiBjYWxsYmFjaykgY2FsbGJhY2sodmVydGV4VG9SZW1vdmUpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgVmVjMydzLCBjb21wdXRlcyB0aGUgY29udmV4IGh1bGwuIFVzZWQgaW4gY29uc3RydWN0aW5nIGJvZGllcyBpbiB0aGUgcGh5c2ljcyBzeXN0ZW0gYW5kIHRvXG4gKiBjcmVhdGUgY3VzdG9tIEdMIG1lc2hlcy5cbiAqXG4gKiBAY2xhc3MgQ29udmV4SHVsbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1ZlYzNbXX0gdmVydGljZXMgQ2xvdWQgb2YgdmVydGljZXMgb2Ygd2hpY2ggdGhlIGVuY2xvc2luZyBjb252ZXggaHVsbCBpcyBkZXNpcmVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zID0gMWUzXSBNYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBjb21wb3NlIHRoZSBjb252ZXggaHVsbC5cbiAqL1xuZnVuY3Rpb24gQ29udmV4SHVsbCh2ZXJ0aWNlcywgaXRlcmF0aW9ucykge1xuICAgIGl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zIHx8IDFlMztcbiAgICB2YXIgaHVsbCA9IF9jb21wdXRlQ29udmV4SHVsbCh2ZXJ0aWNlcywgaXRlcmF0aW9ucyk7XG5cbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBodWxsLmZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBmID0gaHVsbC5mZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKGYpIGluZGljZXMucHVzaChmLnZlcnRleEluZGljZXMpO1xuICAgIH1cblxuICAgIHZhciBwb2x5aGVkcmFsUHJvcGVydGllcyA9IF9jb21wdXRlUG9seWhlZHJhbFByb3BlcnRpZXMoaHVsbC52ZXJ0aWNlcywgaW5kaWNlcyk7XG4gICAgdmFyIGNlbnRyb2lkID0gcG9seWhlZHJhbFByb3BlcnRpZXMuY2VudHJvaWQ7XG5cbiAgICB2YXIgd29ybGRWZXJ0aWNlcyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGh1bGwudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgd29ybGRWZXJ0aWNlcy5wdXNoKFZlYzMuc3VidHJhY3QoaHVsbC52ZXJ0aWNlc1tpXS52ZXJ0ZXgsIGNlbnRyb2lkLCBuZXcgVmVjMygpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB3b3JsZFZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5vcm1hbHMucHVzaChWZWMzLm5vcm1hbGl6ZSh3b3JsZFZlcnRpY2VzW2ldLCBuZXcgVmVjMygpKSk7XG4gICAgfVxuXG4gICAgdmFyIGdyYXBoID0ge307XG4gICAgdmFyIF9uZWlnaGJvck1hdHJpeCA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gaW5kaWNlc1tpXVswXTtcbiAgICAgICAgdmFyIGIgPSBpbmRpY2VzW2ldWzFdO1xuICAgICAgICB2YXIgYyA9IGluZGljZXNbaV1bMl07XG5cbiAgICAgICAgX25laWdoYm9yTWF0cml4W2FdID0gX25laWdoYm9yTWF0cml4W2FdIHx8IHt9O1xuICAgICAgICBfbmVpZ2hib3JNYXRyaXhbYl0gPSBfbmVpZ2hib3JNYXRyaXhbYl0gfHwge307XG4gICAgICAgIF9uZWlnaGJvck1hdHJpeFtjXSA9IF9uZWlnaGJvck1hdHJpeFtjXSB8fCB7fTtcblxuICAgICAgICBncmFwaFthXSA9IGdyYXBoW2FdIHx8IFtdO1xuICAgICAgICBncmFwaFtiXSA9IGdyYXBoW2JdIHx8IFtdO1xuICAgICAgICBncmFwaFtjXSA9IGdyYXBoW2NdIHx8IFtdO1xuXG4gICAgICAgIGlmICghX25laWdoYm9yTWF0cml4W2FdW2JdKSB7XG4gICAgICAgICAgICBfbmVpZ2hib3JNYXRyaXhbYV1bYl0gPSAxO1xuICAgICAgICAgICAgZ3JhcGhbYV0ucHVzaChiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9uZWlnaGJvck1hdHJpeFthXVtjXSkge1xuICAgICAgICAgICAgX25laWdoYm9yTWF0cml4W2FdW2NdID0gMTtcbiAgICAgICAgICAgIGdyYXBoW2FdLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbmVpZ2hib3JNYXRyaXhbYl1bYV0pIHtcbiAgICAgICAgICAgIF9uZWlnaGJvck1hdHJpeFtiXVthXSA9IDE7XG4gICAgICAgICAgICBncmFwaFtiXS5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX25laWdoYm9yTWF0cml4W2JdW2NdKSB7XG4gICAgICAgICAgICBfbmVpZ2hib3JNYXRyaXhbYl1bY10gPSAxO1xuICAgICAgICAgICAgZ3JhcGhbYl0ucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9uZWlnaGJvck1hdHJpeFtjXVthXSkge1xuICAgICAgICAgICAgX25laWdoYm9yTWF0cml4W2NdW2FdID0gMTtcbiAgICAgICAgICAgIGdyYXBoW2NdLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbmVpZ2hib3JNYXRyaXhbY11bYl0pIHtcbiAgICAgICAgICAgIF9uZWlnaGJvck1hdHJpeFtjXVtiXSA9IDE7XG4gICAgICAgICAgICBncmFwaFtjXS5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICB0aGlzLnZlcnRpY2VzID0gd29ybGRWZXJ0aWNlcztcbiAgICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuICAgIHRoaXMucG9seWhlZHJhbFByb3BlcnRpZXMgPSBwb2x5aGVkcmFsUHJvcGVydGllcztcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIGFjdHVhbCBjb21wdXRhdGlvbiBvZiB0aGUgY29udmV4IGh1bGwuXG4gKlxuICogQG1ldGhvZCBfY29tcHV0ZUNvbnZleEh1bGxcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1ZlYzNbXX0gdmVydGljZXMgQ2xvdWQgb2YgdmVydGljZXMgb2Ygd2hpY2ggdGhlIGVuY2xvc2luZyBjb252ZXggaHVsbCBpcyBkZXNpcmVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEl0ZXJhdGlvbnMgTWF4aW11bSBudW1iZXIgb2YgdmVydGljZXMgdG8gY29tcG9zZSB0aGUgY29udmV4IGh1bGwuXG4gKiBAcmV0dXJuIHtEeW5hbWljR2VvbWV0cnl9IFRoZSBjb21wdXRlZCBodWxsLlxuICovXG5mdW5jdGlvbiBfY29tcHV0ZUNvbnZleEh1bGwodmVydGljZXMsIG1heEl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgaHVsbCA9IG5ldyBEeW5hbWljR2VvbWV0cnkoKTtcblxuICAgIGh1bGwuYWRkVmVydGV4KF9odWxsU3VwcG9ydCh2ZXJ0aWNlcywgbmV3IFZlYzMoMSwgMCwgMCkpKTtcbiAgICBodWxsLmFkZFZlcnRleChfaHVsbFN1cHBvcnQodmVydGljZXMsIG5ldyBWZWMzKC0xLCAwLCAwKSkpO1xuICAgIHZhciBBID0gaHVsbC52ZXJ0aWNlc1swXS52ZXJ0ZXg7XG4gICAgdmFyIEIgPSBodWxsLnZlcnRpY2VzWzFdLnZlcnRleDtcbiAgICB2YXIgQUIgPSBWZWMzLnN1YnRyYWN0KEIsIEEsIEFCX1JFR0lTVEVSKTtcblxuICAgIHZhciBkb3Q7XG4gICAgdmFyIHZlcnRleDtcbiAgICB2YXIgZnVydGhlc3Q7XG4gICAgdmFyIGluZGV4O1xuICAgIHZhciBpLCBsZW47XG5cbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgaWYgKHZlcnRleCA9PT0gQSB8fCB2ZXJ0ZXggPT09IEIpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgQVYgPSBWZWMzLnN1YnRyYWN0KHZlcnRleCwgQSwgVkVDX1JFR0lTVEVSKTtcbiAgICAgICAgZG90ID0gVmVjMy5kb3QoQVYsIHRyaXBsZVByb2R1Y3QoQUIsIEFWLCBBQikpO1xuICAgICAgICBkb3QgPSBkb3QgPCAwID8gZG90ICogLTEgOiBkb3Q7XG4gICAgICAgIGlmIChkb3QgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IGRvdDtcbiAgICAgICAgICAgIGZ1cnRoZXN0ID0gdmVydGV4O1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh1bGwuYWRkVmVydGV4KHtcbiAgICAgICAgdmVydGV4OiBmdXJ0aGVzdCxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG5cbiAgICB2YXIgQyA9IGZ1cnRoZXN0O1xuICAgIHZhciBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgIHZhciBBQkMgPSBWZWMzLmNyb3NzKEFCLCBBQywgbmV3IFZlYzMoKSk7XG4gICAgQUJDLm5vcm1hbGl6ZSgpO1xuXG4gICAgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgaWYgKHZlcnRleCA9PT0gQSB8fCB2ZXJ0ZXggPT09IEIgfHwgdmVydGV4ID09PSBDKSBjb250aW51ZTtcbiAgICAgICAgZG90ID0gVmVjMy5kb3QoVmVjMy5zdWJ0cmFjdCh2ZXJ0ZXgsIEEsIFZFQ19SRUdJU1RFUiksIEFCQyk7XG4gICAgICAgIGRvdCA9IGRvdCA8IDAgPyBkb3QgKiAtMSA6IGRvdDtcbiAgICAgICAgaWYgKGRvdCA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gZG90O1xuICAgICAgICAgICAgZnVydGhlc3QgPSB2ZXJ0ZXg7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHVsbC5hZGRWZXJ0ZXgoe1xuICAgICAgICB2ZXJ0ZXg6IGZ1cnRoZXN0LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICB9KTtcblxuICAgIHZhciBEID0gZnVydGhlc3Q7XG4gICAgdmFyIEFEID0gVmVjMy5zdWJ0cmFjdChELCBBLCBBRF9SRUdJU1RFUik7XG4gICAgdmFyIEJDID0gVmVjMy5zdWJ0cmFjdChDLCBCLCBCQ19SRUdJU1RFUik7XG4gICAgdmFyIEJEID0gVmVjMy5zdWJ0cmFjdChELCBCLCBCRF9SRUdJU1RFUik7XG5cbiAgICB2YXIgQUNEID0gVmVjMy5jcm9zcyhBQywgQUQsIG5ldyBWZWMzKCkpO1xuICAgIHZhciBBQkQgPSBWZWMzLmNyb3NzKEFCLCBBRCwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIEJDRCA9IFZlYzMuY3Jvc3MoQkMsIEJELCBuZXcgVmVjMygpKTtcbiAgICBBQ0Qubm9ybWFsaXplKCk7XG4gICAgQUJELm5vcm1hbGl6ZSgpO1xuICAgIEJDRC5ub3JtYWxpemUoKTtcbiAgICBpZiAoVmVjMy5kb3QoQUJDLCBBRCkgPiAwKSBBQkMuaW52ZXJ0KCk7XG4gICAgaWYgKFZlYzMuZG90KEFDRCwgQUIpID4gMCkgQUNELmludmVydCgpO1xuICAgIGlmIChWZWMzLmRvdChBQkQsIEFDKSA+IDApIEFCRC5pbnZlcnQoKTtcbiAgICBpZiAoVmVjMy5kb3QoQkNELCBBQikgPCAwKSBCQ0QuaW52ZXJ0KCk7XG5cbiAgICB2YXIgYSA9IDA7XG4gICAgdmFyIGIgPSAxO1xuICAgIHZhciBjID0gMjtcbiAgICB2YXIgZCA9IDM7XG5cbiAgICBodWxsLmFkZEZlYXR1cmUobnVsbCwgQUJDLCBbYSwgYiwgY10pO1xuICAgIGh1bGwuYWRkRmVhdHVyZShudWxsLCBBQ0QsIFthLCBjLCBkXSk7XG4gICAgaHVsbC5hZGRGZWF0dXJlKG51bGwsIEFCRCwgW2EsIGIsIGRdKTtcbiAgICBodWxsLmFkZEZlYXR1cmUobnVsbCwgQkNELCBbYiwgYywgZF0pO1xuXG4gICAgdmFyIGFzc2lnbmVkID0ge307XG4gICAgZm9yIChpID0gMCwgbGVuID0gaHVsbC52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgIGFzc2lnbmVkW2h1bGwudmVydGljZXNbaV0uaW5kZXhdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSBBLnggKyBCLnggKyBDLnggKyBELng7XG4gICAgdmFyIGN5ID0gQS55ICsgQi55ICsgQy55ICsgRC55O1xuICAgIHZhciBjeiA9IEEueiArIEIueiArIEMueiArIEQuejtcbiAgICB2YXIgcmVmZXJlbmNlUG9pbnQgPSBuZXcgVmVjMyhjeCwgY3ksIGN6KTtcbiAgICByZWZlcmVuY2VQb2ludC5zY2FsZSgwLjI1KTtcblxuICAgIHZhciBmZWF0dXJlcyA9IGh1bGwuZmVhdHVyZXM7XG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgd2hpbGUgKGl0ZXJhdGlvbisrIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgY3VycmVudEZlYXR1cmUgPSBudWxsO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFmZWF0dXJlc1tpXSB8fCBmZWF0dXJlc1tpXS5kb25lKSBjb250aW51ZTtcbiAgICAgICAgICAgIGN1cnJlbnRGZWF0dXJlID0gZmVhdHVyZXNbaV07XG4gICAgICAgICAgICBmdXJ0aGVzdCA9IG51bGw7XG4gICAgICAgICAgICBpbmRleCA9IG51bGw7XG4gICAgICAgICAgICBBID0gaHVsbC52ZXJ0aWNlc1tjdXJyZW50RmVhdHVyZS52ZXJ0ZXhJbmRpY2VzWzBdXS52ZXJ0ZXg7XG4gICAgICAgICAgICB2YXIgcyA9IF9odWxsU3VwcG9ydCh2ZXJ0aWNlcywgY3VycmVudEZlYXR1cmUubm9ybWFsKTtcbiAgICAgICAgICAgIGZ1cnRoZXN0ID0gcy52ZXJ0ZXg7XG4gICAgICAgICAgICBpbmRleCA9IHMuaW5kZXg7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IFZlYzMuZG90KFZlYzMuc3VidHJhY3QoZnVydGhlc3QsIEEsIFZFQ19SRUdJU1RFUiksIGN1cnJlbnRGZWF0dXJlLm5vcm1hbCk7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgMC4wMDEgfHwgYXNzaWduZWRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZlYXR1cmUuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFzc2lnbmVkW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICBodWxsLmFkZFZlcnRleChzKTtcbiAgICAgICAgICAgIGh1bGwucmVzaGFwZShyZWZlcmVuY2VQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIGZlYXR1cmUgaGFzIHBvaW50cyAnYWJvdmUnIGl0IC0+IGZpbmlzaGVkXG4gICAgICAgIGlmIChjdXJyZW50RmVhdHVyZSA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh1bGw7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgaW4gX2NvbXB1dGVQb2x5aGVkcmFsUHJvcGVydGllcy5cbiAqIFNldHMgZjAgLSBmMiBhbmQgZzAgLSBnMiBkZXBlbmRpbmcgb24gdzAgLSB3Mi5cbiAqXG4gKiBAbWV0aG9kIF9zdWJleHByZXNzaW9uc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MCBSZWZlcmVuY2UgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFJlZmVyZW5jZSB5IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gdzIgUmVmZXJlbmNlIHogY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGYgT25lIG9mIHR3byBvdXRwdXQgcmVnaXN0ZXJzIHRvIGNvbnRhaW4gdGhlIHJlc3VsdCBvZiB0aGUgY2FsY3VsYXRpb24uXG4gKiBAcGFyYW0ge051bWJlcltdfSBnIE9uZSBvZiB0d28gb3V0cHV0IHJlZ2lzdGVycyB0byBjb250YWluIHRoZSByZXN1bHQgb2YgdGhlIGNhbGN1bGF0aW9uLlxuICovXG5mdW5jdGlvbiBfc3ViZXhwcmVzc2lvbnModzAsIHcxLCB3MiwgZiwgZykge1xuICAgIHZhciB0MCA9IHcwICsgdzE7XG4gICAgZlswXSA9IHQwICsgdzI7XG4gICAgdmFyIHQxID0gdzAgKiB3MDtcbiAgICB2YXIgdDIgPSB0MSArIHcxICogdDA7XG4gICAgZlsxXSA9IHQyICsgdzIgKiBmWzBdO1xuICAgIGZbMl0gPSB3MCAqIHQxICsgdzEgKiB0MiArIHcyICogZlsxXTtcbiAgICBnWzBdID0gZlsxXSArIHcwICogKGZbMF0gKyB3MCk7XG4gICAgZ1sxXSA9IGZbMV0gKyB3MSAqIChmWzBdICsgdzEpO1xuICAgIGdbMl0gPSBmWzFdICsgdzIgKiAoZlswXSArIHcyKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgdm9sdW1lLlxuICpcbiAqIEBtZXRob2QgX2NvbXB1dGVQb2x5aGVkcmFsUHJvcGVydGllc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VmVjM1tdfSB2ZXJ0aWNlcyBUaGUgdmVydGljZXMgb2YgdGhlIHBvbHloZWRyb24uXG4gKiBAcGFyYW0ge051bWJlcltdW119IGluZGljZXMgQXJyYXkgb2YgYXJyYXlzIG9mIGluZGljZXMgb2YgdmVydGljZXMgY29tcG9zaW5nIHRoZSB0cmlhbmd1bGFyIGZlYXR1cmVzIG9mIHRoZSBwb2x5aGVkcm9uLFxuICogb25lIGFycmF5IGZvciBlYWNoIGZlYXR1cmUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBob2xkaW5nIHRoZSBjYWxjdWxhdGVkIHNwYW4sIHZvbHVtZSwgY2VudGVyLCBhbmQgZXVsZXIgdGVuc29yLlxuICovXG5mdW5jdGlvbiBfY29tcHV0ZVBvbHloZWRyYWxQcm9wZXJ0aWVzKHZlcnRpY2VzLCBpbmRpY2VzKSB7XG4gICAgLy8gT3JkZXI6IDEsIHgsIHksIHosIHheMiwgeV4yLCB6XjIsIHh5LCB5eiwgenhcbiAgICB2YXIgaW50ZWdyYWxzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciBmeCA9IFtdO1xuICAgIHZhciBmeSA9IFtdO1xuICAgIHZhciBmeiA9IFtdO1xuICAgIHZhciBneCA9IFtdO1xuICAgIHZhciBneSA9IFtdO1xuICAgIHZhciBneiA9IFtdO1xuXG4gICAgdmFyIGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIEEgPSB2ZXJ0aWNlc1tpbmRpY2VzW2ldWzBdXS52ZXJ0ZXg7XG4gICAgICAgIHZhciBCID0gdmVydGljZXNbaW5kaWNlc1tpXVsxXV0udmVydGV4O1xuICAgICAgICB2YXIgQyA9IHZlcnRpY2VzW2luZGljZXNbaV1bMl1dLnZlcnRleDtcbiAgICAgICAgdmFyIEFCID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBBQl9SRUdJU1RFUik7XG4gICAgICAgIHZhciBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgICAgICB2YXIgQUJDID0gQUIuY3Jvc3MoQUMpO1xuICAgICAgICBpZiAoVmVjMy5kb3QoQSwgQUJDKSA8IDApIEFCQy5pbnZlcnQoKTtcblxuICAgICAgICB2YXIgZDAgPSBBQkMueDtcbiAgICAgICAgdmFyIGQxID0gQUJDLnk7XG4gICAgICAgIHZhciBkMiA9IEFCQy56O1xuXG4gICAgICAgIHZhciB4MCA9IEEueDtcbiAgICAgICAgdmFyIHkwID0gQS55O1xuICAgICAgICB2YXIgejAgPSBBLno7XG4gICAgICAgIHZhciB4MSA9IEIueDtcbiAgICAgICAgdmFyIHkxID0gQi55O1xuICAgICAgICB2YXIgejEgPSBCLno7XG4gICAgICAgIHZhciB4MiA9IEMueDtcbiAgICAgICAgdmFyIHkyID0gQy55O1xuICAgICAgICB2YXIgejIgPSBDLno7XG5cbiAgICAgICAgX3N1YmV4cHJlc3Npb25zKHgwLCB4MSwgeDIsIGZ4LCBneCk7XG4gICAgICAgIF9zdWJleHByZXNzaW9ucyh5MCwgeTEsIHkyLCBmeSwgZ3kpO1xuICAgICAgICBfc3ViZXhwcmVzc2lvbnMoejAsIHoxLCB6MiwgZnosIGd6KTtcblxuICAgICAgICBpbnRlZ3JhbHNbMF0gKz0gZDAgKiBmeFswXTtcbiAgICAgICAgaW50ZWdyYWxzWzFdICs9IGQwICogZnhbMV07XG4gICAgICAgIGludGVncmFsc1syXSArPSBkMSAqIGZ5WzFdO1xuICAgICAgICBpbnRlZ3JhbHNbM10gKz0gZDIgKiBmelsxXTtcbiAgICAgICAgaW50ZWdyYWxzWzRdICs9IGQwICogZnhbMl07XG4gICAgICAgIGludGVncmFsc1s1XSArPSBkMSAqIGZ5WzJdO1xuICAgICAgICBpbnRlZ3JhbHNbNl0gKz0gZDIgKiBmelsyXTtcbiAgICAgICAgaW50ZWdyYWxzWzddICs9IGQwICogKHkwICogZ3hbMF0gKyB5MSAqIGd4WzFdICsgeTIgKiBneFsyXSk7XG4gICAgICAgIGludGVncmFsc1s4XSArPSBkMSAqICh6MCAqIGd5WzBdICsgejEgKiBneVsxXSArIHoyICogZ3lbMl0pO1xuICAgICAgICBpbnRlZ3JhbHNbOV0gKz0gZDIgKiAoeDAgKiBnelswXSArIHgxICogZ3pbMV0gKyB4MiAqIGd6WzJdKTtcbiAgICB9XG5cbiAgICBpbnRlZ3JhbHNbMF0gLz0gNjtcbiAgICBpbnRlZ3JhbHNbMV0gLz0gMjQ7XG4gICAgaW50ZWdyYWxzWzJdIC89IDI0O1xuICAgIGludGVncmFsc1szXSAvPSAyNDtcbiAgICBpbnRlZ3JhbHNbNF0gLz0gNjA7XG4gICAgaW50ZWdyYWxzWzVdIC89IDYwO1xuICAgIGludGVncmFsc1s2XSAvPSA2MDtcbiAgICBpbnRlZ3JhbHNbN10gLz0gMTIwO1xuICAgIGludGVncmFsc1s4XSAvPSAxMjA7XG4gICAgaW50ZWdyYWxzWzldIC89IDEyMDtcblxuICAgIHZhciBtaW5YID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWluWiA9IEluZmluaXR5LCBtYXhaID0gLUluZmluaXR5O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW2ldLnZlcnRleDtcbiAgICAgICAgaWYgKHZlcnRleC54IDwgbWluWCkgbWluWCA9IHZlcnRleC54O1xuICAgICAgICBpZiAodmVydGV4LnggPiBtYXhYKSBtYXhYID0gdmVydGV4Lng7XG4gICAgICAgIGlmICh2ZXJ0ZXgueSA8IG1pblkpIG1pblkgPSB2ZXJ0ZXgueTtcbiAgICAgICAgaWYgKHZlcnRleC55ID4gbWF4WSkgbWF4WSA9IHZlcnRleC55O1xuICAgICAgICBpZiAodmVydGV4LnogPCBtaW5aKSBtaW5aID0gdmVydGV4Lno7XG4gICAgICAgIGlmICh2ZXJ0ZXgueiA+IG1heFopIG1heFogPSB2ZXJ0ZXguejtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IFttYXhYIC0gbWluWCwgbWF4WSAtIG1pblksIG1heFogLSBtaW5aXTtcbiAgICB2YXIgdm9sdW1lID0gaW50ZWdyYWxzWzBdO1xuICAgIHZhciBjZW50cm9pZCA9IG5ldyBWZWMzKGludGVncmFsc1sxXSwgaW50ZWdyYWxzWzJdLCBpbnRlZ3JhbHNbM10pO1xuICAgIGNlbnRyb2lkLnNjYWxlKDEgLyB2b2x1bWUpO1xuXG4gICAgdmFyIGV1bGVyVGVuc29yID0gbmV3IE1hdDMzKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhbHNbNF0sIGludGVncmFsc1s3XSwgaW50ZWdyYWxzWzldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmFsc1s3XSwgaW50ZWdyYWxzWzVdLCBpbnRlZ3JhbHNbOF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYWxzWzldLCBpbnRlZ3JhbHNbOF0sIGludGVncmFsc1s2XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICB2b2x1bWU6IHZvbHVtZSxcbiAgICAgICAgY2VudHJvaWQ6IGNlbnRyb2lkLFxuICAgICAgICBldWxlclRlbnNvcjogZXVsZXJUZW5zb3JcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBEeW5hbWljR2VvbWV0cnk6IER5bmFtaWNHZW9tZXRyeSxcbiAgICBDb252ZXhIdWxsOiBDb252ZXhIdWxsXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGFydGljbGUgPSByZXF1aXJlKCcuL2JvZGllcy9QYXJ0aWNsZScpO1xudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKTtcbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vZm9yY2VzL0ZvcmNlJyk7XG5cbnZhciBDYWxsYmFja1N0b3JlID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL0NhbGxiYWNrU3RvcmUnKTtcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG5cbnZhciBWRUNfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFFVQVRfUkVHSVNURVIgPSBuZXcgUXVhdGVybmlvbigpO1xudmFyIERFTFRBX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTaW5nbGV0b24gUGh5c2ljc0VuZ2luZSBvYmplY3QuXG4gKiBNYW5hZ2VzIGJvZGllcywgZm9yY2VzLCBjb25zdHJhaW50cy5cbiAqXG4gKiBAY2xhc3MgUGh5c2ljc0VuZ2luZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBoYXNoIG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBQaHlzaWNzRW5naW5lKG9wdGlvbnMpIHtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBDYWxsYmFja1N0b3JlKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvKiogQHByb3AgYm9kaWVzIFRoZSBib2RpZXMgY3VycmVudGx5IGFjdGl2ZSBpbiB0aGUgZW5naW5lLiAqL1xuICAgIHRoaXMuYm9kaWVzID0gW107XG4gICAgLyoqIEBwcm9wIGZvcmNlcyBUaGUgZm9yY2VzIGN1cnJlbnRseSBhY3RpdmUgaW4gdGhlIGVuZ2luZS4gKi9cbiAgICB0aGlzLmZvcmNlcyA9IFtdO1xuICAgIC8qKiBAcHJvcCBjb25zdHJhaW50cyBUaGUgY29uc3RyYWludHMgY3VycmVudGx5IGFjdGl2ZSBpbiB0aGUgZW5naW5lLiAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIC8qKiBAcHJvcCBzdGVwIFRoZSB0aW1lIGJldHdlZW4gZnJhbWVzIGluIHRoZSBlbmdpbmUuICovXG4gICAgdGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwIHx8IDEwMDAvNjA7XG4gICAgLyoqIEBwcm9wIGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiB0aW1lcyBlYWNoIGNvbnN0cmFpbnQgaXMgc29sdmVkIHBlciBmcmFtZS4gKi9cbiAgICB0aGlzLml0ZXJhdGlvbnMgPSBvcHRpb25zLml0ZXJhdGlvbnMgfHwgMTA7XG4gICAgLyoqIEBwcm9wIF9pbmRleFBvb2wgUG9vbHMgb2YgaW5kaWNpZXMgdG8gdHJhY2sgaG9sZXMgaW4gdGhlIGFycmF5cy4gKi9cbiAgICB0aGlzLl9pbmRleFBvb2xzID0ge1xuICAgICAgICBib2RpZXM6IFtdLFxuICAgICAgICBmb3JjZXM6IFtdLFxuICAgICAgICBjb25zdHJhaW50czogW11cbiAgICB9O1xuXG4gICAgdGhpcy5fZW50aXR5TWFwcyA9IHtcbiAgICAgICAgYm9kaWVzOiB7fSxcbiAgICAgICAgZm9yY2VzOiB7fSxcbiAgICAgICAgY29uc3RyYWludHM6IHt9XG4gICAgfTtcblxuICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkIHx8IDEuMDtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuZGVsdGEgPSAwO1xuXG4gICAgdGhpcy5vcmlnaW4gPSBvcHRpb25zLm9yaWdpbiB8fCBuZXcgVmVjMygpO1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uID8gb3B0aW9ucy5vcmllbnRhdGlvbi5ub3JtYWxpemUoKSA6ICBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgdGhpcy5mcmFtZURlcGVuZGVudCA9IG9wdGlvbnMuZnJhbWVEZXBlbmRlbnQgfHwgZmFsc2U7XG5cbiAgICB0aGlzLnRyYW5zZm9ybUJ1ZmZlcnMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBbMCwgMCwgMF0sXG4gICAgICAgIHJvdGF0aW9uOiBbMCwgMCwgMCwgMV1cbiAgICB9O1xufVxuXG4vKipcbiAqIExpc3RlbiBmb3IgYSBzcGVjaWZpYyBldmVudC5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGNoYWluYWJsZVxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGtleSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmV2ZW50cy5vbihrZXksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RvcCBsaXN0ZW5pbmcgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGtleSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoa2V5LCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoa2V5LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5ldmVudHMudHJpZ2dlcihrZXksIHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG9yaWdpbiBvZiB0aGUgd29ybGQuXG4gKlxuICogQG1ldGhvZCBzZXRPcmlnaW5cbiAqIEBjaGFpbmFibGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuc2V0T3JpZ2luID0gZnVuY3Rpb24gc2V0T3JpZ2luKHgsIHksIHopIHtcbiAgICB0aGlzLm9yaWdpbi5zZXQoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHdvcmxkLlxuICpcbiAqIEBtZXRob2Qgc2V0T3JpZW50YXRpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiBzZXRPcmllbnRhdGlvbih3LCB4LCB5LCB6KSB7XG4gICAgdGhpcy5vcmllbnRhdGlvbi5zZXQodywgeCwgeSwgeikubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB0byBzdG9yZSBhbiBlbGVtZW50IGluIGEgbGlicmFyeSBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIF9hZGRFbGVtZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGJvZHksIGZvcmNlLCBvciBjb25zdHJhaW50IHRvIGFkZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgV2hlcmUgdG8gc3RvcmUgdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIF9hZGRFbGVtZW50KGNvbnRleHQsIGVsZW1lbnQsIGtleSkge1xuICAgIHZhciBtYXAgPSBjb250ZXh0Ll9lbnRpdHlNYXBzW2tleV07XG4gICAgaWYgKG1hcFtlbGVtZW50Ll9JRF0gPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlicmFyeSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgdmFyIGluZGV4UG9vbCA9IGNvbnRleHQuX2luZGV4UG9vbHNba2V5XTtcbiAgICAgICAgaWYgKGluZGV4UG9vbC5sZW5ndGgpIG1hcFtlbGVtZW50Ll9JRF0gPSBpbmRleFBvb2wucG9wKCk7XG4gICAgICAgIGVsc2UgbWFwW2VsZW1lbnQuX0lEXSA9IGxpYnJhcnkubGVuZ3RoO1xuICAgICAgICBsaWJyYXJ5W21hcFtlbGVtZW50Ll9JRF1dID0gZWxlbWVudDtcbiAgICB9XG59XG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgbWV0aG9kIHRvIHJlbW92ZSBhbiBlbGVtZW50IGZyb20gYSBsaWJyYXJ5IGFycmF5LlxuICpcbiAqIEBtZXRob2QgX3JlbW92ZUVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBUaGUgYm9keSwgZm9yY2UsIG9yIGNvbnN0cmFpbnQgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBXaGVyZSB0byBzdG9yZSB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnQoY29udGV4dCwgZWxlbWVudCwga2V5KSB7XG4gICAgdmFyIG1hcCA9IGNvbnRleHQuX2VudGl0eU1hcHNba2V5XTtcbiAgICB2YXIgaW5kZXggPSBtYXBbZWxlbWVudC5fSURdO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnRleHQuX2luZGV4UG9vbHNba2V5XS5wdXNoKGluZGV4KTtcbiAgICAgICAgY29udGV4dFtrZXldW2luZGV4XSA9IG51bGw7XG4gICAgICAgIG1hcFtlbGVtZW50Ll9JRF0gPSBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBZGQgYSBncm91cCBvZiBib2RpZXMsIGZvcmNlLCBvciBjb25zdHJhaW50cyB0byB0aGUgZW5naW5lLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgdmFyIGVudGl0eSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZW50aXR5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlbnRpdHlbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgUGFydGljbGUpIHRoaXMuYWRkQm9keShlbnRpdHkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW50aXR5IGluc3RhbmNlb2YgQ29uc3RyYWludCkgdGhpcy5hZGRDb25zdHJhaW50KGVudGl0eSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBGb3JjZSkgdGhpcy5hZGRGb3JjZShlbnRpdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBncm91cCBvZiBib2RpZXMsIGZvcmNlLCBvciBjb25zdHJhaW50cyBmcm9tIHRoZSBlbmdpbmUuXG4gKlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW5qID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICB2YXIgZW50aXR5ID0gYXJndW1lbnRzW2pdO1xuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRpdHkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGVudGl0eVtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBQYXJ0aWNsZSkgdGhpcy5yZW1vdmVCb2R5KGVudGl0eSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBDb25zdHJhaW50KSB0aGlzLnJlbW92ZUNvbnN0cmFpbnQoZW50aXR5KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEZvcmNlKSB0aGlzLnJlbW92ZUZvcmNlKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEJlZ2luIHRyYWNraW5nIGEgYm9keS5cbiAqXG4gKiBAbWV0aG9kIGFkZEJvZHlcbiAqIEBwYXJhbSB7UGFydGljbGV9IGJvZHkgVGhlIGJvZHkgdG8gdHJhY2suXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbiBhZGRCb2R5KGJvZHkpIHtcbiAgICBfYWRkRWxlbWVudCh0aGlzLCBib2R5LCAnYm9kaWVzJyk7XG59O1xuXG4vKipcbiAqIEJlZ2luIHRyYWNraW5nIGEgZm9yY2UuXG4gKlxuICogQG1ldGhvZCBhZGRGb3JjZVxuICogQHBhcmFtIHtGb3JjZX0gZm9yY2UgVGhlIGZvcmNlIHRvIHRyYWNrLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5hZGRGb3JjZSA9IGZ1bmN0aW9uIGFkZEZvcmNlKGZvcmNlKSB7XG4gICAgX2FkZEVsZW1lbnQodGhpcywgZm9yY2UsICdmb3JjZXMnKTtcbn07XG5cbi8qKlxuICogQmVnaW4gdHJhY2tpbmcgYSBjb25zdHJhaW50LlxuICpcbiAqIEBtZXRob2QgYWRkQ29uc3RyYWludFxuICogQHBhcmFtIHtDb25zdHJhaW50fSBjb25zdHJhaW50IFRoZSBjb25zdHJhaW50IHRvIHRyYWNrLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24gYWRkQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gICAgX2FkZEVsZW1lbnQodGhpcywgY29uc3RyYWludCwgJ2NvbnN0cmFpbnRzJyk7XG59O1xuXG4vKipcbiAqIFN0b3AgdHJhY2tpbmcgYSBib2R5LlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keSBUaGUgYm9keSB0byBzdG9wIHRyYWNraW5nLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24gcmVtb3ZlQm9keShib2R5KSB7XG4gICAgX3JlbW92ZUVsZW1lbnQodGhpcywgYm9keSwgJ2JvZGllcycpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRyYWNraW5nIGEgZm9yY2UuXG4gKlxuICogQG1ldGhvZCByZW1vdmVGb3JjZVxuICogQHBhcmFtIHtGb3JjZX0gZm9yY2UgVGhlIGZvcmNlIHRvIHN0b3AgdHJhY2tpbmcuXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLnJlbW92ZUZvcmNlID0gZnVuY3Rpb24gcmVtb3ZlRm9yY2UoZm9yY2UpIHtcbiAgICBfcmVtb3ZlRWxlbWVudCh0aGlzLCBmb3JjZSwgJ2ZvcmNlcycpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRyYWNraW5nIGEgY29uc3RyYWludC5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY29uc3RyYWludCBUaGUgY29uc3RyYWludCB0byBzdG9wIHRyYWNraW5nLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24gcmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gICAgX3JlbW92ZUVsZW1lbnQodGhpcywgY29uc3RyYWludCwgJ2NvbnN0cmFpbnRzJyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgcGh5c2ljcyBzeXN0ZW0gdG8gcmVmbGVjdCB0aGUgY2hhbmdlcyBzaW5jZSB0aGUgbGFzdCBmcmFtZS4gU3RlcHMgZm9yd2FyZCBpbiBpbmNyZW1lbnRzIG9mXG4gKiBQaHlzaWNzRW5naW5lLnN0ZXAuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lKSB7XG4gICAgaWYgKHRoaXMudGltZSA9PT0gMCkgdGhpcy50aW1lID0gdGltZTtcblxuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcbiAgICB2YXIgZm9yY2VzID0gdGhpcy5mb3JjZXM7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcblxuICAgIHZhciBmcmFtZURlcGVuZGVudCA9IHRoaXMuZnJhbWVEZXBlbmRlbnQ7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgdmFyIGR0ID0gc3RlcCAqIDAuMDAxO1xuICAgIHZhciBzcGVlZCA9IHRoaXMuc3BlZWQ7XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmRlbHRhO1xuICAgIGRlbHRhICs9ICh0aW1lIC0gdGhpcy50aW1lKSAqIHNwZWVkO1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG5cbiAgICB2YXIgaSwgbGVuO1xuICAgIHZhciBmb3JjZSwgYm9keSwgY29uc3RyYWludDtcblxuICAgIHdoaWxlKGRlbHRhID4gc3RlcCkge1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdwcmVzdGVwJywgdGltZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIEZvcmNlcyBvbiBwYXJ0aWNsZXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZm9yY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3JjZSA9IGZvcmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChmb3JjZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICBmb3JjZS51cGRhdGUodGltZSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVudGF0aXZlbHkgdXBkYXRlIHZlbG9jaXRpZXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYm9kaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGJvZHkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgX2ludGVncmF0ZVZlbG9jaXR5KGJvZHksIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXAgY29uc3RyYWludHMgZm9yIHNvbHZlclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb25zdHJhaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3RyYWludC51cGRhdGUodGltZSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0aXZlbHkgcmVzb2x2ZSBjb25zdHJhaW50c1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbnVtSXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9uczsgaiA8IG51bUl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29uc3RyYWludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50ID0gY29uc3RyYWludHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucmVzb2x2ZSh0aW1lLCBkdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmNyZW1lbnQgcG9zaXRpb25zIGFuZCBvcmllbnRhdGlvbnNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYm9kaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGJvZHkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgX2ludGVncmF0ZVBvc2UoYm9keSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigncG9zdHN0ZXAnLCB0aW1lKTtcblxuICAgICAgICBpZiAoZnJhbWVEZXBlbmRlbnQpIGRlbHRhID0gMDtcbiAgICAgICAgZWxzZSBkZWx0YSAtPSBzdGVwO1xuICAgIH1cblxuICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0cmFuc2Zvcm0gZXF1aXZhbGVudCB0byB0aGUgUGFydGljbGUncyBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24uXG4gKlxuICogQG1ldGhvZCBnZXRUcmFuc2Zvcm1cbiAqIEByZXR1cm4ge09iamVjdH0gUG9zaXRpb24gYW5kIHJvdGF0aW9uIG9mIHRoZSBib3ksIHRha2luZyBpbnRvIGFjY291bnRcbiAqIHRoZSBvcmlnaW4gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSB3b3JsZC5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKGJvZHkpIHtcbiAgICB2YXIgbyA9IHRoaXMub3JpZ2luO1xuICAgIHZhciBvcSA9IHRoaXMub3JpZW50YXRpb247XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtQnVmZmVycztcblxuICAgIHZhciBwID0gYm9keS5wb3NpdGlvbjtcbiAgICB2YXIgcSA9IGJvZHkub3JpZW50YXRpb247XG4gICAgdmFyIHJvdCA9IHE7XG4gICAgdmFyIGxvYyA9IHA7XG5cbiAgICBpZiAob3EudyAhPT0gMSkge1xuICAgICAgICByb3QgPSBRdWF0ZXJuaW9uLm11bHRpcGx5KHEsIG9xLCBRVUFUX1JFR0lTVEVSKTtcbiAgICAgICAgbG9jID0gb3Eucm90YXRlVmVjdG9yKHAsIFZFQ19SRUdJU1RFUik7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uWzBdID0gby54K2xvYy54O1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvblsxXSA9IG8ueStsb2MueTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb25bMl0gPSBvLnorbG9jLno7XG5cbiAgICB0cmFuc2Zvcm0ucm90YXRpb25bMF0gPSByb3QueDtcbiAgICB0cmFuc2Zvcm0ucm90YXRpb25bMV0gPSByb3QueTtcbiAgICB0cmFuc2Zvcm0ucm90YXRpb25bMl0gPSByb3QuejtcbiAgICB0cmFuc2Zvcm0ucm90YXRpb25bM10gPSByb3QudztcblxuICAgIHJldHVybiB0cmFuc2Zvcm07XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgUGFydGljbGUgbW9tZW50YSBiYXNlZCBvZmYgb2YgY3VycmVudCBpbmNpZGVudCBmb3JjZSBhbmQgdG9ycXVlLlxuICpcbiAqIEBtZXRob2QgX2ludGVncmF0ZVZlbG9jaXR5XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keVxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IGRlbHRhIHRpbWVcbiAqL1xuZnVuY3Rpb24gX2ludGVncmF0ZVZlbG9jaXR5KGJvZHksIGR0KSB7XG4gICAgYm9keS5tb21lbnR1bS5hZGQoVmVjMy5zY2FsZShib2R5LmZvcmNlLCBkdCwgREVMVEFfUkVHSVNURVIpKTtcbiAgICBib2R5LmFuZ3VsYXJNb21lbnR1bS5hZGQoVmVjMy5zY2FsZShib2R5LnRvcnF1ZSwgZHQsIERFTFRBX1JFR0lTVEVSKSk7XG4gICAgVmVjMy5zY2FsZShib2R5Lm1vbWVudHVtLCBib2R5LmludmVyc2VNYXNzLCBib2R5LnZlbG9jaXR5KTtcbiAgICBib2R5LmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KGJvZHkuYW5ndWxhck1vbWVudHVtLCBib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgYm9keS5mb3JjZS5jbGVhcigpO1xuICAgIGJvZHkudG9ycXVlLmNsZWFyKCk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBQYXJ0aWNsZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gYmFzZWQgb2ZmIGN1cnJlbnQgdHJhbnNsYXRpb25hbCBhbmQgYW5ndWxhciB2ZWxvY2l0aWVzLlxuICpcbiAqIEBtZXRob2QgX2ludGVncmF0ZVBvc2VcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5XG4gKiBAcGFyYW0gZHQge051bWJlcn0gZGVsdGEgdGltZVxuICovXG5mdW5jdGlvbiBfaW50ZWdyYXRlUG9zZShib2R5LCBkdCkge1xuICAgIGlmIChib2R5LnJlc3RyaWN0aW9ucyAhPT0gMCkge1xuICAgICAgICB2YXIgcmVzdHJpY3Rpb25zID0gYm9keS5yZXN0cmljdGlvbnM7XG4gICAgICAgIHZhciB4ID0gbnVsbDtcbiAgICAgICAgdmFyIHkgPSBudWxsO1xuICAgICAgICB2YXIgeiA9IG51bGw7XG4gICAgICAgIHZhciBheCA9IG51bGw7XG4gICAgICAgIHZhciBheSA9IG51bGw7XG4gICAgICAgIHZhciBheiA9IG51bGw7XG5cbiAgICAgICAgaWYgKHJlc3RyaWN0aW9ucyAmIDMyKSB4ID0gMDtcbiAgICAgICAgaWYgKHJlc3RyaWN0aW9ucyAmIDE2KSB5ID0gMDtcbiAgICAgICAgaWYgKHJlc3RyaWN0aW9ucyAmIDgpIHogPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgNCkgYXggPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgMikgYXkgPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgMSkgYXogPSAwO1xuXG4gICAgICAgIGlmICh4ICE9PSBudWxsIHx8IHkgIT09IG51bGwgfHwgeiAhPT0gbnVsbCkgYm9keS5zZXRWZWxvY2l0eSh4LHkseik7XG4gICAgICAgIGlmIChheCAhPT0gbnVsbCB8fCBheSAhPT0gbnVsbCB8fCBheiAhPT0gbnVsbCkgYm9keS5zZXRBbmd1bGFyVmVsb2NpdHkoYXgsIGF5LCBheik7XG4gICAgfVxuXG4gICAgYm9keS5wb3NpdGlvbi5hZGQoVmVjMy5zY2FsZShib2R5LnZlbG9jaXR5LCBkdCwgREVMVEFfUkVHSVNURVIpKTtcblxuICAgIHZhciB3ID0gYm9keS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdmFyIHEgPSBib2R5Lm9yaWVudGF0aW9uO1xuICAgIHZhciB3eCA9IHcueDtcbiAgICB2YXIgd3kgPSB3Lnk7XG4gICAgdmFyIHd6ID0gdy56O1xuXG4gICAgdmFyIHF3ID0gcS53O1xuICAgIHZhciBxeCA9IHEueDtcbiAgICB2YXIgcXkgPSBxLnk7XG4gICAgdmFyIHF6ID0gcS56O1xuXG4gICAgdmFyIGhkdCA9IGR0ICogMC41O1xuICAgIHEudyArPSAoLXd4ICogcXggLSB3eSAqIHF5IC0gd3ogKiBxeikgKiBoZHQ7XG4gICAgcS54ICs9ICh3eCAqIHF3ICsgd3kgKiBxeiAtIHd6ICogcXkpICogaGR0O1xuICAgIHEueSArPSAod3kgKiBxdyArIHd6ICogcXggLSB3eCAqIHF6KSAqIGhkdDtcbiAgICBxLnogKz0gKHd6ICogcXcgKyB3eCAqIHF5IC0gd3kgKiBxeCkgKiBoZHQ7XG5cbiAgICBxLm5vcm1hbGl6ZSgpO1xuXG4gICAgYm9keS51cGRhdGVJbmVydGlhKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGh5c2ljc0VuZ2luZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG52YXIgQ29udmV4Qm9keUZhY3RvcnkgPSByZXF1aXJlKCcuL0NvbnZleEJvZHlGYWN0b3J5Jyk7XG5cbnZhciBfQm94ID0gQ29udmV4Qm9keUZhY3RvcnkoW1xuICAgICAgICAgICAgLy8gT3JkZXI6IGJhY2stbGVmdCxiYWNrLXJpZ2h0LGZyb250LWxlZnQsZnJvbnQtcmlnaHRcbiAgICAgICAgICAgIC8vIFRvcCBoYWxmXG4gICAgICAgICAgICBuZXcgVmVjMygtMTAwLCAtMTAwLCAtMTAwKSxcbiAgICAgICAgICAgIG5ldyBWZWMzKDEwMCwgLTEwMCwgLTEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygtMTAwLCAtMTAwLCAxMDApLFxuICAgICAgICAgICAgbmV3IFZlYzMoMTAwLCAtMTAwLCAxMDApLFxuICAgICAgICAgICAgLy8gQm90dG9tIGhhbGZcbiAgICAgICAgICAgIG5ldyBWZWMzKC0xMDAsIDEwMCwgLTEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygxMDAsIDEwMCwgLTEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygtMTAwLCAxMDAsIDEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygxMDAsIDEwMCwgMTAwKSxcbiAgICAgICAgXSk7XG5cbi8qKlxuICogQGNsYXNzIEJveFxuICogQGV4dGVuZHMgUGFydGljbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEJveChvcHRpb25zKSB7XG4gICAgX0JveC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMubm9ybWFscyA9IFtcbiAgICAgICAgLy8gT3JkZXI6IHRvcCwgcmlnaHQsIGZyb250XG4gICAgICAgIG5ldyBWZWMzKDAsIDEsIDApLFxuICAgICAgICBuZXcgVmVjMygxLCAwLCAwKSxcbiAgICAgICAgbmV3IFZlYzMoMCwgMCwgMSlcbiAgICBdO1xuXG4gICAgdGhpcy50eXBlID0gMSA8PCAxO1xufVxuXG5Cb3gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfQm94LnByb3RvdHlwZSk7XG5Cb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vUGFydGljbGUnKTtcbnZhciBNYXQzMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvTWF0MzMnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIENvbnZleEh1bGwgPSBHZW9tZXRyeS5Db252ZXhIdWxsO1xuXG52YXIgVEVNUF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIGNvbnN0cnVjdG9yIGZvciBhIHBoeXNpY2FsIGJvZHkgcmVmbGVjdGluZyB0aGUgc2hhcGUgZGVmaW5lZCBieSBpbnB1dCBDb252ZXhIdWxsIG9yIFZlYzMgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBDb252ZXhCb2R5RmFjdG9yeVxuICogQHBhcmFtIHtDb252ZXhIdWxsIHwgVmVjM1tdfSBodWxsXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBDb252ZXhCb2R5RmFjdG9yeShodWxsKSB7XG4gICAgaWYgKCEoaHVsbCBpbnN0YW5jZW9mIENvbnZleEh1bGwpKSB7XG4gICAgICAgIGlmICghKGh1bGwgaW5zdGFuY2VvZiBBcnJheSkpIHRocm93IG5ldyBFcnJvcignQ29udmV4Qm9keUZhY3RvcnkgcmVxdWlyZXMgYSBDb252ZXhIdWxsIG9iamVjdCBvciBhbiBhcnJheSBvZiBWZWMzXFwncyBhcyBpbnB1dC4nKTtcbiAgICAgICAgZWxzZSBodWxsID0gbmV3IENvbnZleEh1bGwoaHVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgY2xhc3Mgd2l0aCBpbmVydGlhIGFuZCB2ZXJ0aWNlcyBpbmZlcnJlZCBmcm9tIHRoZSBpbnB1dCBDb252ZXhIdWxsIG9yIFZlYzMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ29udmV4Qm9keVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udmV4Qm9keShvcHRpb25zKSB7XG4gICAgICAgIFBhcnRpY2xlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsU2l6ZSA9IGh1bGwucG9seWhlZHJhbFByb3BlcnRpZXMuc2l6ZTtcbiAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLnNpemUgfHwgb3JpZ2luYWxTaXplO1xuXG4gICAgICAgIHZhciBzY2FsZVggPSBzaXplWzBdIC8gb3JpZ2luYWxTaXplWzBdO1xuICAgICAgICB2YXIgc2NhbGVZID0gc2l6ZVsxXSAvIG9yaWdpbmFsU2l6ZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlWiA9IHNpemVbMl0gLyBvcmlnaW5hbFNpemVbMl07XG5cbiAgICAgICAgdGhpcy5fc2NhbGUgPSBbc2NhbGVYLCBzY2FsZVksIHNjYWxlWl07XG5cbiAgICAgICAgdmFyIFQgPSBuZXcgTWF0MzMoW3NjYWxlWCwgMCwgMCwgMCwgc2NhbGVZLCAwLCAwLCAwLCBzY2FsZVpdKTtcblxuICAgICAgICB0aGlzLmh1bGwgPSBodWxsO1xuXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGh1bGwudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaChULnZlY3Rvck11bHRpcGx5KGh1bGwudmVydGljZXNbaV0sIG5ldyBWZWMzKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jb21wdXRlSW5lcnRpYVByb3BlcnRpZXMuY2FsbCh0aGlzLCBUKTtcbiAgICAgICAgdGhpcy5pbnZlcnNlSW5lcnRpYS5jb3B5KHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5lcnRpYSgpO1xuXG4gICAgICAgIHZhciB3ID0gb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHk7XG4gICAgICAgIGlmICh3KSB0aGlzLnNldEFuZ3VsYXJWZWxvY2l0eSh3LngsIHcueSwgdy56KTtcbiAgICB9XG5cbiAgICBDb252ZXhCb2R5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFydGljbGUucHJvdG90eXBlKTtcbiAgICBDb252ZXhCb2R5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnZleEJvZHk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpemUgYW5kIHJlY2FsY3VsYXRlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldFNpemVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggc3Bhbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBzcGFuLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IHNwYW4uXG4gICAgICovXG4gICAgQ29udmV4Qm9keS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUoeCx5LHopIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsU2l6ZSA9IGh1bGwucG9seWhlZHJhbFByb3BlcnRpZXMuc2l6ZTtcblxuICAgICAgICB0aGlzLnNpemVbMF0gPSB4O1xuICAgICAgICB0aGlzLnNpemVbMV0gPSB5O1xuICAgICAgICB0aGlzLnNpemVbMl0gPSB6O1xuXG4gICAgICAgIHZhciBzY2FsZVggPSB4IC8gb3JpZ2luYWxTaXplWzBdO1xuICAgICAgICB2YXIgc2NhbGVZID0geSAvIG9yaWdpbmFsU2l6ZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlWiA9IHogLyBvcmlnaW5hbFNpemVbMl07XG5cbiAgICAgICAgdGhpcy5fc2NhbGUgPSBbc2NhbGVYLCBzY2FsZVksIHNjYWxlWl07XG5cbiAgICAgICAgdmFyIFQgPSBuZXcgTWF0MzMoW3NjYWxlWCwgMCwgMCwgMCwgc2NhbGVZLCAwLCAwLCAwLCBzY2FsZVpdKTtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaHVsbC52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgVC52ZWN0b3JNdWx0aXBseShodWxsLnZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBsb2NhbCBpbmVydGlhIGFuZCBpbnZlcnNlIGluZXJ0aWEgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzaXplLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1cGRhdGVMb2NhbEluZXJ0aWFcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgQ29udmV4Qm9keS5wcm90b3R5cGUudXBkYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24gdXBkYXRlSW5lcnRpYSgpIHtcbiAgICAgICAgdmFyIHNjYWxlWCA9IHRoaXMuX3NjYWxlWzBdO1xuICAgICAgICB2YXIgc2NhbGVZID0gdGhpcy5fc2NhbGVbMV07XG4gICAgICAgIHZhciBzY2FsZVogPSB0aGlzLl9zY2FsZVsyXTtcblxuICAgICAgICB2YXIgVCA9IG5ldyBNYXQzMyhbc2NhbGVYLCAwLCAwLCAwLCBzY2FsZVksIDAsIDAsIDAsIHNjYWxlWl0pO1xuXG4gICAgICAgIF9jb21wdXRlSW5lcnRpYVByb3BlcnRpZXMuY2FsbCh0aGlzLCBUKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHZlcnRleCBmdXJ0aGVzdCBpbiBhIGRpcmVjdGlvbi4gVXNlZCBpbnRlcm5hbGx5IGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzdXBwb3J0XG4gICAgICogQHJldHVybiB7VmVjM30gVGhlIGZ1cnRoZXN0IHZlcnRleC5cbiAgICAgKi9cbiAgICBDb252ZXhCb2R5LnByb3RvdHlwZS5zdXBwb3J0ID0gZnVuY3Rpb24gc3VwcG9ydChkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIHZlcnRleCwgZG90LCBmdXJ0aGVzdDtcbiAgICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGRvdCA9IFZlYzMuZG90KHZlcnRleCxkaXJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGRvdCA+IG1heCkge1xuICAgICAgICAgICAgICAgIGZ1cnRoZXN0ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgIG1heCA9IGRvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVydGhlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB2ZXJ0aWNlcyB0byByZWZsZWN0IGN1cnJlbnQgb3JpZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVNoYXBlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIENvbnZleEJvZHkucHJvdG90eXBlLnVwZGF0ZVNoYXBlID0gZnVuY3Rpb24gdXBkYXRlU2hhcGUoKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgIHZhciBxID0gdGhpcy5vcmllbnRhdGlvbjtcbiAgICAgICAgdmFyIG1vZGVsVmVydGljZXMgPSB0aGlzLmh1bGwudmVydGljZXM7XG5cbiAgICAgICAgdmFyIHNjYWxlWCA9IHRoaXMuX3NjYWxlWzBdO1xuICAgICAgICB2YXIgc2NhbGVZID0gdGhpcy5fc2NhbGVbMV07XG4gICAgICAgIHZhciBzY2FsZVogPSB0aGlzLl9zY2FsZVsyXTtcblxuICAgICAgICB2YXIgdCA9IFRFTVBfUkVHSVNURVI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdC5jb3B5KG1vZGVsVmVydGljZXNbaV0pO1xuICAgICAgICAgICAgdC54ICo9IHNjYWxlWDtcbiAgICAgICAgICAgIHQueSAqPSBzY2FsZVk7XG4gICAgICAgICAgICB0LnogKj0gc2NhbGVaO1xuICAgICAgICAgICAgVmVjMy5hcHBseVJvdGF0aW9uKHQsIHEsIHZlcnRpY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29udmV4Qm9keTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIG1hc3MgYW5kIGluZXJ0aWEgdGVuc29yIGJhc2VkIG9mZiB0aGUgZGVuc2l0eSwgc2l6ZSwgYW5kIGZhY2V0IGluZm9ybWF0aW9uIG9mIHRoZSBwb2x5aGVkcm9uLlxuICpcbiAqIEBtZXRob2QgX2NvbXB1dGVJbmVydGlhUHJvcGVydGllc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TWF0MzN9IFQgVGhlIG1hdHJpeCB0cmFuc2Zvcm1pbmcgdGhlIGludGlhbCBzZXQgb2YgdmVydGljZXMgdG8gYSBzZXQgcmVmbGVjdGluZyB0aGUgYm9keSBzaXplLlxuICovXG5mdW5jdGlvbiBfY29tcHV0ZUluZXJ0aWFQcm9wZXJ0aWVzKFQpIHtcbiAgICB2YXIgcG9seWhlZHJhbFByb3BlcnRpZXMgPSB0aGlzLmh1bGwucG9seWhlZHJhbFByb3BlcnRpZXM7XG4gICAgdmFyIFRfdmFsdWVzID0gVC5nZXQoKTtcbiAgICB2YXIgZGV0VCA9IFRfdmFsdWVzWzBdICogVF92YWx1ZXNbNF0gKiBUX3ZhbHVlc1s4XTtcblxuICAgIHZhciBFX28gPSBwb2x5aGVkcmFsUHJvcGVydGllcy5ldWxlclRlbnNvcjtcblxuICAgIHZhciBFID0gbmV3IE1hdDMzKCk7XG4gICAgTWF0MzMubXVsdGlwbHkoVCwgRV9vLCBFKTtcbiAgICBNYXQzMy5tdWx0aXBseShFLCBULCBFKTtcbiAgICB2YXIgRV92YWx1ZXMgPSBFLmdldCgpO1xuXG4gICAgdmFyIEV4eCA9IEVfdmFsdWVzWzBdO1xuICAgIHZhciBFeXkgPSBFX3ZhbHVlc1s0XTtcbiAgICB2YXIgRXp6ID0gRV92YWx1ZXNbOF07XG4gICAgdmFyIEV4eSA9IEVfdmFsdWVzWzFdO1xuICAgIHZhciBFeXogPSBFX3ZhbHVlc1s3XTtcbiAgICB2YXIgRXh6ID0gRV92YWx1ZXNbMl07XG5cbiAgICB2YXIgbmV3Vm9sdW1lID0gcG9seWhlZHJhbFByb3BlcnRpZXMudm9sdW1lICogZGV0VDtcbiAgICB2YXIgbWFzcyA9IHRoaXMubWFzcztcbiAgICB2YXIgZGVuc2l0eSA9IG1hc3MgLyBuZXdWb2x1bWU7XG5cbiAgICB2YXIgSXh4ID0gRXl5ICsgRXp6O1xuICAgIHZhciBJeXkgPSBFeHggKyBFeno7XG4gICAgdmFyIEl6eiA9IEV4eCArIEV5eTtcbiAgICB2YXIgSXh5ID0gLUV4eTtcbiAgICB2YXIgSXl6ID0gLUV5ejtcbiAgICB2YXIgSXh6ID0gLUV4ejtcblxuICAgIHZhciBjZW50cm9pZCA9IHBvbHloZWRyYWxQcm9wZXJ0aWVzLmNlbnRyb2lkO1xuXG4gICAgSXh4IC09IG5ld1ZvbHVtZSAqIChjZW50cm9pZC55ICogY2VudHJvaWQueSArIGNlbnRyb2lkLnogKiBjZW50cm9pZC56KTtcbiAgICBJeXkgLT0gbmV3Vm9sdW1lICogKGNlbnRyb2lkLnogKiBjZW50cm9pZC56ICsgY2VudHJvaWQueCAqIGNlbnRyb2lkLngpO1xuICAgIEl6eiAtPSBuZXdWb2x1bWUgKiAoY2VudHJvaWQueCAqIGNlbnRyb2lkLnggKyBjZW50cm9pZC55ICogY2VudHJvaWQueSk7XG4gICAgSXh5ICs9IG5ld1ZvbHVtZSAqIGNlbnRyb2lkLnggKiBjZW50cm9pZC55O1xuICAgIEl5eiArPSBuZXdWb2x1bWUgKiBjZW50cm9pZC55ICogY2VudHJvaWQuejtcbiAgICBJeHogKz0gbmV3Vm9sdW1lICogY2VudHJvaWQueiAqIGNlbnRyb2lkLng7XG5cbiAgICBJeHggKj0gZGVuc2l0eSAqIGRldFQ7XG4gICAgSXl5ICo9IGRlbnNpdHkgKiBkZXRUO1xuICAgIEl6eiAqPSBkZW5zaXR5ICogZGV0VDtcbiAgICBJeHkgKj0gZGVuc2l0eSAqIGRldFQ7XG4gICAgSXl6ICo9IGRlbnNpdHkgKiBkZXRUO1xuICAgIEl4eiAqPSBkZW5zaXR5ICogZGV0VDtcblxuICAgIHZhciBpbmVydGlhID0gW1xuICAgICAgICBJeHgsIEl4eSwgSXh6LFxuICAgICAgICBJeHksIEl5eSwgSXl6LFxuICAgICAgICBJeHosIEl5eiwgSXp6XG4gICAgXTtcblxuICAgIHRoaXMubG9jYWxJbmVydGlhLnNldChpbmVydGlhKTtcbiAgICBNYXQzMy5pbnZlcnNlKHRoaXMubG9jYWxJbmVydGlhLCB0aGlzLmxvY2FsSW52ZXJzZUluZXJ0aWEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnZleEJvZHlGYWN0b3J5O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi8uLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBNYXQzMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvTWF0MzMnKTtcblxudmFyIENhbGxiYWNrU3RvcmUgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvQ2FsbGJhY2tTdG9yZScpO1xuXG52YXIgWkVST19WRUNUT1IgPSBuZXcgVmVjMygpO1xuXG52YXIgTUFUMV9SRUdJU1RFUiA9IG5ldyBNYXQzMygpO1xuXG52YXIgX0lEID0gMDtcbi8qKlxuICogRnVuZGFtZW50YWwgcGh5c2ljYWwgYm9keS4gTWFpbnRhaW5zIHRyYW5zbGF0aW9uYWwgYW5kIGFuZ3VsYXIgbW9tZW50dW0sIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiwgYW5kIG90aGVyIHByb3BlcnRpZXNcbiAqIHN1Y2ggYXMgc2l6ZSBhbmQgY29lZmZpY2llbnRzIG9mIHJlc3RpdHV0aW9uIGFuZCBmcmljdGlvbiB1c2VkIGluIGNvbGxpc2lvbiByZXNwb25zZS5cbiAqXG4gKiBAY2xhc3MgUGFydGljbGVcbiAqIEBleHRlbmRzIFBhcnRpY2xlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBzZXRzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBQYXJ0aWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlKG9wdGlvbnMpIHtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBDYWxsYmFja1N0b3JlKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uIHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb24gfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMubW9tZW50dW0gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ3VsYXJNb21lbnR1bSA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLm1hc3MgPSBvcHRpb25zLm1hc3MgfHwgMTtcbiAgICB0aGlzLmludmVyc2VNYXNzID0gMSAvIHRoaXMubWFzcztcblxuICAgIHRoaXMuZm9yY2UgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uICE9IG51bGwgPyBvcHRpb25zLnJlc3RpdHV0aW9uIDogMC40O1xuICAgIHRoaXMuZnJpY3Rpb24gPSBvcHRpb25zLmZyaWN0aW9uICE9IG51bGwgPyBvcHRpb25zLmZyaWN0aW9uIDogMC4yO1xuXG4gICAgdGhpcy5pbnZlcnNlSW5lcnRpYSA9IG5ldyBNYXQzMyhbMCwwLDAsMCwwLDAsMCwwLDBdKTtcblxuICAgIHRoaXMubG9jYWxJbmVydGlhID0gbmV3IE1hdDMzKFswLDAsMCwwLDAsMCwwLDAsMF0pO1xuICAgIHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYSA9IG5ldyBNYXQzMyhbMCwwLDAsMCwwLDAsMCwwLDBdKTtcblxuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZSB8fCBbMCwgMCwgMF07XG5cbiAgICB2YXIgdiA9IG9wdGlvbnMudmVsb2NpdHk7XG4gICAgaWYgKHYpIHRoaXMuc2V0VmVsb2NpdHkodi54LCB2LnksIHYueik7XG5cbiAgICB0aGlzLnJlc3RyaWN0aW9ucyA9IDA7XG4gICAgdGhpcy5zZXRSZXN0cmljdGlvbnMuYXBwbHkodGhpcywgb3B0aW9ucy5yZXN0cmljdGlvbnMgfHwgW10pO1xuXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrIHx8IDE7XG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgfHwgMTtcblxuICAgIHRoaXMudHlwZSA9IDEgPDwgMDtcblxuICAgIHRoaXMuX0lEID0gX0lEKys7XG59XG5cbi8qKlxuICogTGlzdGVuIGZvciBhIHNwZWNpZmljIGV2ZW50LlxuICpcbiAqIEBtZXRob2Qgb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGtleSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmV2ZW50cy5vbihrZXksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RvcCBsaXN0ZW5pbmcgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihrZXksIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ldmVudHMub2ZmKGtleSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50LlxuICpcbiAqIEBtZXRob2Qgb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlcihrZXksIHBheWxvYWQpIHtcbiAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKGtleSwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIHJlc3RyaWN0aW9uIGJpdG1hc2suIENvbnZlcnRzIHRoZSByZXN0cmljdGlvbnMgdG8gdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBtZXRob2QgZ2V0UmVzdHJpY3Rpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX0gcmVzdHJpY3Rpb25zXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRSZXN0cmljdGlvbnMgPSBmdW5jdGlvbiBnZXRSZXN0cmljdGlvbnMoKSB7XG4gICAgdmFyIGxpbmVhciA9ICcnO1xuICAgIHZhciBhbmd1bGFyID0gJyc7XG4gICAgdmFyIHJlc3RyaWN0aW9ucyA9IHRoaXMucmVzdHJpY3Rpb25zO1xuICAgIGlmIChyZXN0cmljdGlvbnMgJiAzMikgbGluZWFyICs9ICd4JztcbiAgICBpZiAocmVzdHJpY3Rpb25zICYgMTYpIGxpbmVhciArPSAneSc7XG4gICAgaWYgKHJlc3RyaWN0aW9ucyAmIDgpIGxpbmVhciArPSAneic7XG4gICAgaWYgKHJlc3RyaWN0aW9ucyAmIDQpIGFuZ3VsYXIgKz0gJ3gnO1xuICAgIGlmIChyZXN0cmljdGlvbnMgJiAyKSBhbmd1bGFyICs9ICd5JztcbiAgICBpZiAocmVzdHJpY3Rpb25zICYgMSkgYW5ndWxhciArPSAneic7XG5cbiAgICByZXR1cm4gW2xpbmVhciwgYW5ndWxhcl07XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgdGhlIHBhcnRpY2xlIHJlc3RyaWN0aW9uIGJpdG1hc2suXG4gKlxuICogQG1ldGhvZCBzZXRSZXN0cmljdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc1Jlc3RyaWN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHJvdFJlc3RyaWN0aW9uc1xuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0UmVzdHJpY3Rpb25zID0gZnVuY3Rpb24gc2V0UmVzdHJpY3Rpb25zKHRyYW5zUmVzdHJpY3Rpb25zLCByb3RSZXN0cmljdGlvbnMpIHtcbiAgICB0cmFuc1Jlc3RyaWN0aW9ucyA9IHRyYW5zUmVzdHJpY3Rpb25zIHx8ICcnO1xuICAgIHJvdFJlc3RyaWN0aW9ucyA9IHJvdFJlc3RyaWN0aW9ucyB8fCAnJztcbiAgICB0aGlzLnJlc3RyaWN0aW9ucyA9IDA7XG4gICAgaWYgKHRyYW5zUmVzdHJpY3Rpb25zLmluZGV4T2YoJ3gnKSA+IC0xKSB0aGlzLnJlc3RyaWN0aW9ucyB8PSAzMjtcbiAgICBpZiAodHJhbnNSZXN0cmljdGlvbnMuaW5kZXhPZigneScpID4gLTEpIHRoaXMucmVzdHJpY3Rpb25zIHw9IDE2O1xuICAgIGlmICh0cmFuc1Jlc3RyaWN0aW9ucy5pbmRleE9mKCd6JykgPiAtMSkgdGhpcy5yZXN0cmljdGlvbnMgfD0gODtcbiAgICBpZiAocm90UmVzdHJpY3Rpb25zLmluZGV4T2YoJ3gnKSA+IC0xKSB0aGlzLnJlc3RyaWN0aW9ucyB8PSA0O1xuICAgIGlmIChyb3RSZXN0cmljdGlvbnMuaW5kZXhPZigneScpID4gLTEpIHRoaXMucmVzdHJpY3Rpb25zIHw9IDI7XG4gICAgaWYgKHJvdFJlc3RyaWN0aW9ucy5pbmRleE9mKCd6JykgPiAtMSkgdGhpcy5yZXN0cmljdGlvbnMgfD0gMTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciBtYXNzXG4gKlxuICogQG1ldGhvZCBnZXRNYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IG1hc3NcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldE1hc3MgPSBmdW5jdGlvbiBnZXRNYXNzKCkge1xuICAgIHJldHVybiB0aGlzLm1hc3M7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWFzcyBvZiB0aGUgUGFydGljbGUuICBDYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIG1hc3Mgc2V2ZXJhbCB0aW1lc1xuICpcbiAqIEBtZXRob2Qgc2V0TWFzc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3NcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldE1hc3MgPSBmdW5jdGlvbiBzZXRNYXNzKG1hc3MpIHtcbiAgICB0aGlzLm1hc3MgPSBtYXNzO1xuICAgIHRoaXMuaW52ZXJzZU1hc3MgPSAxIC8gbWFzcztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciBpbnZlcnNlIG1hc3NcbiAqXG4gKiBAbWV0aG9kIGdldEludmVyc2VNYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGludmVyc2UgbWFzc1xuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0SW52ZXJzZU1hc3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZlcnNlTWFzcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSBpbmVydGlhIHRlbnNvciBhbmQgaXRzIGludmVyc2UgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzaGFwZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZUxvY2FsSW5lcnRpYVxuICogQGNoYWluYWJsZVxuICogQHBhcmFtIHtNYXQzM30gTWF0MzNcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2FsSW5lcnRpYSgpIHtcbiAgICB0aGlzLmxvY2FsSW5lcnRpYS5zZXQoWzAsMCwwLDAsMCwwLDAsMCwwXSk7XG4gICAgdGhpcy5sb2NhbEludmVyc2VJbmVydGlhLnNldChbMCwwLDAsMCwwLDAsMCwwLDBdKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgd29ybGQgaW52ZXJzZSBpbmVydGlhIHRlbnNvci5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZUluZXJ0aWFcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUluZXJ0aWEgPSBmdW5jdGlvbiB1cGRhdGVJbmVydGlhKCkge1xuICAgIHZhciBsb2NhbEludkkgPSB0aGlzLmxvY2FsSW52ZXJzZUluZXJ0aWE7XG4gICAgdmFyIHEgPSB0aGlzLm9yaWVudGF0aW9uO1xuICAgIGlmIChsb2NhbEludklbMF0gPT09IGxvY2FsSW52SVs0XSAmJiBsb2NhbEludklbNF0gPT09IGxvY2FsSW52SVs4XSkgcmV0dXJuO1xuICAgIGlmIChxLncgPT09IDEpIHJldHVybjtcbiAgICB2YXIgUiA9IHEudG9NYXRyaXgoTUFUMV9SRUdJU1RFUik7XG4gICAgTWF0MzMubXVsdGlwbHkoUiwgdGhpcy5pbnZlcnNlSW5lcnRpYSwgdGhpcy5pbnZlcnNlSW5lcnRpYSk7XG4gICAgTWF0MzMubXVsdGlwbHkodGhpcy5sb2NhbEludmVyc2VJbmVydGlhLCBSLnRyYW5zcG9zZSgpLCB0aGlzLmludmVyc2VJbmVydGlhKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciBwb3NpdGlvblxuICpcbiAqIEBtZXRob2QgZ2V0UG9zaXRpb25cbiAqIEByZXR1cm4ge1ZlYzN9IHBvc2l0aW9uXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHBvc2l0aW9uXG4gKlxuICogQG1ldGhvZCBzZXRQb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZSBmb3IgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geiB0aGUgeiBjb29yZGluYXRlIGZvciBwb3NpdGlvblxuICogQHJldHVybiB7UGFydGljbGV9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSwgeikge1xuICAgIHRoaXMucG9zaXRpb24uc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHZlbG9jaXR5XG4gKlxuICogQG1ldGhvZCBnZXRWZWxvY2l0eVxuICogQHJldHVybiB7VmVjM30gdmVsb2NpdHlcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gZ2V0VmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHk7XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgdmVsb2NpdHlcbiAqXG4gKiBAbWV0aG9kIHNldHZlbG9jaXR5XG4gKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeCBjb29yZGluYXRlIGZvciB2ZWxvY2l0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHkgY29vcmRpbmF0ZSBmb3IgdmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IHRoZSB6IGNvb3JkaW5hdGUgZm9yIHZlbG9jaXR5XG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRWZWxvY2l0eSA9IGZ1bmN0aW9uIHNldFZlbG9jaXR5KHgsIHksIHopIHtcbiAgICB0aGlzLnZlbG9jaXR5LnNldCh4LCB5LCB6KTtcbiAgICBWZWMzLnNjYWxlKHRoaXMudmVsb2NpdHksIHRoaXMubWFzcywgdGhpcy5tb21lbnR1bSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgbW9tZW51dG1cbiAqXG4gKiBAbWV0aG9kIGdldE1vbWVudHVtXG4gKiBAcmV0dXJuIHtWZWMzfSBtb21lbnR1bVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0TW9tZW50dW0gPSBmdW5jdGlvbiBnZXRNb21lbnR1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb21lbnR1bTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciBtb21lbnR1bVxuICpcbiAqIEBtZXRob2Qgc2V0TW9tZW50dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIG1vbWVudHVtXG4gKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIGZvciBtb21lbnR1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHogdGhlIHogY29vcmRpbmF0ZSBmb3IgbW9tZW50dW1cbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldE1vbWVudHVtID0gZnVuY3Rpb24gc2V0TW9tZW50dW0oeCwgeSwgeikge1xuICAgIHRoaXMubW9tZW50dW0uc2V0KHgsIHksIHopO1xuICAgIFZlYzMuc2NhbGUodGhpcy5tb21lbnR1bSwgdGhpcy5pbnZlcnNlTWFzcywgdGhpcy52ZWxvY2l0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3Igb3JpZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGdldE9yaWVudGF0aW9uXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBvcmllbnRhdGlvblxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiBnZXRPcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbjtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciBvcmllbnRhdGlvblxuICpcbiAqIEBtZXRob2Qgc2V0T3JpZW50YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB3XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIHNldE9yaWVudGF0aW9uKHcseCx5LHopIHtcbiAgICB0aGlzLm9yaWVudGF0aW9uLnNldCh3LHgseSx6KS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLnVwZGF0ZUluZXJ0aWEoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciBhbmd1bGFyIHZlbG9jaXR5XG4gKlxuICogQG1ldGhvZCBnZXRBbmd1bGFyVmVsb2NpdHlcbiAqIEByZXR1cm4ge1ZlYzN9IGFuZ3VsYXJWZWxvY2l0eVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gZ2V0QW5ndWxhclZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmFuZ3VsYXJWZWxvY2l0eTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciBhbmd1bGFyIHZlbG9jaXR5XG4gKlxuICogQG1ldGhvZCBzZXRBbmd1bGFyVmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uIHNldEFuZ3VsYXJWZWxvY2l0eSh4LHkseikge1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnNldCh4LHkseik7XG4gICAgdmFyIEkgPSBNYXQzMy5pbnZlcnNlKHRoaXMuaW52ZXJzZUluZXJ0aWEsIE1BVDFfUkVHSVNURVIpO1xuICAgIGlmIChJKSBJLnZlY3Rvck11bHRpcGx5KHRoaXMuYW5ndWxhclZlbG9jaXR5LCB0aGlzLmFuZ3VsYXJNb21lbnR1bSk7XG4gICAgZWxzZSB0aGlzLmFuZ3VsYXJNb21lbnR1bS5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIGFuZ3VsYXIgbW9tZW50dW1cbiAqXG4gKiBAbWV0aG9kIGdldEFuZ3VsYXJNb21lbnR1bVxuICogQHJldHVybiB7VmVjM30gYW5ndWxhciBtb21lbnR1bVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0QW5ndWxhck1vbWVudHVtID0gZnVuY3Rpb24gZ2V0QW5ndWxhck1vbWVudHVtKCkge1xuICAgIHJldHVybiB0aGlzLmFuZ3VsYXJNb21lbnR1bTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciBhbmd1bGFyIG1vbWVudHVtXG4gKlxuICogQG1ldGhvZCBzZXRBbmd1bGFyTW9tZW50dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldEFuZ3VsYXJNb21lbnR1bSA9IGZ1bmN0aW9uIHNldEFuZ3VsYXJNb21lbnR1bSh4LHkseikge1xuICAgIHRoaXMuYW5ndWxhck1vbWVudHVtLnNldCh4LHkseik7XG4gICAgdGhpcy5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseSh0aGlzLmFuZ3VsYXJNb21lbnR1bSwgdGhpcy5hbmd1bGFyVmVsb2NpdHkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHRoZSBmb3JjZSBvbiB0aGUgUGFydGljbGVcbiAqXG4gKiBAbWV0aG9kIGdldEZvcmNlXG4gKiBAcmV0dXJuIHtWZWMzfSBmb3JjZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0Rm9yY2UgPSBmdW5jdGlvbiBnZXRGb3JjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JjZTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciB0aGUgZm9yY2Ugb24gdGhlIFBhcnRpY2xlXG4gKlxuICogQG1ldGhvZCBzZXRGb3JjZVxuICogQHBhcmFtIHtWZWMzfSB2IHRoZSBuZXcgRm9yY2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldEZvcmNlID0gZnVuY3Rpb24gc2V0Rm9yY2UoeCwgeSwgeikge1xuICAgIHRoaXMuZm9yY2Uuc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHRvcnF1ZS5cbiAqXG4gKiBAbWV0aG9kIGdldFRvcnF1ZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0VG9ycXVlID0gZnVuY3Rpb24gZ2V0VG9ycXVlKCkge1xuICAgIHJldHVybiB0aGlzLnRvcnF1ZTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciB0b3JxdWUuXG4gKlxuICogQG1ldGhvZCBzZXRUb3JxdWVcbiAqIEBwYXJhbSB7VmVjM30gdlxuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0VG9ycXVlID0gZnVuY3Rpb24gc2V0VG9ycXVlKHgsIHksIHopIHtcbiAgICB0aGlzLnRvcnF1ZS5zZXQoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgUGFydGljbGUuYXBwbHlGb3JjZSB3aXRoIGFuIG9wdGlvbmFsIGFyZ3VtZW50XG4gKiB0byBhcHBseSB0aGUgZm9yY2UgYXQgYW4gb2ZmLWNlbnRlcmVkIGxvY2F0aW9uLCByZXN1bHRpbmcgaW4gYSB0b3JxdWUuXG4gKlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKiBAcGFyYW0gZm9yY2Uge1ZlYzN9IGZvcmNlXG4gKiBAcGFyYW0ge1ZlYzN9IGxvY2F0aW9uIG9mZi1jZW50ZXIgbG9jYXRpb24gb24gdGhlIFBhcnRpY2xlIChvcHRpb25hbClcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiBhcHBseUZvcmNlKGZvcmNlKSB7XG4gICAgdGhpcy5mb3JjZS5hZGQoZm9yY2UpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVkIGEgdG9ycXVlIGZvcmNlIHRvIGEgUGFydGljbGUsIGluZHVjaW5nIGEgcm90YXRpb24uXG4gKlxuICogQG1ldGhvZCBhcHBseVRvcnF1ZVxuICogQHBhcmFtIHRvcnF1ZSB7VmVjM30gdG9ycXVlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5hcHBseVRvcnF1ZSA9IGZ1bmN0aW9uIGFwcGx5VG9ycXVlKHRvcnF1ZSkge1xuICAgIHRoaXMudG9ycXVlLmFkZCh0b3JxdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGFuIGltcHVsc2UgdG8gbW9tZW50dW0gYW5kIHVwZGF0ZXMgdmVsb2NpdHkuXG4gKlxuICogQG1ldGhvZCBhcHBseUltcHVsc2VcbiAqIEBwYXJhbSB7VmVjM30gaW1wdWxzZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24gYXBwbHlJbXB1bHNlKGltcHVsc2UpIHtcbiAgICB0aGlzLm1vbWVudHVtLmFkZChpbXB1bHNlKTtcbiAgICBWZWMzLnNjYWxlKHRoaXMubW9tZW50dW0sIHRoaXMuaW52ZXJzZU1hc3MsIHRoaXMudmVsb2NpdHkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGFuIGFuZ3VsYXIgaW1wdWxzZSB0byBhbmd1bGFyIG1vbWVudHVtIGFuZCB1cGRhdGVzIGFuZ3VsYXIgdmVsb2NpdHkuXG4gKlxuICogQG1ldGhvZCBhcHBseUFuZ3VsYXJJbXB1bHNlXG4gKiBAcGFyYW0ge1ZlYzN9IGFuZ3VsYXJJbXB1bHNlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5hcHBseUFuZ3VsYXJJbXB1bHNlID0gZnVuY3Rpb24gYXBwbHlBbmd1bGFySW1wdWxzZShhbmd1bGFySW1wdWxzZSkge1xuICAgIHRoaXMuYW5ndWxhck1vbWVudHVtLmFkZChhbmd1bGFySW1wdWxzZSk7XG4gICAgdGhpcy5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseSh0aGlzLmFuZ3VsYXJNb21lbnR1bSwgdGhpcy5hbmd1bGFyVmVsb2NpdHkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVc2VkIGluIGNvbGxpc2lvbiBkZXRlY3Rpb24uIFRoZSBzdXBwb3J0IGZ1bmN0aW9uIHNob3VsZCBhY2NlcHQgYSBWZWMzIGRpcmVjdGlvblxuICogYW5kIHJldHVybiB0aGUgcG9pbnQgb24gdGhlIGJvZHkncyBzaGFwZSBmdXJ0aGVzdCBpbiB0aGF0IGRpcmVjdGlvbi4gRm9yIHBvaW50IHBhcnRpY2xlcyxcbiAqIHRoaXMgcmV0dXJucyB0aGUgemVybyB2ZWN0b3IuXG4gKlxuICogQG1ldGhvZCBzdXBwb3J0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc3VwcG9ydCA9IGZ1bmN0aW9uIHN1cHBvcnQoKSB7XG4gICAgcmV0dXJuIFpFUk9fVkVDVE9SO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvZHkncyBzaGFwZSB0byByZWZsZWN0IGN1cnJlbnQgb3JpZW50YXRpb24uIENhbGxlZCBpbiBDb2xsaXNpb24uXG4gKiBOb29wIGZvciBwb2ludCBwYXJ0aWNsZXMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVTaGFwZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlU2hhcGUgPSBmdW5jdGlvbiB1cGRhdGVTaGFwZSgpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBhcnRpY2xlID0gcmVxdWlyZSgnLi9QYXJ0aWNsZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL1ZlYzMnKTtcblxudmFyIFNVUFBPUlRfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNwaGVyaWNhbCBSaWdpZCBib2R5XG4gKlxuICogQGNsYXNzIFNwaGVyZVxuICogQGV4dGVuZHMgUGFydGljbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFNwaGVyZShvcHRpb25zKSB7XG4gICAgUGFydGljbGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB2YXIgciAgPSBvcHRpb25zLnJhZGl1cyB8fCAxO1xuICAgIHRoaXMucmFkaXVzID0gcjtcbiAgICB0aGlzLnNpemUgPSBbMipyLCAyKnIsIDIqcl07XG4gICAgdGhpcy51cGRhdGVMb2NhbEluZXJ0aWEoKTtcbiAgICB0aGlzLmludmVyc2VJbmVydGlhLmNvcHkodGhpcy5sb2NhbEludmVyc2VJbmVydGlhKTtcblxuICAgIHZhciB3ID0gb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHk7XG4gICAgaWYgKHcpIHRoaXMuc2V0QW5ndWxhclZlbG9jaXR5KHcueCwgdy55LCB3LnopO1xuXG4gICAgdGhpcy50eXBlID0gMSA8PCAyO1xufVxuXG5TcGhlcmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJ0aWNsZS5wcm90b3R5cGUpO1xuU3BoZXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHJhZGl1cy5cbiAqXG4gKiBAbWV0aG9kIGdldFJhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfSByYWRpdXNcbiAqL1xuU3BoZXJlLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHJhZGl1cy5cbiAqXG4gKiBAbWV0aG9kIHNldFJhZGl1c1xuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgaW50ZW5kZWQgcmFkaXVzIG9mIHRoZSBzcGhlcmUuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblNwaGVyZS5wcm90b3R5cGUuc2V0UmFkaXVzID0gZnVuY3Rpb24gc2V0UmFkaXVzKHJhZGl1cykge1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIHRoaXMuc2l6ZSA9IFsyKnRoaXMucmFkaXVzLCAyKnRoaXMucmFkaXVzLCAyKnRoaXMucmFkaXVzXTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5mZXJzIHRoZSBpbmVydGlhIHRlbnNvci5cbiAqXG4gKiBAb3ZlcnJpZGVcbiAqIEBtZXRob2QgdXBkYXRlSW5lcnRpYVxuICovXG5TcGhlcmUucHJvdG90eXBlLnVwZGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uIHVwZGF0ZUluZXJ0aWEoKSB7XG4gICAgdmFyIG0gPSB0aGlzLm1hc3M7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcblxuICAgIHZhciBtcnIgPSBtICogciAqIHI7XG5cbiAgICB0aGlzLmxvY2FsSW5lcnRpYS5zZXQoW1xuICAgICAgICAwLjQgKiBtcnIsIDAsIDAsXG4gICAgICAgIDAsIDAuNCAqIG1yciwgMCxcbiAgICAgICAgMCwgMCwgMC40ICogbXJyXG4gICAgXSk7XG5cbiAgICB0aGlzLmxvY2FsSW52ZXJzZUluZXJ0aWEuc2V0KFtcbiAgICAgICAgMi41IC8gbXJyLCAwLCAwLFxuICAgICAgICAwLCAyLjUgLyBtcnIsIDAsXG4gICAgICAgIDAsIDAsIDIuNSAvIG1yclxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgc3BoZXJlIGZ1cnRoZXN0IGluIGEgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBtZXRob2Qgc3VwcG9ydFxuICogQHBhcmFtIHtWZWMzfSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7VmVjM31cbiAqL1xuU3BoZXJlLnByb3RvdHlwZS5zdXBwb3J0ID0gZnVuY3Rpb24gc3VwcG9ydChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gVmVjMy5zY2FsZShkaXJlY3Rpb24sIHRoaXMucmFkaXVzLCBTVVBQT1JUX1JFR0lTVEVSKTtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgU3BoZXJlXG4gKiBAbW9kdWxlIFNwaGVyZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFNwaGVyZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vUGFydGljbGUnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogQGVudW0gZGlyZWN0aW9uc1xuICovXG5XYWxsLkRPV04gPSAwO1xuV2FsbC5VUCA9IDE7XG5XYWxsLkxFRlQgPSAyO1xuV2FsbC5SSUdIVCA9IDM7XG5XYWxsLkZPUldBUkQgPSA0O1xuV2FsbC5CQUNLV0FSRCA9IDU7XG5cbi8qKlxuICogQW4gYXhpcy1hbGlnbmVkIGJvdW5kYXJ5LiBXaWxsIG5vdCByZXNwb25kIHRvIGZvcmNlcyBvciBpbXB1bHNlcy5cbiAqXG4gKiBAY2xhc3MgV2FsbFxuICogQGV4dGVuZHMgUGFydGljbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFdhbGwob3B0aW9ucykge1xuICAgIFBhcnRpY2xlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB2YXIgbiA9IHRoaXMubm9ybWFsID0gbmV3IFZlYzMoKTtcblxuICAgIHZhciBkID0gdGhpcy5kaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgY2FzZSBXYWxsLkRPV046XG4gICAgICAgICAgICBuLnNldCgwLCAxLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFdhbGwuVVA6XG4gICAgICAgICAgICBuLnNldCgwLCAtMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXYWxsLkxFRlQ6XG4gICAgICAgICAgICBuLnNldCgtMSwgMCwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXYWxsLlJJR0hUOlxuICAgICAgICAgICAgbi5zZXQoMSwgMCwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXYWxsLkZPUldBUkQ6XG4gICAgICAgICAgICBuLnNldCgwLCAwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXYWxsLkJBQ0tXQVJEOlxuICAgICAgICAgICAgbi5zZXQoMCwgMCwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuaW52Tm9ybWFsID0gVmVjMy5jbG9uZShuLCBuZXcgVmVjMygpKS5pbnZlcnQoKTtcblxuICAgIHRoaXMubWFzcyA9IEluZmluaXR5O1xuICAgIHRoaXMuaW52ZXJzZU1hc3MgPSAwO1xuXG4gICAgdGhpcy50eXBlID0gMSA8PCAzO1xufVxuXG5XYWxsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFydGljbGUucHJvdG90eXBlKTtcbldhbGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBXYWxsO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL01hdDMzJyk7XG5cbnZhciBERUxUQV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IGtlZXBzIGEgcGh5c2ljcyBib2R5IGEgZ2l2ZW4gZGlyZWN0aW9uIGF3YXkgZnJvbSBhIGdpdmVuXG4gKiAgYW5jaG9yLCBvciBhbm90aGVyIGF0dGFjaGVkIGJvZHkuXG4gKlxuICogIEBjbGFzcyBBbmdsZVxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBBbmdsZShhLCBiLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5lZmZlY3RpdmVJbmVydGlhID0gbmV3IE1hdDMzKCk7XG4gICAgdGhpcy5hbmd1bGFySW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5lcnJvciA9IDA7XG59XG5cbkFuZ2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuQW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5nbGU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgQW5nbGUuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuQW5nbGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvc0FuZ2xlID0gdGhpcy5jb3NBbmdsZSB8fCB0aGlzLmEub3JpZW50YXRpb24uZG90KHRoaXMuYi5vcmllbnRhdGlvbik7XG59O1xuXG4vKipcbiAqIFdhcm1zdGFydCB0aGUgY29uc3RyYWludCBhbmQgcHJlcGFyZSBjYWxjdWxhdGlvbnMgdXNlZCBpbiAucmVzb2x2ZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5BbmdsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBhID0gdGhpcy5hO1xuICAgIHZhciBiID0gdGhpcy5iO1xuXG4gICAgdmFyIHExID0gYS5vcmllbnRhdGlvbjtcbiAgICB2YXIgcTIgPSBiLm9yaWVudGF0aW9uO1xuXG4gICAgdmFyIGNvc1RoZXRhID0gcTEuZG90KHEyKTtcbiAgICB2YXIgZGlmZiA9IDIqKGNvc1RoZXRhIC0gdGhpcy5jb3NBbmdsZSk7XG5cbiAgICB0aGlzLmVycm9yID0gZGlmZjtcblxuICAgIHZhciBhbmd1bGFySW1wdWxzZSA9IHRoaXMuYW5ndWxhckltcHVsc2U7XG4gICAgYi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ3VsYXJJbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5ndWxhckltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgTWF0MzMuYWRkKGEuaW52ZXJzZUluZXJ0aWEsIGIuaW52ZXJzZUluZXJ0aWEsIHRoaXMuZWZmZWN0aXZlSW5lcnRpYSk7XG4gICAgdGhpcy5lZmZlY3RpdmVJbmVydGlhLmludmVyc2UoKTtcblxuICAgIGFuZ3VsYXJJbXB1bHNlLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYW5ndWxhciBpbXB1bHNlIHRvIGEgcGh5c2ljcyBib2R5J3MgYW5ndWxhciB2ZWxvY2l0eS5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuQW5nbGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgZGlmZlcgPSBERUxUQV9SRUdJU1RFUjtcblxuICAgIHZhciB3MSA9IGEuYW5ndWxhclZlbG9jaXR5O1xuICAgIHZhciB3MiA9IGIuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgVmVjMy5zdWJ0cmFjdCh3MSwgdzIsIGRpZmZXKTtcbiAgICBkaWZmVy5zY2FsZSgxICsgdGhpcy5lcnJvcik7XG5cbiAgICB2YXIgYW5ndWxhckltcHVsc2UgPSBkaWZmVy5hcHBseU1hdHJpeCh0aGlzLmVmZmVjdGl2ZUluZXJ0aWEpO1xuXG4gICAgYi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ3VsYXJJbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5ndWxhckltcHVsc2UuaW52ZXJ0KCkpO1xuICAgIGFuZ3VsYXJJbXB1bHNlLmludmVydCgpO1xuICAgIHRoaXMuYW5ndWxhckltcHVsc2UuYWRkKGFuZ3VsYXJJbXB1bHNlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5nbGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9NYXQzMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi8uLi9tYXRoL1F1YXRlcm5pb24nKTtcblxudmFyIFZFQzFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZFQzJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZCMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBXeFJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqICBBIGNvbnN0cmFpbnQgdGhhdCBtYWludGFpbnMgcG9zaXRpb25zIGFuZCBvcmllbnRhdGlvbnMgd2l0aCByZXNwZWN0IHRvIGEgc3BlY2lmaWMgYW5jaG9yIHBvaW50LlxuICpcbiAqICBAY2xhc3MgQmFsbEFuZFNvY2tldFxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEFuIG9iamVjdCBvZiBjb25maWd1cmFibGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gQmFsbEFuZFNvY2tldChhLCBiLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VCID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmVycm9yID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXggPSBuZXcgTWF0MzMoKTtcbn1cblxuQmFsbEFuZFNvY2tldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnN0cmFpbnQucHJvdG90eXBlKTtcbkJhbGxBbmRTb2NrZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFsbEFuZFNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBCYWxsQW5kU29ja2V0LiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqL1xuQmFsbEFuZFNvY2tldC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gdGhpcy5hbmNob3I7XG5cbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBxMXQgPSBRdWF0ZXJuaW9uLmNvbmp1Z2F0ZShhLm9yaWVudGF0aW9uLCBuZXcgUXVhdGVybmlvbigpKTtcbiAgICB2YXIgcTJ0ID0gUXVhdGVybmlvbi5jb25qdWdhdGUoYi5vcmllbnRhdGlvbiwgbmV3IFF1YXRlcm5pb24oKSk7XG5cbiAgICB0aGlzLnJBID0gVmVjMy5zdWJ0cmFjdCh3LCBhLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLnJCID0gVmVjMy5zdWJ0cmFjdCh3LCBiLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcblxuICAgIHRoaXMuYm9keVJBID0gcTF0LnJvdGF0ZVZlY3Rvcih0aGlzLnJBLCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLmJvZHlSQiA9IHEydC5yb3RhdGVWZWN0b3IodGhpcy5yQiwgbmV3IFZlYzMoKSk7XG59O1xuXG4vKipcbiAqIERldGVjdCB2aW9sYXRpb25zIG9mIHRoZSBjb25zdHJhaW50LiBXYXJtIHN0YXJ0IHRoZSBjb25zdHJhaW50LCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5CYWxsQW5kU29ja2V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih0aW1lLCBkdCkge1xuICAgIHZhciBhID0gdGhpcy5hO1xuICAgIHZhciBiID0gdGhpcy5iO1xuXG4gICAgdmFyIHJBID0gYS5vcmllbnRhdGlvbi5yb3RhdGVWZWN0b3IodGhpcy5ib2R5UkEsIHRoaXMuckEpO1xuICAgIHZhciByQiA9IGIub3JpZW50YXRpb24ucm90YXRlVmVjdG9yKHRoaXMuYm9keVJCLCB0aGlzLnJCKTtcblxuICAgIHZhciB4UkEgPSBuZXcgTWF0MzMoWzAsckEueiwtckEueSwtckEueiwwLHJBLngsckEueSwtckEueCwwXSk7XG4gICAgdmFyIHhSQiA9IG5ldyBNYXQzMyhbMCxyQi56LC1yQi55LC1yQi56LDAsckIueCxyQi55LC1yQi54LDBdKTtcblxuICAgIHZhciBSSWFSdCA9IE1hdDMzLm11bHRpcGx5KHhSQSwgYS5pbnZlcnNlSW5lcnRpYSwgbmV3IE1hdDMzKCkpLm11bHRpcGx5KHhSQS50cmFuc3Bvc2UoKSk7XG4gICAgdmFyIFJJYlJ0ID0gTWF0MzMubXVsdGlwbHkoeFJCLCBiLmludmVyc2VJbmVydGlhLCBuZXcgTWF0MzMoKSkubXVsdGlwbHkoeFJCLnRyYW5zcG9zZSgpKTtcblxuICAgIHZhciBpbnZFZmZJbmVydGlhID0gTWF0MzMuYWRkKFJJYVJ0LCBSSWJSdCwgUklhUnQpO1xuXG4gICAgdmFyIHdvcmxkQSA9IFZlYzMuYWRkKGEucG9zaXRpb24sIHRoaXMuckEsIHRoaXMuYW5jaG9yKTtcbiAgICB2YXIgd29ybGRCID0gVmVjMy5hZGQoYi5wb3NpdGlvbiwgdGhpcy5yQiwgVkVDMl9SRUdJU1RFUik7XG5cbiAgICBWZWMzLnN1YnRyYWN0KHdvcmxkQiwgd29ybGRBLCB0aGlzLmVycm9yKTtcbiAgICB0aGlzLmVycm9yLnNjYWxlKDAuMi9kdCk7XG5cbiAgICB2YXIgaW1BID0gYS5pbnZlcnNlTWFzcztcbiAgICB2YXIgaW1CID0gYi5pbnZlcnNlTWFzcztcblxuICAgIHZhciBpbnZFZmZNYXNzID0gbmV3IE1hdDMzKFtpbUEgKyBpbUIsMCwwLDAsaW1BICsgaW1CLDAsMCwwLGltQSArIGltQl0pO1xuXG4gICAgTWF0MzMuYWRkKGludkVmZkluZXJ0aWEsIGludkVmZk1hc3MsIHRoaXMuZWZmTWFzc01hdHJpeCk7XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4LmludmVyc2UoKTtcblxuICAgIHZhciBpbXB1bHNlID0gdGhpcy5pbXB1bHNlO1xuICAgIHZhciBhbmdJbXB1bHNlQSA9IHRoaXMuYW5nSW1wdWxzZUE7XG4gICAgdmFyIGFuZ0ltcHVsc2VCID0gdGhpcy5hbmdJbXB1bHNlQjtcblxuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGIuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQik7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcbiAgICBhLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUEpO1xuXG4gICAgaW1wdWxzZS5jbGVhcigpO1xuICAgIGFuZ0ltcHVsc2VBLmNsZWFyKCk7XG4gICAgYW5nSW1wdWxzZUIuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZXMgdG8gcmVzb2x2ZSB0aGUgY29uc3RyYWludC5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuQmFsbEFuZFNvY2tldC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgckEgPSB0aGlzLnJBO1xuICAgIHZhciByQiA9IHRoaXMuckI7XG5cbiAgICB2YXIgdjEgPSBWZWMzLmFkZChhLnZlbG9jaXR5LCBWZWMzLmNyb3NzKGEuYW5ndWxhclZlbG9jaXR5LCByQSwgV3hSX1JFR0lTVEVSKSwgVkIxX1JFR0lTVEVSKTtcbiAgICB2YXIgdjIgPSBWZWMzLmFkZChiLnZlbG9jaXR5LCBWZWMzLmNyb3NzKGIuYW5ndWxhclZlbG9jaXR5LCByQiwgV3hSX1JFR0lTVEVSKSwgVkIyX1JFR0lTVEVSKTtcblxuICAgIHZhciBpbXB1bHNlID0gdjEuc3VidHJhY3QodjIpLnN1YnRyYWN0KHRoaXMuZXJyb3IpLmFwcGx5TWF0cml4KHRoaXMuZWZmTWFzc01hdHJpeCk7XG4gICAgdmFyIGFuZ0ltcHVsc2VCID0gVmVjMy5jcm9zcyhyQiwgaW1wdWxzZSwgVkVDMV9SRUdJU1RFUik7XG4gICAgdmFyIGFuZ0ltcHVsc2VBID0gVmVjMy5jcm9zcyhyQSwgaW1wdWxzZSwgVkVDMl9SRUdJU1RFUikuaW52ZXJ0KCk7XG5cbiAgICBiLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBiLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUIpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VBKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuXG4gICAgdGhpcy5pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBLmFkZChhbmdJbXB1bHNlQSk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQi5hZGQoYW5nSW1wdWxzZUIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWxsQW5kU29ja2V0O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL1ZlYzMnKTtcbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG5cbnZhciBTd2VlcEFuZFBydW5lID0gcmVxdWlyZSgnLi9jb2xsaXNpb24vU3dlZXBBbmRQcnVuZScpO1xudmFyIEJydXRlRm9yY2UgPSByZXF1aXJlKCcuL2NvbGxpc2lvbi9CcnV0ZUZvcmNlJyk7XG52YXIgQ29udmV4Q29sbGlzaW9uID0gcmVxdWlyZSgnLi9jb2xsaXNpb24vQ29udmV4Q29sbGlzaW9uRGV0ZWN0aW9uJyk7XG52YXIgR0pLID0gQ29udmV4Q29sbGlzaW9uLkdKSztcbnZhciBFUEEgPSBDb252ZXhDb2xsaXNpb24uRVBBO1xudmFyIENvbnRhY3RNYW5pZm9sZFRhYmxlID0gcmVxdWlyZSgnLi9jb2xsaXNpb24vQ29udGFjdE1hbmlmb2xkJyk7XG5cbnZhciBPYmplY3RNYW5hZ2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzL09iamVjdE1hbmFnZXInKTtcbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIoJ0NvbGxpc2lvbkRhdGEnLCBDb2xsaXNpb25EYXRhKTtcbnZhciBPTVJlcXVlc3RDb2xsaXNpb25EYXRhID0gT2JqZWN0TWFuYWdlci5yZXF1ZXN0Q29sbGlzaW9uRGF0YTtcblxudmFyIFZFQ19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNsYW1wIGEgdmFsdWUgdG8gYSBnaXZlbiByYW5nZS5cbiAqXG4gKiBAbWV0aG9kIGNsYW1wXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbG93ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cHBlclxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbG93ZXIsIHVwcGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgbG93ZXIgPyBsb3dlciA6IHZhbHVlID4gdXBwZXIgPyB1cHBlciA6IHZhbHVlO1xufVxuXG4vKipcbiAqIE9iamVjdCBtYWludGFpbmluZyB2YXJpb3VzIGZpZ3VyZXMgb2YgYSBjb2xsaXNpb24uIFJlZ2lzdGVyZWQgaW4gT2JqZWN0TWFuYWdlci5cbiAqXG4gKiBAY2xhc3MgQ29sbGlzaW9uRGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IHBlbmV0cmF0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9IG5vcm1hbFxuICogQHBhcmFtIHtWZWMzfSB3b3JsZENvbnRhY3RBXG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkQ29udGFjdEJcbiAqIEBwYXJhbSB7VmVjM30gbG9jYWxDb250YWN0QVxuICogQHBhcmFtIHtWZWMzfSBsb2NhbENvbnRhY3RCXG4gKi9cbmZ1bmN0aW9uIENvbGxpc2lvbkRhdGEocGVuZXRyYXRpb24sIG5vcm1hbCwgd29ybGRDb250YWN0QSwgd29ybGRDb250YWN0QiwgbG9jYWxDb250YWN0QSwgbG9jYWxDb250YWN0Qikge1xuICAgIHRoaXMucGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLndvcmxkQ29udGFjdEEgPSB3b3JsZENvbnRhY3RBO1xuICAgIHRoaXMud29ybGRDb250YWN0QiA9IHdvcmxkQ29udGFjdEI7XG4gICAgdGhpcy5sb2NhbENvbnRhY3RBID0gbG9jYWxDb250YWN0QTtcbiAgICB0aGlzLmxvY2FsQ29udGFjdEIgPSBsb2NhbENvbnRhY3RCO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCB0aGUgb2JqZWN0IHdpdGggZGlmZmVyZW50IGRhdGEuXG4gKlxuICogQG1ldGhvZCByZXNldFxuICogQHBhcmFtIHtPYmplY3RbXX0gYXJnc1xuICogQGNoYWluYWJsZVxuICovXG5Db2xsaXNpb25EYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KHBlbmV0cmF0aW9uLCBub3JtYWwsIHdvcmxkQ29udGFjdEEsIHdvcmxkQ29udGFjdEIsIGxvY2FsQ29udGFjdEEsIGxvY2FsQ29udGFjdEIpIHtcbiAgICB0aGlzLnBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy53b3JsZENvbnRhY3RBID0gd29ybGRDb250YWN0QTtcbiAgICB0aGlzLndvcmxkQ29udGFjdEIgPSB3b3JsZENvbnRhY3RCO1xuICAgIHRoaXMubG9jYWxDb250YWN0QSA9IGxvY2FsQ29udGFjdEE7XG4gICAgdGhpcy5sb2NhbENvbnRhY3RCID0gbG9jYWxDb250YWN0QjtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSaWRpZCBib2R5IEVsYXN0aWMgQ29sbGlzaW9uXG4gKlxuICogQGNsYXNzIENvbGxpc2lvblxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICBpZiAodGFyZ2V0cykgdGhpcy50YXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuQ29sbGlzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuQ29sbGlzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbGxpc2lvbjtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBDb2xsaXNpb24gdHJhY2tlci4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5Db2xsaXNpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5icm9hZFBoYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb2FkUGhhc2UgaW5zdGFuY2VvZiBGdW5jdGlvbikgdGhpcy5icm9hZFBoYXNlID0gbmV3IHRoaXMuYnJvYWRQaGFzZSh0aGlzLnRhcmdldHMpO1xuICAgIH1cbiAgICBlbHNlIHRoaXMuYnJvYWRQaGFzZSA9IG5ldyBTd2VlcEFuZFBydW5lKHRoaXMudGFyZ2V0cyk7XG4gICAgdGhpcy5jb250YWN0TWFuaWZvbGRUYWJsZSA9IHRoaXMuY29udGFjdE1hbmlmb2xkVGFibGUgfHwgbmV3IENvbnRhY3RNYW5pZm9sZFRhYmxlKCk7XG59O1xuXG4vKipcbiAqIENvbGxpc29uIGRldGVjdGlvbi4gVXBkYXRlcyB0aGUgZXhpc3RpbmcgY29udGFjdCBtYW5pZm9sZHMsIHJ1bnMgdGhlIGJyb2FkcGhhc2UsIGFuZCBwZXJmb3JtcyBuYXJyb3dwaGFzZVxuICogY29sbGlzaW9uIGRldGVjdGlvbi4gV2FybSBzdGFydHMgdGhlIGNvbnRhY3RzIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyBwaHlzaWNzIGZyYW1lXG4gKiBhbmQgcHJlcGFyZXMgbmVjZXNzc2FyeSBjYWxjdWxhdGlvbnMgZm9yIHRoZSByZXNvbHV0aW9uLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbiBDb2xsaXNpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lLCBkdCkge1xuICAgIHRoaXMuY29udGFjdE1hbmlmb2xkVGFibGUudXBkYXRlKGR0KTtcbiAgICBpZiAodGhpcy50YXJnZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0c1tpXS51cGRhdGVTaGFwZSgpO1xuICAgIH1cbiAgICB2YXIgcG90ZW50aWFsQ29sbGlzaW9ucyA9IHRoaXMuYnJvYWRQaGFzZS51cGRhdGUoKTtcbiAgICB2YXIgcGFpcjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb3RlbnRpYWxDb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIChwYWlyID0gcG90ZW50aWFsQ29sbGlzaW9uc1tpXSkgJiYgdGhpcy5hcHBseU5hcnJvd1BoYXNlKHBhaXIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhY3RNYW5pZm9sZFRhYmxlLnByZXBDb250YWN0cyhkdCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgYWxsIENvbnRhY3QgY29uc3RyYWludHMuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkNvbGxpc2lvbi5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUodGltZSwgZHQpIHtcbiAgICB0aGlzLmNvbnRhY3RNYW5pZm9sZFRhYmxlLnJlc29sdmVNYW5pZm9sZHMoZHQpO1xufTtcblxuLyoqXG4gKiBBZGQgYSB0YXJnZXQgb3IgdGFyZ2V0cyB0byB0aGUgY29sbGlzaW9uIHN5c3RlbS5cbiAqXG4gKiBAbWV0aG9kIGFkZFRhcmdldFxuICogQHBhcmFtIHtQYXJ0aWNsZX1cbiAqL1xuQ29sbGlzaW9uLnByb3RvdHlwZS5hZGRUYXJnZXQgPSBmdW5jdGlvbiBhZGRUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB0aGlzLmJyb2FkUGhhc2UuYWRkKHRhcmdldCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRhcmdldCBvciB0YXJnZXRzIGZyb20gdGhlIGNvbGxpc2lvbiBzeXN0ZW0uXG4gKlxuICogQG1ldGhvZCBhZGRUYXJnZXRcbiAqIEBwYXJhbSB7UGFydGljbGV9XG4gKi9cbkNvbGxpc2lvbi5wcm90b3R5cGUucmVtb3ZlVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuICAgIHRoaXMudGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuYnJvYWRQaGFzZS5yZW1vdmUodGFyZ2V0KTtcbn07XG5cblxudmFyIENPTlZFWCA9IDEgPDwgMDtcbnZhciBCT1ggPSAxIDw8IDE7XG52YXIgU1BIRVJFID0gMSA8PCAyO1xudmFyIFdBTEwgPSAxIDw8IDM7XG5cbnZhciBDT05WRVhfQ09OVkVYID0gQ09OVkVYIHwgQ09OVkVYO1xudmFyIEJPWF9CT1ggPSBCT1ggfCBCT1g7XG52YXIgQk9YX0NPTlZFWCA9IEJPWCB8IENPTlZFWDtcbnZhciBTUEhFUkVfU1BIRVJFID0gU1BIRVJFIHwgU1BIRVJFO1xudmFyIEJPWF9TUEhFUkUgPSBCT1ggfCBTUEhFUkU7XG52YXIgQ09OVkVYX1NQSEVSRSA9IENPTlZFWCB8IFNQSEVSRTtcbnZhciBDT05WRVhfV0FMTCA9IENPTlZFWCB8IFdBTEw7XG52YXIgQk9YX1dBTEwgPSBCT1ggfCBXQUxMO1xudmFyIFNQSEVSRV9XQUxMID0gU1BIRVJFIHwgV0FMTDtcblxudmFyIGRpc3BhdGNoID0ge307XG5kaXNwYXRjaFtDT05WRVhfQ09OVkVYXSA9IGNvbnZleEludGVyc2VjdENvbnZleDtcbmRpc3BhdGNoW0JPWF9CT1hdID0gY29udmV4SW50ZXJzZWN0Q29udmV4O1xuZGlzcGF0Y2hbQk9YX0NPTlZFWF0gPSBjb252ZXhJbnRlcnNlY3RDb252ZXg7XG5kaXNwYXRjaFtDT05WRVhfU1BIRVJFXSA9IGNvbnZleEludGVyc2VjdENvbnZleDtcbmRpc3BhdGNoW1NQSEVSRV9TUEhFUkVdID0gc3BoZXJlSW50ZXJzZWN0U3BoZXJlO1xuZGlzcGF0Y2hbQk9YX1NQSEVSRV0gPSBib3hJbnRlcnNlY3RTcGhlcmU7XG5kaXNwYXRjaFtDT05WRVhfV0FMTF0gPSBjb252ZXhJbnRlcnNlY3RXYWxsO1xuZGlzcGF0Y2hbQk9YX1dBTExdID0gY29udmV4SW50ZXJzZWN0V2FsbDtcbmRpc3BhdGNoW1NQSEVSRV9XQUxMXSA9IGNvbnZleEludGVyc2VjdFdhbGw7XG5cbi8qKlxuICogTmFycm93cGhhc2UgY29sbGlzaW9uIGRldGVjdGlvbixcbiAqIHJlZ2lzdGVycyB0aGUgQ29udGFjdCBjb25zdHJhaW50cyBmb3IgY29sbGlkaW5nIGJvZGllcy5cbiAqXG4gKiBXaWxsIGRldGVjdCB0aGUgdHlwZSBvZiBib2RpZXMgaW4gdGhlIGNvbGxpc2lvbi5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5TmFycm93UGhhc2VcbiAqIEBwYXJhbSB7UGFydGljbGVbXX0gdGFyZ2V0c1xuICovXG5Db2xsaXNpb24ucHJvdG90eXBlLmFwcGx5TmFycm93UGhhc2UgPSBmdW5jdGlvbiBhcHBseU5hcnJvd1BoYXNlKHRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdmFyICBhID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgICAgIHZhciBiID0gdGFyZ2V0c1tqXTtcblxuICAgICAgICAgICAgaWYgKChhLmNvbGxpc2lvbk1hc2sgJiBiLmNvbGxpc2lvbkdyb3VwICYmIGEuY29sbGlzaW9uR3JvdXAgJiBiLmNvbGxpc2lvbk1hc2spID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvblR5cGUgPSBhLnR5cGUgfCBiLnR5cGU7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoW2NvbGxpc2lvblR5cGVdICYmIGRpc3BhdGNoW2NvbGxpc2lvblR5cGVdKHRoaXMsIGEsIGIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXRlY3RzIHNwaGVyZS1zcGhlcmUgY29sbGlzaW9ucyBhbmQgcmVnaXN0ZXJzIHRoZSBDb250YWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHNwaGVyZUludGVyc2VjdFNwaGVyZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUxXG4gKiBAcGFyYW0ge1NwaGVyZX0gc3BoZXJlMlxuICovXG5mdW5jdGlvbiBzcGhlcmVJbnRlcnNlY3RTcGhlcmUoY29udGV4dCwgc3BoZXJlMSwgc3BoZXJlMikge1xuICAgIHZhciBwMSA9IHNwaGVyZTEucG9zaXRpb247XG4gICAgdmFyIHAyID0gc3BoZXJlMi5wb3NpdGlvbjtcbiAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IFZlYzMuc3VidHJhY3QocDIsIHAxLCBuZXcgVmVjMygpKTtcbiAgICB2YXIgZGlzdGFuY2UgPSByZWxhdGl2ZVBvc2l0aW9uLmxlbmd0aCgpO1xuICAgIHZhciBzdW1SYWRpaSA9IHNwaGVyZTEucmFkaXVzICsgc3BoZXJlMi5yYWRpdXM7XG4gICAgdmFyIG4gPSByZWxhdGl2ZVBvc2l0aW9uLnNjYWxlKDEvZGlzdGFuY2UpO1xuXG4gICAgdmFyIG92ZXJsYXAgPSBzdW1SYWRpaSAtIGRpc3RhbmNlO1xuXG4gICAgLy8gRGlzdGFuY2UgY2hlY2tcbiAgICBpZiAob3ZlcmxhcCA8IDApIHJldHVybjtcblxuICAgIHZhciByU3BoZXJlMSA9IFZlYzMuc2NhbGUobiwgc3BoZXJlMS5yYWRpdXMsIG5ldyBWZWMzKCkpO1xuICAgIHZhciByU3BoZXJlMiA9IFZlYzMuc2NhbGUobiwgLXNwaGVyZTIucmFkaXVzLCBuZXcgVmVjMygpKTtcblxuICAgIHZhciB3U3BoZXJlMSA9IFZlYzMuYWRkKHAxLCByU3BoZXJlMSwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIHdTcGhlcmUyID0gVmVjMy5hZGQocDIsIHJTcGhlcmUyLCBuZXcgVmVjMygpKTtcblxuICAgIHZhciBjb2xsaXNpb25EYXRhID0gT01SZXF1ZXN0Q29sbGlzaW9uRGF0YSgpLnJlc2V0KG92ZXJsYXAsIG4sIHdTcGhlcmUxLCB3U3BoZXJlMiwgclNwaGVyZTEsIHJTcGhlcmUyKTtcblxuICAgIGNvbnRleHQuY29udGFjdE1hbmlmb2xkVGFibGUucmVnaXN0ZXJDb250YWN0KHNwaGVyZTEsIHNwaGVyZTIsIGNvbGxpc2lvbkRhdGEpO1xufVxuXG4vKipcbiogRGV0ZWN0cyBib3gtc3BoZXJlIGNvbGxpc2lvbnMgYW5kIHJlZ2lzdGVycyB0aGUgQ29udGFjdC5cbipcbiogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiogQHBhcmFtIHtCb3h9IGJveFxuKiBAcGFyYW0ge1NwaGVyZX0gc3BoZXJlXG4qL1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0U3BoZXJlKGNvbnRleHQsIGJveCwgc3BoZXJlKSB7XG4gICAgaWYgKGJveC50eXBlID09PSBTUEhFUkUpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBzcGhlcmU7XG4gICAgICAgIHNwaGVyZSA9IGJveDtcbiAgICAgICAgYm94ID0gdGVtcDtcbiAgICB9XG5cbiAgICB2YXIgcGIgPSBib3gucG9zaXRpb247XG4gICAgdmFyIHBzID0gc3BoZXJlLnBvc2l0aW9uO1xuICAgIHZhciByZWxhdGl2ZVBvc2l0aW9uID0gVmVjMy5zdWJ0cmFjdChwcywgcGIsIFZFQ19SRUdJU1RFUik7XG5cbiAgICB2YXIgcSA9IGJveC5vcmllbnRhdGlvbjtcblxuICAgIHZhciByID0gc3BoZXJlLnJhZGl1cztcblxuICAgIHZhciBic2l6ZSA9IGJveC5zaXplO1xuICAgIHZhciBoYWxmV2lkdGggPSBic2l6ZVswXSowLjU7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBic2l6ZVsxXSowLjU7XG4gICAgdmFyIGhhbGZEZXB0aCA9IGJzaXplWzJdKjAuNTtcblxuICAgIC8vIHgsIHksIHpcbiAgICB2YXIgYm5vcm1hbHMgPSBib3gubm9ybWFscztcbiAgICB2YXIgbjEgPSBxLnJvdGF0ZVZlY3Rvcihibm9ybWFsc1sxXSwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIG4yID0gcS5yb3RhdGVWZWN0b3IoYm5vcm1hbHNbMF0sIG5ldyBWZWMzKCkpO1xuICAgIHZhciBuMyA9IHEucm90YXRlVmVjdG9yKGJub3JtYWxzWzJdLCBuZXcgVmVjMygpKTtcblxuICAgIC8vIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBjdWJlIGNsb3Nlc3QgdG8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlXG4gICAgdmFyIGNsb3Nlc3RQb2ludCA9IG5ldyBWZWMzKCk7XG4gICAgY2xvc2VzdFBvaW50LnggPSBjbGFtcChWZWMzLmRvdChyZWxhdGl2ZVBvc2l0aW9uLG4xKSwgLWhhbGZXaWR0aCwgaGFsZldpZHRoKTtcbiAgICBjbG9zZXN0UG9pbnQueSA9IGNsYW1wKFZlYzMuZG90KHJlbGF0aXZlUG9zaXRpb24sbjIpLCAtaGFsZkhlaWdodCwgaGFsZkhlaWdodCk7XG4gICAgY2xvc2VzdFBvaW50LnogPSBjbGFtcChWZWMzLmRvdChyZWxhdGl2ZVBvc2l0aW9uLG4zKSwgLWhhbGZEZXB0aCwgaGFsZkRlcHRoKTtcbiAgICAvLyBUaGUgdmVjdG9yIGZvdW5kIGlzIHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHVucm90YXRlZCBib3ggLS0gcm90YXRlIGl0XG4gICAgLy8gdG8gZmluZCB0aGUgcG9pbnQgdy5yLnQuIHRvIGN1cnJlbnQgb3JpZW50YXRpb25cbiAgICBjbG9zZXN0UG9pbnQuYXBwbHlSb3RhdGlvbihxKTtcblxuICAgIC8vIFRoZSBpbXBhY3QgcG9pbnQgaW4gd29ybGQgc3BhY2VcbiAgICB2YXIgaW1wYWN0UG9pbnQgPSBWZWMzLmFkZChwYiwgY2xvc2VzdFBvaW50LCBuZXcgVmVjMygpKTtcbiAgICB2YXIgc3BoZXJlVG9JbXBhY3QgPSBWZWMzLnN1YnRyYWN0KGltcGFjdFBvaW50LCBwcywgaW1wYWN0UG9pbnQpO1xuICAgIHZhciBkaXN0YW5jZVRvU3BoZXJlID0gc3BoZXJlVG9JbXBhY3QubGVuZ3RoKCk7XG5cbiAgICAvLyBJZiBpbXBhY3QgcG9pbnQgaXMgbm90IGNsb3NlciB0byB0aGUgc3BoZXJlJ3MgY2VudGVyIHRoYW4gaXRzIHJhZGl1cyAtPiBubyBjb2xsaXNpb25cbiAgICB2YXIgb3ZlcmxhcCA9IHIgLSBkaXN0YW5jZVRvU3BoZXJlO1xuICAgIGlmIChvdmVybGFwIDwgMCkgcmV0dXJuO1xuXG4gICAgdmFyIG4gPSBWZWMzLnNjYWxlKHNwaGVyZVRvSW1wYWN0LCAtMSAvIGRpc3RhbmNlVG9TcGhlcmUsIG5ldyBWZWMzKCkpO1xuICAgIHZhciByQm94ID0gY2xvc2VzdFBvaW50O1xuICAgIHZhciByU3BoZXJlID0gc3BoZXJlVG9JbXBhY3Q7XG5cbiAgICB2YXIgd0JveCA9IFZlYzMuYWRkKHBiLCByQm94LCBuZXcgVmVjMygpKTtcbiAgICB2YXIgd1NwaGVyZSA9IFZlYzMuYWRkKHBzLCByU3BoZXJlLCBuZXcgVmVjMygpKTtcblxuICAgIHZhciBjb2xsaXNpb25EYXRhID0gT01SZXF1ZXN0Q29sbGlzaW9uRGF0YSgpLnJlc2V0KG92ZXJsYXAsIG4sIHdCb3gsIHdTcGhlcmUsIHJCb3gsIHJTcGhlcmUpO1xuXG4gICAgY29udGV4dC5jb250YWN0TWFuaWZvbGRUYWJsZS5yZWdpc3RlckNvbnRhY3QoYm94LCBzcGhlcmUsIGNvbGxpc2lvbkRhdGEpO1xufVxuXG4vKipcbiogRGV0ZWN0cyBjb252ZXgtY29udmV4IGNvbGxpc2lvbnMgYW5kIHJlZ2lzdGVycyB0aGUgQ29udGFjdC4gVXNlcyBHSksgdG8gZGV0ZXJtaW5lIG92ZXJsYXAgYW5kIHRoZW5cbiogRVBBIHRvIGRldGVybWluZSB0aGUgYWN0dWFsIGNvbGxpc2lvbiBkYXRhLlxuKlxuKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuKiBAcGFyYW0ge0NvbnZleEJvZHl9IGNvbnZleDFcbiogQHBhcmFtIHtDb252ZXhCb2R5fSBjb252ZXgyXG4qL1xuZnVuY3Rpb24gY29udmV4SW50ZXJzZWN0Q29udmV4KGNvbnRleHQsIGNvbnZleDEsIGNvbnZleDIpIHtcbiAgICB2YXIgZ2xrU2ltcGxleCA9IEdKSyhjb252ZXgxLCBjb252ZXgyKTtcblxuICAgIC8vIE5vIHNpbXBsZXggLT4gbm8gY29sbGlzaW9uXG4gICAgaWYgKCFnbGtTaW1wbGV4KSByZXR1cm47XG5cbiAgICB2YXIgY29sbGlzaW9uRGF0YSA9IEVQQShjb252ZXgxLCBjb252ZXgyLCBnbGtTaW1wbGV4KTtcbiAgICBpZiAoY29sbGlzaW9uRGF0YSAhPT0gbnVsbCkgY29udGV4dC5jb250YWN0TWFuaWZvbGRUYWJsZS5yZWdpc3RlckNvbnRhY3QoY29udmV4MSwgY29udmV4MiwgY29sbGlzaW9uRGF0YSk7XG59XG5cbi8qKlxuKiBEZXRlY3RzIGNvbnZleC13YWxsIGNvbGxpc2lvbnMgYW5kIHJlZ2lzdGVycyB0aGUgQ29udGFjdC5cbipcbiogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiogQHBhcmFtIHtDb252ZXhCb2R5fSBjb252ZXhcbiogQHBhcmFtIHtDb252ZXhCb2R5fSB3YWxsXG4qL1xuZnVuY3Rpb24gY29udmV4SW50ZXJzZWN0V2FsbChjb250ZXh0LCBjb252ZXgsIHdhbGwpIHtcbiAgICBpZiAoY29udmV4LnR5cGUgPT09IFdBTEwpIHtcbiAgICAgICAgdmFyIHRlbXAgPSB3YWxsO1xuICAgICAgICB3YWxsID0gY29udmV4O1xuICAgICAgICBjb252ZXggPSB0ZW1wO1xuICAgIH1cblxuICAgIHZhciBjb252ZXhQb3MgPSBjb252ZXgucG9zaXRpb247XG4gICAgdmFyIHdhbGxQb3MgPSB3YWxsLnBvc2l0aW9uO1xuXG4gICAgdmFyIG4gPSB3YWxsLm5vcm1hbDtcbiAgICB2YXIgaW52TiA9IHdhbGwuaW52Tm9ybWFsO1xuXG4gICAgdmFyIHJDb252ZXggPSBjb252ZXguc3VwcG9ydChpbnZOKTtcbiAgICB2YXIgd0NvbnZleCA9IFZlYzMuYWRkKGNvbnZleFBvcywgckNvbnZleCwgbmV3IFZlYzMoKSk7XG5cbiAgICB2YXIgZGlmZiA9IFZlYzMuc3VidHJhY3Qod0NvbnZleCwgd2FsbFBvcywgVkVDX1JFR0lTVEVSKTtcblxuICAgIHZhciBwZW5ldHJhdGlvbiA9IFZlYzMuZG90KGRpZmYsIGludk4pO1xuXG4gICAgaWYgKHBlbmV0cmF0aW9uIDwgMCkgcmV0dXJuO1xuXG4gICAgdmFyIHdXYWxsID0gVmVjMy5zY2FsZShuLCBwZW5ldHJhdGlvbiwgbmV3IFZlYzMoKSkuYWRkKHdDb252ZXgpO1xuICAgIHZhciByV2FsbCA9IFZlYzMuc3VidHJhY3Qod1dhbGwsIHdhbGwucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuXG4gICAgdmFyIGNvbGxpc2lvbkRhdGEgPSBPTVJlcXVlc3RDb2xsaXNpb25EYXRhKCkucmVzZXQocGVuZXRyYXRpb24sIGludk4sIHdDb252ZXgsIHdXYWxsLCByQ29udmV4LCByV2FsbCk7XG5cbiAgICBjb250ZXh0LmNvbnRhY3RNYW5pZm9sZFRhYmxlLnJlZ2lzdGVyQ29udGFjdChjb252ZXgsIHdhbGwsIGNvbGxpc2lvbkRhdGEpO1xufVxuXG5Db2xsaXNpb24uU3dlZXBBbmRQcnVuZSA9IFN3ZWVwQW5kUHJ1bmU7XG5Db2xsaXNpb24uQnJ1dGVGb3JjZSA9IEJydXRlRm9yY2UuQnJ1dGVGb3JjZTtcbkNvbGxpc2lvbi5CcnV0ZUZvcmNlQUFCQiA9IEJydXRlRm9yY2UuQnJ1dGVGb3JjZUFBQkI7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9JRCA9IDA7XG4vKipcbiAqIEJhc2UgQ29uc3RyYWludCBjbGFzcyB0byBiZSB1c2VkIGluIHRoZSBQaHlzaWNzXG4gKiBTdWJjbGFzcyB0aGlzIGNsYXNzIHRvIGltcGxlbWVudCBhIGNvbnN0cmFpbnRcbiAqXG4gKiBAdmlydHVhbFxuICogQGNsYXNzIENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gQ29uc3RyYWludChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fSUQgPSBfSUQrKztcbn1cblxuLyoqXG4gKiBEZWNvcmF0ZXMgdGhlIENvbnN0cmFpbnQgd2l0aCB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQG1ldGhvZCBzZXRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uc1xuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCBpbnZva2VkIHVwb24gaW5zdGFudGlhdGlvbiBhbmQgdGhlIHNldHRpbmcgb2Ygb3B0aW9ucy5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHt9O1xuXG4vKipcbiAqIERldGVjdCB2aW9sYXRpb25zIG9mIHRoZSBjb25zdHJhaW50LiBXYXJtIHN0YXJ0IHRoZSBjb25zdHJhaW50LCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHt9O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgdGhlIGNvbnN0cmFpbnQuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHRpbWUsIGR0KSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG5cbnZhciBJTVBVTFNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBOT1JNQUxfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKiogQGNvbnN0ICovXG52YXIgRVBTSUxTT04gPSAxZS03O1xuLyoqIEBjb25zdCAqL1xudmFyIFBJID0gTWF0aC5QSTtcblxuXG4vKipcbiAqICBBIGNvbnN0cmFpbnQgdGhhdCBrZWVwcyBhIHBoeXNpY3MgYm9keSBvbiBhIGdpdmVuIGltcGxpY2l0IGN1cnZlLlxuICpcbiAqICBAY2xhc3MgQ3VydmVcbiAqICBAY29uc3RydWN0b3JcbiAqICBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKi9cbmZ1bmN0aW9uIEN1cnZlKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0cykge1xuICAgICAgICBpZiAodGFyZ2V0cyBpbnN0YW5jZW9mIEFycmF5KSB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgICAgICBlbHNlIHRoaXMudGFyZ2V0cyA9IFt0YXJnZXRzXTtcbiAgICB9XG4gICAgZWxzZSB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW1wdWxzZXMgPSB7fTtcbiAgICB0aGlzLm5vcm1hbHMgPSB7fTtcbiAgICB0aGlzLnZlbG9jaXR5Qmlhc2VzID0ge307XG4gICAgdGhpcy5kaXZpc29ycyA9IHt9O1xufVxuXG5DdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnN0cmFpbnQucHJvdG90eXBlKTtcbkN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1cnZlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIEN1cnZlLiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqL1xuQ3VydmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVxdWF0aW9uMSA9IHRoaXMuZXF1YXRpb24xIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIHRoaXMuZXF1YXRpb24yID0gdGhpcy5lcXVhdGlvbjIgfHwgZnVuY3Rpb24oeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gejtcbiAgICB9O1xuICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMTtcbiAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IHRoaXMuZGFtcGluZ1JhdGlvIHx8IDAuNTtcblxuICAgIHRoaXMuc3RpZmZuZXNzID0gNCAqIFBJICogUEkgLyAodGhpcy5wZXJpb2QgKiB0aGlzLnBlcmlvZCk7XG4gICAgdGhpcy5kYW1waW5nID0gNCAqIFBJICogdGhpcy5kYW1waW5nUmF0aW8gLyB0aGlzLnBlcmlvZDtcbn07XG5cbi8qKlxuICogV2FybXN0YXJ0IHRoZSBjb25zdHJhaW50IGFuZCBwcmVwYXJlIGNhbGN1bGF0aW9ucyB1c2VkIGluIHRoZSAucmVzb2x2ZSBzdGVwLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkN1cnZlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcblxuICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xuICAgIHZhciB2ZWxvY2l0eUJpYXNlcyA9IHRoaXMudmVsb2NpdHlCaWFzZXM7XG4gICAgdmFyIGRpdmlzb3JzID0gdGhpcy5kaXZpc29ycztcbiAgICB2YXIgaW1wdWxzZXMgPSB0aGlzLmltcHVsc2VzO1xuXG4gICAgdmFyIGltcHVsc2UgPSBJTVBVTFNFX1JFR0lTVEVSO1xuICAgIHZhciBuID0gTk9STUFMX1JFR0lTVEVSO1xuXG4gICAgdmFyIGYgPSB0aGlzLmVxdWF0aW9uMTtcbiAgICB2YXIgZyA9IHRoaXMuZXF1YXRpb24yO1xuXG4gICAgdmFyIF9jID0gdGhpcy5kYW1waW5nO1xuICAgIHZhciBfayA9IHRoaXMuc3RpZmZuZXNzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgSUQgPSBib2R5Ll9JRDtcbiAgICAgICAgaWYgKGJvZHkuaW1tdW5lKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgcCA9IGJvZHkucG9zaXRpb247XG4gICAgICAgIHZhciBtID0gYm9keS5tYXNzO1xuXG4gICAgICAgIHZhciBnYW1tYTtcbiAgICAgICAgdmFyIGJldGE7XG5cbiAgICAgICAgaWYgKHRoaXMucGVyaW9kID09PSAwKSB7XG4gICAgICAgICAgICBnYW1tYSA9IDA7XG4gICAgICAgICAgICBiZXRhID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjID0gX2MgKiBtO1xuICAgICAgICAgICAgdmFyIGsgPSBfayAqIG07XG5cbiAgICAgICAgICAgIGdhbW1hID0gMSAvIChkdCooYyArIGR0KmspKTtcbiAgICAgICAgICAgIGJldGEgID0gZHQqayAvIChjICsgZHQqayk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHAueDtcbiAgICAgICAgdmFyIHkgPSBwLnk7XG4gICAgICAgIHZhciB6ID0gcC56O1xuXG4gICAgICAgIHZhciBmMCA9IGYoeCwgeSwgeik7XG4gICAgICAgIHZhciBkZnggPSAoZih4ICsgRVBTSUxTT04sIHksIHopIC0gZjApIC8gRVBTSUxTT047XG4gICAgICAgIHZhciBkZnkgPSAoZih4LCB5ICsgRVBTSUxTT04sIHopIC0gZjApIC8gRVBTSUxTT047XG4gICAgICAgIHZhciBkZnogPSAoZih4LCB5LCB6ICsgRVBTSUxTT04pIC0gZjApIC8gRVBTSUxTT047XG5cbiAgICAgICAgdmFyIGcwID0gZyh4LCB5LCB6KTtcbiAgICAgICAgdmFyIGRneCA9IChnKHggKyBFUFNJTFNPTiwgeSwgeikgLSBnMCkgLyBFUFNJTFNPTjtcbiAgICAgICAgdmFyIGRneSA9IChnKHgsIHkgKyBFUFNJTFNPTiwgeikgLSBnMCkgLyBFUFNJTFNPTjtcbiAgICAgICAgdmFyIGRneiA9IChnKHgsIHksIHogKyBFUFNJTFNPTikgLSBnMCkgLyBFUFNJTFNPTjtcblxuICAgICAgICBuLnNldChkZnggKyBkZ3gsIGRmeSArIGRneSwgZGZ6ICsgZGd6KTtcbiAgICAgICAgbi5ub3JtYWxpemUoKTtcblxuICAgICAgICB2YXIgYmF1bWdhcnRlID0gYmV0YSAqIChmMCArIGcwKSAvIGR0O1xuICAgICAgICB2YXIgZGl2aXNvciA9IGdhbW1hICsgMSAvIG07XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9IGltcHVsc2VzW0lEXSB8fCAwO1xuICAgICAgICBWZWMzLnNjYWxlKG4sIGxhbWJkYSwgaW1wdWxzZSk7XG4gICAgICAgIGJvZHkuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuXG4gICAgICAgIG5vcm1hbHNbSURdID0gbm9ybWFsc1tJRF0gfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgbm9ybWFsc1tJRF0uY29weShuKTtcbiAgICAgICAgdmVsb2NpdHlCaWFzZXNbSURdID0gYmF1bWdhcnRlO1xuICAgICAgICBkaXZpc29yc1tJRF0gPSBkaXZpc29yO1xuICAgICAgICBpbXB1bHNlc1tJRF0gPSAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkcyBhIGN1cnZlIGltcHVsc2UgdG8gYSBwaHlzaWNzIGJvZHkuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cbkN1cnZlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcblxuICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xuICAgIHZhciB2ZWxvY2l0eUJpYXNlcyA9IHRoaXMudmVsb2NpdHlCaWFzZXM7XG4gICAgdmFyIGRpdmlzb3JzID0gdGhpcy5kaXZpc29ycztcbiAgICB2YXIgaW1wdWxzZXMgPSB0aGlzLmltcHVsc2VzO1xuXG4gICAgdmFyIGltcHVsc2UgPSBJTVBVTFNFX1JFR0lTVEVSO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgSUQgPSBib2R5Ll9JRDtcbiAgICAgICAgaWYgKGJvZHkuaW1tdW5lKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgdiA9IGJvZHkudmVsb2NpdHk7XG4gICAgICAgIHZhciBuID0gbm9ybWFsc1tJRF07XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9IC0oVmVjMy5kb3QobiwgdikgKyB2ZWxvY2l0eUJpYXNlc1tJRF0pIC8gZGl2aXNvcnNbSURdO1xuXG4gICAgICAgIFZlYzMuc2NhbGUobiwgbGFtYmRhLCBpbXB1bHNlKTtcbiAgICAgICAgYm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG5cblxuICAgICAgICBpbXB1bHNlc1tJRF0gKz0gbGFtYmRhO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VydmU7IiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG5cbnZhciBOT1JNQUxfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIElNUFVMU0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFBfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIERJUkVDVElPTl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKiBAY29uc3QgKi9cbnZhciBQSSA9IE1hdGguUEk7XG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IG1haW50YWlucyB0aGUgZGlyZWN0aW9uIG9mIG9uZSBib2R5IGZyb20gYW5vdGhlci5cbiAqXG4gKiAgQGNsYXNzIERpcmVjdGlvblxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBEaXJlY3Rpb24oYSwgYiwgb3B0aW9ucykge1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW1wdWxzZSA9IDA7XG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5ub3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudmVsb2NpdHlCaWFzID0gMDtcbiAgICB0aGlzLmRpdmlzb3IgPSAwO1xufVxuXG5EaXJlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb25zdHJhaW50LnByb3RvdHlwZSk7XG5EaXJlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0aW9uO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIERpcmVjdGlvbi4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKi9cbkRpcmVjdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb24gfHwgVmVjMy5zdWJ0cmFjdCh0aGlzLmIucG9zaXRpb24sIHRoaXMuYS5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG4gICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgdGhpcy5taW5MZW5ndGggPSB0aGlzLm1pbkxlbmd0aCB8fCAwO1xuICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMC4yO1xuICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gdGhpcy5kYW1waW5nUmF0aW8gfHwgMC41O1xuXG4gICAgdGhpcy5zdGlmZm5lc3MgPSA0ICogUEkgKiBQSSAvICh0aGlzLnBlcmlvZCAqIHRoaXMucGVyaW9kKTtcbiAgICB0aGlzLmRhbXBpbmcgPSA0ICogUEkgKiB0aGlzLmRhbXBpbmdSYXRpbyAvIHRoaXMucGVyaW9kO1xufTtcblxuLyoqXG4gKiBXYXJtc3RhcnQgdGhlIGNvbnN0cmFpbnQgYW5kIHByZXBhcmUgY2FsY3VsYXRpb25zIHVzZWQgaW4gLnJlc29sdmUuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuRGlyZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBuID0gTk9STUFMX1JFR0lTVEVSO1xuICAgIHZhciBkaWZmUCA9IFBfUkVHSVNURVI7XG4gICAgdmFyIGltcHVsc2UgPSBJTVBVTFNFX1JFR0lTVEVSO1xuICAgIHZhciBkaXJlY3Rpb25WZWN0b3IgPSBESVJFQ1RJT05fUkVHSVNURVI7XG5cbiAgICB2YXIgcDEgPSBhLnBvc2l0aW9uO1xuICAgIHZhciB3MSA9IGEuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgcDIgPSBiLnBvc2l0aW9uO1xuICAgIHZhciB3MiA9IGIuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG5cbiAgICBWZWMzLnN1YnRyYWN0KHAyLCBwMSwgZGlmZlApO1xuICAgIFZlYzMuc2NhbGUoZGlyZWN0aW9uLCBWZWMzLmRvdChkaXJlY3Rpb24sIGRpZmZQKSwgZGlyZWN0aW9uVmVjdG9yKTtcbiAgICB2YXIgZ29hbCA9IGRpcmVjdGlvblZlY3Rvci5hZGQocDEpO1xuXG4gICAgVmVjMy5zdWJ0cmFjdChwMiwgZ29hbCwgbik7XG4gICAgdmFyIGRpc3QgPSBuLmxlbmd0aCgpO1xuICAgIG4ubm9ybWFsaXplKCk7XG5cbiAgICB2YXIgaW52RWZmZWN0aXZlTWFzcyA9IHcxICsgdzI7XG4gICAgdmFyIGVmZmVjdGl2ZU1hc3MgPSAxIC8gaW52RWZmZWN0aXZlTWFzcztcbiAgICB2YXIgZ2FtbWE7XG4gICAgdmFyIGJldGE7XG5cbiAgICBpZiAodGhpcy5wZXJpb2QgPT09IDApIHtcbiAgICAgICAgZ2FtbWEgPSAwO1xuICAgICAgICBiZXRhICA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYyA9IHRoaXMuZGFtcGluZyAqIGVmZmVjdGl2ZU1hc3M7XG4gICAgICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MgKiBlZmZlY3RpdmVNYXNzO1xuXG4gICAgICAgIGdhbW1hID0gMSAvIChkdCooYyArIGR0KmspKTtcbiAgICAgICAgYmV0YSAgPSBkdCprIC8gKGMgKyBkdCprKTtcbiAgICB9XG5cbiAgICB2YXIgYmF1bWdhcnRlID0gYmV0YSAqIGRpc3QgLyBkdDtcbiAgICB2YXIgZGl2aXNvciA9IGdhbW1hICsgaW52RWZmZWN0aXZlTWFzcztcblxuICAgIHZhciBsYW1iZGEgPSB0aGlzLmltcHVsc2U7XG4gICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgdGhpcy5ub3JtYWwuY29weShuKTtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdDtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyA9IGJhdW1nYXJ0ZTtcbiAgICB0aGlzLmRpdmlzb3IgPSBkaXZpc29yO1xuICAgIHRoaXMuaW1wdWxzZSA9IDA7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gaW1wdWxzZSB0byBhIHBoeXNpY3MgYm9keSdzIHZlbG9jaXR5IGR1ZSB0byB0aGUgY29uc3RyYWludFxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5EaXJlY3Rpb24ucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgaW1wdWxzZSAgPSBJTVBVTFNFX1JFR0lTVEVSO1xuICAgIHZhciBkaWZmViA9IFZfUkVHSVNURVI7XG5cbiAgICB2YXIgbWluTGVuZ3RoID0gdGhpcy5taW5MZW5ndGg7XG5cbiAgICB2YXIgZGlzdCA9IHRoaXMuZGlzdGFuY2U7XG4gICAgaWYgKE1hdGguYWJzKGRpc3QpIDwgbWluTGVuZ3RoKSByZXR1cm47XG5cbiAgICB2YXIgdjEgPSBhLnZlbG9jaXR5O1xuICAgIHZhciB2MiA9IGIudmVsb2NpdHk7XG4gICAgdmFyIG4gPSB0aGlzLm5vcm1hbDtcblxuICAgIFZlYzMuc3VidHJhY3QodjIsIHYxLCBkaWZmVik7XG5cbiAgICB2YXIgbGFtYmRhID0gLShWZWMzLmRvdChuLCBkaWZmVikgKyB0aGlzLnZlbG9jaXR5QmlhcykgLyB0aGlzLmRpdmlzb3I7XG4gICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgdGhpcy5pbXB1bHNlICs9IGxhbWJkYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlyZWN0aW9uO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG5cbnZhciBOT1JNQUxfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIElNUFVMU0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFBfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKiogQGNvbnN0ICovXG52YXIgUEkgPSBNYXRoLlBJO1xuXG4vKipcbiAqICBBIGNvbnN0cmFpbnQgdGhhdCBrZWVwcyB0d28gYm9kaWVzIHdpdGhpbiBhIGNlcnRhaW4gZGlzdGFuY2UuXG4gKlxuICogIEBjbGFzcyBEaXN0YW5jZVxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBEaXN0YW5jZShhLCBiLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbXB1bHNlID0gMDtcbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICB0aGlzLm5vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgPSAwO1xuICAgIHRoaXMuZGl2aXNvciA9IDA7XG59XG5cbkRpc3RhbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuRGlzdGFuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlzdGFuY2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRGlzdGFuY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5EaXN0YW5jZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgVmVjMy5zdWJ0cmFjdCh0aGlzLmIucG9zaXRpb24sIHRoaXMuYS5wb3NpdGlvbiwgUF9SRUdJU1RFUikubGVuZ3RoKCk7XG4gICAgdGhpcy5taW5MZW5ndGggPSB0aGlzLm1pbkxlbmd0aCB8fCAwO1xuICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMC4yO1xuICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gdGhpcy5kYW1waW5nUmF0aW8gfHwgMC41O1xuXG4gICAgdGhpcy5zdGlmZm5lc3MgPSA0ICogUEkgKiBQSSAvICh0aGlzLnBlcmlvZCAqIHRoaXMucGVyaW9kKTtcbiAgICB0aGlzLmRhbXBpbmcgPSA0ICogUEkgKiB0aGlzLmRhbXBpbmdSYXRpbyAvIHRoaXMucGVyaW9kO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgdmlvbGF0aW9ucyBvZiB0aGUgY29uc3RyYWludC4gV2FybSBzdGFydCB0aGUgY29uc3RyYWludCwgaWYgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuRGlzdGFuY2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHRpbWUsIGR0KSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgbiA9IE5PUk1BTF9SRUdJU1RFUjtcbiAgICB2YXIgZGlmZlAgPSBQX1JFR0lTVEVSO1xuICAgIHZhciBpbXB1bHNlID0gSU1QVUxTRV9SRUdJU1RFUjtcblxuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgIHZhciBwMSA9IGEucG9zaXRpb247XG4gICAgdmFyIHcxID0gYS5pbnZlcnNlTWFzcztcblxuICAgIHZhciBwMiA9IGIucG9zaXRpb247XG4gICAgdmFyIHcyID0gYi5pbnZlcnNlTWFzcztcblxuICAgIFZlYzMuc3VidHJhY3QocDIsIHAxLCBkaWZmUCk7XG5cbiAgICB2YXIgc2VwYXJhdGlvbiA9IGRpZmZQLmxlbmd0aCgpO1xuXG4gICAgVmVjMy5zY2FsZShkaWZmUCwgMSAvIHNlcGFyYXRpb24sIG4pO1xuXG4gICAgdmFyIGRpc3QgPSBzZXBhcmF0aW9uIC0gbGVuZ3RoO1xuXG4gICAgdmFyIGludkVmZmVjdGl2ZU1hc3MgPSB3MSArIHcyO1xuICAgIHZhciBlZmZlY3RpdmVNYXNzID0gMSAvIGludkVmZmVjdGl2ZU1hc3M7XG4gICAgdmFyIGdhbW1hO1xuICAgIHZhciBiZXRhO1xuXG4gICAgaWYgKHRoaXMucGVyaW9kID09PSAwKSB7XG4gICAgICAgIGdhbW1hID0gMDtcbiAgICAgICAgYmV0YSAgPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmRhbXBpbmcgKiBlZmZlY3RpdmVNYXNzO1xuICAgICAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzICogZWZmZWN0aXZlTWFzcztcblxuICAgICAgICBnYW1tYSA9IDEgLyAoZHQqKGMgKyBkdCprKSk7XG4gICAgICAgIGJldGEgID0gZHQqayAvIChjICsgZHQqayk7XG4gICAgfVxuXG4gICAgdmFyIGJhdW1nYXJ0ZSA9IGJldGEgKiBkaXN0IC8gZHQ7XG4gICAgdmFyIGRpdmlzb3IgPSBnYW1tYSArIGludkVmZmVjdGl2ZU1hc3M7XG5cbiAgICB2YXIgbGFtYmRhID0gdGhpcy5pbXB1bHNlO1xuICAgIFZlYzMuc2NhbGUobiwgbGFtYmRhLCBpbXB1bHNlKTtcbiAgICBiLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBhLmFwcGx5SW1wdWxzZShpbXB1bHNlLmludmVydCgpKTtcblxuICAgIHRoaXMubm9ybWFsLmNvcHkobik7XG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3Q7XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgPSBiYXVtZ2FydGU7XG4gICAgdGhpcy5kaXZpc29yID0gZGl2aXNvcjtcbiAgICB0aGlzLmltcHVsc2UgPSAwO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlcyB0byByZXNvbHZlIHRoZSBjb25zdHJhaW50LlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5EaXN0YW5jZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgaW1wdWxzZSA9IElNUFVMU0VfUkVHSVNURVI7XG4gICAgdmFyIGRpZmZWID0gVl9SRUdJU1RFUjtcblxuICAgIHZhciBtaW5MZW5ndGggPSB0aGlzLm1pbkxlbmd0aDtcblxuICAgIHZhciBkaXN0ID0gdGhpcy5kaXN0YW5jZTtcbiAgICBpZiAoTWF0aC5hYnMoZGlzdCkgPCBtaW5MZW5ndGgpIHJldHVybjtcblxuICAgIHZhciB2MSA9IGEuZ2V0VmVsb2NpdHkoKTtcbiAgICB2YXIgdjIgPSBiLmdldFZlbG9jaXR5KCk7XG5cbiAgICB2YXIgbiA9IHRoaXMubm9ybWFsO1xuXG4gICAgVmVjMy5zdWJ0cmFjdCh2MiwgdjEsIGRpZmZWKTtcbiAgICB2YXIgbGFtYmRhID0gLShWZWMzLmRvdChuLCBkaWZmVikgKyB0aGlzLnZlbG9jaXR5QmlhcykgLyB0aGlzLmRpdmlzb3I7XG4gICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgdGhpcy5pbXB1bHNlICs9IGxhbWJkYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2U7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvTWF0MzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG5cbnZhciBWRUMxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWRUMyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWRUMzX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWRUM0X1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWQjFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZCMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgV3hSX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBERUxUQV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IGNvbmZpbmVzIHR3byBib2RpZXMgdG8gdGhlIHBsYW5lIGRlZmluZWQgYnkgdGhlIGF4aXMgb2YgdGhlIGhpbmdlLlxuICpcbiAqICBAY2xhc3MgSGluZ2VcbiAqICBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiAgQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gQW4gb2JqZWN0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICpcbiAqL1xuZnVuY3Rpb24gSGluZ2UoYSwgYiwgb3B0aW9ucykge1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5lcnJvciA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5lcnJvclJvdCA9IFswLDBdO1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeCA9IG5ldyBNYXQzMygpO1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeFJvdCA9IFtdO1xufVxuXG5IaW5nZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnN0cmFpbnQucHJvdG90eXBlKTtcbkhpbmdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhpbmdlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIEhpbmdlLiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqL1xuSGluZ2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IHRoaXMuYW5jaG9yO1xuXG4gICAgdmFyIHUgPSB0aGlzLmF4aXMubm9ybWFsaXplKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBxMXQgPSBRdWF0ZXJuaW9uLmNvbmp1Z2F0ZShhLm9yaWVudGF0aW9uLCBuZXcgUXVhdGVybmlvbigpKTtcbiAgICB2YXIgcTJ0ID0gUXVhdGVybmlvbi5jb25qdWdhdGUoYi5vcmllbnRhdGlvbiwgbmV3IFF1YXRlcm5pb24oKSk7XG5cbiAgICB0aGlzLnJBID0gVmVjMy5zdWJ0cmFjdCh3LCBhLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLnJCID0gVmVjMy5zdWJ0cmFjdCh3LCBiLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcblxuICAgIHRoaXMuYm9keVJBID0gcTF0LnJvdGF0ZVZlY3Rvcih0aGlzLnJBLCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLmJvZHlSQiA9IHEydC5yb3RhdGVWZWN0b3IodGhpcy5yQiwgbmV3IFZlYzMoKSk7XG5cbiAgICB0aGlzLmF4aXNBID0gVmVjMy5jbG9uZSh1KTtcbiAgICB0aGlzLmF4aXNCID0gVmVjMy5jbG9uZSh1KTtcblxuICAgIHRoaXMuYXhpc0JUYW5nZW50MSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5heGlzQlRhbmdlbnQyID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMudDF4QSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50MnhBID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMuYm9keUF4aXNBID0gcTF0LnJvdGF0ZVZlY3Rvcih1LCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLmJvZHlBeGlzQiA9IHEydC5yb3RhdGVWZWN0b3IodSwgbmV3IFZlYzMoKSk7XG59O1xuXG4vKipcbiAqIERldGVjdCB2aW9sYXRpb25zIG9mIHRoZSBjb25zdHJhaW50LiBXYXJtIHN0YXJ0IHRoZSBjb25zdHJhaW50LCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5IaW5nZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odGltZSwgZHQpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBheGlzQSA9IGEub3JpZW50YXRpb24ucm90YXRlVmVjdG9yKHRoaXMuYm9keUF4aXNBLCB0aGlzLmF4aXNBKTtcbiAgICB2YXIgYXhpc0IgPSBiLm9yaWVudGF0aW9uLnJvdGF0ZVZlY3Rvcih0aGlzLmJvZHlBeGlzQiwgdGhpcy5heGlzQik7XG4gICAgdGhpcy5heGlzLmNvcHkoYXhpc0IpO1xuXG4gICAgdmFyIG4gPSBheGlzQjtcbiAgICB2YXIgdDEgPSB0aGlzLmF4aXNCVGFuZ2VudDE7XG4gICAgdmFyIHQyID0gdGhpcy5heGlzQlRhbmdlbnQyO1xuXG4gICAgaWYgKG4ueCA+PSAwLjU3NzM1KSB7XG4gICAgICAgIHQxLnNldChuLnksIC1uLngsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdDEuc2V0KDAsIG4ueiwgLW4ueSk7XG4gICAgfVxuICAgIHQxLm5vcm1hbGl6ZSgpO1xuICAgIFZlYzMuY3Jvc3MobiwgdDEsIHQyKTtcblxuICAgIHZhciB0MXhBID0gVmVjMy5jcm9zcyh0MSwgYXhpc0EsIHRoaXMudDF4QSk7XG4gICAgdmFyIHQyeEEgPSBWZWMzLmNyb3NzKHQyLCBheGlzQSwgdGhpcy50MnhBKTtcblxuICAgIHZhciByQSA9IGEub3JpZW50YXRpb24ucm90YXRlVmVjdG9yKHRoaXMuYm9keVJBLCB0aGlzLnJBKTtcbiAgICB2YXIgckIgPSBiLm9yaWVudGF0aW9uLnJvdGF0ZVZlY3Rvcih0aGlzLmJvZHlSQiwgdGhpcy5yQik7XG5cbiAgICB2YXIgeFJBID0gbmV3IE1hdDMzKFswLHJBLnosLXJBLnksLXJBLnosMCxyQS54LHJBLnksLXJBLngsMF0pO1xuICAgIHZhciB4UkIgPSBuZXcgTWF0MzMoWzAsckIueiwtckIueSwtckIueiwwLHJCLngsckIueSwtckIueCwwXSk7XG5cbiAgICB2YXIgUklhUnQgPSBNYXQzMy5tdWx0aXBseSh4UkEsIGEuaW52ZXJzZUluZXJ0aWEsIG5ldyBNYXQzMygpKS5tdWx0aXBseSh4UkEudHJhbnNwb3NlKCkpO1xuICAgIHZhciBSSWJSdCA9IE1hdDMzLm11bHRpcGx5KHhSQiwgYi5pbnZlcnNlSW5lcnRpYSwgbmV3IE1hdDMzKCkpLm11bHRpcGx5KHhSQi50cmFuc3Bvc2UoKSk7XG5cbiAgICB2YXIgaW52RWZmSW5lcnRpYSA9IE1hdDMzLmFkZChSSWFSdCwgUkliUnQsIFJJYVJ0KTtcblxuICAgIHZhciB3b3JsZEEgPSBWZWMzLmFkZChhLnBvc2l0aW9uLCB0aGlzLnJBLCB0aGlzLmFuY2hvcik7XG4gICAgdmFyIHdvcmxkQiA9IFZlYzMuYWRkKGIucG9zaXRpb24sIHRoaXMuckIsIFZFQzFfUkVHSVNURVIpO1xuXG4gICAgdmFyIGludkR0ID0gMS9kdDtcbiAgICBWZWMzLnN1YnRyYWN0KHdvcmxkQiwgd29ybGRBLCB0aGlzLmVycm9yKTtcbiAgICB0aGlzLmVycm9yLnNjYWxlKDAuMippbnZEdCk7XG5cbiAgICB2YXIgaW1BID0gYS5pbnZlcnNlTWFzcztcbiAgICB2YXIgaW1CID0gYi5pbnZlcnNlTWFzcztcblxuICAgIHZhciBpbnZFZmZNYXNzID0gbmV3IE1hdDMzKFtpbUEgKyBpbUIsMCwwLDAsaW1BICsgaW1CLDAsMCwwLGltQSArIGltQl0pO1xuXG4gICAgTWF0MzMuYWRkKGludkVmZkluZXJ0aWEsIGludkVmZk1hc3MsIHRoaXMuZWZmTWFzc01hdHJpeCk7XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4LmludmVyc2UoKTtcblxuICAgIHZhciBpbnZJQXQxeEEgPSBhLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHQxeEEsIFZFQzFfUkVHSVNURVIpO1xuICAgIHZhciBpbnZJQXQyeEEgPSBhLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHQyeEEsIFZFQzJfUkVHSVNURVIpO1xuICAgIHZhciBpbnZJQnQxeEEgPSBiLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHQxeEEsIFZFQzNfUkVHSVNURVIpO1xuICAgIHZhciBpbnZJQnQyeEEgPSBiLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHQyeEEsIFZFQzRfUkVHSVNURVIpO1xuXG4gICAgdmFyIGExMSA9IFZlYzMuZG90KHQxeEEsIGludklBdDF4QSkgKyBWZWMzLmRvdCh0MXhBLCBpbnZJQnQxeEEpO1xuICAgIHZhciBhMTIgPSBWZWMzLmRvdCh0MXhBLCBpbnZJQXQyeEEpICsgVmVjMy5kb3QodDF4QSwgaW52SUJ0MnhBKTtcbiAgICB2YXIgYTIxID0gVmVjMy5kb3QodDJ4QSwgaW52SUF0MXhBKSArIFZlYzMuZG90KHQyeEEsIGludklCdDF4QSk7XG4gICAgdmFyIGEyMiA9IFZlYzMuZG90KHQyeEEsIGludklBdDJ4QSkgKyBWZWMzLmRvdCh0MnhBLCBpbnZJQnQyeEEpO1xuXG4gICAgdmFyIGRldCA9IDEgLyAoYTExKmEyMiAtIGExMiphMjEpO1xuXG4gICAgdGhpcy5lZmZNYXNzTWF0cml4Um90WzBdID0gYTIyICogZGV0O1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeFJvdFsxXSA9IC1hMjEgKiBkZXQ7XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4Um90WzJdID0gLWExMiAqIGRldDtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXhSb3RbM10gPSBhMTEgKiBkZXQ7XG5cbiAgICB0aGlzLmVycm9yUm90WzBdID0gVmVjMy5kb3QoYXhpc0EsIHQxKSAqIDAuMippbnZEdDtcbiAgICB0aGlzLmVycm9yUm90WzFdID0gVmVjMy5kb3QoYXhpc0EsIHQyKSAqIDAuMippbnZEdDtcblxuICAgIHZhciBpbXB1bHNlID0gdGhpcy5pbXB1bHNlLnNjYWxlKDAuNSk7XG4gICAgdmFyIGFuZ0ltcHVsc2VBID0gdGhpcy5hbmdJbXB1bHNlQS5zY2FsZSgwLjUpO1xuICAgIHZhciBhbmdJbXB1bHNlQiA9IHRoaXMuYW5nSW1wdWxzZUIuc2NhbGUoMC41KTtcblxuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGIuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQik7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcbiAgICBhLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUEpO1xuXG4gICAgaW1wdWxzZS5jbGVhcigpO1xuICAgIGFuZ0ltcHVsc2VBLmNsZWFyKCk7XG4gICAgYW5nSW1wdWxzZUIuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZXMgdG8gcmVzb2x2ZSB0aGUgY29uc3RyYWludC5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuSGluZ2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHZhciBhID0gdGhpcy5hO1xuICAgIHZhciBiID0gdGhpcy5iO1xuXG4gICAgdmFyIHJBID0gdGhpcy5yQTtcbiAgICB2YXIgckIgPSB0aGlzLnJCO1xuXG4gICAgdmFyIHQxeEEgPSB0aGlzLnQxeEE7XG4gICAgdmFyIHQyeEEgPSB0aGlzLnQyeEE7XG5cbiAgICB2YXIgdzEgPSBhLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB2YXIgdzIgPSBiLmFuZ3VsYXJWZWxvY2l0eTtcblxuICAgIHZhciB2MSA9IFZlYzMuYWRkKGEudmVsb2NpdHksIFZlYzMuY3Jvc3ModzEsIHJBLCBXeFJfUkVHSVNURVIpLCBWQjFfUkVHSVNURVIpO1xuICAgIHZhciB2MiA9IFZlYzMuYWRkKGIudmVsb2NpdHksIFZlYzMuY3Jvc3ModzIsIHJCLCBXeFJfUkVHSVNURVIpLCBWQjJfUkVHSVNURVIpO1xuXG4gICAgdmFyIGltcHVsc2UgPSB2MS5zdWJ0cmFjdCh2Mikuc3VidHJhY3QodGhpcy5lcnJvcikuYXBwbHlNYXRyaXgodGhpcy5lZmZNYXNzTWF0cml4KTtcblxuICAgIHZhciBkaWZmVyA9IFZlYzMuc3VidHJhY3QodzIsIHcxLCBERUxUQV9SRUdJU1RFUik7XG5cbiAgICB2YXIgZXJyb3JSb3QgPSB0aGlzLmVycm9yUm90O1xuICAgIHZhciBqdjEgPSBWZWMzLmRvdCh0MXhBLCBkaWZmVykgKyBlcnJvclJvdFswXTtcbiAgICB2YXIganYyID0gVmVjMy5kb3QodDJ4QSwgZGlmZlcpICsgZXJyb3JSb3RbMV07XG5cbiAgICB2YXIgSyA9IHRoaXMuZWZmTWFzc01hdHJpeFJvdDtcblxuICAgIHZhciBsMSA9IC0oS1swXSpqdjEgKyBLWzFdKmp2Mik7XG4gICAgdmFyIGwyID0gLShLWzJdKmp2MSArIEtbM10qanYyKTtcblxuICAgIHZhciBhbmdJbXB1bHNlID0gVmVjMy5zY2FsZSh0MXhBLCBsMSwgVkVDMl9SRUdJU1RFUikuYWRkKFZlYzMuc2NhbGUodDJ4QSwgbDIsIFZFQzNfUkVHSVNURVIpKTtcblxuICAgIHZhciBhbmdJbXB1bHNlQiA9IFZlYzMuY3Jvc3MockIsIGltcHVsc2UsIFZFQzFfUkVHSVNURVIpLmFkZChhbmdJbXB1bHNlKTtcbiAgICB2YXIgYW5nSW1wdWxzZUEgPSBWZWMzLmNyb3NzKHJBLCBpbXB1bHNlLCBWRUM0X1JFR0lTVEVSKS5pbnZlcnQoKS5zdWJ0cmFjdChhbmdJbXB1bHNlKTtcblxuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGIuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQik7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcbiAgICBhLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUEpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG5cbiAgICB0aGlzLmltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUEuYWRkKGFuZ0ltcHVsc2VBKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VCLmFkZChhbmdJbXB1bHNlQik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhpbmdlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBeGlzLWFsaWduZWQgYm91bmRpbmcgYm94LiBVc2VkIGluIGNvbGxpc2lvbiBicm9hZHBoYXNlcy5cbiAqXG4gKiBAY2xhc3MgQUFCQlxuICovXG5mdW5jdGlvbiBBQUJCKGJvZHkpIHtcbiAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICB0aGlzLl9JRCA9IGJvZHkuX0lEO1xuICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMudmVydGljZXMgPSB7XG4gICAgICAgIHg6IFtdLFxuICAgICAgICB5OiBbXSxcbiAgICAgICAgejogW11cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlKCk7XG59XG5cbnZhciBTUEhFUkUgPSAxIDw8IDI7XG52YXIgV0FMTCA9IDEgPDwgMztcblxudmFyIERPV04gPSAwO1xudmFyIFVQID0gMTtcbnZhciBMRUZUID0gMjtcbnZhciBSSUdIVCA9IDM7XG52YXIgRk9SV0FSRCA9IDQ7XG52YXIgQkFDS1dBUkQgPSA1O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRzIHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gYW5kIHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgQm9keS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5BQUJCLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9keSA9IHRoaXMuX2JvZHk7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24gPSBib2R5LnBvc2l0aW9uO1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xuICAgIHZhciBtaW5aID0gSW5maW5pdHksIG1heFogPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgdHlwZSA9IGJvZHkudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gU1BIRVJFKSB7XG4gICAgICAgIG1heFggPSBtYXhZID0gbWF4WiA9IGJvZHkucmFkaXVzO1xuICAgICAgICBtaW5YID0gbWluWSA9IG1pblogPSAtYm9keS5yYWRpdXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFdBTEwpIHtcbiAgICAgICAgdmFyIGQgPSBib2R5LmRpcmVjdGlvbjtcbiAgICAgICAgbWF4WCA9IG1heFkgPSBtYXhaID0gMWU2O1xuICAgICAgICBtaW5YID0gbWluWSA9IG1pblogPSAtMWU2O1xuICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICAgIGNhc2UgRE9XTjpcbiAgICAgICAgICAgICAgICBtYXhZID0gMjU7XG4gICAgICAgICAgICAgICAgbWluWSA9IC0xZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVQOlxuICAgICAgICAgICAgICAgIG1heFkgPSAxZTM7XG4gICAgICAgICAgICAgICAgbWluWSA9IC0yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTEVGVDpcbiAgICAgICAgICAgICAgICBtYXhYID0gMjU7XG4gICAgICAgICAgICAgICAgbWluWCA9IC0xZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJJR0hUOlxuICAgICAgICAgICAgICAgIG1heFggPSAxZTM7XG4gICAgICAgICAgICAgICAgbWluWCA9IC0yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRk9SV0FSRDpcbiAgICAgICAgICAgICAgICBtYXhaID0gMjU7XG4gICAgICAgICAgICAgICAgbWluWiA9IC0xZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJBQ0tXQVJEOlxuICAgICAgICAgICAgICAgIG1heFogPSAxZTM7XG4gICAgICAgICAgICAgICAgbWluWiA9IC0yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChib2R5LnZlcnRpY2VzKSB7XG4gICAgICAgIC8vIENvbnZleEJvZHlcbiAgICAgICAgdmFyIGJvZHlWZXJ0aWNlcyA9IGJvZHkudmVydGljZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBib2R5VmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBib2R5VmVydGljZXNbaV07XG4gICAgICAgICAgICBpZiAodmVydGV4LnggPCBtaW5YKSBtaW5YID0gdmVydGV4Lng7XG4gICAgICAgICAgICBpZiAodmVydGV4LnggPiBtYXhYKSBtYXhYID0gdmVydGV4Lng7XG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPCBtaW5ZKSBtaW5ZID0gdmVydGV4Lnk7XG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPiBtYXhZKSBtYXhZID0gdmVydGV4Lnk7XG4gICAgICAgICAgICBpZiAodmVydGV4LnogPCBtaW5aKSBtaW5aID0gdmVydGV4Lno7XG4gICAgICAgICAgICBpZiAodmVydGV4LnogPiBtYXhaKSBtYXhaID0gdmVydGV4Lno7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJ0aWNsZVxuICAgICAgICBtYXhYID0gbWF4WSA9IG1heFogPSAyNTtcbiAgICAgICAgbWluWCA9IG1pblkgPSBtaW5aID0gLTI1O1xuICAgIH1cbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZlcnRpY2VzLnhbMF0gPSBtaW5YICsgcG9zLng7XG4gICAgdmVydGljZXMueFsxXSA9IG1heFggKyBwb3MueDtcbiAgICB2ZXJ0aWNlcy55WzBdID0gbWluWSArIHBvcy55O1xuICAgIHZlcnRpY2VzLnlbMV0gPSBtYXhZICsgcG9zLnk7XG4gICAgdmVydGljZXMuelswXSA9IG1pblogKyBwb3MuejtcbiAgICB2ZXJ0aWNlcy56WzFdID0gbWF4WiArIHBvcy56O1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3Igb3ZlcmxhcCBiZXR3ZWVuIHR3byBBQUJCJ3MuXG4gKlxuICogQG1ldGhvZCBjaGVja092ZXJsYXBcbiAqIEBwYXJhbSB7QUFCQn0gYWFiYjFcbiAqIEBwYXJhbSB7QUFCQn0gYWFiYjJcbiAqL1xuQUFCQi5jaGVja092ZXJsYXAgPSBmdW5jdGlvbihhYWJiMSwgYWFiYjIpIHtcbiAgICB2YXIgdmVydGljZXMxID0gYWFiYjEudmVydGljZXM7XG4gICAgdmFyIHZlcnRpY2VzMiA9IGFhYmIyLnZlcnRpY2VzO1xuXG4gICAgdmFyIHgxMCA9IHZlcnRpY2VzMS54WzBdO1xuICAgIHZhciB4MTEgPSB2ZXJ0aWNlczEueFsxXTtcbiAgICB2YXIgeDIwID0gdmVydGljZXMyLnhbMF07XG4gICAgdmFyIHgyMSA9IHZlcnRpY2VzMi54WzFdO1xuICAgIGlmICgoeDIwIDw9IHgxMCAmJiB4MTAgPD0geDIxKSB8fCAoeDEwIDw9IHgyMCAmJiB4MjAgPD0geDExKSkge1xuICAgICAgICB2YXIgeTEwID0gdmVydGljZXMxLnlbMF07XG4gICAgICAgIHZhciB5MTEgPSB2ZXJ0aWNlczEueVsxXTtcbiAgICAgICAgdmFyIHkyMCA9IHZlcnRpY2VzMi55WzBdO1xuICAgICAgICB2YXIgeTIxID0gdmVydGljZXMyLnlbMV07XG4gICAgICAgIGlmICgoeTIwIDw9IHkxMCAmJiB5MTAgPD0geTIxKSB8fCAoeTEwIDw9IHkyMCAmJiB5MjAgPD0geTExKSkge1xuICAgICAgICAgICAgdmFyIHoxMCA9IHZlcnRpY2VzMS56WzBdO1xuICAgICAgICAgICAgdmFyIHoxMSA9IHZlcnRpY2VzMS56WzFdO1xuICAgICAgICAgICAgdmFyIHoyMCA9IHZlcnRpY2VzMi56WzBdO1xuICAgICAgICAgICAgdmFyIHoyMSA9IHZlcnRpY2VzMi56WzFdO1xuICAgICAgICAgICAgaWYgKCh6MjAgPD0gejEwICYmIHoxMCA8PSB6MjEpIHx8ICh6MTAgPD0gejIwICYmIHoyMCA8PSB6MTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQUFCQi52ZXJ0ZXhUaHJlc2hvbGQgPSAxMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gQUFCQjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBQUJCID0gcmVxdWlyZSgnLi9BQUJCJyk7XG5cbi8qKlxuICogTyhuXjIpIGNvbXBhcmlzb25zIHdpdGggYW4gQUFCQiBjaGVjayBmb3IgYSBtaWRwaGFzZS4gTGlrZWx5IHRvIGJlIG1vcmUgcGVyZm9ybWFudFxuICogdGhhdCB0aGUgQnJ1dGVGb3JjZSB3aGVuIHRoZSBib2RpZXMgaGF2ZSBtYW55IHZlcnRpY2VzLiBPbmx5IGZlYXNpYmxlIGZvciBhIHNtYWxsIG51bWJlciBvZiBib2RpZXMuXG4gKlxuICogQGNsYXNzIEJydXRlRm9yQUFCQlxuICogQHBhcmFtIHtQYXJ0aWNsZXNbXX0gdGFyZ2V0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQnJ1dGVGb3JjZUFBQkIodGFyZ2V0cykge1xuICAgIHRoaXMuX3ZvbHVtZXMgPSBbXTtcbiAgICB0aGlzLl9lbnRpdHlSZWdpc3RyeSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXRzW2ldKTtcbiAgICB9XG59XG5cbi8qKlxuICogU3RhcnQgdHJhY2tpbmcgYSBQYXJ0aWNsZS5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keVxuICovXG5CcnV0ZUZvcmNlQUFCQi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGJvZHkpIHtcbiAgICB2YXIgYm91bmRpbmdWb2x1bWUgPSBuZXcgQUFCQihib2R5KTtcblxuICAgIHRoaXMuX2VudGl0eVJlZ2lzdHJ5W2JvZHkuX0lEXSA9IGJvZHk7XG4gICAgdGhpcy5fdm9sdW1lcy5wdXNoKGJvdW5kaW5nVm9sdW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIHBvc3NpYmxlIGNvbGxpc2lvbiBwYWlycywgY3VsbGVkIGJ5IGFuIEFBQkIgaW50ZXJzZWN0aW9uIHRlc3QuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEByZXR1cm4ge1BhcnRpY2xlW11bXX1cbiAqL1xuQnJ1dGVGb3JjZUFBQkIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgX3ZvbHVtZXMgPSB0aGlzLl92b2x1bWVzO1xuICAgIHZhciBfZW50aXR5UmVnaXN0cnkgPSB0aGlzLl9lbnRpdHlSZWdpc3RyeTtcblxuICAgIGZvciAodmFyIGsgPSAwLCBsZW4gPSBfdm9sdW1lcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBfdm9sdW1lc1trXS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRhcmdldHMgPSBfdm9sdW1lcy5sZW5ndGg7IGkgPCBudW1UYXJnZXRzOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbnVtVGFyZ2V0czsgaisrKSB7XG4gICAgICAgICAgICBpZiAoQUFCQi5jaGVja092ZXJsYXAoX3ZvbHVtZXNbaV0sIF92b2x1bWVzW2pdKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtfZW50aXR5UmVnaXN0cnlbaV0sIF9lbnRpdHlSZWdpc3RyeVtqXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRoZSBtb3N0IHNpbXBsZSB5ZXQgY29tcHV0YXRpb25hbGx5IGludGVuc2l2ZSBicm9hZC1waGFzZS4gSW1tZWRpYXRlbHkgcGFzc2VzIGl0cyB0YXJnZXRzIHRvIHRoZSBuYXJyb3ctcGhhc2UsXG4gKiByZXN1bHRpbmcgaW4gYW4gTyhuXjIpIHByb2Nlc3MuIE9ubHkgZmVhc2libGUgZm9yIGEgcmVsYXRpdmVseSBzbWFsbCBudW1iZXIgb2YgYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBCcnV0ZUZvcmNlXG4gKiBAcGFyYW0ge1BhcnRpY2xlW119IHRhcmdldHNcbiAqL1xuZnVuY3Rpb24gQnJ1dGVGb3JjZSh0YXJnZXRzKSB7XG4gICAgdGhpcy50YXJnZXRzID0gdGFyZ2V0cztcbn1cblxuLyoqXG4gKiBTdGFydCB0cmFja2luZyBhIFBhcnRpY2xlLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5XG4gKi9cbkJydXRlRm9yY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChib2R5KSB7XG4gICAgdGhpcy50YXJnZXRzLnB1c2goYm9keSk7XG59O1xuXG4vKipcbiAqIEltbWVkaWF0ZWx5IHJldHVybnMgYW4gYXJyYXkgb2YgcG9zc2libGUgY29sbGlzaW9ucy5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHJldHVybiB7UGFydGljbGVbXVtdfVxuICovXG5CcnV0ZUZvcmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnRhcmdldHNdO1xufTtcblxubW9kdWxlLmV4cG9ydHMuQnJ1dGVGb3JjZUFBQkIgPSBCcnV0ZUZvcmNlQUFCQjtcbm1vZHVsZS5leHBvcnRzLkJydXRlRm9yY2UgPSBCcnV0ZUZvcmNlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgvVmVjMycpO1xudmFyIE9iamVjdE1hbmFnZXIgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsaXRpZXMvT2JqZWN0TWFuYWdlcicpO1xuXG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyKCdNYW5pZm9sZCcsIE1hbmlmb2xkKTtcbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIoJ0NvbnRhY3QnLCBDb250YWN0KTtcbnZhciBPTVJlcXVlc3RNYW5pZm9sZCA9IE9iamVjdE1hbmFnZXIucmVxdWVzdE1hbmlmb2xkO1xudmFyIE9NUmVxdWVzdENvbnRhY3QgPSBPYmplY3RNYW5hZ2VyLnJlcXVlc3RDb250YWN0O1xudmFyIE9NRnJlZU1hbmlmb2xkID0gT2JqZWN0TWFuYWdlci5mcmVlTWFuaWZvbGQ7XG52YXIgT01GcmVlQ29udGFjdCA9IE9iamVjdE1hbmFnZXIuZnJlZUNvbnRhY3Q7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNsYW1wIGEgdmFsdWUgdG8gYSBnaXZlbiByYW5nZS5cbiAqXG4gKiBAbWV0aG9kIGNsYW1wXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dlclxuICogQHBhcmFtIHtOdW1iZXJ9IHVwcGVyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbG93ZXIsIHVwcGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgbG93ZXIgPyBsb3dlciA6IHZhbHVlID4gdXBwZXIgPyB1cHBlciA6IHZhbHVlO1xufVxuXG52YXIgVkVDMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkVDMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWQjJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFd4Ul9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgUjFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFIyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBOT1JNQUxJTVBVTFNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBUQU5HRU5USU1QVUxTRTFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFRBTkdFTlRJTVBVTFNFMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgV0FfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFdCX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBQRU5FVFJBVElOR19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgRFJJRlRBX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBEUklGVEJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFRhYmxlIG1haW50YWluaW5nIGFuZCBtYW5hZ2luZyBjdXJyZW50IGNvbnRhY3QgbWFuaWZvbGRzLlxuICpcbiAqIEBjbGFzcyBDb250YWN0TWFuaWZvbGRUYWJsZVxuICovXG5mdW5jdGlvbiBDb250YWN0TWFuaWZvbGRUYWJsZSgpIHtcbiAgICB0aGlzLm1hbmlmb2xkcyA9IFtdO1xuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4ID0ge307XG4gICAgdGhpcy5fSURQb29sID0gW107XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbnRhY3QgbWFuaWZvbGQuIFRyYWNrZWQgYnkgdGhlIGNvbGxpc2lvbk1hdHJpeCBhY2NvcmRpbmcgdG9cbiAqIGl0cyBsb3ctaGlnaCBvcmRlcmVkIElEIHBhaXIuXG4gKlxuICogQG1ldGhvZCBhZGRNYW5pZm9sZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd0lkXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaElEXG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5QVxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keUJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYW5pZm9sZH1cbiAqL1xuQ29udGFjdE1hbmlmb2xkVGFibGUucHJvdG90eXBlLmFkZE1hbmlmb2xkID0gZnVuY3Rpb24gYWRkTWFuaWZvbGQobG93SUQsIGhpZ2hJRCwgYm9keUEsIGJvZHlCKSB7XG4gICAgdmFyIGNvbGxpc2lvbk1hdHJpeCA9IHRoaXMuY29sbGlzaW9uTWF0cml4O1xuICAgIGNvbGxpc2lvbk1hdHJpeFtsb3dJRF0gPSBjb2xsaXNpb25NYXRyaXhbbG93SURdIHx8IHt9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fSURQb29sLmxlbmd0aCA/IHRoaXMuX0lEUG9vbC5wb3AoKSA6IHRoaXMubWFuaWZvbGRzLmxlbmd0aDtcbiAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFtsb3dJRF1baGlnaElEXSA9IGluZGV4O1xuICAgIHZhciBtYW5pZm9sZCA9IE9NUmVxdWVzdE1hbmlmb2xkKCkucmVzZXQobG93SUQsIGhpZ2hJRCwgYm9keUEsIGJvZHlCKTtcbiAgICB0aGlzLm1hbmlmb2xkc1tpbmRleF0gPSBtYW5pZm9sZDtcblxuICAgIHJldHVybiBtYW5pZm9sZDtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgbWFuaWZvbGQgYW5kIGZyZWUgaXQgZm9yIGxhdGVyIHJldXNlLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlTWFuaWZvbGRcbiAqIEBwYXJhbSB7Q29udGFjdE1hbmlmb2xkfSBtYW5pZm9sZFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5yZW1vdmVNYW5pZm9sZCA9IGZ1bmN0aW9uIHJlbW92ZU1hbmlmb2xkKG1hbmlmb2xkLCBpbmRleCkge1xuICAgIHZhciBjb2xsaXNpb25NYXRyaXggPSB0aGlzLmNvbGxpc2lvbk1hdHJpeDtcblxuICAgIHRoaXMubWFuaWZvbGRzW2luZGV4XSA9IG51bGw7XG4gICAgY29sbGlzaW9uTWF0cml4W21hbmlmb2xkLmxvd0lEXVttYW5pZm9sZC5oaWdoSURdID0gbnVsbDtcbiAgICB0aGlzLl9JRFBvb2wucHVzaChpbmRleCk7XG5cbiAgICBPTUZyZWVNYW5pZm9sZChtYW5pZm9sZCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBlYWNoIG9mIHRoZSBtYW5pZm9sZHMsIHJlbW92aW5nIHRob3NlIHRoYXQgbm8gbG9uZ2VyIGNvbnRhaW4gY29udGFjdCBwb2ludHMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdFxuICovXG5Db250YWN0TWFuaWZvbGRUYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG4gICAgdmFyIG1hbmlmb2xkcyA9IHRoaXMubWFuaWZvbGRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYW5pZm9sZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG1hbmlmb2xkID0gbWFuaWZvbGRzW2ldO1xuICAgICAgICBpZiAoIW1hbmlmb2xkKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHBlcnNpc3RzID0gbWFuaWZvbGQudXBkYXRlKGR0KTtcbiAgICAgICAgaWYgKCFwZXJzaXN0cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVNYW5pZm9sZChtYW5pZm9sZCwgaSk7XG4gICAgICAgICAgICBtYW5pZm9sZC5ib2R5QS5ldmVudHMudHJpZ2dlcignY29sbGlzaW9uOmVuZCcsIG1hbmlmb2xkKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmJvZHlCLmV2ZW50cy50cmlnZ2VyKCdjb2xsaXNpb246ZW5kJywgbWFuaWZvbGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBXYXJtIHN0YXJ0IGFsbCBDb250YWN0cywgYW5kIHBlcmZvcm0gcHJlY2FsY3VsYXRpb25zIG5lZWRlZCBpbiB0aGUgaXRlcmF0aXZlIHNvbHZlci5cbiAqXG4gKiBAbWV0aG9kIHByZXBDb250YWN0c1xuICogQHBhcmFtIHtOdW1iZXJ9IGR0XG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5wcmVwQ29udGFjdHMgPSBmdW5jdGlvbiBwcmVwQ29udGFjdHMoZHQpIHtcbiAgICB2YXIgbWFuaWZvbGRzID0gdGhpcy5tYW5pZm9sZHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hbmlmb2xkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbWFuaWZvbGQgPSBtYW5pZm9sZHNbaV07XG4gICAgICAgIGlmICghbWFuaWZvbGQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgY29udGFjdHMgPSBtYW5pZm9sZC5jb250YWN0cztcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBjb250YWN0cy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjb250YWN0ID0gY29udGFjdHNbal07XG4gICAgICAgICAgICBpZiAoIWNvbnRhY3QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29udGFjdC51cGRhdGUoZHQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGFsbCBjb250YWN0IG1hbmlmb2xkcy5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVNYW5pZm9sZHNcbiAqL1xuQ29udGFjdE1hbmlmb2xkVGFibGUucHJvdG90eXBlLnJlc29sdmVNYW5pZm9sZHMgPSBmdW5jdGlvbiByZXNvbHZlTWFuaWZvbGRzKCkge1xuICAgIHZhciBtYW5pZm9sZHMgPSB0aGlzLm1hbmlmb2xkcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFuaWZvbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBtYW5pZm9sZCA9IG1hbmlmb2xkc1tpXTtcbiAgICAgICAgaWYgKCFtYW5pZm9sZCkgY29udGludWU7XG4gICAgICAgIG1hbmlmb2xkLnJlc29sdmVDb250YWN0cygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IENvbnRhY3QsIGFsc28gY3JlYXRpbmcgYSBuZXcgTWFuaWZvbGQgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoYXQgcGFpci5cbiAqXG4gKiBAbWV0aG9kIHJlZ2lzdGVyQ29udGFjdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5yZWdpc3RlckNvbnRhY3QgPSBmdW5jdGlvbiByZWdpc3RlckNvbnRhY3QoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKSB7XG4gICAgdmFyIGxvd0lEO1xuICAgIHZhciBoaWdoSUQ7XG5cbiAgICBpZiAoYm9keUEuX0lEIDwgYm9keUIuX0lEKSB7XG4gICAgICAgIGxvd0lEID0gYm9keUEuX0lEO1xuICAgICAgICBoaWdoSUQgPSBib2R5Qi5fSUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG93SUQgPSBib2R5Qi5fSUQ7XG4gICAgICAgIGhpZ2hJRCA9IGJvZHlBLl9JRDtcbiAgICB9XG5cbiAgICB2YXIgbWFuaWZvbGRzID0gdGhpcy5tYW5pZm9sZHM7XG4gICAgdmFyIGNvbGxpc2lvbk1hdHJpeCA9IHRoaXMuY29sbGlzaW9uTWF0cml4O1xuICAgIHZhciBtYW5pZm9sZDtcbiAgICBpZiAoIWNvbGxpc2lvbk1hdHJpeFtsb3dJRF0gfHwgY29sbGlzaW9uTWF0cml4W2xvd0lEXVtoaWdoSURdID09IG51bGwpIHtcbiAgICAgICAgbWFuaWZvbGQgPSB0aGlzLmFkZE1hbmlmb2xkKGxvd0lELCBoaWdoSUQsIGJvZHlBLCBib2R5Qik7XG4gICAgICAgIG1hbmlmb2xkLmFkZENvbnRhY3QoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKTtcbiAgICAgICAgYm9keUEuZXZlbnRzLnRyaWdnZXIoJ2NvbGxpc2lvbjpzdGFydCcsIG1hbmlmb2xkKTtcbiAgICAgICAgYm9keUIuZXZlbnRzLnRyaWdnZXIoJ2NvbGxpc2lvbjpzdGFydCcsIG1hbmlmb2xkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYW5pZm9sZCA9IG1hbmlmb2xkc1sgY29sbGlzaW9uTWF0cml4W2xvd0lEXVtoaWdoSURdIF07XG4gICAgICAgIG1hbmlmb2xkLmNvbnRhaW5zKGNvbGxpc2lvbkRhdGEpO1xuICAgICAgICBtYW5pZm9sZC5hZGRDb250YWN0KGJvZHlBLCBib2R5QiwgY29sbGlzaW9uRGF0YSk7XG4gICAgfVxufTtcblxudmFyIFRIUkVTSE9MRCA9IDEwO1xuXG4vKipcbiAqIENsYXNzIHRvIGtlZXAgdHJhY2sgb2YgQ29udGFjdCBwb2ludHMuXG4gKiBAY2xhc3MgbWFuaWZvbGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hJZFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBNYW5pZm9sZChsb3dJRCwgaGlnaElELCBib2R5QSwgYm9keUIpIHtcbiAgICB0aGlzLmxvd0lEID0gbG93SUQ7XG4gICAgdGhpcy5oaWdoSUQgPSBoaWdoSUQ7XG5cbiAgICB0aGlzLmNvbnRhY3RzID0gW107XG4gICAgdGhpcy5udW1Db250YWN0cyA9IDA7XG5cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgdGhpcy5scnUgPSAwO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCB0aGUgb2JqZWN0IHdpdGggZGlmZmVyZW50IGRhdGEuXG4gKlxuICogQG1ldGhvZCByZXNldFxuICogQHBhcmFtIHtPYmplY3RbXX0gYXJnc1xuICogQGNoYWluYWJsZVxuICovXG5NYW5pZm9sZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldChsb3dJRCwgaGlnaElELCBib2R5QSwgYm9keUIpIHtcbiAgICB0aGlzLmxvd0lEID0gbG93SUQ7XG4gICAgdGhpcy5oaWdoSUQgPSBoaWdoSUQ7XG5cbiAgICB0aGlzLmNvbnRhY3RzID0gW107XG4gICAgdGhpcy5udW1Db250YWN0cyA9IDA7XG5cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgdGhpcy5scnUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBDb250YWN0IHBvaW50IGFuZCBhZGQgaXQgdG8gdGhlIE1hbmlmb2xkLlxuICpcbiAqIEBtZXRob2QgYWRkQ29udGFjdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKi9cbk1hbmlmb2xkLnByb3RvdHlwZS5hZGRDb250YWN0ID0gZnVuY3Rpb24gYWRkQ29udGFjdChib2R5QSwgYm9keUIsIGNvbGxpc2lvbkRhdGEpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmxydTtcbiAgICBpZiAodGhpcy5jb250YWN0c1tpbmRleF0pIHRoaXMucmVtb3ZlQ29udGFjdCh0aGlzLmNvbnRhY3RzW2luZGV4XSwgaW5kZXgpO1xuICAgIHRoaXMuY29udGFjdHNbaW5kZXhdID0gT01SZXF1ZXN0Q29udGFjdCgpLnJlc2V0KGJvZHlBLCBib2R5QiwgY29sbGlzaW9uRGF0YSk7XG4gICAgdGhpcy5scnUgPSAodGhpcy5scnUgKyAxKSAlIDQ7XG4gICAgdGhpcy5udW1Db250YWN0cysrO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW5kIGZyZWUgYSBDb250YWN0IGZvciBsYXRlciByZXVzZS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnRhY3RcbiAqIEBwYXJhbSB7Q29udGFjdH0gY29udGFjdFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKi9cbk1hbmlmb2xkLnByb3RvdHlwZS5yZW1vdmVDb250YWN0ID0gZnVuY3Rpb24gcmVtb3ZlQ29udGFjdChjb250YWN0LCBpbmRleCkge1xuICAgIHRoaXMuY29udGFjdHNbaW5kZXhdID0gbnVsbDtcbiAgICB0aGlzLm51bUNvbnRhY3RzLS07XG5cbiAgICBPYmplY3RNYW5hZ2VyLmZyZWVDb2xsaXNpb25EYXRhKGNvbnRhY3QuZGF0YSk7XG4gICAgY29udGFjdC5kYXRhID0gbnVsbDtcbiAgICBPTUZyZWVDb250YWN0KGNvbnRhY3QpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIENvbnRhY3QgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBjb2xsaXNpb24gZGF0YSB3aXRoaW4gYSBjZXJ0YWluIHRvbGVyYW5jZS5cbiAqIElmIGZvdW5kLCByZW1vdmUgdGhlIENvbnRhY3QuXG4gKlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5NYW5pZm9sZC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhjb2xsaXNpb25EYXRhKSB7XG4gICAgdmFyIHdBID0gY29sbGlzaW9uRGF0YS53b3JsZENvbnRhY3RBO1xuICAgIHZhciB3QiA9IGNvbGxpc2lvbkRhdGEud29ybGRDb250YWN0QjtcblxuICAgIHZhciBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRhY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb250YWN0ID0gY29udGFjdHNbaV07XG4gICAgICAgIGlmICghY29udGFjdCkgY29udGludWU7XG4gICAgICAgIHZhciBkYXRhID0gY29udGFjdC5kYXRhO1xuICAgICAgICB2YXIgZGlzdEEgPSBWZWMzLnN1YnRyYWN0KGRhdGEud29ybGRDb250YWN0QSwgd0EsIERSSUZUQV9SRUdJU1RFUikubGVuZ3RoKCk7XG4gICAgICAgIHZhciBkaXN0QiA9IFZlYzMuc3VidHJhY3QoZGF0YS53b3JsZENvbnRhY3RCLCB3QiwgRFJJRlRCX1JFR0lTVEVSKS5sZW5ndGgoKTtcblxuICAgICAgICBpZiAoZGlzdEEgPCBUSFJFU0hPTEQgfHwgZGlzdEIgPCBUSFJFU0hPTEQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdChjb250YWN0LCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgQ29udGFjdHMgdGhlIGxvY2FsIHBvaW50cyBvZiB3aGljaCBoYXZlIGRyaWZ0ZWQgYWJvdmUgYSBjZXJ0YWluIHRvbGVyYW5jZS5cbiAqIFJldHVybiB0cnVlIG9yIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgdGhlIE1hbmlmb2xkIHN0aWxsIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBDb250YWN0LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFuaWZvbGQgcGVyc2lzdHNcbiAqL1xuTWFuaWZvbGQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzO1xuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgdmFyIGJvZHlCID0gdGhpcy5ib2R5QjtcblxuICAgIHZhciBwb3NBID0gYm9keUEucG9zaXRpb247XG4gICAgdmFyIHBvc0IgPSBib2R5Qi5wb3NpdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb250YWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29udGFjdCA9IGNvbnRhY3RzW2ldO1xuICAgICAgICBpZiAoIWNvbnRhY3QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZGF0YSA9IGNvbnRhY3QuZGF0YTtcbiAgICAgICAgdmFyIG4gPSBkYXRhLm5vcm1hbDtcbiAgICAgICAgdmFyIHJBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgICAgICB2YXIgckIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICAgICAgdmFyIGNhY2hlZF93QSA9IGRhdGEud29ybGRDb250YWN0QTtcbiAgICAgICAgdmFyIGNhY2hlZF93QiA9IGRhdGEud29ybGRDb250YWN0QjtcblxuICAgICAgICB2YXIgd0EgPSBWZWMzLmFkZChwb3NBLCByQSwgV0FfUkVHSVNURVIpO1xuICAgICAgICB2YXIgd0IgPSBWZWMzLmFkZChwb3NCLCByQiwgV0JfUkVHSVNURVIpO1xuXG4gICAgICAgIHZhciBub3RQZW5ldHJhdGluZyA9IFZlYzMuZG90KFZlYzMuc3VidHJhY3Qod0IsIHdBLCBQRU5FVFJBVElOR19SRUdJU1RFUiksIG4pID4gMDtcblxuICAgICAgICB2YXIgZHJpZnRBID0gVmVjMy5zdWJ0cmFjdChjYWNoZWRfd0EsIHdBLCBEUklGVEFfUkVHSVNURVIpO1xuICAgICAgICB2YXIgZHJpZnRCID0gVmVjMy5zdWJ0cmFjdChjYWNoZWRfd0IsIHdCLCBEUklGVEJfUkVHSVNURVIpO1xuXG5cbiAgICAgICAgaWYgKGRyaWZ0QS5sZW5ndGgoKSA+PSBUSFJFU0hPTEQgfHwgZHJpZnRCLmxlbmd0aCgpID49IFRIUkVTSE9MRCB8fCBub3RQZW5ldHJhdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb250YWN0KGNvbnRhY3QsIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubnVtQ29udGFjdHMpIHJldHVybiB0cnVlO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIGFsbCBjb250YWN0cy5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVDb250YWN0c1xuICovXG5NYW5pZm9sZC5wcm90b3R5cGUucmVzb2x2ZUNvbnRhY3RzID0gZnVuY3Rpb24gcmVzb2x2ZUNvbnRhY3RzKCkge1xuICAgIHZhciBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRhY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghY29udGFjdHNbaV0pIGNvbnRpbnVlO1xuICAgICAgICBjb250YWN0c1tpXS5yZXNvbHZlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGFzcyB0byBtYWludGFpbiBjb2xsaXNpb24gZGF0YSBiZXR3ZWVuIHR3byBib2RpZXMuXG4gKiBUaGUgZW5kIG9mIHRoZSByZXNvbHZlIGNoYWluLCBhbmQgd2hlcmUgdGhlIGFjdHVhbCBpbXB1bHNlcyBhcmUgYXBwbGllZC5cbiAqXG4gKiBAY2xhc3MgQ29udGFjdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3QoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKSB7XG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcbiAgICB0aGlzLmRhdGEgPSBjb2xsaXNpb25EYXRhO1xuXG4gICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMSA9IDA7XG4gICAgdGhpcy50YW5nZW50SW1wdWxzZTIgPSAwO1xuXG4gICAgdGhpcy5pbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VCID0gbmV3IFZlYzMoKTtcblxuICAgIGlmIChjb2xsaXNpb25EYXRhKSB0aGlzLmluaXQoKTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IE9iamVjdE1hbmFnZXIgdG8gcmVzZXQgdGhlIG9iamVjdCB3aXRoIGRpZmZlcmVudCBkYXRhLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7T2JqZWN0W119IGFyZ3NcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29udGFjdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldChib2R5QSwgYm9keUIsIGNvbGxpc2lvbkRhdGEpIHtcbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuICAgIHRoaXMuZGF0YSA9IGNvbGxpc2lvbkRhdGE7XG5cbiAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UxID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMiA9IDA7XG5cbiAgICB0aGlzLmltcHVsc2UuY2xlYXIoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBLmNsZWFyKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQi5jbGVhcigpO1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gbWV0aG9kIGNhbGxlZCBvbiBpbnN0YW50aWFudGlvbiBvciByZXNldCBvZiB0aGUgQ29udGFjdC4gUGVyZm9ybXNcbiAqIHByZWNhbGN1bGF0aW9ucyB0aGF0IHdpbGwgbm90IGNoYW5nZSBvdmVyIHRoZSBsaWZlIG9mIHRoZSBDb250YWN0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5Db250YWN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbiA9IGRhdGEubm9ybWFsO1xuICAgIHZhciB0MSA9IG5ldyBWZWMzKCk7XG4gICAgaWYgKG4ueCA+PSAwLjU3NzM1KSB7XG4gICAgICAgIHQxLnNldChuLnksIC1uLngsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHQxLnNldCgwLCBuLnosIC1uLnkpO1xuICAgIH1cbiAgICB0MS5ub3JtYWxpemUoKTtcbiAgICB2YXIgdDIgPSBWZWMzLmNyb3NzKG4sIHQxLCBuZXcgVmVjMygpKTtcblxuICAgIHRoaXMudGFuZ2VudDEgPSB0MTtcbiAgICB0aGlzLnRhbmdlbnQyID0gdDI7XG5cbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2YXIgckJvZHlBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgIHZhciByQm9keUIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICB2YXIgaW52RWZmZWN0aXZlTWFzcyA9IGJvZHlBLmludmVyc2VNYXNzICsgYm9keUIuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgcjFuID0gVmVjMy5jcm9zcyhyQm9keUEsIG4sIFIxX1JFR0lTVEVSKTtcbiAgICB2YXIgcjJuID0gVmVjMy5jcm9zcyhyQm9keUIsIG4sIFIyX1JFR0lTVEVSKTtcbiAgICB0aGlzLmVmZk5vcm1hbE1hc3MgPSAxIC8gKGludkVmZmVjdGl2ZU1hc3MgK1xuICAgICAgICBWZWMzLmRvdChyMW4sIGJvZHlBLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHIxbiwgVkVDMV9SRUdJU1RFUikpICtcbiAgICAgICAgVmVjMy5kb3QocjJuLCBib2R5Qi5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMm4sIFZFQzFfUkVHSVNURVIpKSk7XG5cbiAgICB2YXIgcjF0MSA9IFZlYzMuY3Jvc3MockJvZHlBLCB0MSwgUjFfUkVHSVNURVIpO1xuICAgIHZhciByMnQxID0gVmVjMy5jcm9zcyhyQm9keUIsIHQxLCBSMl9SRUdJU1RFUik7XG4gICAgdGhpcy5lZmZUYW5nZW50aWFsTWFzczEgPSAxIC8gKGludkVmZmVjdGl2ZU1hc3MgK1xuICAgICAgICBWZWMzLmRvdChyMXQxLCBib2R5QS5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMXQxLCBWRUMxX1JFR0lTVEVSKSkgK1xuICAgICAgICAgVmVjMy5kb3QocjJ0MSwgYm9keUIuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkocjJ0MSwgVkVDMV9SRUdJU1RFUikpKTtcblxuICAgIHZhciByMXQyID0gVmVjMy5jcm9zcyhyQm9keUEsIHQyLCBSMV9SRUdJU1RFUik7XG4gICAgdmFyIHIydDIgPSBWZWMzLmNyb3NzKHJCb2R5QiwgdDIsIFIyX1JFR0lTVEVSKTtcbiAgICB0aGlzLmVmZlRhbmdlbnRpYWxNYXNzMiA9IDEgLyAoaW52RWZmZWN0aXZlTWFzcyArXG4gICAgICAgIFZlYzMuZG90KHIxdDIsIGJvZHlBLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHIxdDIsIFZFQzFfUkVHSVNURVIpKSArXG4gICAgICAgICBWZWMzLmRvdChyMnQyLCBib2R5Qi5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMnQyLCBWRUMxX1JFR0lTVEVSKSkpO1xuXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IE1hdGgubWluKGJvZHlBLnJlc3RpdHV0aW9uLCBib2R5Qi5yZXN0aXR1dGlvbik7XG4gICAgdGhpcy5mcmljdGlvbiA9IGJvZHlBLmZyaWN0aW9uICogYm9keUIuZnJpY3Rpb247XG59O1xuXG4vKipcbiAqIFdhcm0gc3RhcnQgdGhlIENvbnRhY3QsIHByZXBhcmUgZm9yIHRoZSBpdGVyYXRpdmUgc29sdmVyLCBhbmQgcmVzZXQgaW1wdWxzZXMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdFxuICovXG5Db250YWN0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2YXIgckJvZHlBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgIHZhciByQm9keUIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICB2YXIgbiA9IGRhdGEubm9ybWFsO1xuXG4gICAgdmFyIHZiMSA9IFZlYzMuYWRkKGJvZHlBLnZlbG9jaXR5LCBWZWMzLmNyb3NzKGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSwgckJvZHlBLCBXeFJfUkVHSVNURVIpLCBWQjFfUkVHSVNURVIpO1xuICAgIHZhciB2YjIgPSBWZWMzLmFkZChib2R5Qi52ZWxvY2l0eSwgVmVjMy5jcm9zcyhib2R5Qi5hbmd1bGFyVmVsb2NpdHksIHJCb2R5QiwgV3hSX1JFR0lTVEVSKSwgVkIyX1JFR0lTVEVSKTtcbiAgICB2YXIgcmVsYXRpdmVWZWxvY2l0eSA9IHZiMi5zdWJ0cmFjdCh2YjEpO1xuICAgIHZhciBjb250YWN0U3BlZWQgPSBWZWMzLmRvdChyZWxhdGl2ZVZlbG9jaXR5LCBuKTtcblxuICAgIHZhciBiZXRhID0gMC4xNTtcbiAgICB2YXIgc2xvcCA9IDEuNTtcbiAgICB2YXIgdmVsb2NpdHlUb2xlcmFuY2UgPSAyMC4wO1xuXG4gICAgdmFyIHJlc3RpdHV0aW9uID0gTWF0aC5hYnMoY29udGFjdFNwZWVkKSA8IHZlbG9jaXR5VG9sZXJhbmNlID8gMC4wIDogdGhpcy5yZXN0aXR1dGlvbjtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyA9IC1iZXRhICogTWF0aC5tYXgoZGF0YS5wZW5ldHJhdGlvbiAtIHNsb3AsIDAuMCkgLyBkdDtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyArPSByZXN0aXR1dGlvbiAqIGNvbnRhY3RTcGVlZDtcblxuICAgIHZhciBpbXB1bHNlID0gdGhpcy5pbXB1bHNlLnNjYWxlKDAuMjUpO1xuICAgIHZhciBhbmdJbXB1bHNlQSA9IHRoaXMuYW5nSW1wdWxzZUEuc2NhbGUoMC4yNSk7XG4gICAgdmFyIGFuZ0ltcHVsc2VCID0gdGhpcy5hbmdJbXB1bHNlQi5zY2FsZSgwLjI1KTtcblxuICAgIGJvZHlCLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBib2R5Qi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VCKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuICAgIGJvZHlBLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBib2R5QS5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VBKTtcblxuICAgIHRoaXMubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgdGhpcy50YW5nZW50SW1wdWxzZTEgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UyID0gMDtcblxuICAgIGltcHVsc2UuY2xlYXIoKTtcbiAgICBhbmdJbXB1bHNlQS5jbGVhcigpO1xuICAgIGFuZ0ltcHVsc2VCLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgdGhlIGNvbnRhY3QgYW5kIHNpbXVsYXRlIGZyaWN0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5Db250YWN0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2YXIgckJvZHlBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgIHZhciByQm9keUIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICB2YXIgbiA9IGRhdGEubm9ybWFsO1xuICAgIHZhciB0MSA9IHRoaXMudGFuZ2VudDE7XG4gICAgdmFyIHQyID0gdGhpcy50YW5nZW50MjtcblxuICAgIHZhciB2YjEgPSBWZWMzLmFkZChib2R5QS52ZWxvY2l0eSwgVmVjMy5jcm9zcyhib2R5QS5hbmd1bGFyVmVsb2NpdHksIHJCb2R5QSwgV3hSX1JFR0lTVEVSKSwgVkIxX1JFR0lTVEVSKTtcbiAgICB2YXIgdmIyID0gVmVjMy5hZGQoYm9keUIudmVsb2NpdHksIFZlYzMuY3Jvc3MoYm9keUIuYW5ndWxhclZlbG9jaXR5LCByQm9keUIsIFd4Ul9SRUdJU1RFUiksIFZCMl9SRUdJU1RFUik7XG4gICAgdmFyIHJlbGF0aXZlVmVsb2NpdHkgPSB2YjIuc3VidHJhY3QodmIxKTtcblxuICAgIHZhciBub3JtYWxMYW1iZGEgPSAtKFZlYzMuZG90KHJlbGF0aXZlVmVsb2NpdHksIG4pICsgdGhpcy52ZWxvY2l0eUJpYXMpICogdGhpcy5lZmZOb3JtYWxNYXNzO1xuICAgIHZhciBuZXdOb3JtYWxJbXB1bHNlID0gTWF0aC5tYXgodGhpcy5ub3JtYWxJbXB1bHNlICsgbm9ybWFsTGFtYmRhLCAwKTtcbiAgICBub3JtYWxMYW1iZGEgPSBuZXdOb3JtYWxJbXB1bHNlIC0gdGhpcy5ub3JtYWxJbXB1bHNlO1xuXG4gICAgdmFyIG1heEZyaWN0aW9uID0gdGhpcy5mcmljdGlvbiAqIG5ld05vcm1hbEltcHVsc2U7XG5cbiAgICB2YXIgdGFuZ2VudExhbWJkYTEgPSAtVmVjMy5kb3QocmVsYXRpdmVWZWxvY2l0eSwgdDEpICogdGhpcy5lZmZUYW5nZW50aWFsTWFzczE7XG4gICAgdmFyIG5ld1RhbmdlbnRJbXB1bHNlMSA9IGNsYW1wKHRoaXMudGFuZ2VudEltcHVsc2UxICsgdGFuZ2VudExhbWJkYTEsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xuICAgIHRhbmdlbnRMYW1iZGExID0gbmV3VGFuZ2VudEltcHVsc2UxIC0gdGhpcy50YW5nZW50SW1wdWxzZTE7XG5cbiAgICB2YXIgdGFuZ2VudExhbWJkYTIgPSAtVmVjMy5kb3QocmVsYXRpdmVWZWxvY2l0eSwgdDIpICogdGhpcy5lZmZUYW5nZW50aWFsTWFzczI7XG4gICAgdmFyIG5ld1RhbmdlbnRJbXB1bHNlMiA9IGNsYW1wKHRoaXMudGFuZ2VudEltcHVsc2UyICsgdGFuZ2VudExhbWJkYTIsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xuICAgIHRhbmdlbnRMYW1iZGEyID0gbmV3VGFuZ2VudEltcHVsc2UyIC0gdGhpcy50YW5nZW50SW1wdWxzZTI7XG5cbiAgICB2YXIgaW1wdWxzZSA9IFZlYzMuc2NhbGUobiwgbm9ybWFsTGFtYmRhLCBOT1JNQUxJTVBVTFNFX1JFR0lTVEVSKTtcbiAgICB2YXIgdGFuZ2VudEltcHVsc2UxID0gVmVjMy5zY2FsZSh0MSwgdGFuZ2VudExhbWJkYTEsIFRBTkdFTlRJTVBVTFNFMV9SRUdJU1RFUik7XG4gICAgdmFyIHRhbmdlbnRJbXB1bHNlMiA9IFZlYzMuc2NhbGUodDIsIHRhbmdlbnRMYW1iZGEyLCBUQU5HRU5USU1QVUxTRTJfUkVHSVNURVIpO1xuXG4gICAgaW1wdWxzZS5hZGQodGFuZ2VudEltcHVsc2UxKS5hZGQodGFuZ2VudEltcHVsc2UyKTtcblxuICAgIHZhciBhbmdJbXB1bHNlQiA9IFZlYzMuY3Jvc3MockJvZHlCLCBpbXB1bHNlLCBWRUMxX1JFR0lTVEVSKTtcbiAgICB2YXIgYW5nSW1wdWxzZUEgPSBWZWMzLmNyb3NzKHJCb2R5QSwgaW1wdWxzZSwgVkVDMl9SRUdJU1RFUikuaW52ZXJ0KCk7XG5cbiAgICBib2R5Qi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYm9keUIuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQik7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcbiAgICBib2R5QS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYm9keUEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQSk7XG5cbiAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSBuZXdOb3JtYWxJbXB1bHNlO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UxID0gbmV3VGFuZ2VudEltcHVsc2UxO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UyID0gbmV3VGFuZ2VudEltcHVsc2UyO1xuXG4gICAgdGhpcy5pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBLmFkZChhbmdJbXB1bHNlQSk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQi5hZGQoYW5nSW1wdWxzZUIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0TWFuaWZvbGRUYWJsZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aC9WZWMzJyk7XG52YXIgT2JqZWN0TWFuYWdlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxpdGllcy9PYmplY3RNYW5hZ2VyJyk7XG5cbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIoJ0dKS19FUEFTdXBwb3J0UG9pbnQnLCBHSktfRVBBU3VwcG9ydFBvaW50KTtcbnZhciBPTVJlcXVlc3RHSktfRVBBU3VwcG9ydFBvaW50ID0gT2JqZWN0TWFuYWdlci5yZXF1ZXN0R0pLX0VQQVN1cHBvcnRQb2ludDtcbnZhciBPTVJlcXVlc3REeW5hbWljR2VvbWV0cnkgPSBPYmplY3RNYW5hZ2VyLnJlcXVlc3REeW5hbWljR2VvbWV0cnk7XG52YXIgT01GcmVlR0pLX0VQQVN1cHBvcnRQb2ludCA9IE9iamVjdE1hbmFnZXIuZnJlZUdKS19FUEFTdXBwb3J0UG9pbnQ7XG52YXIgT01GcmVlRHluYW1pY0dlb21ldHJ5ID0gT2JqZWN0TWFuYWdlci5mcmVlRHluYW1pY0dlb21ldHJ5O1xudmFyIE9NRnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmUgPSBPYmplY3RNYW5hZ2VyLmZyZWVEeW5hbWljR2VvbWV0cnlGZWF0dXJlO1xuXG52YXIgUF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVjBfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFYxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbnZhciBESVJFQ1RJT05fUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIElOVkRJUkVDVElPTl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU3VwcG9ydCBwb2ludCB0byBiZSBhZGRlZCB0byB0aGUgRHluYW1pY0dlb21ldHJ5LiBUaGUgcG9pbnQgaW4gTWlua293c2tpIHNwYWNlIGFzIHdlbGwgYXMgdGhlXG4gKiBvcmlnaW5hbCBwYWlyLlxuICpcbiAqIEBjbGFzcyBHSktfRVBBU3VwcG9ydFBvaW50XG4gKiBAcGFyYW0ge1ZlYzN9IHZlcnRleFxuICogQHBhcmFtIHtWZWMzfSB3b3JsZFZlcnRleEFcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRWZXJ0ZXhBQlxuICovXG5mdW5jdGlvbiBHSktfRVBBU3VwcG9ydFBvaW50KHZlcnRleCwgd29ybGRWZXJ0ZXhBLCB3b3JsZFZlcnRleEIpIHtcbiAgICB0aGlzLnZlcnRleCA9IHZlcnRleDtcbiAgICB0aGlzLndvcmxkVmVydGV4QSA9IHdvcmxkVmVydGV4QTtcbiAgICB0aGlzLndvcmxkVmVydGV4QiA9IHdvcmxkVmVydGV4Qjtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IE9iamVjdE1hbmFnZXIgdG8gcmVzZXQgdGhlIG9iamVjdCB3aXRoIGRpZmZlcmVudCBkYXRhLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7T2JqZWN0W119IGFyZ3NcbiAqIEBjaGFpbmFibGVcbiAqL1xuR0pLX0VQQVN1cHBvcnRQb2ludC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCh2ZXJ0ZXgsIHdvcmxkVmVydGV4QSwgd29ybGRWZXJ0ZXhCKSB7XG4gICAgdGhpcy52ZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgdGhpcy53b3JsZFZlcnRleEEgPSB3b3JsZFZlcnRleEE7XG4gICAgdGhpcy53b3JsZFZlcnRleEIgPSB3b3JsZFZlcnRleEI7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRnJlZSB0aGUgRHluYW1pY0dlb210ZXRyeSBhbmQgYXNzb2NpYXRlIHZlcnRpY2VzIGFuZCBmZWF0dXJlcyBmb3IgbGF0ZXIgcmV1c2UuXG4gKlxuICogQG1ldGhvZCBmcmVlR0pLX0VQQUR5bmFtaWNHZW9tZXRyeVxuICogQHBhcmFtIHtEeW5hbWljR2VvbWV0cnl9IGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIGZyZWVHSktfRVBBRHluYW1pY0dlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgdmFyIGk7XG4gICAgaSA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciB2ID0gdmVydGljZXMucG9wKCk7XG4gICAgICAgIGlmICh2ICE9PSBudWxsKSBPTUZyZWVHSktfRVBBU3VwcG9ydFBvaW50KHYpO1xuICAgIH1cbiAgICBnZW9tZXRyeS5udW1WZXJ0aWNlcyA9IDA7XG4gICAgdmFyIGZlYXR1cmVzID0gZ2VvbWV0cnkuZmVhdHVyZXM7XG4gICAgaSA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBmID0gZmVhdHVyZXMucG9wKCk7XG4gICAgICAgIGlmIChmICE9PSBudWxsKSBPTUZyZWVEeW5hbWljR2VvbWV0cnlGZWF0dXJlKGYpO1xuICAgIH1cbiAgICBnZW9tZXRyeS5udW1GZWF0dXJlcyA9IDA7XG4gICAgT01GcmVlRHluYW1pY0dlb21ldHJ5KGdlb21ldHJ5KTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBwb2ludCBpbiBNaW5rb3dza2kgc3BhY2UgZnVydGhlc3QgaW4gYSBnaXZlbiBkaXJlY3Rpb24gZm9yIHR3byBjb252ZXggQm9kaWVzLlxuICpcbiAqIEBtZXRob2QgbWlua293c2tpU3VwcG9ydFxuICogQHBhcmFtIHtCb2R5fSBib2R5MVxuICogQHBhcmFtIHtCb2R5fSBib2R5MlxuICogQHBhcmFtIHtWZWMzfSBkaXJlY3Rpb25cbiAqIEByZXR1cm4ge0dKS19FUEFTdXBwb3J0UG9pbnR9XG4gKi9cbmZ1bmN0aW9uIG1pbmtvd3NraVN1cHBvcnQoYm9keTEsIGJvZHkyLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgaW52ZXJzZURpcmVjdGlvbiA9IFZlYzMuc2NhbGUoZGlyZWN0aW9uLCAtMSwgSU5WRElSRUNUSU9OX1JFR0lTVEVSKTtcblxuICAgIHZhciB3MSA9IFZlYzMuYWRkKGJvZHkxLnN1cHBvcnQoZGlyZWN0aW9uKSwgYm9keTEucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuICAgIHZhciB3MiA9IFZlYzMuYWRkKGJvZHkyLnN1cHBvcnQoaW52ZXJzZURpcmVjdGlvbiksIGJvZHkyLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcblxuICAgIC8vIFRoZSB2ZXJ0ZXggaW4gTWlua293c2tpIHNwYWNlIGFzIHdlbGwgYXMgdGhlIG9yaWdpbmFsIHBhaXIgaW4gd29ybGQgc3BhY2VcbiAgICByZXR1cm4gT01SZXF1ZXN0R0pLX0VQQVN1cHBvcnRQb2ludCgpLnJlc2V0KFZlYzMuc3VidHJhY3QodzEsIHcyLCBuZXcgVmVjMygpKSwgdzEsIHcyKTtcbn1cblxuLyoqXG4gKiBHaWxiZXJ0LUpvaG5zb24tS2VlcnRoaSBjb2xsaXNpb24gZGV0ZWN0aW9uLiBSZXR1cm5zIGEgRHluYW1pY0dlb21ldHJ5IHNpbXBsZXggaWYgdGhlIGJvZGllcyBhcmUgZm91bmRcbiAqIHRvIGhhdmUgY29sbGlkZWQgb3IgZmFsc2UgZm9yIG5vIGNvbGxzaW9uLlxuICpcbiAqIEBtZXRob2QgR0pLXG4gKiBwYXJhbSB7Qm9keX0gYm9keTFcbiAqIHBhcmFtIHtCb2R5fSBib2R5MlxuICogQHJldHVybiB7RHluYW1pY0dlb21ldHJ5IHwgQm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gR0pLKGJvZHkxLCBib2R5Mikge1xuICAgIHZhciBzdXBwb3J0ID0gbWlua293c2tpU3VwcG9ydDtcbiAgICAvLyBVc2UgcDIgLSBwMSB0byBzZWVkIHRoZSBpbml0aWFsIGNob2ljZSBvZiBkaXJlY3Rpb25cbiAgICB2YXIgZGlyZWN0aW9uID0gVmVjMy5zdWJ0cmFjdChib2R5Mi5wb3NpdGlvbiwgYm9keTEucG9zaXRpb24sIERJUkVDVElPTl9SRUdJU1RFUikubm9ybWFsaXplKCk7XG4gICAgdmFyIHNpbXBsZXggPSBPTVJlcXVlc3REeW5hbWljR2VvbWV0cnkoKTtcbiAgICBzaW1wbGV4LmFkZFZlcnRleChzdXBwb3J0KGJvZHkxLCBib2R5MiwgZGlyZWN0aW9uKSk7XG4gICAgZGlyZWN0aW9uLmludmVydCgpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBtYXhJdGVyYXRpb25zID0gMWUzO1xuICAgIHdoaWxlKGkrKyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbi54ID09PSAwICYmIGRpcmVjdGlvbi55ID09PSAwICYmIGRpcmVjdGlvbi56ID09PSAwKSBicmVhaztcbiAgICAgICAgc2ltcGxleC5hZGRWZXJ0ZXgoc3VwcG9ydChib2R5MSwgYm9keTIsIGRpcmVjdGlvbikpO1xuICAgICAgICBpZiAoVmVjMy5kb3Qoc2ltcGxleC5nZXRMYXN0VmVydGV4KCkudmVydGV4LCBkaXJlY3Rpb24pIDwgMCkgYnJlYWs7XG4gICAgICAgIC8vIElmIHNpbXBsZXggY29udGFpbnMgb3JpZ2luLCByZXR1cm4gZm9yIHVzZSBpbiBFUEFcbiAgICAgICAgaWYgKHNpbXBsZXguc2ltcGxleENvbnRhaW5zT3JpZ2luKGRpcmVjdGlvbiwgT01GcmVlR0pLX0VQQVN1cHBvcnRQb2ludCkpIHJldHVybiBzaW1wbGV4O1xuICAgIH1cbiAgICBmcmVlR0pLX0VQQUR5bmFtaWNHZW9tZXRyeShzaW1wbGV4KTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRXhwYW5kaW5nIFBvbHl0b3BlIEFsZ29yaXRobS0tcGVuZXRyYXRpb24gZGVwdGgsIGNvbGxpc2lvbiBub3JtYWwsIGFuZCBjb250YWN0IHBvaW50cy5cbiAqIFJldHVybnMgYSBDb2xsaXNvbkRhdGEgb2JqZWN0LlxuICpcbiAqIEBtZXRob2QgRVBBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHkxXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHkyXG4gKiBAcGFyYW0ge0R5bmFtaWNHZW9tZXRyeX0gcG9seXRvcGVcbiAqIEByZXR1cm4ge0NvbGxpc2lvbkRhdGF9XG4gKi9cbmZ1bmN0aW9uIEVQQShib2R5MSwgYm9keTIsIHBvbHl0b3BlKSB7XG4gICAgdmFyIHN1cHBvcnQgPSBtaW5rb3dza2lTdXBwb3J0O1xuICAgIHZhciBkZXB0aEVzdGltYXRlID0gSW5maW5pdHk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxZTM7XG4gICAgd2hpbGUoaSsrIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgY2xvc2VzdCA9IHBvbHl0b3BlLmdldEZlYXR1cmVDbG9zZXN0VG9PcmlnaW4oKTtcbiAgICAgICAgaWYgKGNsb3Nlc3QgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gY2xvc2VzdC5ub3JtYWw7XG4gICAgICAgIHZhciBwb2ludCA9IHN1cHBvcnQoYm9keTEsIGJvZHkyLCBkaXJlY3Rpb24pO1xuICAgICAgICBkZXB0aEVzdGltYXRlID0gTWF0aC5taW4oZGVwdGhFc3RpbWF0ZSwgVmVjMy5kb3QocG9pbnQudmVydGV4LCBkaXJlY3Rpb24pKTtcbiAgICAgICAgaWYgKGRlcHRoRXN0aW1hdGUgLSBjbG9zZXN0LmRpc3RhbmNlIDw9IDAuMDEpIHtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0QSA9IHBvbHl0b3BlLnZlcnRpY2VzW2Nsb3Nlc3QudmVydGV4SW5kaWNlc1swXV07XG4gICAgICAgICAgICB2YXIgc3VwcG9ydEIgPSBwb2x5dG9wZS52ZXJ0aWNlc1tjbG9zZXN0LnZlcnRleEluZGljZXNbMV1dO1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRDID0gcG9seXRvcGUudmVydGljZXNbY2xvc2VzdC52ZXJ0ZXhJbmRpY2VzWzJdXTtcblxuICAgICAgICAgICAgdmFyIEEgPSBzdXBwb3J0QS52ZXJ0ZXg7XG4gICAgICAgICAgICB2YXIgQiA9IHN1cHBvcnRCLnZlcnRleDtcbiAgICAgICAgICAgIHZhciBDID0gc3VwcG9ydEMudmVydGV4O1xuICAgICAgICAgICAgdmFyIFAgPSBWZWMzLnNjYWxlKGRpcmVjdGlvbiwgY2xvc2VzdC5kaXN0YW5jZSwgUF9SRUdJU1RFUik7XG5cbiAgICAgICAgICAgIHZhciBWMCA9IFZlYzMuc3VidHJhY3QoQiwgQSwgVjBfUkVHSVNURVIpO1xuICAgICAgICAgICAgdmFyIFYxID0gVmVjMy5zdWJ0cmFjdChDLCBBLCBWMV9SRUdJU1RFUik7XG4gICAgICAgICAgICB2YXIgVjIgPSBWZWMzLnN1YnRyYWN0KFAsIEEsIFYyX1JFR0lTVEVSKTtcblxuICAgICAgICAgICAgdmFyIGQwMCA9IFZlYzMuZG90KFYwLCBWMCk7XG4gICAgICAgICAgICB2YXIgZDAxID0gVmVjMy5kb3QoVjAsIFYxKTtcbiAgICAgICAgICAgIHZhciBkMTEgPSBWZWMzLmRvdChWMSwgVjEpO1xuICAgICAgICAgICAgdmFyIGQyMCA9IFZlYzMuZG90KFYyLCBWMCk7XG4gICAgICAgICAgICB2YXIgZDIxID0gVmVjMy5kb3QoVjIsIFYxKTtcbiAgICAgICAgICAgIHZhciBkZW5vbSA9IGQwMCpkMTEgLSBkMDEqZDAxO1xuXG4gICAgICAgICAgICB2YXIgdiA9IChkMTEqZDIwIC0gZDAxKmQyMSkgLyBkZW5vbTtcbiAgICAgICAgICAgIHZhciB3ID0gKGQwMCpkMjEgLSBkMDEqZDIwKSAvIGRlbm9tO1xuICAgICAgICAgICAgdmFyIHUgPSAxLjAgLSB2IC0gdztcblxuICAgICAgICAgICAgdmFyIGJvZHkxQ29udGFjdCA9ICAgICAgc3VwcG9ydEEud29ybGRWZXJ0ZXhBLnNjYWxlKHUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChzdXBwb3J0Qi53b3JsZFZlcnRleEEuc2NhbGUodikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChzdXBwb3J0Qy53b3JsZFZlcnRleEEuc2NhbGUodykpO1xuXG4gICAgICAgICAgICB2YXIgYm9keTJDb250YWN0ID0gICAgICBzdXBwb3J0QS53b3JsZFZlcnRleEIuc2NhbGUodSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHN1cHBvcnRCLndvcmxkVmVydGV4Qi5zY2FsZSh2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHN1cHBvcnRDLndvcmxkVmVydGV4Qi5zY2FsZSh3KSk7XG5cbiAgICAgICAgICAgIHZhciBsb2NhbEJvZHkxQ29udGFjdCA9IFZlYzMuc3VidHJhY3QoYm9keTFDb250YWN0LCBib2R5MS5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG4gICAgICAgICAgICB2YXIgbG9jYWxCb2R5MkNvbnRhY3QgPSBWZWMzLnN1YnRyYWN0KGJvZHkyQ29udGFjdCwgYm9keTIucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuXG4gICAgICAgICAgICBmcmVlR0pLX0VQQUR5bmFtaWNHZW9tZXRyeShwb2x5dG9wZSk7XG4gICAgICAgICAgICBPTUZyZWVHSktfRVBBU3VwcG9ydFBvaW50KHBvaW50KTtcblxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdE1hbmFnZXIucmVxdWVzdENvbGxpc2lvbkRhdGEoKS5yZXNldChjbG9zZXN0LmRpc3RhbmNlLCBkaXJlY3Rpb24sIGJvZHkxQ29udGFjdCwgYm9keTJDb250YWN0LCBsb2NhbEJvZHkxQ29udGFjdCwgbG9jYWxCb2R5MkNvbnRhY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9seXRvcGUuYWRkVmVydGV4KHBvaW50KTtcbiAgICAgICAgICAgIHBvbHl0b3BlLnJlc2hhcGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VQQSBmYWlsZWQgdG8gdGVybWluYXRlIGluIGFsbG90dGVkIGl0ZXJhdGlvbnMuJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzLkdKSyA9IEdKSztcbm1vZHVsZS5leHBvcnRzLkVQQSA9IEVQQTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBQUJCID0gcmVxdWlyZSgnLi9BQUJCJyk7XG5cbi8qKlxuICogQGNvbnN0IHtTdHJpbmdbXX0gQVhFUyB4LCB5LCBhbmQgeiBheGVzXG4gKi9cbnZhciBBWEVTID0gWyd4JywgJ3knLCAneiddO1xuXG4vKipcbiAqIFBlcnNpc3RhbnQgb2JqZWN0IG1haW50YWluaW5nIHNvcnRlZCBsaXN0cyBvZiBBQUJCIGVuZHBvaW50cyB1c2VkIGluIGEgc3dlZXAtYW5kLXBydW5lIGJyb2FkcGhhc2UuXG4gKiBVc2VkIHRvIGFjY2VsZXJhdGUgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3dlZXBfYW5kX3BydW5lXG4gKlxuICogQGNsYXNzIFN3ZWVwQW5kUHJ1bmVcbiAqIEBwYXJhbSB7Qm9keVtdfSB0YXJnZXRzXG4gKi9cbmZ1bmN0aW9uIFN3ZWVwQW5kUHJ1bmUodGFyZ2V0cykge1xuICAgIHRoaXMuX3N3ZWVwVm9sdW1lcyA9IFtdO1xuICAgIHRoaXMuX2VudGl0eVJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5fYm91bmRpbmdWb2x1bWVSZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuZW5kcG9pbnRzID0ge3g6IFtdLCB5OiBbXSwgejogW119O1xuXG4gICAgdGhpcy5vdmVybGFwcyA9IFtdO1xuICAgIHRoaXMub3ZlcmxhcHNNYXRyaXggPSB7fTtcbiAgICB0aGlzLl9JRFBvb2wgPSBbXTtcbiAgICB0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0c1tpXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0YXJ0IHRyYWNraW5nIGEgYm9keSBpbiB0aGUgYnJvYWQtcGhhc2UuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5Td2VlcEFuZFBydW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIGJvdW5kaW5nVm9sdW1lID0gbmV3IEFBQkIoYm9keSk7XG4gICAgdmFyIHN3ZWVwVm9sdW1lID0gbmV3IFN3ZWVwVm9sdW1lKGJvdW5kaW5nVm9sdW1lKTtcblxuICAgIHRoaXMuX2VudGl0eVJlZ2lzdHJ5W2JvZHkuX0lEXSA9IGJvZHk7XG4gICAgdGhpcy5fYm91bmRpbmdWb2x1bWVSZWdpc3RyeVtib2R5Ll9JRF0gPSBib3VuZGluZ1ZvbHVtZTtcbiAgICB0aGlzLl9zd2VlcFZvbHVtZXMucHVzaChzd2VlcFZvbHVtZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgdmFyIGF4aXMgPSBBWEVTW2ldO1xuICAgICAgICB0aGlzLmVuZHBvaW50c1theGlzXS5wdXNoKHN3ZWVwVm9sdW1lLnBvaW50c1theGlzXVswXSk7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzW2F4aXNdLnB1c2goc3dlZXBWb2x1bWUucG9pbnRzW2F4aXNdWzFdKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0b3AgdHJhY2tpbmcgYSBib2R5IGluIHRoZSBicm9hZC1waGFzZS5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cblN3ZWVwQW5kUHJ1bmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShib2R5KSB7XG4gICAgdGhpcy5fZW50aXR5UmVnaXN0cnlbYm9keS5fSURdID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZGluZ1ZvbHVtZVJlZ2lzdHJ5W2JvZHkuX0lEXSA9IG51bGw7XG4gICAgdmFyIGksIGxlbjtcbiAgICB2YXIgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fc3dlZXBWb2x1bWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9zd2VlcFZvbHVtZXNbaV0uX0lEID09PSBib2R5Ll9JRCkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc3dlZXBWb2x1bWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgdmFyIGVuZHBvaW50cyA9IHRoaXMuZW5kcG9pbnRzO1xuICAgIHZhciBwb2ludDtcblxuICAgIHZhciB4cyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGVuZHBvaW50cy54Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gZW5kcG9pbnRzLnhbaV07XG4gICAgICAgIGlmIChwb2ludC5fSUQgIT09IGJvZHkuX0lEKSB4cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgdmFyIHlzID0gW107XG4gICAgZm9yIChpID0gMCwgbGVuID0gZW5kcG9pbnRzLnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBlbmRwb2ludHMueVtpXTtcbiAgICAgICAgaWYgKHBvaW50Ll9JRCAhPT0gYm9keS5fSUQpIHlzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICB2YXIgenMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBlbmRwb2ludHMuei5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IGVuZHBvaW50cy56W2ldO1xuICAgICAgICBpZiAocG9pbnQuX0lEICE9PSBib2R5Ll9JRCkgenMucHVzaChwb2ludCk7XG4gICAgfVxuICAgIGVuZHBvaW50cy54ID0geHM7XG4gICAgZW5kcG9pbnRzLnkgPSB5cztcbiAgICBlbmRwb2ludHMueiA9IHpzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGVuZHBvaW50cyBvZiB0aGUgdHJhY2tlZCBBQUJCJ3MgYW5kIHJlc29ydCB0aGUgZW5kcG9pbnQgbGlzdHMgYWNjb3JkaW5nbHkuIFVzZXMgYW4gaW5zZXJ0aW9uIHNvcnQsXG4gKiB3aGVyZSBzd2FwcyBkdXJpbmcgdGhlIHNvcnQgYXJlIHRha2VuIHRvIHNpZ25pZnkgYSBwb3RlbnRpYWwgY2hhbmdlIGluIG92ZXJsYXAgc3RhdHVzIGZvciB0aGUgdHdvXG4gKiByZWxldmFudCBBQUJCJ3MuIFJldHVybnMgcGFpcnMgb2Ygb3ZlcmxhcHBpbmcgQUFCQidzLlxuICpcbiAqIEBwYXJhbSB1cGRhdGVcbiAqIEByZXR1cm4ge1BhcnRpY2xlW11bXX1cbiAqL1xuU3dlZXBBbmRQcnVuZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9zd2VlcFZvbHVtZXMgPSB0aGlzLl9zd2VlcFZvbHVtZXM7XG4gICAgdmFyIF9lbnRpdHlSZWdpc3RyeSA9IHRoaXMuX2VudGl0eVJlZ2lzdHJ5O1xuICAgIHZhciBfYm91bmRpbmdWb2x1bWVSZWdpc3RyeSA9IHRoaXMuX2JvdW5kaW5nVm9sdW1lUmVnaXN0cnk7XG5cbiAgICB2YXIgaSwgaiwgaywgbGVuO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gX3N3ZWVwVm9sdW1lcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBfc3dlZXBWb2x1bWVzW2pdLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBlbmRwb2ludHMgPSB0aGlzLmVuZHBvaW50cztcbiAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLm92ZXJsYXBzO1xuICAgIHZhciBvdmVybGFwc01hdHJpeCA9IHRoaXMub3ZlcmxhcHNNYXRyaXg7XG4gICAgdmFyIF9JRFBvb2wgPSB0aGlzLl9JRFBvb2w7XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgMzsgaysrKSB7XG4gICAgICAgIHZhciBheGlzID0gQVhFU1trXTtcbiAgICAgICAgLy8gSW5zZXJ0aW9uIHNvcnQ6XG4gICAgICAgIHZhciBlbmRwb2ludEF4aXMgPSBlbmRwb2ludHNbYXhpc107XG4gICAgICAgIGZvciAoaiA9IDEsIGxlbiA9IGVuZHBvaW50QXhpcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbmRwb2ludEF4aXNbal07XG4gICAgICAgICAgICB2YXIgdmFsID0gY3VycmVudC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzd2FwO1xuICAgICAgICAgICAgdmFyIHJvdztcbiAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgIHZhciBsb3dJRDtcbiAgICAgICAgICAgIHZhciBoaWdoSUQ7XG4gICAgICAgICAgICB2YXIgY0lEO1xuICAgICAgICAgICAgdmFyIHNJRDtcblxuICAgICAgICAgICAgaSA9IGogLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAoc3dhcCA9IGVuZHBvaW50QXhpc1tpXSkudmFsdWUgPiB2YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHN3YXAgb2NjdXJlbmNlIGluZGljYXRlcyB0aGF0IGN1cnJlbnQgYW5kIHN3YXAgZWl0aGVyIGp1c3Qgc3RhcnRlZCBvciBqdXN0IHN0b3BwZWQgb3ZlcmxhcHBpbmdcblxuICAgICAgICAgICAgICAgIGNJRCA9IGN1cnJlbnQuX0lEO1xuICAgICAgICAgICAgICAgIHNJRCA9IHN3YXAuX0lEO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNJRCA8IHNJRCkge1xuICAgICAgICAgICAgICAgICAgICBsb3dJRCA9IGNJRDtcbiAgICAgICAgICAgICAgICAgICAgaGlnaElEID0gc0lEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd0lEID0gc0lEO1xuICAgICAgICAgICAgICAgICAgICBoaWdoSUQgPSBjSUQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYsIGZvciB0aGlzIGF4aXMsIG1pbiBwb2ludCBvZiBjdXJyZW50IGFuZCBtYXggcG9pbnQgb2Ygc3dhcFxuICAgICAgICAgICAgICAgIGlmICh+Y3VycmVudC5zaWRlICYgc3dhcC5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyBvdmVybGFwcGluZyBvbiB0aGlzIGF4aXMgLT4gcG9zc2libGUgb3ZlcmxhcCwgZG8gZnVsbCBBQUJCIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChBQUJCLmNoZWNrT3ZlcmxhcChfYm91bmRpbmdWb2x1bWVSZWdpc3RyeVtjSURdLCBfYm91bmRpbmdWb2x1bWVSZWdpc3RyeVtzSURdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gb3ZlcmxhcHNNYXRyaXhbbG93SURdID0gb3ZlcmxhcHNNYXRyaXhbbG93SURdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByb3dbaGlnaElEXSA9IF9JRFBvb2wubGVuZ3RoID8gX0lEUG9vbC5wb3AoKSA6IG92ZXJsYXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzW2luZGV4XSA9IFtfZW50aXR5UmVnaXN0cnlbbG93SURdLCBfZW50aXR5UmVnaXN0cnlbaGlnaElEXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAvLyBFbHNlIGlmLCBmb3IgdGhpcyBheGlzLCBtYXggcG9pbnQgb2YgY3VycmVudCBhbmQgbWluIHBvaW50IG9mIHN3YXBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQuc2lkZSAmIH5zd2FwLnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IG5vdCBvdmVybGFwcGluZyBvbiB0aGlzIGF4aXMgLT4gZGVmaW5pdGVseSBub3Qgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPSBvdmVybGFwc01hdHJpeFtsb3dJRF0pICYmIHJvd1toaWdoSURdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcm93W2hpZ2hJRF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93W2hpZ2hJRF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX0lEUG9vbC5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlmIG1heCBvZiBib3RoIG9yIG1pbiBvZiBib3RoLCBzdGlsbCBvdmVybGFwcGluZ1xuXG4gICAgICAgICAgICAgICAgZW5kcG9pbnRBeGlzW2kgKyAxXSA9IHN3YXA7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kcG9pbnRBeGlzW2kgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3ZlcmxhcHM7XG59O1xuXG4vKipcbiAqIE9iamVjdCB1c2VkIHRvIGFzc29jaWF0ZSBhbiBBQUJCIHdpdGggaXRzIGVuZHBvaW50cyBpbiB0aGUgc29ydGVkIGxpc3RzLlxuICpcbiAqIEBjbGFzcyBTd2VlcFZvbHVtZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FBQkJ9IGJvdW5kaW5nVm9sdW1lXG4gKi9cbmZ1bmN0aW9uIFN3ZWVwVm9sdW1lKGJvdW5kaW5nVm9sdW1lKSB7XG4gICAgdGhpcy5fYm91bmRpbmdWb2x1bWUgPSBib3VuZGluZ1ZvbHVtZTtcbiAgICB0aGlzLl9JRCA9IGJvdW5kaW5nVm9sdW1lLl9JRDtcbiAgICB0aGlzLnBvaW50cyA9IHtcbiAgICAgICAgeDogW3tfSUQ6IGJvdW5kaW5nVm9sdW1lLl9JRCwgc2lkZTogMCwgdmFsdWU6IG51bGx9LCB7X0lEOiBib3VuZGluZ1ZvbHVtZS5fSUQsIHNpZGU6IDEsIHZhbHVlOiBudWxsfV0sXG4gICAgICAgIHk6IFt7X0lEOiBib3VuZGluZ1ZvbHVtZS5fSUQsIHNpZGU6IDAsIHZhbHVlOiBudWxsfSwge19JRDogYm91bmRpbmdWb2x1bWUuX0lELCBzaWRlOiAxLCB2YWx1ZTogbnVsbH1dLFxuICAgICAgICB6OiBbe19JRDogYm91bmRpbmdWb2x1bWUuX0lELCBzaWRlOiAwLCB2YWx1ZTogbnVsbH0sIHtfSUQ6IGJvdW5kaW5nVm9sdW1lLl9JRCwgc2lkZTogMSwgdmFsdWU6IG51bGx9XVxuICAgIH07XG4gICAgdGhpcy51cGRhdGUoKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGVuZHBvaW50cyB0byByZWZsZWN0IHRoZSBjdXJyZW50IGxvY2F0aW9uIG9mIHRoZSBBQUJCLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblN3ZWVwVm9sdW1lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm91bmRpbmdWb2x1bWUgPSB0aGlzLl9ib3VuZGluZ1ZvbHVtZTtcbiAgICBib3VuZGluZ1ZvbHVtZS51cGRhdGUoKTtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHZhciBheGlzID0gQVhFU1tpXTtcbiAgICAgICAgcG9pbnRzW2F4aXNdWzBdLnZhbHVlID0gYm91bmRpbmdWb2x1bWUudmVydGljZXNbYXhpc11bMF07XG4gICAgICAgIHBvaW50c1theGlzXVsxXS52YWx1ZSA9IGJvdW5kaW5nVm9sdW1lLnZlcnRpY2VzW2F4aXNdWzFdO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3dlZXBBbmRQcnVuZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vRm9yY2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG5cbnZhciBGT1JDRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogVXNlIGRyYWcgdG8gb3Bwb3NlIG1vbWVudHVtIG9mIGEgbW92aW5nIG9iamVjdFxuICpcbiAqIEBjbGFzcyBEcmFnXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gRHJhZyh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuRHJhZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZvcmNlLnByb3RvdHlwZSk7XG5EcmFnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWc7XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSB2ZWxvY2l0eSBpbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGRyYWcgZm9yY2UuXG4gKlxuICogQGF0dHJpYnV0ZSBRVUFEUkFUSUNcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHJldHVybiB7TnVtYmVyfSB1c2VkIHRvIHNxdWFyZSB0aGUgbWFnbml0dWRlIG9mIHRoZSB2ZWxvY2l0eVxuICovXG5EcmFnLlFVQURSQVRJQyA9IGZ1bmN0aW9uIFFVQURSQVRJQyh2KSB7XG4gICAgcmV0dXJuIHYqdjtcbn07XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSB2ZWxvY2l0eSBpbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGRyYWcgZm9yY2UuXG4gKlxuICogQGF0dHJpYnV0ZSBMSU5FQVJcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHJldHVybiB7TnVtYmVyfSBzdHJlbmd0aCAxLCB3aWxsIG5vdCBzY2FsZSB0aGUgdmVsb2NpdHlcbiAqL1xuRHJhZy5MSU5FQVIgPSBmdW5jdGlvbiBMSU5FQVIodikge1xuICAgIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBGb3JjZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5EcmFnLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXggPSB0aGlzLm1heCB8fCBJbmZpbml0eTtcbiAgICB0aGlzLnN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aCB8fCAxO1xuICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSB8fCBEcmFnLkxJTkVBUjtcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkRyYWcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIHZhciBmb3JjZSA9IEZPUkNFX1JFR0lTVEVSO1xuXG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBzdHJlbmd0aCA9IHRoaXMuc3RyZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IHRhcmdldC52ZWxvY2l0eTtcbiAgICAgICAgdmFyIHYgPSB2ZWxvY2l0eS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIGludlYgPSB2ID8gMSAvIHYgOiAwO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gLXN0cmVuZ3RoICogdHlwZSh2KTtcbiAgICAgICAgVmVjMy5zY2FsZSh2ZWxvY2l0eSwgKG1hZ25pdHVkZSA8IC1tYXggPyAtbWF4IDogbWFnbml0dWRlKSAqIGludlYsIGZvcmNlKTtcbiAgICAgICAgdGFyZ2V0LmFwcGx5Rm9yY2UoZm9yY2UpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfSUQgPSAwO1xuLyoqXG4gKiBBYnN0cmFjdCBmb3JjZSBtYW5hZ2VyIHRvIGFwcGx5IGZvcmNlcyB0byB0YXJnZXRzLlxuICpcbiAqIEBjbGFzcyBGb3JjZVxuICogQHZpcnR1YWxcbiAqIEBwYXJhbSB7UGFydGljbGVbXX0gdGFyZ2V0cyBUaGUgdGFyZ2V0cyBvZiB0aGUgZm9yY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5mdW5jdGlvbiBGb3JjZSh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgICAgaWYgKHRhcmdldHMgaW5zdGFuY2VvZiBBcnJheSkgdGhpcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICAgICAgZWxzZSB0aGlzLnRhcmdldHMgPSBbdGFyZ2V0c107XG4gICAgfVxuICAgIGVsc2UgdGhpcy50YXJnZXRzID0gW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9JRCA9IF9JRCsrO1xufVxuXG4vKipcbiAqIERlY29yYXRlcyB0aGUgRm9yY2Ugd2l0aCB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQG1ldGhvZCBzZXRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5Gb3JjZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBZGQgYSB0YXJnZXQgb3IgdGFyZ2V0cyB0byB0aGUgRm9yY2UuXG4gKlxuICogQG1ldGhvZCBhZGRUYXJnZXRcbiAqIEBwYXJhbSB7UGFydGljbGV9IHRhcmdldCBUaGUgYm9keSB0byBiZWdpbiB0YXJnZXR0aW5nLlxuICovXG5Gb3JjZS5wcm90b3R5cGUuYWRkVGFyZ2V0ID0gZnVuY3Rpb24gYWRkVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0cy5wdXNoKHRhcmdldCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRhcmdldCBvciB0YXJnZXRzIGZyb20gdGhlIEZvcmNlLlxuICpcbiAqIEBtZXRob2QgYWRkVGFyZ2V0XG4gKiBAcGFyYW0ge1BhcnRpY2xlfSB0YXJnZXQgVGhlIGJvZHkgdG8gc3RvcCB0YXJnZXR0aW5nLlxuICovXG5Gb3JjZS5wcm90b3R5cGUucmVtb3ZlVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuICAgIHRoaXMudGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgaW52b2tlZCB1cG9uIGluc3RhbnRpYXRpb24gYW5kIHRoZSBzZXR0aW5nIG9mIG9wdGlvbnMuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5Gb3JjZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge307XG5cbi8qKlxuICogQXBwbHkgZm9yY2VzIG9uIGVhY2ggdGFyZ2V0LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkZvcmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmNlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9Gb3JjZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL1ZlYzMnKTtcblxudmFyIEZPUkNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBGb3JjZSB0aGF0IHB1bGxzIGFsbCBvYmplY3RzIGluIGEgZGlyZWN0aW9uIHdpdGggY29uc3RhbnQgYWNjZWxlcmF0aW9uXG4gKlxuICogQGNsYXNzIEdyYXZpdHkxRFxuICogQGV4dGVuZHMgRm9yY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEdyYXZpdHkxRCh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuR3Jhdml0eTFELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRm9yY2UucHJvdG90eXBlKTtcbkdyYXZpdHkxRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmF2aXR5MUQ7XG5cbi8qKlxuICogQGVudW0gZGlyZWN0aW9uc1xuICovXG5HcmF2aXR5MUQuRE9XTiAgICAgPSAwO1xuR3Jhdml0eTFELlVQICAgICAgID0gMTtcbkdyYXZpdHkxRC5MRUZUICAgICA9IDI7XG5HcmF2aXR5MUQuUklHSFQgICAgPSAzO1xuR3Jhdml0eTFELkZPUldBUkQgID0gNDtcbkdyYXZpdHkxRC5CQUNLV0FSRCA9IDU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuR3Jhdml0eTFELnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMubWF4ID0gdGhpcy5tYXggfHwgSW5maW5pdHk7XG4gICAgaWYgKG9wdGlvbnMuYWNjZWxlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RyZW5ndGggPSB0aGlzLmFjY2VsZXJhdGlvbi5sZW5ndGgoKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVmVjMygpO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uIHx8IEdyYXZpdHkxRC5ET1dOO1xuICAgIHZhciBtYWduaXR1ZGUgPSB0aGlzLnN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aCB8fCAyMDA7XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBHcmF2aXR5MUQuRE9XTjpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQoMCwgbWFnbml0dWRlLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5VUDpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQoMCwgLTEgKiBtYWduaXR1ZGUsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR3Jhdml0eTFELkxFRlQ6XG4gICAgICAgICAgICBhY2NlbGVyYXRpb24uc2V0KC0xICogbWFnbml0dWRlLCAwLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5SSUdIVDpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQobWFnbml0dWRlLCAwLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5GT1JXQVJEOlxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnNldCgwLCAwLCAtMSAqIG1hZ25pdHVkZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHcmF2aXR5MUQuQkFDS1dBUkQ6XG4gICAgICAgICAgICBhY2NlbGVyYXRpb24uc2V0KDAsIDAsIG1hZ25pdHVkZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkdyYXZpdHkxRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG5cbiAgICB2YXIgZm9yY2UgPSBGT1JDRV9SRUdJU1RFUjtcblxuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgYWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb247XG4gICAgdmFyIGEgPSBhY2NlbGVyYXRpb24ubGVuZ3RoKCk7XG4gICAgdmFyIGludkEgPSBhID8gMSAvIGEgOiAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gYSAqIHRhcmdldC5tYXNzO1xuICAgICAgICBWZWMzLnNjYWxlKGFjY2VsZXJhdGlvbiwgKG1hZ25pdHVkZSA+IG1heCA/IG1heCA6IG1hZ25pdHVkZSkgKiBpbnZBLCBmb3JjZSk7XG4gICAgICAgIHRhcmdldC5hcHBseUZvcmNlKGZvcmNlKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXZpdHkxRDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vRm9yY2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG5cbnZhciBGT1JDRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQW4gaW52ZXJzZSBzcXVhcmUgZm9yY2UgZGVwZW5kZW50IG9uIHRoZSBtYXNzZXMgb2YgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0cy5cbiAqXG4gKiBAY2xhc3MgR3Jhdml0eTNEXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gR3Jhdml0eTNEKHNvdXJjZSwgdGFyZ2V0cywgb3B0aW9ucykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlIHx8IG51bGw7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuR3Jhdml0eTNELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRm9yY2UucHJvdG90eXBlKTtcbkdyYXZpdHkzRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmF2aXR5M0Q7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5HcmF2aXR5M0QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1heCA9IHRoaXMubWF4IHx8IEluZmluaXR5O1xuICAgIHRoaXMuc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoIHx8IDIwMDtcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkdyYXZpdHkzRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuXG4gICAgdmFyIGZvcmNlID0gRk9SQ0VfUkVHSVNURVI7XG5cbiAgICB2YXIgc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoO1xuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgYW5jaG9yID0gdGhpcy5hbmNob3IgfHwgc291cmNlLnBvc2l0aW9uO1xuICAgIHZhciBzb3VyY2VNYXNzID0gdGhpcy5hbmNob3IgPyAxIDogc291cmNlLm1hc3M7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIFZlYzMuc3VidHJhY3QoYW5jaG9yLCB0YXJnZXQucG9zaXRpb24sIGZvcmNlKTtcbiAgICAgICAgdmFyIGRpc3QgPSBmb3JjZS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIGludkRpc3RhbmNlID0gZGlzdCA/IDEgLyBkaXN0IDogMDtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IHN0cmVuZ3RoICogc291cmNlTWFzcyAqIHRhcmdldC5tYXNzICogaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZTtcbiAgICAgICAgaWYgKG1hZ25pdHVkZSA8IDApIHtcbiAgICAgICAgICAgIG1hZ25pdHVkZSA9IG1hZ25pdHVkZSA8IC1tYXggPyAtbWF4IDogbWFnbml0dWRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFnbml0dWRlID0gbWFnbml0dWRlID4gbWF4ID8gbWF4IDogbWFnbml0dWRlO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlLnNjYWxlKG1hZ25pdHVkZSAqIGludkRpc3RhbmNlKTtcbiAgICAgICAgdGFyZ2V0LmFwcGx5Rm9yY2UoZm9yY2UpO1xuICAgICAgICBpZiAoc291cmNlKSBzb3VyY2UuYXBwbHlGb3JjZShmb3JjZS5pbnZlcnQoKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmF2aXR5M0Q7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRm9yY2UgPSByZXF1aXJlKCcuL0ZvcmNlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjMycpO1xuXG52YXIgVE9SUVVFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBBIGJlaGF2aW9yIHRoYXQgc2xvd3MgYW5ndWxhciB2ZWxvY2l0eSBieSBhcHBseWluZyB0b3JxdWUuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxEcmFnXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyB0byBzZXQgb24gZHJhZ1xuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsRHJhZyh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuUm90YXRpb25hbERyYWcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGb3JjZS5wcm90b3R5cGUpO1xuUm90YXRpb25hbERyYWcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbERyYWc7XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSBhbmd1bGFyIHZlbG9jaXR5IGluIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgZHJhZyB0b3JxdWUuXG4gKlxuICogQGF0dHJpYnV0ZSBRVUFEUkFUSUNcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9IG9tZWdhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblJvdGF0aW9uYWxEcmFnLlFVQURSQVRJQyA9IGZ1bmN0aW9uIFFVQURSQVRJQyhvbWVnYSkge1xuICAgIHJldHVybiBvbWVnYS5sZW5ndGgoKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSBhbmd1bGFyIHZlbG9jaXR5IGluIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgZHJhZyB0b3JxdWUuXG4gKlxuICogQGF0dHJpYnV0ZSBMSU5FQVJcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblJvdGF0aW9uYWxEcmFnLkxJTkVBUiA9IGZ1bmN0aW9uIExJTkVBUigpIHtcbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5Sb3RhdGlvbmFsRHJhZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5tYXggPSB0aGlzLm1heCB8fCBJbmZpbml0eTtcbiAgICB0aGlzLnN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aCB8fCAxO1xuICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSB8fCBSb3RhdGlvbmFsRHJhZy5MSU5FQVI7XG59O1xuXG4vKipcbiAqIEFkZHMgYSByb3RhdGlvbmFsIGRyYWcgZm9yY2UgdG8gYSBwaHlzaWNzIGJvZHkncyB0b3JxdWUgYWNjdW11bGF0b3IuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuUm90YXRpb25hbERyYWcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIHZhciB0b3JxdWUgPSBUT1JRVUVfUkVHSVNURVI7XG5cbiAgICB2YXIgbWF4ID0gdGhpcy5tYXg7XG4gICAgdmFyIHN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgdmFyIG9tZWdhID0gdGFyZ2V0LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IC1zdHJlbmd0aCAqIHR5cGUob21lZ2EpO1xuICAgICAgICBWZWMzLnNjYWxlKG9tZWdhLCBtYWduaXR1ZGUgPCAtbWF4ID8gLW1heCA6IG1hZ25pdHVkZSwgdG9ycXVlKTtcbiAgICAgICAgdGFyZ2V0LmFwcGx5VG9ycXVlKHRvcnF1ZSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsRHJhZztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vRm9yY2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL01hdDMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uLy4uL21hdGgvUXVhdGVybmlvbicpO1xuXG52YXIgUV9SRUdJU1RFUiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgREFNUElOR19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgWFlaX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBNQVRfUkVHSVNURVIgPSBuZXcgTWF0MzMoKTtcblxuLyoqIEBjb25zdCBQSSAqL1xudmFyIFBJID0gTWF0aC5QSTtcblxuLyoqXG4gKiBBIHNwcmluZy1saWtlIGJlaGF2aW9yIHRoYXQgYXR0ZW1wdHMgdG8gZW5mb3JjZSBhIHNwZWNmaWMgb3JpZW50YXRpb24gYnkgYXBwbHlpbmcgdG9ycXVlLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsU3ByaW5nXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbFNwcmluZyhzb3VyY2UsIHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSB8fCBudWxsO1xuICAgIEZvcmNlLmNhbGwodGhpcywgdGFyZ2V0cywgb3B0aW9ucyk7XG59XG5cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGb3JjZS5wcm90b3R5cGUpO1xuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsU3ByaW5nO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIEZvcmNlLiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gKi9cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlKSB0aGlzLmFuY2hvciA9IHRoaXMuYW5jaG9yID8gdGhpcy5hbmNob3Iubm9ybWFsaXplKCkgOiBuZXcgUXVhdGVybmlvbigxLDAsMCwwKTtcbiAgICBpZiAob3B0aW9ucy5zdGlmZm5lc3MgfHwgb3B0aW9ucy5kYW1waW5nKSB7XG4gICAgICAgIHRoaXMuc3RpZmZuZXNzID0gdGhpcy5zdGlmZm5lc3MgfHwgMTAwO1xuICAgICAgICB0aGlzLmRhbXBpbmcgPSB0aGlzLmRhbXBpbmcgfHwgMDtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBudWxsO1xuICAgICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMucGVyaW9kIHx8IG9wdGlvbnMuZGFtcGluZ1JhdGlvKSB7XG4gICAgICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMTtcbiAgICAgICAgdGhpcy5kYW1waW5nUmF0aW8gPSB0aGlzLmRhbXBpbmdSYXRpbyB8fCAwO1xuXG4gICAgICAgIHRoaXMuc3RpZmZuZXNzID0gMiAqIFBJIC8gdGhpcy5wZXJpb2Q7XG4gICAgICAgIHRoaXMuc3RpZmZuZXNzICo9IHRoaXMuc3RpZmZuZXNzO1xuICAgICAgICB0aGlzLmRhbXBpbmcgPSA0ICogUEkgKiB0aGlzLmRhbXBpbmdSYXRpbyAvIHRoaXMucGVyaW9kO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkcyBhIHRvcnF1ZSBmb3JjZSB0byBhIHBoeXNpY3MgYm9keSdzIHRvcnF1ZSBhY2N1bXVsYXRvci5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuXG4gICAgdmFyIGRlbHRhUSA9IFFfUkVHSVNURVI7XG4gICAgdmFyIGRhbXBpbmdUb3JxdWUgPSBEQU1QSU5HX1JFR0lTVEVSO1xuICAgIHZhciBYWVogPSBYWVpfUkVHSVNURVI7XG4gICAgdmFyIGVmZkluZXJ0aWEgPSBNQVRfUkVHSVNURVI7XG5cbiAgICB2YXIgbWF4ID0gdGhpcy5tYXg7XG4gICAgdmFyIHN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzO1xuICAgIHZhciBkYW1waW5nID0gdGhpcy5kYW1waW5nO1xuICAgIHZhciBhbmNob3IgPSB0aGlzLmFuY2hvciB8fCBzb3VyY2Uub3JpZW50YXRpb247XG4gICAgdmFyIGludlNvdXJjZUluZXJ0aWEgPSB0aGlzLmFuY2hvciA/IG51bGwgOiBzb3VyY2UuaW52ZXJzZUluZXJ0aWE7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIHZhciBxID0gdGFyZ2V0Lm9yaWVudGF0aW9uO1xuICAgICAgICBRdWF0ZXJuaW9uLmNvbmp1Z2F0ZShxLCBkZWx0YVEpO1xuICAgICAgICBkZWx0YVEubXVsdGlwbHkoYW5jaG9yKTtcblxuICAgICAgICBpZiAoZGVsdGFRLncgPj0gMSkgY29udGludWU7XG4gICAgICAgIHZhciBoYWxmdGhldGEgPSBNYXRoLmFjb3MoZGVsdGFRLncpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KDEgLSBkZWx0YVEudyAqIGRlbHRhUS53KTtcblxuICAgICAgICB2YXIgZGVsdGFPbWVnYSA9IFhZWi5jb3B5KGRlbHRhUSkuc2NhbGUoMiAqIGhhbGZ0aGV0YSAvIGxlbmd0aCk7XG5cbiAgICAgICAgZGVsdGFPbWVnYS5zY2FsZShzdGlmZm5lc3MpO1xuXG4gICAgICAgIGlmIChpbnZTb3VyY2VJbmVydGlhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBNYXQzMy5hZGQoaW52U291cmNlSW5lcnRpYSwgdGFyZ2V0LmludmVyc2VJbmVydGlhLCBlZmZJbmVydGlhKS5pbnZlcnNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBNYXQzMy5pbnZlcnNlKHRhcmdldC5pbnZlcnNlSW5lcnRpYSwgZWZmSW5lcnRpYSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGFtcGluZyAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGRlbHRhT21lZ2EuYWRkKFZlYzMuc3VidHJhY3QodGFyZ2V0LmFuZ3VsYXJWZWxvY2l0eSwgc291cmNlLmFuZ3VsYXJWZWxvY2l0eSwgZGFtcGluZ1RvcnF1ZSkuc2NhbGUoLWRhbXBpbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbHRhT21lZ2EuYWRkKFZlYzMuc2NhbGUodGFyZ2V0LmFuZ3VsYXJWZWxvY2l0eSwgLWRhbXBpbmcsIGRhbXBpbmdUb3JxdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3JxdWUgPSBkZWx0YU9tZWdhLmFwcGx5TWF0cml4KGVmZkluZXJ0aWEpO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gdG9ycXVlLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmIChtYWduaXR1ZGUgPiBtYXgpIHRvcnF1ZS5zY2FsZShtYXgvbWFnbml0dWRlKTtcblxuICAgICAgICB0YXJnZXQuYXBwbHlUb3JxdWUodG9ycXVlKTtcbiAgICAgICAgaWYgKHNvdXJjZSkgc291cmNlLmFwcGx5VG9ycXVlKHRvcnF1ZS5pbnZlcnQoKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsU3ByaW5nO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9Gb3JjZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL1ZlYzMnKTtcblxudmFyIEZPUkNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBEQU1QSU5HX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBBIGZvcmNlIHRoYXQgYWNjZWxlcmF0ZXMgYSBQYXJ0aWNsZSB0b3dhcmRzIGEgc3BlY2lmaWMgYW5jaG9yIHBvaW50LiBDYW4gYmUgYW5jaG9yZWQgdG9cbiAqIGEgVmVjMyBvciBhbm90aGVyIHNvdXJjZSBQYXJ0aWNsZS5cbiAqXG4gKiAgQGNsYXNzIFNwcmluZ1xuICogIEBleHRlbmRzIEZvcmNlXG4gKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyB0byBzZXQgb24gZHJhZ1xuICovXG5mdW5jdGlvbiBTcHJpbmcoc291cmNlLCB0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2UgfHwgbnVsbDtcbiAgICBGb3JjZS5jYWxsKHRoaXMsIHRhcmdldHMsIG9wdGlvbnMpO1xufVxuXG5TcHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGb3JjZS5wcm90b3R5cGUpO1xuU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcmluZztcblxuLyoqIEBjb25zdCAqL1xudmFyIFBJID0gTWF0aC5QSTtcblxuLyoqXG4gKiBBIEZFTkUgKEZpbml0ZWx5IEV4dGVuc2libGUgTm9ubGluZWFyIEVsYXN0aWMpIHNwcmluZyBmb3JjZVxuICogICAgICBzZWU6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRkVORVxuICogQGF0dHJpYnV0ZSBGRU5FXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3QgY3VycmVudCBkaXN0YW5jZSB0YXJnZXQgaXMgZnJvbSBzb3VyY2UgYm9keVxuICogQHBhcmFtIHtOdW1iZXJ9IHJNYXggbWF4aW11bSByYW5nZSBvZiBpbmZsdWVuY2VcbiAqIEByZXR1cm4ge051bWJlcn0gdW5zY2FsZWQgZm9yY2VcbiAqL1xuU3ByaW5nLkZFTkUgPSBmdW5jdGlvbihkaXN0LCByTWF4KSB7XG4gICAgdmFyIHJNYXhTbWFsbCA9IHJNYXggKiAwLjk5O1xuICAgIHZhciByID0gTWF0aC5tYXgoTWF0aC5taW4oZGlzdCwgck1heFNtYWxsKSwgLXJNYXhTbWFsbCk7XG4gICAgcmV0dXJuIHIgLyAoMSAtIHIgKiByLyhyTWF4ICogck1heCkpO1xufTtcblxuLyoqXG4gKiBBIEhvb2tlYW4gc3ByaW5nIGZvcmNlLCBsaW5lYXIgaW4gdGhlIGRpc3BsYWNlbWVudFxuICogICAgICBzZWU6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXdcbiAqIEBhdHRyaWJ1dGUgSE9PS0VcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZGlzdCBjdXJyZW50IGRpc3RhbmNlIHRhcmdldCBpcyBmcm9tIHNvdXJjZSBib2R5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHVuc2NhbGVkIGZvcmNlXG4gKi9cblNwcmluZy5IT09LRSA9IGZ1bmN0aW9uKGRpc3QpIHtcbiAgICByZXR1cm4gZGlzdDtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMubWF4ID0gdGhpcy5tYXggfHwgSW5maW5pdHk7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSB8fCBTcHJpbmcuSE9PS0U7XG4gICAgdGhpcy5tYXhMZW5ndGggPSB0aGlzLm1heExlbmd0aCB8fCBJbmZpbml0eTtcbiAgICBpZiAob3B0aW9ucy5zdGlmZm5lc3MgfHwgb3B0aW9ucy5kYW1waW5nKSB7XG4gICAgICAgIHRoaXMuc3RpZmZuZXNzID0gdGhpcy5zdGlmZm5lc3MgfHwgMTAwO1xuICAgICAgICB0aGlzLmRhbXBpbmcgPSB0aGlzLmRhbXBpbmcgfHwgMDtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBudWxsO1xuICAgICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMucGVyaW9kIHx8IG9wdGlvbnMuZGFtcGluZ1JhdGlvKSB7XG4gICAgICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMTtcbiAgICAgICAgdGhpcy5kYW1waW5nUmF0aW8gPSB0aGlzLmRhbXBpbmdSYXRpbyB8fCAwO1xuXG4gICAgICAgIHRoaXMuc3RpZmZuZXNzID0gMiAqIFBJIC8gdGhpcy5wZXJpb2Q7XG4gICAgICAgIHRoaXMuc3RpZmZuZXNzICo9IHRoaXMuc3RpZmZuZXNzO1xuICAgICAgICB0aGlzLmRhbXBpbmcgPSA0ICogUEkgKiB0aGlzLmRhbXBpbmdSYXRpbyAvIHRoaXMucGVyaW9kO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblNwcmluZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuXG4gICAgdmFyIGZvcmNlID0gRk9SQ0VfUkVHSVNURVI7XG4gICAgdmFyIGRhbXBpbmdGb3JjZSA9IERBTVBJTkdfUkVHSVNURVI7XG5cbiAgICB2YXIgbWF4ID0gdGhpcy5tYXg7XG4gICAgdmFyIHN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzO1xuICAgIHZhciBkYW1waW5nID0gdGhpcy5kYW1waW5nO1xuICAgIHZhciByZXN0TGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIG1heExlbmd0aCA9IHRoaXMubWF4TGVuZ3RoO1xuICAgIHZhciBhbmNob3IgPSB0aGlzLmFuY2hvciB8fCBzb3VyY2UucG9zaXRpb247XG4gICAgdmFyIGludlNvdXJjZU1hc3MgPSB0aGlzLmFuY2hvciA/IDAgOiBzb3VyY2UuaW52ZXJzZU1hc3M7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgVmVjMy5zdWJ0cmFjdChhbmNob3IsIHRhcmdldC5wb3NpdGlvbiwgZm9yY2UpO1xuICAgICAgICB2YXIgZGlzdCA9IGZvcmNlLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3RyZXRjaCA9IGRpc3QgLSByZXN0TGVuZ3RoO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhzdHJldGNoKSA8IDFlLTYpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBlZmZNYXNzID0gMSAvICh0YXJnZXQuaW52ZXJzZU1hc3MgKyBpbnZTb3VyY2VNYXNzKTtcbiAgICAgICAgaWYgKHRoaXMucGVyaW9kICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGlmZm5lc3MgKj0gZWZmTWFzcztcbiAgICAgICAgICAgIGRhbXBpbmcgKj0gZWZmTWFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcmNlLnNjYWxlKHN0aWZmbmVzcyAqIHR5cGUoc3RyZXRjaCwgbWF4TGVuZ3RoKSAvIHN0cmV0Y2gpO1xuXG4gICAgICAgIGlmIChkYW1waW5nICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yY2UuYWRkKFZlYzMuc3VidHJhY3QodGFyZ2V0LnZlbG9jaXR5LCBzb3VyY2UudmVsb2NpdHksIGRhbXBpbmdGb3JjZSkuc2NhbGUoLWRhbXBpbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcmNlLmFkZChWZWMzLnNjYWxlKHRhcmdldC52ZWxvY2l0eSwgLWRhbXBpbmcsIGRhbXBpbmdGb3JjZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IGZvcmNlLmxlbmd0aCgpO1xuICAgICAgICB2YXIgaW52TWFnID0gbWFnbml0dWRlID8gMSAvIG1hZ25pdHVkZSA6IDA7XG5cbiAgICAgICAgVmVjMy5zY2FsZShmb3JjZSwgKG1hZ25pdHVkZSA+IG1heCA/IG1heCA6IG1hZ25pdHVkZSkgKiBpbnZNYWcsIGZvcmNlKTtcblxuICAgICAgICB0YXJnZXQuYXBwbHlGb3JjZShmb3JjZSk7XG4gICAgICAgIGlmIChzb3VyY2UpIHNvdXJjZS5hcHBseUZvcmNlKGZvcmNlLmludmVydCgpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUGFydGljbGU6IHJlcXVpcmUoJy4vYm9kaWVzL1BhcnRpY2xlJyksXG4gICAgQ29udmV4Qm9keUZhY3Rvcnk6IHJlcXVpcmUoJy4vYm9kaWVzL0NvbnZleEJvZHlGYWN0b3J5JyksXG4gICAgQm94OiByZXF1aXJlKCcuL2JvZGllcy9Cb3gnKSxcbiAgICBTcGhlcmU6IHJlcXVpcmUoJy4vYm9kaWVzL1NwaGVyZScpLFxuICAgIFdhbGw6IHJlcXVpcmUoJy4vYm9kaWVzL1dhbGwnKSxcblxuICAgIENvbnN0cmFpbnQ6IHJlcXVpcmUoJy4vY29uc3RyYWludHMvQ29uc3RyYWludCcpLFxuICAgIEFuZ2xlOiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0FuZ2xlJyksXG4gICAgQ29sbGlzaW9uOiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0NvbGxpc2lvbicpLFxuICAgIERpcmVjdGlvbjogcmVxdWlyZSgnLi9jb25zdHJhaW50cy9EaXJlY3Rpb24nKSxcbiAgICBEaXN0YW5jZTogcmVxdWlyZSgnLi9jb25zdHJhaW50cy9EaXN0YW5jZScpLFxuICAgIEN1cnZlOiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0N1cnZlJyksXG4gICAgSGluZ2U6IHJlcXVpcmUoJy4vY29uc3RyYWludHMvSGluZ2UnKSxcbiAgICBCYWxsQW5kU29ja2V0OiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0JhbGxBbmRTb2NrZXQnKSxcblxuICAgIEZvcmNlOiByZXF1aXJlKCcuL2ZvcmNlcy9Gb3JjZScpLFxuICAgIERyYWc6IHJlcXVpcmUoJy4vZm9yY2VzL0RyYWcnKSxcbiAgICBSb3RhdGlvbmFsRHJhZzogcmVxdWlyZSgnLi9mb3JjZXMvUm90YXRpb25hbERyYWcnKSxcbiAgICBHcmF2aXR5MUQ6IHJlcXVpcmUoJy4vZm9yY2VzL0dyYXZpdHkxRCcpLFxuICAgIEdyYXZpdHkzRDogcmVxdWlyZSgnLi9mb3JjZXMvR3Jhdml0eTNEJyksXG4gICAgU3ByaW5nOiByZXF1aXJlKCcuL2ZvcmNlcy9TcHJpbmcnKSxcbiAgICBSb3RhdGlvbmFsU3ByaW5nOiByZXF1aXJlKCcuL2ZvcmNlcy9Sb3RhdGlvbmFsU3ByaW5nJyksXG5cbiAgICBQaHlzaWNzRW5naW5lOiByZXF1aXJlKCcuL1BoeXNpY3NFbmdpbmUnKSxcbiAgICBHZW9tZXRyeTogcmVxdWlyZSgnLi9HZW9tZXRyeScpXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4vLyBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG4gXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLiBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kIFRpbm8gWmlqZGVsXG4gXG4vLyBNSVQgbGljZW5zZVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsYXN0VGltZSA9IDA7XG52YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5cbnZhciByQUYsIGNBRjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICBjQUYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFyQUY7ICsreCkge1xuICAgICAgICByQUYgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgICAgY0FGID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10gfHxcbiAgICAgICAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXTtcbiAgICB9XG5cbiAgICBpZiAockFGICYmICFjQUYpIHtcbiAgICAgICAgLy8gY0FGIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBzZXRJbnRlcnZhbCBmb3Igbm93ICh2ZXJ5IHJhcmUpLlxuICAgICAgICByQUYgPSBudWxsO1xuICAgIH1cbn1cblxuaWYgKCFyQUYpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3cgPyBEYXRlLm5vdyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICByQUYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VyclRpbWUgPSBub3coKTtcbiAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgIHZhciBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcblxuICAgIGNBRiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZTogckFGLFxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lOiBjQUZcbn07XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJlcXVpcmUoJy4vYW5pbWF0aW9uRnJhbWUnKS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWU6IHJlcXVpcmUoJy4vYW5pbWF0aW9uRnJhbWUnKS5jYW5jZWxBbmltYXRpb25GcmFtZVxufTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb250ZXh0ID0gcmVxdWlyZSgnLi9Db250ZXh0Jyk7XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgbmV3IENvbXBvc2l0b3IsIHVzZWQgZm9yIHJvdXRpbmcgY29tbWFuZHMgcmVjZWl2ZWQgZnJvbSB0aGVcbiAqIFdlYldvcmtlciB0byB0aGUgV2ViR0wgYW5kIERPTSByZW5kZXJlci5cbiAqXG4gKiBAY2xhc3MgQ29tcG9zaXRvclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0b3IoKSB7XG4gICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLl9vdXRDb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuX2luQ29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLl90aW1lID0gbnVsbDtcblxuICAgIHRoaXMuX3Jlc2l6ZWQgPSBmYWxzZTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fcmVzaXplZCA9IHRydWU7XG4gICAgfSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB0aW1lIGJlaW5nIHVzZWQgYnkgdGhlIGludGVybmFsIGNsb2NrIG1hbmFnZWQgYnlcbiAqIGBGYW1vdXNFbmdpbmVgLlxuICogXG4gKiBAbWV0aG9kICBnZXRUaW1lXG4gKiAgXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBDbG9jayB0aW1lLlxuICovIFxuQ29tcG9zaXRvci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uIGdldFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWU7XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlcyBhbiBldmVudCB0byBiZSBzZW50IHRvIHRoZSBXZWJXb3JrZXIgdGhlIG5leHQgdGltZSB0aGUgb3V0IGNvbW1hbmRcbiAqIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQG1ldGhvZCBzZW5kRXZlbnRcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBwYXRoICAgIHJlbmRlciBwYXRoIHRvIHRoZSBub2RlIHRoZSBldmVudCBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgb24gKCp0YXJnZXRlZCBldmVudCopXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGV2ICAgICAgZXZlbnQgdHlwZVxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkIGV2ZW50IG9iamVjdCAoc2VyaWFsaXphYmxlIHVzaW5nIHN0cnVjdHVyZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uaW5nIGFsZ29yaXRobSlcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuc2VuZEV2ZW50ID0gZnVuY3Rpb24gc2VuZEV2ZW50KHBhdGgsIGV2LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fb3V0Q29tbWFuZHMucHVzaCgnV0lUSCcsIHBhdGgsICdUUklHR0VSJywgZXYsIHBheWxvYWQpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIHVzZWQgZm9yIG5vdGlmeWluZyB0aGUgV2ViV29ya2VyIGFib3V0IGV4dGVybmFsbHlcbiAqIHJlc2l6ZWQgY29udGV4dHMgKGUuZy4gYnkgcmVzaXppbmcgdGhlIGJyb3dzZXIgd2luZG93KS5cbiAqXG4gKiBAbWV0aG9kIHNlbmRSZXNpemVcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzZWxlY3RvciAgICByZW5kZXIgcGF0aCB0byB0aGUgbm9kZSAoY29udGV4dCkgdGhhdCBzaG91bGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgcmVzaXplZFxuICogQHBhcmFtICB7QXJyYXl9IHNpemUgICAgICAgICBuZXcgY29udGV4dCBzaXplXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLnNlbmRSZXNpemUgPSBmdW5jdGlvbiBzZW5kUmVzaXplIChzZWxlY3Rvciwgc2l6ZSkge1xuICAgIHRoaXMuc2VuZEV2ZW50KHNlbGVjdG9yLCAnQ09OVEVYVF9SRVNJWkUnLCBzaXplKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB1c2VkIGJ5IGBkcmF3Q29tbWFuZHNgLlxuICpcbiAqIEBtZXRob2QgaGFuZGxlV2l0aFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gY29tbWFuZHMgICAgIHJlbWFpbmluZyBtZXNzYWdlIHF1ZXVlIHJlY2VpdmVkIGZyb20gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYldvcmtlciwgdXNlZCB0byBzaGlmdCBzaW5nbGUgbWVzc2FnZXMgZnJvbVxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5oYW5kbGVXaXRoID0gZnVuY3Rpb24gaGFuZGxlV2l0aCAoaXRlcmF0b3IsIGNvbW1hbmRzKSB7XG4gICAgdmFyIHBhdGggPSBjb21tYW5kc1tpdGVyYXRvcl07XG4gICAgdmFyIHBhdGhBcnIgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldE9yU2V0Q29udGV4dChwYXRoQXJyLnNoaWZ0KCkpO1xuICAgIHJldHVybiBjb250ZXh0LnJlY2VpdmUocGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB0b3AtbGV2ZWwgQ29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHBhc3NlZCBpbiBkb2N1bWVudFxuICogcXVlcnkgc2VsZWN0b3IuIElmIG5vIHN1Y2ggQ29udGV4dCBleGlzdHMsIGEgbmV3IG9uZSB3aWxsIGJlIGluc3RhbnRpYXRlZC5cbiAqXG4gKiBAbWV0aG9kIGdldE9yU2V0Q29udGV4dFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNlbGVjdG9yICAgICAgICAgICAgZG9jdW1lbnQgcXVlcnkgc2VsZWN0b3IgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyaWV2aW5nIHRoZSBET00gbm9kZSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWaXJ0dWFsRWxlbWVudCBzaG91bGQgYmUgYXR0YWNoZWQgdG9cbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gKiBAcmV0dXJuIHtDb250ZXh0fSAgICAgICAgICAgICAgICAgICAgZmluYWwgVmlydHVhbEVsZW1lbnRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZ2V0T3JTZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0T3JTZXRDb250ZXh0KHNlbGVjdG9yKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSkgcmV0dXJuIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXTtcbiAgICBlbHNlIHJldHVybiAodGhpcy5fY29udGV4dHNbc2VsZWN0b3JdID0gbmV3IENvbnRleHQoc2VsZWN0b3IsIHRoaXMpKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB1c2VkIGJ5IGBkcmF3Q29tbWFuZHNgLlxuICpcbiAqIEBtZXRob2QgZ2l2ZVNpemVGb3JcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGNvbW1hbmRzICAgICByZW1haW5pbmcgbWVzc2FnZSBxdWV1ZSByZWNlaXZlZCBmcm9tIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJXb3JrZXIsIHVzZWQgdG8gc2hpZnQgc2luZ2xlIG1lc3NhZ2VzIGZyb21cbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZ2l2ZVNpemVGb3IgPSBmdW5jdGlvbiBnaXZlU2l6ZUZvcihpdGVyYXRvciwgY29tbWFuZHMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb21tYW5kc1tpdGVyYXRvcl07XG4gICAgdmFyIHNpemUgPSB0aGlzLmdldE9yU2V0Q29udGV4dChzZWxlY3RvcikuZ2V0Um9vdFNpemUoKTtcbiAgICB0aGlzLnNlbmRSZXNpemUoc2VsZWN0b3IsIHNpemUpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgdGhlIHByZXZpb3VzbHkgdmlhIGByZWNlaXZlQ29tbWFuZHNgIHVwZGF0ZWQgaW5jb21pbmcgXCJpblwiXG4gKiBjb21tYW5kIHF1ZXVlLlxuICogQ2FsbGVkIGJ5IFRocmVhZE1hbmFnZXIuXG4gKlxuICogQG1ldGhvZCBkcmF3Q29tbWFuZHNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0Q29tbWFuZHMgIHNldCBvZiBjb21tYW5kcyB0byBiZSBzZW50IGJhY2sgdG8gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYldvcmtlclxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5kcmF3Q29tbWFuZHMgPSBmdW5jdGlvbiBkcmF3Q29tbWFuZHMoKSB7XG4gICAgdmFyIGNvbW1hbmRzID0gdGhpcy5faW5Db21tYW5kcztcbiAgICB2YXIgbG9jYWxJdGVyYXRvciA9IDA7XG4gICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kc1tsb2NhbEl0ZXJhdG9yXTtcbiAgICB3aGlsZSAoY29tbWFuZCkge1xuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RJTUUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWUgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnV0lUSCc6XG4gICAgICAgICAgICAgICAgbG9jYWxJdGVyYXRvciA9IHRoaXMuaGFuZGxlV2l0aCgrK2xvY2FsSXRlcmF0b3IsIGNvbW1hbmRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ05FRURfU0laRV9GT1InOlxuICAgICAgICAgICAgICAgIHRoaXMuZ2l2ZVNpemVGb3IoKytsb2NhbEl0ZXJhdG9yLCBjb21tYW5kcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU3dpdGNoIHRvIGFzc29jaWF0aXZlIGFycmF5cyBoZXJlLi4uXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY29udGV4dHMpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dHNba2V5XS5kcmF3KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jlc2l6ZWQgJiYgdGhpcy5fY29udGV4dHMuYm9keSkge1xuICAgICAgICB0aGlzLnNlbmRSZXNpemUoJ2JvZHknLCB0aGlzLl9jb250ZXh0cy5ib2R5LmdldFJvb3RTaXplKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9vdXRDb21tYW5kcztcbn07XG5cbi8qKlxuICogVXNlZCBieSBUaHJlYWRNYW5hZ2VyIHRvIHVwZGF0ZSB0aGUgaW50ZXJhbCBxdWV1ZSBvZiBpbmNvbWluZyBjb21tYW5kcy5cbiAqIFJlY2VpdmluZyBjb21tYW5kcyBkb2VzIG5vdCBpbW1lZGlhdGVseSBzdGFydCB0aGUgcmVkZXJuaW5nIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGNvbW1hbmRzICAgICBjb21tYW5kIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZCBieSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRvcidzIGBkcmF3Q29tbWFuZHNgIG1ldGhvZFxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5yZWNlaXZlQ29tbWFuZHMgPSBmdW5jdGlvbiByZWNlaXZlQ29tbWFuZHMoY29tbWFuZHMpIHtcbiAgICB2YXIgbGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5faW5Db21tYW5kcy5wdXNoKGNvbW1hbmRzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZsdXNoZXMgdGhlIHF1ZXVlIG9mIG91dGdvaW5nIFwib3V0XCIgY29tbWFuZHMuXG4gKiBDYWxsZWQgYnkgVGhyZWFkTWFuYWdlci5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyQ29tbWFuZHNcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuY2xlYXJDb21tYW5kcyA9IGZ1bmN0aW9uIGNsZWFyQ29tbWFuZHMoKSB7XG4gICAgdGhpcy5faW5Db21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX291dENvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcmVzaXplZCA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0b3I7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3dlYmdsLXJlbmRlcmVycy9XZWJHTFJlbmRlcmVyJyk7XG52YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9DYW1lcmEnKTtcbnZhciBET01SZW5kZXJlciA9IHJlcXVpcmUoJy4uL2RvbS1yZW5kZXJlcnMvRE9NUmVuZGVyZXInKTtcblxuLyoqXG4gKiBDb250ZXh0IGlzIGEgcmVuZGVyIGxheWVyIHdpdGggaXRzIG93biBXZWJHTFJlbmRlcmVyIGFuZCBET01SZW5kZXJlci5cbiAqIEl0IGlzIHRoZSBpbnRlcmZhY2UgYmV0d2VlbiB0aGUgQ29tcG9zaXRvciB3aGljaCByZWNlaXZlcyBjb21tYW5kc1xuICogYW5kIHRoZSByZW5kZXJlcnMgdGhhdCBpbnRlcnByZXQgdGhlbS4gIEl0IGFsc28gcmVsYXlzIGluZm9ybWF0aW9uIHRvXG4gKiB0aGUgcmVuZGVyZXJzIGFib3V0IHJlc2l6aW5nLlxuICpcbiAqIFRoZSBET01FbGVtZW50IGF0IHRoZSBnaXZlbiBxdWVyeSBzZWxlY3RvciBpcyB1c2VkIGFzIHRoZSByb290LiAgQVxuICogbmV3IERPTUVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhpcyByb290IGVsZW1lbnQsIGFuZCB1c2VkIGFzIHRoZVxuICogcGFyZW50IGVsZW1lbnQgZm9yIGFsbCBGYW1vdXMgRE9NIHJlbmRlcmluZyBhdCB0aGlzIGNvbnRleHQuICBBIFxuICogY2FudmFzIGlzIGFkZGVkIGFuZCB1c2VkIGZvciBhbGwgV2ViR0wgcmVuZGVyaW5nIGF0IHRoaXMgY29udGV4dC5cbiAqXG4gKiBAY2xhc3MgQ29udGV4dFxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIFF1ZXJ5IHNlbGVjdG9yIHVzZWQgdG8gbG9jYXRlIHJvb3QgZWxlbWVudCBvZlxuICogY29udGV4dCBsYXllci5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciBDb21wb3NpdG9yIHJlZmVyZW5jZSB0byBwYXNzIGRvd24gdG8gXG4gKiBXZWJHTFJlbmRlcmVyLlxuICovXG5mdW5jdGlvbiBDb250ZXh0KHNlbGVjdG9yLCBjb21wb3NpdG9yKSB7XG4gICAgdGhpcy5fY29tcG9zaXRvciA9IGNvbXBvc2l0b3I7XG4gICAgdGhpcy5fcm9vdEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICAvLyBJZiByb290IGVsZW1lbnQgaXMgdGhlIGJvZHksIHVwZGF0ZSBzaXplIG9uIHRoZSBjb250ZXh0XG4gICAgLy8gb24gd2luZG93IHJlc2l6ZSBldmVudHMuXG5cbiAgICBpZiAodGhpcy5fcm9vdEVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnVwZGF0ZVNpemUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIERPTSBlbGVtZW50IHRvIGJlIHVzZWQgYXMgcm9vdCBmb3IgYWxsIGZhbW91cyBET01cbiAgICAvLyByZW5kZXJpbmcgYW5kIGFwcGVuZCBlbGVtZW50IHRvIHRoZSByb290IGVsZW1lbnQuXG5cbiAgICB2YXIgRE9NTGF5ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIERPTUxheWVyRWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgRE9NTGF5ZXJFbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgRE9NTGF5ZXJFbC5zdHlsZS50cmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgRE9NTGF5ZXJFbC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG5cbiAgICB0aGlzLl9yb290RWwuYXBwZW5kQ2hpbGQoRE9NTGF5ZXJFbCk7XG5cbiAgICAvLyBJbnN0YW50aWF0ZSByZW5kZXJlcnNcblxuICAgIHRoaXMuRE9NUmVuZGVyZXIgPSBuZXcgRE9NUmVuZGVyZXIoRE9NTGF5ZXJFbCwgc2VsZWN0b3IsIGNvbXBvc2l0b3IpO1xuICAgIHRoaXMuV2ViR0xSZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgLy8gU3RhdGUgaG9sZGVyc1xuXG4gICAgdGhpcy5fcmVuZGVyU3RhdGUgPSB7XG4gICAgICAgIHByb2plY3Rpb25UeXBlOiBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT04sXG4gICAgICAgIHBlcnNwZWN0aXZlVHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIHZpZXdUcmFuc2Zvcm06IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgdmlld0RpcnR5OiBmYWxzZSxcbiAgICAgICAgcGVyc3BlY3RpdmVEaXJ0eTogZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpcy5fc2l6ZSA9IFtdO1xuICAgIHRoaXMuX2NoaWxkcmVuID0ge307XG4gICAgdGhpcy5fZWxlbWVudEhhc2ggPSB7fTtcblxuICAgIHRoaXMuX21lc2hUcmFuc2Zvcm0gPSBbXTtcbiAgICB0aGlzLl9tZXNoU2l6ZSA9IFswLCAwLCAwXTtcbn1cblxuLyoqXG4gKiBRdWVyaWVzIERPTVJlbmRlcmVyIHNpemUgYW5kIHVwZGF0ZXMgY2FudmFzIHNpemUuICBSZWxheXMgc2l6ZSBpbmZvcm1hdGlvbiB0byBcbiAqIFdlYkdMUmVuZGVyZXIuXG4gKlxuICogQG1ldGhvZCBkcmF3QnVmZmVyc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBjb250ZXh0LlxuICovXG5Db250ZXh0LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdTaXplID0gdGhpcy5ET01SZW5kZXJlci5nZXRTaXplKCk7XG5cbiAgICB2YXIgd2lkdGggPSBuZXdTaXplWzBdO1xuICAgIHZhciBoZWlnaHQgPSBuZXdTaXplWzFdO1xuXG4gICAgdGhpcy5fc2l6ZVswXSA9IHdpZHRoO1xuICAgIHRoaXMuX3NpemVbMV0gPSBoZWlnaHQ7XG4gICAgdGhpcy5fc2l6ZVsyXSA9ICh3aWR0aCA+IGhlaWdodCkgPyB3aWR0aCA6IGhlaWdodDtcblxuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCAgPSB3aWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci51cGRhdGVTaXplKHRoaXMuX3NpemUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERyYXcgZnVuY3Rpb24gY2FsbGVkIGFmdGVyIGFsbCBjb21tYW5kcyBoYXZlIGJlZW4gaGFuZGxlZCBmb3IgY3VycmVudCBmcmFtZS5cbiAqIElzc3VlcyBkcmF3IGNvbW1hbmRzIHRvIGFsbCByZW5kZXJlcnMgd2l0aCBjdXJyZW50IHJlbmRlclN0YXRlLlxuICpcbiAqIEBtZXRob2QgZHJhd1xuICovXG5Db250ZXh0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZHJhdygpIHtcbiAgICB0aGlzLkRPTVJlbmRlcmVyLmRyYXcodGhpcy5fcmVuZGVyU3RhdGUpO1xuICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci5kcmF3KHRoaXMuX3JlbmRlclN0YXRlKTtcblxuICAgIGlmICh0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5KSB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX3JlbmRlclN0YXRlLnZpZXdEaXJ0eSkgdGhpcy5fcmVuZGVyU3RhdGUudmlld0RpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBET01SZW5kZXJlciBmb3IgdGhpcyBjb250ZXh0LlxuICpcbiAqIEBtZXRob2QgZ2V0Um9vdFNpemVcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZ2V0Um9vdFNpemUgPSBmdW5jdGlvbiBnZXRSb290U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ET01SZW5kZXJlci5nZXRTaXplKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgaW5pdGlhbGl6YXRpb24gb2YgV2ViR0xSZW5kZXJlciB3aGVuIG5lY2Vzc2FyeSwgaW5jbHVkaW5nIGNyZWF0aW9uXG4gKiBvZiB0aGUgY2FudmFzIGVsZW1lbnQgYW5kIGluc3RhbnRpYXRpb24gb2YgdGhlIHJlbmRlcmVyLiAgQWxzbyB1cGRhdGVzIHNpemVcbiAqIHRvIHBhc3Mgc2l6ZSBpbmZvcm1hdGlvbiB0byB0aGUgcmVuZGVyZXIuXG4gKlxuICogQG1ldGhvZCBpbml0V2ViR0xcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuaW5pdFdlYkdMID0gZnVuY3Rpb24gaW5pdFdlYkdMKCkge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5fcm9vdEVsLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICB0aGlzLldlYkdMUmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcih0aGlzLmNhbnZhcywgdGhpcy5fY29tcG9zaXRvcik7XG4gICAgdGhpcy51cGRhdGVTaXplKCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgZGVsZWdhdGlvbiBvZiBjb21tYW5kcyB0byByZW5kZXJlcnMgb2YgdGhpcyBjb250ZXh0LlxuICpcbiAqIEBtZXRob2QgcmVjZWl2ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFN0cmluZyB1c2VkIGFzIGlkZW50aWZpZXIgb2YgYSBnaXZlbiBub2RlIGluIHRoZVxuICogc2NlbmUgZ3JhcGguXG4gKiBAcGFyYW0ge0FycmF5fSBjb21tYW5kcyBMaXN0IG9mIGFsbCBjb21tYW5kcyBmcm9tIHRoaXMgZnJhbWUuXG4gKiBAcGFyYW0ge051bWJlcn0gaXRlcmF0b3IgTnVtYmVyIGluZGljYXRpbmcgcHJvZ3Jlc3MgdGhyb3VnaCB0aGUgY29tbWFuZFxuICogcXVldWUuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBpdGVyYXRvciBpbmRpY2F0aW5nIHByb2dyZXNzIHRocm91Z2ggdGhlIGNvbW1hbmQgcXVldWUuXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbiByZWNlaXZlKHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIHZhciBsb2NhbEl0ZXJhdG9yID0gaXRlcmF0b3I7XG5cbiAgICB2YXIgY29tbWFuZCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgdGhpcy5ET01SZW5kZXJlci5sb2FkUGF0aChwYXRoKTtcbiAgICB0aGlzLkRPTVJlbmRlcmVyLmZpbmRUYXJnZXQoKTtcbiAgICB3aGlsZSAoY29tbWFuZCkge1xuXG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAnSU5JVF9ET00nOlxuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIuaW5zZXJ0RWwoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0RPTV9SRU5ERVJfU0laRSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5nZXRTaXplT2YoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9UUkFOU0ZPUk0nOlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IDE2IDsgaSsrKSB0aGlzLl9tZXNoVHJhbnNmb3JtW2ldID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIuc2V0TWF0cml4KHRoaXMuX21lc2hUcmFuc2Zvcm0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldEN1dG91dFVuaWZvcm0ocGF0aCwgJ3VfdHJhbnNmb3JtJywgdGhpcy5fbWVzaFRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1NJWkUnOlxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNoU2l6ZVswXSA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNoU2l6ZVsxXSA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldEN1dG91dFVuaWZvcm0ocGF0aCwgJ3Vfc2l6ZScsIHRoaXMuX21lc2hTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9QUk9QRVJUWSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIuc2V0UHJvcGVydHkoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSwgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9DT05URU5UJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5zZXRDb250ZW50KGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfQVRUUklCVVRFJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5zZXRBdHRyaWJ1dGUoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSwgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0FERF9DTEFTUyc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIuYWRkQ2xhc3MoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9DTEFTUyc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIucmVtb3ZlQ2xhc3MoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlICdTVUJTQ1JJQkUnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci5nZXRPclNldEN1dG91dChwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLnN1YnNjcmliZShjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLCBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfU0VUX0RSQVdfT1BUSU9OUyc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldE1lc2hPcHRpb25zKHBhdGgsIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9BTUJJRU5UX0xJR0hUJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuc2V0QW1iaWVudExpZ2h0Q29sb3IoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9MSUdIVF9QT1NJVElPTic6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldExpZ2h0UG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9MSUdIVF9DT0xPUic6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldExpZ2h0Q29sb3IoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdNQVRFUklBTF9JTlBVVCc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLmhhbmRsZU1hdGVyaWFsSW5wdXQoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9TRVRfR0VPTUVUUlknOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0dMX1VOSUZPUk1TJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuc2V0TWVzaFVuaWZvcm0oXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9CVUZGRVJfREFUQSc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLmJ1ZmZlckRhdGEoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9DVVRPVVRfU1RBVEUnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRDdXRvdXRTdGF0ZShwYXRoLCBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfTUVTSF9WSVNJQklMSVRZJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuc2V0TWVzaFZpc2liaWxpdHkocGF0aCwgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0dMX1JFTU9WRV9NRVNIJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIucmVtb3ZlTWVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnUElOSE9MRV9QUk9KRUNUSU9OJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5QSU5IT0xFX1BST0pFQ1RJT047XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTFdID0gLTEgLyBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ09SVEhPR1JBUEhJQ19QUk9KRUNUSU9OJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSAwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RSQU5TRk9STSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVswXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsyXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVszXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzRdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzVdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzZdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzddID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bOF0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bOV0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTBdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzExXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzEyXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxM10gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTRdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzE1XSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdXSVRIJzogcmV0dXJuIGxvY2FsSXRlcmF0b3IgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsSXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBVSU1hbmFnZXIgaXMgYmVpbmcgdXBkYXRlZCBieSBhbiBFbmdpbmUgYnkgY29uc2VjdXRpdmVseSBjYWxsaW5nIGl0c1xuICogYHVwZGF0ZWAgbWV0aG9kLiBJdCBjYW4gZWl0aGVyIG1hbmFnZSBhIHJlYWwgV2ViLVdvcmtlciBvciB0aGUgZ2xvYmFsXG4gKiBGYW1vdXNFbmdpbmUgY29yZSBzaW5nbGV0b24uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBjb21wb3NpdG9yID0gbmV3IENvbXBvc2l0b3IoKTtcbiAqIHZhciBlbmdpbmUgPSBuZXcgRW5naW5lKCk7XG4gKiBcbiAqIC8vIFVzaW5nIGEgV2ViIFdvcmtlclxuICogdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoJ3dvcmtlci5idW5kbGUuanMnKTtcbiAqIHZhciB0aHJlYWRtYW5nZXIgPSBuZXcgVUlNYW5hZ2VyKHdvcmtlciwgY29tcG9zaXRvciwgZW5naW5lKTtcbiAqIFxuICogLy8gV2l0aG91dCB1c2luZyBhIFdlYiBXb3JrZXJcbiAqIHZhciB0aHJlYWRtYW5nZXIgPSBuZXcgVUlNYW5hZ2VyKEZhbW91cywgY29tcG9zaXRvciwgZW5naW5lKTtcbiAqIFxuICogQGNsYXNzICBVSU1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge0ZhbW91c3xXb3JrZXJ9IHRocmVhZCAgICAgICAgVGhlIHRocmVhZCBiZWluZyB1c2VkIHRvIHJlY2VpdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcyBmcm9tIGFuZCBwb3N0IG1lc3NhZ2VzIHRvLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4cGVjdGVkIHRvIGV4cG9zZSBhIFdlYldvcmtlci1saWtlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBJLCB3aGljaCBtZWFucyBwcm92aWRpbmcgYSB3YXkgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW4gZm9yIHVwZGF0ZXMgYnkgc2V0dGluZyBpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgb25tZXNzYWdlYCBwcm9wZXJ0eSBhbmQgc2VuZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMgdXNpbmcgYHBvc3RNZXNzYWdlYC5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciAgICAgICBhbiBpbnN0YW5jZSBvZiBDb21wb3NpdG9yIHVzZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0IGVucXVldWVkIGRyYXcgY29tbWFuZHMgZnJvbSB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHNlbnQgdG8gdGhlIHRocmVhZC5cbiAqIEBwYXJhbSB7RW5naW5lfSBlbmdpbmUgICAgICAgICAgICAgICBhbiBpbnN0YW5jZSBvZiBFbmdpbmUgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpbmcgdGhlIGBFTkdJTkVgIGNvbW1hbmRzIG9uLlxuICovXG5mdW5jdGlvbiBVSU1hbmFnZXIgKHRocmVhZCwgY29tcG9zaXRvciwgZW5naW5lKSB7XG4gICAgdGhpcy5fdGhyZWFkID0gdGhyZWFkO1xuICAgIHRoaXMuX2NvbXBvc2l0b3IgPSBjb21wb3NpdG9yO1xuICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcblxuICAgIHRoaXMuX2VuZ2luZS51cGRhdGUodGhpcyk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3RocmVhZC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBldi5kYXRhID8gZXYuZGF0YSA6IGV2O1xuICAgICAgICBpZiAobWVzc2FnZVswXSA9PT0gJ0VOR0lORScpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZVsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTVE9QJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnVW5rbm93biBFTkdJTkUgY29tbWFuZCBcIicgKyBtZXNzYWdlWzFdICsgJ1wiJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9jb21wb3NpdG9yLnJlY2VpdmVDb21tYW5kcyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fdGhyZWFkLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aHJlYWQgYmVpbmcgdXNlZCBieSB0aGUgVUlNYW5hZ2VyLlxuICogVGhpcyBjb3VsZCBlaXRoZXIgYmUgYW4gYW4gYWN0dWFsIHdlYiB3b3JrZXIgb3IgYSBgRmFtb3VzRW5naW5lYCBzaW5nbGV0b24uXG4gKlxuICogQG1ldGhvZCBnZXRUaHJlYWRcbiAqIFxuICogQHJldHVybiB7V29ya2VyfEZhbW91c0VuZ2luZX0gIEVpdGhlciBhIHdlYiB3b3JrZXIgb3IgYSBgRmFtb3VzRW5naW5lYCBzaW5nbGV0b24uXG4gKi9cblVJTWFuYWdlci5wcm90b3R5cGUuZ2V0VGhyZWFkID0gZnVuY3Rpb24gZ2V0VGhyZWFkKCkge1xuICAgIHJldHVybiB0aGlzLl90aHJlYWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbXBvc2l0b3IgYmVpbmcgdXNlZCBieSB0aGlzIFVJTWFuYWdlci5cbiAqXG4gKiBAbWV0aG9kIGdldENvbXBvc2l0b3JcbiAqIFxuICogQHJldHVybiB7Q29tcG9zaXRvcn0gICAgIFRoZSBjb21wb3NpdG9yIHVzZWQgYnkgdGhlIFVJTWFuYWdlci5cbiAqL1xuVUlNYW5hZ2VyLnByb3RvdHlwZS5nZXRDb21wb3NpdG9yID0gZnVuY3Rpb24gZ2V0Q29tcG9zaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9zaXRvcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZW5naW5lIGJlaW5nIHVzZWQgYnkgdGhpcyBVSU1hbmFnZXIuXG4gKlxuICogQG1ldGhvZCBnZXRFbmdpbmVcbiAqIFxuICogQHJldHVybiB7RW5naW5lfSAgICAgVGhlIGVuZ2luZSB1c2VkIGJ5IHRoZSBVSU1hbmFnZXIuXG4gKi9cblVJTWFuYWdlci5wcm90b3R5cGUuZ2V0RW5naW5lID0gZnVuY3Rpb24gZ2V0RW5naW5lKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmdpbmU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBtZXRob2QgYmVpbmcgaW52b2tlZCBieSB0aGUgRW5naW5lIG9uIGV2ZXJ5IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICogVXNlZCBmb3IgdXBkYXRpbmcgdGhlIG5vdGlvbiBvZiB0aW1lIHdpdGhpbiB0aGUgbWFuYWdlZCB0aHJlYWQgYnkgc2VuZGluZ1xuICogYSBGUkFNRSBjb21tYW5kIGFuZCBzZW5kaW5nIG1lc3NhZ2VzIHRvIFxuICogXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgdW5peCB0aW1lc3RhbXAgdG8gYmUgcGFzc2VkIGRvd24gdG8gdGhlIHdvcmtlciBhcyBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgRlJBTUUgY29tbWFuZFxuICovXG5VSU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAodGltZSkge1xuICAgIHRoaXMuX3RocmVhZC5wb3N0TWVzc2FnZShbJ0ZSQU1FJywgdGltZV0pO1xuICAgIHZhciB0aHJlYWRNZXNzYWdlcyA9IHRoaXMuX2NvbXBvc2l0b3IuZHJhd0NvbW1hbmRzKCk7XG4gICAgdGhpcy5fdGhyZWFkLnBvc3RNZXNzYWdlKHRocmVhZE1lc3NhZ2VzKTtcbiAgICB0aGlzLl9jb21wb3NpdG9yLmNsZWFyQ29tbWFuZHMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVUlNYW5hZ2VyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ29tcG9zaXRvcjogcmVxdWlyZSgnLi9Db21wb3NpdG9yJyksXG4gICAgVUlNYW5hZ2VyOiByZXF1aXJlKCcuL1VJTWFuYWdlcicpXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNoaW50IC1XMDA4ICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1cnZlcyA9IHtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbGluZWFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlSW5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VJbjogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZU91dFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZU91dDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCooMi10KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VJbk91dFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZUluT3V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDw9IDAuNSkgcmV0dXJuIDIqdCp0O1xuICAgICAgICBlbHNlIHJldHVybiAtMip0KnQgKyA0KnQgLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZU91dEJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZU91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCooMyAtIDIqdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBzcHJpbmdcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHNwcmluZzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKDEgLSB0KSAqIE1hdGguc2luKDYgKiBNYXRoLlBJICogdCkgKyB0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5RdWFkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblF1YWQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFF1YWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0odC09MSkqdCsxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRRdWFkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0O1xuICAgICAgICByZXR1cm4gLS41KigoLS10KSoodC0yKSAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5DdWJpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5DdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRDdWJpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KnQgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0Q3ViaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQ7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqdCArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5RdWFydFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5RdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFF1YXJ0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRRdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLSgoLS10KSp0KnQqdCAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRRdWFydFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRRdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQqdCp0O1xuICAgICAgICByZXR1cm4gLS41ICogKCh0LT0yKSp0KnQqdCAtIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5RdWludFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5RdWludDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQqdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0UXVpbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFF1aW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCp0KnQqdCArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRRdWludFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQqdCp0KnQ7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqdCp0KnQgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluU2luZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5TaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtMS4wKk1hdGguY29zKHQgKiAoTWF0aC5QSS8yKSkgKyAxLjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRTaW5lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRTaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkvMikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRTaW5lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0uNSooTWF0aC5jb3MoTWF0aC5QSSp0KSAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5FeHBvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICh0PT09MCkgPyAwLjAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0RXhwb1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0RXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKHQ9PT0xLjApID8gMS4wIDogKC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRFeHBvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wO1xuICAgICAgICBpZiAodD09PTEuMCkgcmV0dXJuIDEuMDtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgICAgICByZXR1cm4gLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIC0tdCkgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQ2lyY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5DaXJjOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKE1hdGguc3FydCgxIC0gdCp0KSAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0Q2lyY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0Q2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS10KSp0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0Q2lyY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRDaXJjOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC0uNSAqIChNYXRoLnNxcnQoMSAtIHQqdCkgLSAxKTtcbiAgICAgICAgcmV0dXJuIC41ICogKE1hdGguc3FydCgxIC0gKHQtPTIpKnQpICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkVsYXN0aWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluRWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAodD09PTEpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9LjM7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgcmV0dXJuIC0oYSpNYXRoLnBvdygyLDEwKih0LT0xKSkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS8gcCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0RWxhc3RpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAodD09PTEpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9LjM7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgcmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqdCkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSArIDEuMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0RWxhc3RpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICgodC89LjUpPT09MikgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0oLjMqMS41KTtcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICBpZiAodCA8IDEpIHJldHVybiAtLjUqKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkpO1xuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkqLjUgKyAxLjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkJhY2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIHQqdCooKHMrMSkqdCAtIHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0QmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0QmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KigocysxKSp0ICsgcykgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0QmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRCYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSoodCp0KigoKHMqPSgxLjUyNSkpKzEpKnQgLSBzKSk7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqKCgocyo9KDEuNTI1KSkrMSkqdCArIHMpICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIDEuMCAtIEN1cnZlcy5vdXRCb3VuY2UoMS4wLXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0Qm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAoMS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqdCp0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMS41LzIuNzUpKSp0ICsgLjc1KTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIuNS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjI1LzIuNzUpKSp0ICsgLjkzNzUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjYyNS8yLjc1KSkqdCArIC45ODQzNzUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAuNSkgcmV0dXJuIEN1cnZlcy5pbkJvdW5jZSh0KjIpICogLjU7XG4gICAgICAgIHJldHVybiBDdXJ2ZXMub3V0Qm91bmNlKHQqMi0xLjApICogLjUgKyAuNTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZsYXRcbiAgICAgKlxuICAgICAqIFVzZWZ1bCBmb3IgZGVsYXlpbmcgdGhlIGV4ZWN1dGlvbiBvZiBhIHN1YnNlcXVlbnQgdHJhbnNpdGlvbi5cbiAgICAgKiBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZsYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnZlcztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXJ2ZXMgPSByZXF1aXJlKCcuL0N1cnZlcycpO1xudmFyIEZhbW91c0VuZ2luZSA9IHJlcXVpcmUoJy4uL2NvcmUvRmFtb3VzRW5naW5lJyk7XG5cbi8qKlxuICogQSBzdGF0ZSBtYWludGFpbmVyIGZvciBhIHNtb290aCB0cmFuc2l0aW9uIGJldHdlZW5cbiAqICAgIG51bWVyaWNhbGx5LXNwZWNpZmllZCBzdGF0ZXMuIEV4YW1wbGUgbnVtZXJpYyBzdGF0ZXMgaW5jbHVkZSBmbG9hdHMgYW5kXG4gKiAgICBhcnJheXMgb2YgZmxvYXRzIG9iamVjdHMuXG4gKlxuICogQW4gaW5pdGlhbCBzdGF0ZSBpcyBzZXQgd2l0aCB0aGUgY29uc3RydWN0b3Igb3IgdXNpbmdcbiAqICAgICB7QGxpbmsgVHJhbnNpdGlvbmFibGUjZnJvbX0uIFN1YnNlcXVlbnQgdHJhbnNpdGlvbnMgY29uc2lzdCBvZiBhblxuICogICAgIGludGVybWVkaWF0ZSBzdGF0ZSwgZWFzaW5nIGN1cnZlLCBkdXJhdGlvbiBhbmQgY2FsbGJhY2suIFRoZSBmaW5hbCBzdGF0ZVxuICogICAgIG9mIGVhY2ggdHJhbnNpdGlvbiBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgc3Vic2VxdWVudCBvbmUuIENhbGxzIHRvXG4gKiAgICAge0BsaW5rIFRyYW5zaXRpb25hYmxlI2dldH0gcHJvdmlkZSB0aGUgaW50ZXJwb2xhdGVkIHN0YXRlIGFsb25nIHRoZSB3YXkuXG4gKlxuICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIGV2ZW50IGxvb3AgaGVyZSAtIGNhbGxzIHRvIHtAbGluayBUcmFuc2l0aW9uYWJsZSNnZXR9XG4gKiAgICBhcmUgdGhlIG9ubHkgd2F5IHRvIGZpbmQgc3RhdGUgcHJvamVjdGVkIHRvIHRoZSBjdXJyZW50IChvciBwcm92aWRlZClcbiAqICAgIHRpbWUgYW5kIGFyZSB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBjYWxsYmFja3MgYW5kIG11dGF0ZSB0aGUgaW50ZXJuYWxcbiAqICAgIHRyYW5zaXRpb24gcXVldWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0ID0gbmV3IFRyYW5zaXRpb25hYmxlKFswLCAwXSk7XG4gKiB0XG4gKiAgICAgLnRvKFsxMDAsIDBdLCAnbGluZWFyJywgMTAwMClcbiAqICAgICAuZGVsYXkoMTAwMClcbiAqICAgICAudG8oWzIwMCwgMF0sICdvdXRCb3VuY2UnLCAxMDAwKTtcbiAqXG4gKiB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gKiBkaXYuc3R5bGUuYmFja2dyb3VuZCA9ICdibHVlJztcbiAqIGRpdi5zdHlsZS53aWR0aCA9ICcxMDBweCc7XG4gKiBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAqXG4gKiBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAqICAgICB0LmlzUGF1c2VkKCkgPyB0LnJlc3VtZSgpIDogdC5wYXVzZSgpO1xuICogfSk7XG4gKlxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AoKSB7XG4gKiAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcgKyB0LmdldCgpWzBdICsgJ3B4KScgKyAnIHRyYW5zbGF0ZVkoJyArIHQuZ2V0KClbMV0gKyAncHgpJztcbiAqICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gKiB9KTtcbiAqXG4gKiBAY2xhc3MgVHJhbnNpdGlvbmFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSBpbml0aWFsU3RhdGUgICAgaW5pdGlhbCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIC0gZXF1aXZhbGVudCB0byBhIHB1cnN1YW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgVHJhbnNpdGlvbmFibGUjZnJvbX1cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbmFibGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9mcm9tID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gbnVsbDtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IG51bGw7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSAhPSBudWxsKSB0aGlzLmZyb20oaW5pdGlhbFN0YXRlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBDbG9jayB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgY3VycmVudCB0aW1lIGZvciB0aGUgb25nb2luZ1xuICogdHJhbnNpdGlvbnMuXG4gKlxuICogQHR5cGUge1BlcmZvcm1hbmNlfERhdGV8Q2xvY2t9XG4gKi9cblRyYW5zaXRpb25hYmxlLkNsb2NrID0gRmFtb3VzRW5naW5lLmdldENsb2NrKCk7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgdHJhbnNpdGlvbiB0byBiZSBwdXNoZWQgb250byB0aGUgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQG1ldGhvZCB0b1xuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheS5OdW1iZXJ9ICAgIGZpbmFsU3RhdGUgICAgICAgICAgICAgIGZpbmFsIHN0YXRlIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0b24gdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gICAgICAgIFtjdXJ2ZT1DdXJ2ZXMubGluZWFyXSAgIGVhc2luZyBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswLCAxXVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICAgICAgW2R1cmF0aW9uPTEwMF0gICAgICAgICAgZHVyYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgIFtjYWxsYmFja10gICAgICAgICAgICAgIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB0cmFuc2l0aW9uIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byhmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrLCBtZXRob2QpIHtcbiAgICBjdXJ2ZSA9IGN1cnZlICE9IG51bGwgJiYgY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcXVldWUucHVzaChcbiAgICAgICAgZmluYWxTdGF0ZSxcbiAgICAgICAgY3VydmUgIT0gbnVsbCA/IGN1cnZlIDogQ3VydmVzLmxpbmVhcixcbiAgICAgICAgZHVyYXRpb24gIT0gbnVsbCA/IGR1cmF0aW9uIDogMTAwLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbWV0aG9kXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSB0cmFuc2l0aW9uIHF1ZXVlIHRvIGEgc3RhYmxlIGluaXRpYWwgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBmcm9tXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5Lk51bWJlcn0gICAgaW5pdGlhbFN0YXRlICAgIGluaXRpYWwgc3RhdGUgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uIGZyb21cbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiBmcm9tKGluaXRpYWxTdGF0ZSkge1xuICAgIHRoaXMuX3N0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuX2Zyb20gPSB0aGlzLl9zeW5jKG51bGwsIHRoaXMuX3N0YXRlKTtcbiAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZvciBhIGNlcnRhaW4gcGVyaW9kIG9mXG4gKiB0aW1lLlxuICpcbiAqIEBtZXRob2QgZGVsYXlcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICBkdXJhdGlvbiAgICBkZWxheSB0aW1lIGluIG1zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbY2FsbGJhY2tdICBaZXJvLWFyZ3VtZW50IGZ1bmN0aW9uIHRvIGNhbGwgb24gb2JzZXJ2ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb24gKHQ9MSlcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVuZFN0YXRlID0gdGhpcy5fcXVldWUubGVuZ3RoID4gMCA/IHRoaXMuX3F1ZXVlW3RoaXMuX3F1ZXVlLmxlbmd0aCAtIDVdIDogdGhpcy5fc3RhdGU7XG4gICAgcmV0dXJuIHRoaXMudG8oZW5kU3RhdGUsIEN1cnZlcy5mbGF0LCBkdXJhdGlvbiwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZXMgY3VycmVudCB0cmFuc2l0aW9uLlxuICpcbiAqIEBtZXRob2Qgb3ZlcnJpZGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBbZmluYWxTdGF0ZV0gICAgZmluYWwgc3RhdGUgdG8gdHJhbnNpdG9uIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259ICAgICAgICBbY3VydmVdICAgICAgICAgZWFzaW5nIGZ1bmN0aW9uIHVzZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGluZyBbMCwgMV1cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgICAgIFtkdXJhdGlvbl0gICAgICBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgICBbY2FsbGJhY2tdICAgICAgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBjb21wbGV0ZVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbiBvdmVycmlkZShmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrLCBtZXRob2QpIHtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZmluYWxTdGF0ZSAhPSBudWxsKSB0aGlzLl9xdWV1ZVswXSA9IGZpbmFsU3RhdGU7XG4gICAgICAgIGlmIChjdXJ2ZSAhPSBudWxsKSAgICAgIHRoaXMuX3F1ZXVlWzFdID0gY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9IG51bGwpICAgdGhpcy5fcXVldWVbMl0gPSBkdXJhdGlvbjtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpICAgdGhpcy5fcXVldWVbM10gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSAgICAgdGhpcy5fcXVldWVbNF0gPSBtZXRob2Q7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLl9pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIF9pbnRlcnBvbGF0ZShvdXRwdXQsIGZyb20sIHRvLCBwcm9ncmVzcywgbWV0aG9kKSB7XG4gICAgaWYgKHRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdzbGVycCcpIHtcbiAgICAgICAgICAgIHZhciB4LCB5LCB6LCB3O1xuICAgICAgICAgICAgdmFyIHF4LCBxeSwgcXosIHF3O1xuICAgICAgICAgICAgdmFyIG9tZWdhLCBjb3NvbWVnYSwgc2lub21lZ2EsIHNjYWxlRnJvbSwgc2NhbGVUbztcblxuICAgICAgICAgICAgeCA9IGZyb21bMF07XG4gICAgICAgICAgICB5ID0gZnJvbVsxXTtcbiAgICAgICAgICAgIHogPSBmcm9tWzJdO1xuICAgICAgICAgICAgdyA9IGZyb21bM107XG5cbiAgICAgICAgICAgIHF4ID0gdG9bMF07XG4gICAgICAgICAgICBxeSA9IHRvWzFdO1xuICAgICAgICAgICAgcXogPSB0b1syXTtcbiAgICAgICAgICAgIHF3ID0gdG9bM107XG5cbiAgICAgICAgICAgIGNvc29tZWdhID0gdyAqIHF3ICsgeCAqIHF4ICsgeSAqIHF5ICsgeiAqIHF6O1xuICAgICAgICAgICAgaWYgKCgxLjAgLSBjb3NvbWVnYSkgPiAxZS01KSB7XG4gICAgICAgICAgICAgICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb21lZ2EpO1xuICAgICAgICAgICAgICAgIHNpbm9tZWdhID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IE1hdGguc2luKCgxLjAgLSBwcm9ncmVzcykgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgICAgICBzY2FsZVRvID0gTWF0aC5zaW4ocHJvZ3Jlc3MgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IDEuMCAtIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHNjYWxlVG8gPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0WzBdID0geCAqIHNjYWxlRnJvbSArIHF4ICogc2NhbGVUbztcbiAgICAgICAgICAgIG91dHB1dFsxXSA9IHkgKiBzY2FsZUZyb20gKyBxeSAqIHNjYWxlVG87XG4gICAgICAgICAgICBvdXRwdXRbMl0gPSB6ICogc2NhbGVGcm9tICsgcXogKiBzY2FsZVRvO1xuICAgICAgICAgICAgb3V0cHV0WzNdID0gdyAqIHNjYWxlRnJvbSArIHF3ICogc2NhbGVUbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSB0aGlzLl9pbnRlcnBvbGF0ZShvdXRwdXRbaV0sIGZyb21baV0sIHRvW2ldLCBwcm9ncmVzcywgbWV0aG9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0bykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gdGhpcy5faW50ZXJwb2xhdGUob3V0cHV0W2tleV0sIGZyb21ba2V5XSwgdG9ba2V5XSwgcHJvZ3Jlc3MsIG1ldGhvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBmcm9tICsgcHJvZ3Jlc3MgKiAodG8gLSBmcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5fc3luYyA9IGZ1bmN0aW9uIF9zeW5jKG91dHB1dCwgaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykgb3V0cHV0ID0gaW5wdXQ7XG4gICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IF9zeW5jKG91dHB1dFtpXSwgaW5wdXRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGlmIChvdXRwdXQgPT0gbnVsbCkgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBfc3luYyhvdXRwdXRba2V5XSwgaW5wdXRba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogR2V0IGludGVycG9sYXRlZCBzdGF0ZSBvZiBjdXJyZW50IGFjdGlvbiBhdCBwcm92aWRlZCB0aW1lLiBJZiB0aGUgbGFzdFxuICogICAgYWN0aW9uIGhhcyBjb21wbGV0ZWQsIGludm9rZSBpdHMgY2FsbGJhY2suXG4gKlxuICogQG1ldGhvZCBnZXRcbiAqXG4gKiBAcGFyYW0ge051bWJlcj19IHRpbWVzdGFtcCBFdmFsdWF0ZSB0aGUgY3VydmUgYXQgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhpc1xuICogICAgdGltZS4gSWYgb21pdHRlZCwgdXNlIGN1cnJlbnQgdGltZS4gKFVuaXggZXBvY2ggdGltZSlcbiAqIEByZXR1cm4ge051bWJlcnxBcnJheS5OdW1iZXJ9IGJlZ2lubmluZyBzdGF0ZVxuICogICAgaW50ZXJwb2xhdGVkIHRvIHRoaXMgcG9pbnQgaW4gdGltZS5cbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCh0KSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3N0YXRlO1xuXG4gICAgdCA9IHRoaXMuX3BhdXNlZEF0ID8gdGhpcy5fcGF1c2VkQXQgOiB0O1xuICAgIHQgPSB0ID8gdCA6IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSAodCAtIHRoaXMuX3N0YXJ0ZWRBdCkgLyB0aGlzLl9xdWV1ZVsyXTtcbiAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2ludGVycG9sYXRlKHRoaXMuX3N0YXRlLCB0aGlzLl9mcm9tLCB0aGlzLl9xdWV1ZVswXSwgdGhpcy5fcXVldWVbMV0ocHJvZ3Jlc3MgPiAxID8gMSA6IHByb2dyZXNzKSwgdGhpcy5fcXVldWVbNF0pO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuX3N0YXJ0ZWRBdCArIHRoaXMuX3F1ZXVlWzJdO1xuICAgICAgICB0aGlzLl9mcm9tID0gdGhpcy5fc3luYyh0aGlzLl9mcm9tLCB0aGlzLl9zdGF0ZSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyZXNzID4gMSA/IHRoaXMuZ2V0KCkgOiBzdGF0ZTtcbn07XG5cbi8qKlxuICogSXMgdGhlcmUgYXQgbGVhc3Qgb25lIHRyYW5zaXRpb24gcGVuZGluZyBjb21wbGV0aW9uP1xuICpcbiAqIEBtZXRob2QgaXNBY3RpdmVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWUubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogSGFsdCB0cmFuc2l0aW9uIGF0IGN1cnJlbnQgc3RhdGUgYW5kIGVyYXNlIGFsbCBwZW5kaW5nIGFjdGlvbnMuXG4gKlxuICogQG1ldGhvZCBoYWx0XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9IHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0KCkge1xuICAgIHJldHVybiB0aGlzLmZyb20odGhpcy5nZXQoKSk7XG59O1xuXG4vKipcbiAqIFBhdXNlIHRyYW5zaXRpb24uIFRoaXMgd2lsbCBub3QgZXJhc2UgYW55IGFjdGlvbnMuXG4gKlxuICogQG1ldGhvZCBwYXVzZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSGFzIHRoZSBjdXJyZW50IGFjdGlvbiBiZWVuIHBhdXNlZD9cbiAqXG4gKiBAbWV0aG9kIGlzUGF1c2VkXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gaWYgdGhlIGN1cnJlbnQgYWN0aW9uIGhhcyBiZWVuIHBhdXNlZFxuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9wYXVzZWRBdDtcbn07XG5cbi8qKlxuICogUmVzdW1lIHRyYW5zaXRpb24uXG4gKlxuICogQG1ldGhvZCByZXN1bWVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHZhciBkaWZmID0gdGhpcy5fcGF1c2VkQXQgLSB0aGlzLl9zdGFydGVkQXQ7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKSAtIGRpZmY7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYW5jZWwgYWxsIHRyYW5zaXRpb25zIGFuZCByZXNldCB0byBhIHN0YWJsZSBzdGF0ZVxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLmZyb21gIGluc3RlYWQhXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfE9iamVjdC48bnVtYmVyLCBudW1iZXI+fSBzdGFydFN0YXRlXG4gKiAgICBzdGFibGUgc3RhdGUgdG8gc2V0IHRvXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShzdGFydCk7XG59O1xuXG4vKipcbiAqIEFkZCB0cmFuc2l0aW9uIHRvIGVuZCBzdGF0ZSB0byB0aGUgcXVldWUgb2YgcGVuZGluZyB0cmFuc2l0aW9ucy4gU3BlY2lhbFxuICogICAgVXNlOiBjYWxsaW5nIHdpdGhvdXQgYSB0cmFuc2l0aW9uIHJlc2V0cyB0aGUgb2JqZWN0IHRvIHRoYXQgc3RhdGUgd2l0aFxuICogICAgbm8gcGVuZGluZyBhY3Rpb25zXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLnRvYCBpbnN0ZWFkIVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfEZhbW91c0VuZ2luZU1hdHJpeHxBcnJheS5OdW1iZXJ8T2JqZWN0LjxudW1iZXIsIG51bWJlcj59IGVuZFN0YXRlXG4gKiAgICBlbmQgc3RhdGUgdG8gd2hpY2ggd2UgaW50ZXJwb2xhdGVcbiAqIEBwYXJhbSB7dHJhbnNpdGlvbj19IHRyYW5zaXRpb24gb2JqZWN0IG9mIHR5cGUge2R1cmF0aW9uOiBudW1iZXIsIGN1cnZlOlxuICogICAgZlswLDFdIC0+IFswLDFdIG9yIG5hbWV9LiBJZiB0cmFuc2l0aW9uIGlzIG9taXR0ZWQsIGNoYW5nZSB3aWxsIGJlXG4gKiAgICBpbnN0YW50YW5lb3VzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpPX0gY2FsbGJhY2sgWmVyby1hcmd1bWVudCBmdW5jdGlvbiB0byBjYWxsIG9uIG9ic2VydmVkXG4gKiAgICBjb21wbGV0aW9uICh0PTEpXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgdHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAodHJhbnNpdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnJvbShzdGF0ZSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvKHN0YXRlLCB0cmFuc2l0aW9uLmN1cnZlLCB0cmFuc2l0aW9uLmR1cmF0aW9uLCBjYWxsYmFjaywgdHJhbnNpdGlvbi5tZXRob2QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbmFibGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDdXJ2ZXM6IHJlcXVpcmUoJy4vQ3VydmVzJyksXG4gICAgVHJhbnNpdGlvbmFibGU6IHJlcXVpcmUoJy4vVHJhbnNpdGlvbmFibGUnKVxufTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBsaWdodHdlaWdodCwgZmVhdHVyZWxlc3MgRXZlbnRFbWl0dGVyLlxuICogXG4gKiBAY2xhc3MgQ2FsbGJhY2tTdG9yZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrU3RvcmUgKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xufVxuXG4vKipcbiAqIEFkZHMgYSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCAoPSBrZXkpLlxuICpcbiAqIEBtZXRob2Qgb25cbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7U3RyaW5nfSAgIGtleVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byBjYWxsIGlmIHlvdSB3YW50IHRvIHJlbW92ZSB0aGUgY2FsbGJhY2tcbiAqL1xuQ2FsbGJhY2tTdG9yZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbiAoa2V5LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2tleV0pIHRoaXMuX2V2ZW50c1trZXldID0gW107XG4gICAgdmFyIGNhbGxiYWNrTGlzdCA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFja0xpc3Quc3BsaWNlKGNhbGxiYWNrTGlzdC5pbmRleE9mKGNhbGxiYWNrKSwgMSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQG1ldGhvZCBvZmZcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICBrZXlcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0NhbGxiYWNrU3RvcmV9ICAgdGhpc1xuICovXG5DYWxsYmFja1N0b3JlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYgKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgaWYgKGV2ZW50cykgZXZlbnRzLnNwbGljZShldmVudHMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGFsbCB0aGUgcHJldmlvdXNseSBmb3IgdGhpcyBrZXkgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgIGtleVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgcGF5bG9hZFxuICogQHJldHVybiB7Q2FsbGJhY2tTdG9yZX0gdGhpc1xuICovXG5DYWxsYmFja1N0b3JlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoa2V5LCBwYXlsb2FkKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIGV2ZW50c1tpXShwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrU3RvcmU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCcuLi90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZScpO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0NvbG9yfFN0cmluZ3xBcnJheX0gT3B0aW9uYWwgYXJndW1lbnQgZm9yIHNldHRpbmcgY29sb3IgdXNpbmdcbiAqIEhleCwgYSBDb2xvciBpbnN0YW5jZSwgY29sb3IgbmFtZSBvciBSR0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDYWxsYmFja1xuICovXG5mdW5jdGlvbiBDb2xvcihjb2xvciwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICB0aGlzLl9yID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuICAgIHRoaXMuX2cgPSBuZXcgVHJhbnNpdGlvbmFibGUoMCk7XG4gICAgdGhpcy5fYiA9IG5ldyBUcmFuc2l0aW9uYWJsZSgwKTtcbiAgICBpZiAoY29sb3IpIHRoaXMuc2V0KGNvbG9yLCB0cmFuc2l0aW9uLCBjYik7XG59XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBDbGFzczogJ0NvbG9yJ1xuKiBAbWV0aG9kIHRvU3RyaW5nXG4qIEByZXR1cm4ge1N0cmluZ30gZGVmaW5pdGlvblxuKi9cbkNvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQ29sb3InO1xufTtcblxuLyoqXG4qIFNldHMgdGhlIGNvbG9yLiBJdCBhY2NlcHRzIGFuIG9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyIGFuZCBjYWxsYmFjay5cbiogc2V0KENvbG9yLCB0cmFuc2l0aW9uLCBjYWxsYmFjaylcbiogc2V0KCcjMDAwMDAwJywgdHJhbnNpdGlvbiwgY2FsbGJhY2spXG4qIHNldCgnYmxhY2snLCB0cmFuc2l0aW9uLCBjYWxsYmFjaylcbiogc2V0KFtyLCBnLCBiXSwgdHJhbnNpdGlvbiwgY2FsbGJhY2spXG4qIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge0NvbG9yfFN0cmluZ3xBcnJheX0gT3B0aW9uYWwgYXJndW1lbnQgZm9yIHNldHRpbmcgY29sb3IgdXNpbmdcbiAqIEhleCwgYSBDb2xvciBpbnN0YW5jZSwgY29sb3IgbmFtZSBvciBSR0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDYWxsYmFja1xuKiBAY2hhaW5hYmxlXG4qL1xuQ29sb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChjb2xvciwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICBzd2l0Y2ggKENvbG9yLmRldGVybWluZVR5cGUoY29sb3IpKSB7XG4gICAgICAgIGNhc2UgJ2hleCc6IHJldHVybiB0aGlzLnNldEhleChjb2xvciwgdHJhbnNpdGlvbiwgY2IpO1xuICAgICAgICBjYXNlICdjb2xvck5hbWUnOiByZXR1cm4gdGhpcy5zZXRDb2xvcihjb2xvciwgdHJhbnNpdGlvbiwgY2IpO1xuICAgICAgICBjYXNlICdpbnN0YW5jZSc6IHJldHVybiB0aGlzLmNoYW5nZVRvKGNvbG9yLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgICAgIGNhc2UgJ3JnYic6IHJldHVybiB0aGlzLnNldFJHQihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgQ29sb3IgaXMgc3RpbGwgaW4gYW4gYW5pbWF0aW5nICh0cmFuc2l0aW9uaW5nKSBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIGlzQWN0aXZlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhblxuICovXG5Db2xvci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fci5pc0FjdGl2ZSgpIHx8IHRoaXMuX2cuaXNBY3RpdmUoKSB8fCB0aGlzLl9iLmlzQWN0aXZlKCk7XG59O1xuXG4vKipcbiAqIEhhbHQgdHJhbnNpdGlvbiBhdCBjdXJyZW50IHN0YXRlIGFuZCBlcmFzZSBhbGwgcGVuZGluZyBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgaGFsdFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0NvbG9yfSB0aGlzXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICB0aGlzLl9yLmhhbHQoKTtcbiAgICB0aGlzLl9nLmhhbHQoKTtcbiAgICB0aGlzLl9iLmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29sb3IgdmFsdWVzIGZyb20gYW5vdGhlciBDb2xvciBpbnN0YW5jZS5cbiAqXG4gKiBAbWV0aG9kIGNoYW5nZVRvXG4gKiBAcGFyYW0ge0NvbG9yfSBDb2xvciBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gT3B0aW9uYWwgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLmNoYW5nZVRvID0gZnVuY3Rpb24gY2hhbmdlVG8oY29sb3IsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgaWYgKENvbG9yLmlzQ29sb3JJbnN0YW5jZShjb2xvcikpIHtcbiAgICAgICAgdmFyIHJnYiA9IGNvbG9yLmdldFJHQigpO1xuICAgICAgICB0aGlzLnNldFJHQihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb2xvciBiYXNlZCBvbiBzdGF0aWMgY29sb3IgbmFtZXMuXG4gKlxuICogQG1ldGhvZCBzZXRDb2xvclxuICogQHBhcmFtIHtTdHJpbmd9IENvbG9yIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gc2V0Q29sb3IobmFtZSwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICBpZiAoY29sb3JOYW1lc1tuYW1lXSkge1xuICAgICAgICB0aGlzLnNldEhleChjb2xvck5hbWVzW25hbWVdLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb2xvciBpbiBlaXRoZXIgUkdCIG9yIHdpdGggdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKlxuICogQG1ldGhvZCBnZXRDb2xvclxuICogQHBhcmFtIHtTdHJpbmd9IE9wdGlvbmFsIGFyZ3VtZW50IGZvciBkZXRlcm1pbmluZyB3aGljaCB0eXBlIG9mIGNvbG9yIHRvIGdldCAoZGVmYXVsdCBpcyBSR0IpXG4gKiBAcmV0dXJucyBDb2xvciBpbiBlaXRoZXIgUkdCIG9yIHNwZWNpZmljIG9wdGlvbiB2YWx1ZVxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvcihvcHRpb24pIHtcbiAgICBpZiAoQ29sb3IuaXNTdHJpbmcob3B0aW9uKSkgb3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChvcHRpb24gPT09ICdoZXgnKSA/IHRoaXMuZ2V0SGV4KCkgOiB0aGlzLmdldFJHQigpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBSIG9mIHRoZSBDb2xvcidzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0UlxuICogQHBhcmFtIHtJbnRlZ2VyfSBSIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldFIgPSBmdW5jdGlvbiBzZXRSKHIsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5fci5zZXQociwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBHIG9mIHRoZSBDb2xvcidzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0R1xuICogQHBhcmFtIHtJbnRlZ2VyfSBHIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldEcgPSBmdW5jdGlvbiBzZXRHKGcsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5fZy5zZXQoZywgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBCIG9mIHRoZSBDb2xvcidzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0QlxuICogQHBhcmFtIHtJbnRlZ2VyfSBCIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldEIgPSBmdW5jdGlvbiBzZXRCKGIsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5fYi5zZXQoYiwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0UkdCXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFIgY2hhbm5lbCBvZiBjb2xvclxuICogQHBhcmFtIHtJbnRlZ2VyfSBHIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7SW50ZWdlcn0gQiBjaGFubmVsIG9mIGNvbG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRSR0IgPSBmdW5jdGlvbiBzZXRSR0IociwgZywgYiwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICB0aGlzLnNldFIociwgdHJhbnNpdGlvbik7XG4gICAgdGhpcy5zZXRHKGcsIHRyYW5zaXRpb24pO1xuICAgIHRoaXMuc2V0QihiLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgUiBvZiBSR0JcbiAqXG4gKiBAbWV0aG9kIGdldFJcbiAqIEByZXR1cm5zIFIgb2YgQ29sb3JcbiAqL1xuQ29sb3IucHJvdG90eXBlLmdldFIgPSBmdW5jdGlvbiBnZXRSKCkge1xuICAgIHJldHVybiB0aGlzLl9yLmdldCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEcgb2YgUkdCXG4gKlxuICogQG1ldGhvZCBnZXRHXG4gKiBAcmV0dXJucyBHIG9mIENvbG9yXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5nZXRHID0gZnVuY3Rpb24gZ2V0RygpIHtcbiAgICByZXR1cm4gdGhpcy5fZy5nZXQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBCIG9mIFJHQlxuICpcbiAqIEBtZXRob2QgZ2V0QlxuICogQHJldHVybnMgQiBvZiBDb2xvclxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0QiA9IGZ1bmN0aW9uIGdldEIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2IuZ2V0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgUkdCXG4gKlxuICogQG1ldGhvZCBnZXRSR0JcbiAqIEByZXR1cm5zIFJHQlxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0UkdCID0gZnVuY3Rpb24gZ2V0UkdCKCkge1xuICAgIHJldHVybiBbdGhpcy5nZXRSKCksIHRoaXMuZ2V0RygpLCB0aGlzLmdldEIoKV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgTm9ybWFsaXplZCBSR0JcbiAqXG4gKiBAbWV0aG9kIGdldE5vcm1hbGl6ZWRSR0JcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgUkdCXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5nZXROb3JtYWxpemVkUkdCID0gZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFJHQigpIHtcbiAgICB2YXIgciA9IHRoaXMuZ2V0UigpIC8gMjU1LjA7XG4gICAgdmFyIGcgPSB0aGlzLmdldEcoKSAvIDI1NS4wO1xuICAgIHZhciBiID0gdGhpcy5nZXRCKCkgLyAyNTUuMDtcbiAgICByZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbG9yIGluIEhleFxuICpcbiAqIEBtZXRob2QgZ2V0SGV4XG4gKiBAcmV0dXJucyBIZXggdmFsdWVcbiAqL1xuQ29sb3IucHJvdG90eXBlLmdldEhleCA9IGZ1bmN0aW9uIGdldEhleCgpIHtcbiAgICB2YXIgciA9IENvbG9yLnRvSGV4KHRoaXMuZ2V0UigpKTtcbiAgICB2YXIgZyA9IENvbG9yLnRvSGV4KHRoaXMuZ2V0RygpKTtcbiAgICB2YXIgYiA9IENvbG9yLnRvSGV4KHRoaXMuZ2V0QigpKTtcbiAgICByZXR1cm4gJyMnICsgciArIGcgKyBiO1xufTtcblxuLyoqXG4gKiBTZXRzIGNvbG9yIHVzaW5nIEhleFxuICpcbiAqIEBtZXRob2Qgc2V0SGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gSGV4IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRIZXggPSBmdW5jdGlvbiBzZXRIZXgoaGV4LCB0cmFuc2l0aW9uLCBjYikge1xuICAgIGhleCA9IChoZXguY2hhckF0KDApID09PSAnIycpID8gaGV4LnN1YnN0cmluZygxLCBoZXgubGVuZ3RoKSA6IGhleDtcblxuICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gICAgICAgIGhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCBmdW5jdGlvbihtLCByLCBnLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMCwgMiksIDE2KTtcbiAgICB2YXIgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KTtcbiAgICB2YXIgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNCwgNiksIDE2KTtcbiAgICB0aGlzLnNldFJHQihyLCBnLCBiLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIHRvIGEgaGV4IHZhbHVlXG4gKlxuICogQG1ldGhvZCB0b0hleFxuICogQHBhcmFtIHtJbnRlZ2VyfSBOdW1iZXJcbiAqIEByZXR1cm5zIEhleCB2YWx1ZVxuICovXG5Db2xvci50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KG51bSkge1xuICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBnaXZlbiBpbnB1dCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjb25maWd1cmF0aW9uXG4gKlxuICogQG1ldGhvZCBkZXRlcm1pbmVUeXBlXG4gKiBAcGFyYW0ge0NvbG9yfFN0cmluZ3xBcnJheX0gQ29sb3IgdHlwZVxuICogQHJldHVybnMge1N0cmluZ30gQXBwcm9wcmlhdGUgY29sb3IgdHlwZVxuICovXG5Db2xvci5kZXRlcm1pbmVUeXBlID0gZnVuY3Rpb24gZGV0ZXJtaW5lVHlwZSh0eXBlKSB7XG4gICAgaWYgKENvbG9yLmlzQ29sb3JJbnN0YW5jZSh0eXBlKSkgcmV0dXJuICdpbnN0YW5jZSc7XG4gICAgaWYgKGNvbG9yTmFtZXNbdHlwZV0pIHJldHVybiAnY29sb3JOYW1lJztcbiAgICBpZiAoQ29sb3IuaXNIZXgodHlwZSkpIHJldHVybiAnaGV4JztcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkgcmV0dXJuICdyZ2InO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBjaGVja2luZyB3aGV0aGVyIGlucHV0IGlzIGEgJ1N0cmluZydcbiAqXG4gKiBAbWV0aG9kIGlzU3RyaW5nXG4gKiBAcGFyYW0gUHJpbWl0aXZlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhblxuICovXG5Db2xvci5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBjaGVja2luZyB3aGV0aGVyIHN0cmluZyBpbnB1dCBoYXMgYSBoYXNoICgjKSBzeW1ib2xcbiAqXG4gKiBAbWV0aG9kIGlzSGV4XG4gKiBAcGFyYW0gU3RyaW5nXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhblxuICovXG5Db2xvci5pc0hleCA9IGZ1bmN0aW9uIGlzSGV4KHZhbCkge1xuICAgIGlmICghQ29sb3IuaXNTdHJpbmcodmFsKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB2YWxbMF0gPT09ICcjJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBib29sZWFuIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgQ29sb3IgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIGlzQ29sb3JJbnN0YW5jZVxuICogQHBhcmFtIENvbG9yIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhblxuICovXG5Db2xvci5pc0NvbG9ySW5zdGFuY2UgPSBmdW5jdGlvbiBpc0NvbG9ySW5zdGFuY2UodmFsKSB7XG4gICAgcmV0dXJuICEhdmFsLmdldENvbG9yO1xufTtcblxuLyoqXG4gKiBDb21tb24gY29sb3IgbmFtZXMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIEhleCB2YWx1ZXNcbiAqL1xudmFyIGNvbG9yTmFtZXMgPSB7IGFsaWNlYmx1ZTogJyNmMGY4ZmYnLCBhbnRpcXVld2hpdGU6ICcjZmFlYmQ3JywgYXF1YTogJyMwMGZmZmYnLCBhcXVhbWFyaW5lOiAnIzdmZmZkNCcsIGF6dXJlOiAnI2YwZmZmZicsIGJlaWdlOiAnI2Y1ZjVkYycsIGJpc3F1ZTogJyNmZmU0YzQnLCBibGFjazogJyMwMDAwMDAnLCBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLCBibHVlOiAnIzAwMDBmZicsIGJsdWV2aW9sZXQ6ICcjOGEyYmUyJywgYnJvd246ICcjYTUyYTJhJywgYnVybHl3b29kOiAnI2RlYjg4NycsIGNhZGV0Ymx1ZTogJyM1ZjllYTAnLCBjaGFydHJldXNlOiAnIzdmZmYwMCcsIGNob2NvbGF0ZTogJyNkMjY5MWUnLCBjb3JhbDogJyNmZjdmNTAnLCBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1ZWQnLCBjb3Juc2lsazogJyNmZmY4ZGMnLCBjcmltc29uOiAnI2RjMTQzYycsIGN5YW46ICcjMDBmZmZmJywgZGFya2JsdWU6ICcjMDAwMDhiJywgZGFya2N5YW46ICcjMDA4YjhiJywgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLCBkYXJrZ3JheTogJyNhOWE5YTknLCBkYXJrZ3JlZW46ICcjMDA2NDAwJywgZGFya2dyZXk6ICcjYTlhOWE5JywgZGFya2toYWtpOiAnI2JkYjc2YicsIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NmIyZicsIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJywgZGFya29yY2hpZDogJyM5OTMyY2MnLCBkYXJrcmVkOiAnIzhiMDAwMCcsIGRhcmtzYWxtb246ICcjZTk5NjdhJywgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsIGRhcmtzbGF0ZWJsdWU6ICcjNDgzZDhiJywgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLCBkYXJrc2xhdGVncmV5OiAnIzJmNGY0ZicsIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJywgZGFya3Zpb2xldDogJyM5NDAwZDMnLCBkZWVwcGluazogJyNmZjE0OTMnLCBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLCBkaW1ncmF5OiAnIzY5Njk2OScsIGRpbWdyZXk6ICcjNjk2OTY5JywgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLCBmaXJlYnJpY2s6ICcjYjIyMjIyJywgZmxvcmFsd2hpdGU6ICcjZmZmYWYwJywgZm9yZXN0Z3JlZW46ICcjMjI4YjIyJywgZnVjaHNpYTogJyNmZjAwZmYnLCBnYWluc2Jvcm86ICcjZGNkY2RjJywgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLCBnb2xkOiAnI2ZmZDcwMCcsIGdvbGRlbnJvZDogJyNkYWE1MjAnLCBncmF5OiAnIzgwODA4MCcsIGdyZWVuOiAnIzAwODAwMCcsIGdyZWVueWVsbG93OiAnI2FkZmYyZicsIGdyZXk6ICcjODA4MDgwJywgaG9uZXlkZXc6ICcjZjBmZmYwJywgaG90cGluazogJyNmZjY5YjQnLCBpbmRpYW5yZWQ6ICcjY2Q1YzVjJywgaW5kaWdvOiAnIzRiMDA4MicsIGl2b3J5OiAnI2ZmZmZmMCcsIGtoYWtpOiAnI2YwZTY4YycsIGxhdmVuZGVyOiAnI2U2ZTZmYScsIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JywgbGF3bmdyZWVuOiAnIzdjZmMwMCcsIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLCBsaWdodGJsdWU6ICcjYWRkOGU2JywgbGlnaHRjb3JhbDogJyNmMDgwODAnLCBsaWdodGN5YW46ICcjZTBmZmZmJywgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJywgbGlnaHRncmF5OiAnI2QzZDNkMycsIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJywgbGlnaHRncmV5OiAnI2QzZDNkMycsIGxpZ2h0cGluazogJyNmZmI2YzEnLCBsaWdodHNhbG1vbjogJyNmZmEwN2EnLCBsaWdodHNlYWdyZWVuOiAnIzIwYjJhYScsIGxpZ2h0c2t5Ymx1ZTogJyM4N2NlZmEnLCBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLCBsaWdodHNsYXRlZ3JleTogJyM3Nzg4OTknLCBsaWdodHN0ZWVsYmx1ZTogJyNiMGM0ZGUnLCBsaWdodHllbGxvdzogJyNmZmZmZTAnLCBsaW1lOiAnIzAwZmYwMCcsIGxpbWVncmVlbjogJyMzMmNkMzInLCBsaW5lbjogJyNmYWYwZTYnLCBtYWdlbnRhOiAnI2ZmMDBmZicsIG1hcm9vbjogJyM4MDAwMDAnLCBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Y2RhYScsIG1lZGl1bWJsdWU6ICcjMDAwMGNkJywgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsIG1lZGl1bXB1cnBsZTogJyM5MzcwZGInLCBtZWRpdW1zZWFncmVlbjogJyMzY2IzNzEnLCBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJywgbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBmYTlhJywgbWVkaXVtdHVycXVvaXNlOiAnIzQ4ZDFjYycsIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLCBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJywgbWludGNyZWFtOiAnI2Y1ZmZmYScsIG1pc3R5cm9zZTogJyNmZmU0ZTEnLCBtb2NjYXNpbjogJyNmZmU0YjUnLCBuYXZham93aGl0ZTogJyNmZmRlYWQnLCBuYXZ5OiAnIzAwMDA4MCcsIG9sZGxhY2U6ICcjZmRmNWU2Jywgb2xpdmU6ICcjODA4MDAwJywgb2xpdmVkcmFiOiAnIzZiOGUyMycsIG9yYW5nZTogJyNmZmE1MDAnLCBvcmFuZ2VyZWQ6ICcjZmY0NTAwJywgb3JjaGlkOiAnI2RhNzBkNicsIHBhbGVnb2xkZW5yb2Q6ICcjZWVlOGFhJywgcGFsZWdyZWVuOiAnIzk4ZmI5OCcsIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJywgcGFsZXZpb2xldHJlZDogJyNkYjcwOTMnLCBwYXBheWF3aGlwOiAnI2ZmZWZkNScsIHBlYWNocHVmZjogJyNmZmRhYjknLCBwZXJ1OiAnI2NkODUzZicsIHBpbms6ICcjZmZjMGNiJywgcGx1bTogJyNkZGEwZGQnLCBwb3dkZXJibHVlOiAnI2IwZTBlNicsIHB1cnBsZTogJyM4MDAwODAnLCByZWJlY2NhcHVycGxlOiAnIzY2MzM5OScsIHJlZDogJyNmZjAwMDAnLCByb3N5YnJvd246ICcjYmM4ZjhmJywgcm95YWxibHVlOiAnIzQxNjllMScsIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsIHNhbG1vbjogJyNmYTgwNzInLCBzYW5keWJyb3duOiAnI2Y0YTQ2MCcsIHNlYWdyZWVuOiAnIzJlOGI1NycsIHNlYXNoZWxsOiAnI2ZmZjVlZScsIHNpZW5uYTogJyNhMDUyMmQnLCBzaWx2ZXI6ICcjYzBjMGMwJywgc2t5Ymx1ZTogJyM4N2NlZWInLCBzbGF0ZWJsdWU6ICcjNmE1YWNkJywgc2xhdGVncmF5OiAnIzcwODA5MCcsIHNsYXRlZ3JleTogJyM3MDgwOTAnLCBzbm93OiAnI2ZmZmFmYScsIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLCB0YW46ICcjZDJiNDhjJywgdGVhbDogJyMwMDgwODAnLCB0aGlzdGxlOiAnI2Q4YmZkOCcsIHRvbWF0bzogJyNmZjYzNDcnLCB0dXJxdW9pc2U6ICcjNDBlMGQwJywgdmlvbGV0OiAnI2VlODJlZScsIHdoZWF0OiAnI2Y1ZGViMycsIHdoaXRlOiAnI2ZmZmZmZicsIHdoaXRlc21va2U6ICcjZjVmNWY1JywgeWVsbG93OiAnI2ZmZmYwMCcsIHllbGxvd2dyZWVuOiAnIzlhY2QzMicgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuIFxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gdG8gbWFwIGtleWJvYXJkIGNvZGVzIGluIHBsYWluIGVuZ2xpc2hcbiAqXG4gKiBAY2xhc3MgS2V5Q29kZXNcbiAqIEBzdGF0aWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgMDogNDgsXG4gICAgMTogNDksXG4gICAgMjogNTAsXG4gICAgMzogNTEsXG4gICAgNDogNTIsXG4gICAgNTogNTMsXG4gICAgNjogNTQsXG4gICAgNzogNTUsXG4gICAgODogNTYsXG4gICAgOTogNTcsXG4gICAgYTogOTcsXG4gICAgYjogOTgsXG4gICAgYzogOTksXG4gICAgZDogMTAwLFxuICAgIGU6IDEwMSxcbiAgICBmOiAxMDIsXG4gICAgZzogMTAzLFxuICAgIGg6IDEwNCxcbiAgICBpOiAxMDUsXG4gICAgajogMTA2LFxuICAgIGs6IDEwNyxcbiAgICBsOiAxMDgsXG4gICAgbTogMTA5LFxuICAgIG46IDExMCxcbiAgICBvOiAxMTEsXG4gICAgcDogMTEyLFxuICAgIHE6IDExMyxcbiAgICByOiAxMTQsXG4gICAgczogMTE1LFxuICAgIHQ6IDExNixcbiAgICB1OiAxMTcsXG4gICAgdjogMTE4LFxuICAgIHc6IDExOSxcbiAgICB4OiAxMjAsXG4gICAgeTogMTIxLFxuICAgIHo6IDEyMixcbiAgICBBOiA2NSxcbiAgICBCOiA2NixcbiAgICBDOiA2NyxcbiAgICBEOiA2OCxcbiAgICBFOiA2OSxcbiAgICBGOiA3MCxcbiAgICBHOiA3MSxcbiAgICBIOiA3MixcbiAgICBJOiA3MyxcbiAgICBKOiA3NCxcbiAgICBLOiA3NSxcbiAgICBMOiA3NixcbiAgICBNOiA3NyxcbiAgICBOOiA3OCxcbiAgICBPOiA3OSxcbiAgICBQOiA4MCxcbiAgICBROiA4MSxcbiAgICBSOiA4MixcbiAgICBTOiA4MyxcbiAgICBUOiA4NCxcbiAgICBVOiA4NSxcbiAgICBWOiA4NixcbiAgICBXOiA4NyxcbiAgICBYOiA4OCxcbiAgICBZOiA4OSxcbiAgICBaOiA5MCxcbiAgICBFTlRFUiA6IDEzLFxuICAgIExFRlRfQVJST1c6IDM3LFxuICAgIFJJR0hUX0FSUk9XOiAzOSxcbiAgICBVUF9BUlJPVzogMzgsXG4gICAgRE9XTl9BUlJPVzogNDAsXG4gICAgU1BBQ0U6IDMyLFxuICAgIFNISUZUOiAxNixcbiAgICBUQUI6IDlcbn07XG5cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2luZ2xldG9uIG9iamVjdCB0byBtYW5hZ2UgcmVjeWNsaW5nIG9mIG9iamVjdHMgd2l0aCB0eXBpY2FsbHkgc2hvcnQgbGlmZXNwYW5zLCB1c2VkIHRvIGN1dCBkb3duIG9uIHRoZVxuICogYW1vdW50IG9mIGdhcmJhZ2UgY29sbGVjdGlvbiByZXF1aXJlZC5cbiAqXG4gKiBAc2luZ2xldG9uXG4gKi9cbnZhciBPYmplY3RNYW5hZ2VyID0ge307XG5cbk9iamVjdE1hbmFnZXIucG9vbHMgPSB7fTtcblxuLyoqXG4gKiBSZWdpc3RlciByZXF1ZXN0IGFuZCBmcmVlIGZ1bmN0aW9ucyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQG1ldGhvZCByZWdpc3RlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbnN0cnVjdG9yXG4gKi9cbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbih0eXBlLCBDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBwb29sID0gdGhpcy5wb29sc1t0eXBlXSA9IFtdO1xuXG4gICAgdGhpc1sncmVxdWVzdCcgKyB0eXBlXSA9IF9yZXF1ZXN0KHBvb2wsIENvbnN0cnVjdG9yKTtcbiAgICB0aGlzWydmcmVlJyArIHR5cGVdID0gX2ZyZWUocG9vbCk7XG59O1xuXG5mdW5jdGlvbiBfcmVxdWVzdChwb29sLCBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0KCkge1xuICAgICAgICBpZiAocG9vbC5sZW5ndGggIT09IDApIHJldHVybiBwb29sLnBvcCgpO1xuICAgICAgICBlbHNlIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfZnJlZShwb29sKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZyZWUob2JqKSB7XG4gICAgICAgIHBvb2wucHVzaChvYmopO1xuICAgIH07XG59XG5cbi8qKlxuICogVW50cmFjayBhbGwgb2JqZWN0IG9mIHRoZSBnaXZlbiB0eXBlLiBVc2VkIHRvIGFsbG93IGFsbG9jYXRlZCBvYmplY3RzIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICpcbiAqIEBtZXRob2QgZGlzcG9zZU9mXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqL1xuT2JqZWN0TWFuYWdlci5kaXNwb3NlT2Y9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgcG9vbCA9IHRoaXMucG9vbHNbdHlwZV07XG4gICAgdmFyIGkgPSBwb29sLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSBwb29sLnBvcCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RNYW5hZ2VyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIGd1YXJhbnRlZWQgdG8gYmUgd2l0aGluIHRoZSByYW5nZSBbbG93ZXIsIHVwcGVyXS5cbiAqXG4gKiBAbWV0aG9kIGNsYW1wXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gYmUgcHJvY2Vzc2VkIGJ5IGNsYW1wXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxvd2VyIGxvd2VyIGJvdW5kICBvZiB0aGUgcmFuZ2VcbiAqIEBwYXJhbSAge051bWJlcn0gdXBwZXIgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIHZhbHVlIGJldHdlZW4gW2xvd2VyLCB1cHBlcl1cbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiB2YWx1ZSA8IGxvd2VyID8gbG93ZXIgOiB2YWx1ZSA+IHVwcGVyID8gdXBwZXIgOiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFtcDtcblxuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiAgRGVlcCBjbG9uZSBhbiBvYmplY3QuXG4gKiAgQG1lbWJlcm9mIFV0aWxpdGllc1xuICogIEBwYXJhbSBiIHtPYmplY3R9IE9iamVjdCB0byBjbG9uZVxuICogIEByZXR1cm4gYSB7T2JqZWN0fSBDbG9uZWQgb2JqZWN0LlxuICovXG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShiKSB7XG4gICAgdmFyIGE7XG4gICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gKGIgaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiW2tleV0gPT09ICdvYmplY3QnICYmIGJba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChiW2tleV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBhW2tleV0gPSBuZXcgQXJyYXkoYltrZXldLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2tleV1baV0gPSBjbG9uZShiW2tleV1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYVtrZXldID0gY2xvbmUoYltrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDYWxsYmFja1N0b3JlOiByZXF1aXJlKCcuL0NhbGxiYWNrU3RvcmUnKSxcbiAgICBjbGFtcDogcmVxdWlyZSgnLi9jbGFtcCcpLFxuICAgIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJyksXG4gICAgQ29sb3I6IHJlcXVpcmUoJy4vQ29sb3InKSxcbiAgICBLZXlDb2RlczogcmVxdWlyZSgnLi9LZXlDb2RlcycpLFxuICAgIGtleVZhbHVlVG9BcnJheXM6IHJlcXVpcmUoJy4va2V5VmFsdWVUb0FycmF5cycpLFxuICAgIGxvYWRVUkw6IHJlcXVpcmUoJy4vbG9hZFVSTCcpLFxuICAgIE9iamVjdE1hbmFnZXI6IHJlcXVpcmUoJy4vT2JqZWN0TWFuYWdlcicpLFxuICAgIHN0cmlwOiByZXF1aXJlKCcuL3N0cmlwJyksXG4gICAgdmVuZG9yUHJlZml4OiByZXF1aXJlKCcuL3ZlbmRvclByZWZpeCcpXG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCBjb250YWluaW5nIGtleXMgYW5kIHZhbHVlcyBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAqIGNvbXByaXNpbmcgdHdvIFwiYXNzb2NpYXRlXCIgYXJyYXlzLCBvbmUgd2l0aCB0aGUga2V5cyBhbmQgdGhlIG90aGVyXG4gKiB3aXRoIHRoZSB2YWx1ZXMuXG4gKlxuICogQG1ldGhvZCBrZXlWYWx1ZXNUb0FycmF5c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBPYmplY3QgY29udGFpbmluZyB0d28gYXJyYXlzLCBvbmUgd2l0aCB0aGUga2V5cyBhbmQgdGhlIG90aGVyIGZvciB2YWx1ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBrZXlWYWx1ZXNUb0FycmF5cyhvYmopIHtcbiAgICB2YXIga2V5c0FycmF5ID0gW10sIHZhbHVlc0FycmF5ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvcih2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGtleXNBcnJheVtpXSA9IGtleTtcbiAgICAgICAgICAgIHZhbHVlc0FycmF5W2ldID0gb2JqW2tleV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5czoga2V5c0FycmF5LFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc0FycmF5XG4gICAgfTtcbn07XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvYWQgYSBVUkwgYW5kIHJldHVybiBpdHMgY29udGVudHMgaW4gYSBjYWxsYmFja1xuICpcbiAqIEBtZXRob2QgbG9hZFVSTFxuICogQG1lbWJlcm9mIFV0aWxpdGllc1xuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB0byBkaXNwYXRjaCB3aXRoIGNvbnRlbnRcbiAqL1xudmFyIGxvYWRVUkwgPSBmdW5jdGlvbiBsb2FkVVJMKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgIHhoci5zZW5kKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRVUkw7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIHZhbHVlcyBub3QgYmVpbmcgb2YgYSBwcmltaXRpdmUgdHlwZSBmcm9tIGFuIGFyYml0cmFyeSBvYmplY3RcbiAqIGxpdGVyYWwuXG4gKlxuICogQG1ldGhvZCBzdHJpcFxuICogQG1lbWJlcm9mIFV0aWxpdGllc1xuICogQHBhcmFtICB7YW55fSAgICAgICAgcHJpbWl0aXZlIG9yIChub24tKXNlcmlhbGl6YWJsZSBvYmplY3Qgd2l0aG91dFxuICogICAgICAgICAgICAgICAgICAgICAgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICogQHJldHVybiB7YW55fSAgICAgICAgcHJpbWl0aXZlIG9yIChuZXN0ZWQpIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgcHJpbWl0aXZlXG4gKiAgICAgICAgICAgICAgICAgICAgICB0eXBlcyAoc2VyaWFsaXphYmxlKVxuICovXG5mdW5jdGlvbiBzdHJpcChvYmopIHtcbiAgICBzd2l0Y2ggKG9iaikge1xuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgc3dpdGNoIChvYmouY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGNhc2UgU3ltYm9sOlxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmlwcGVkID0gc3RyaXAob2JqW2tleV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gc3RyaXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmlwO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBSRUZJWEVTID0gWycnLCAnLW1zLScsICctd2Via2l0LScsICctbW96LScsICctby0nXTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBDU1MgcHJvcGVydHlcbiAqIGhhcyBhIHZlbmRvciBwcmVmaXguXG4gKlxuICogQG1ldGhvZCB2ZW5kb3JQcmVmaXhcbiAqIEBwcml2YXRlXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiB2ZW5kb3JQcmVmaXgocHJvcGVydHkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBSRUZJWEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcmVmaXhlZCA9IFBSRUZJWEVTW2ldICsgcHJvcGVydHk7XG4gICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbcHJlZml4ZWRdID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZW5kb3JQcmVmaXg7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL0dlb21ldHJ5Jyk7XG5cbi8qKlxuICogRHluYW1pY0dlb21ldHJ5IGlzIGEgY29tcG9uZW50IHRoYXQgZGVmaW5lcyB0aGUgZGF0YSB0aGF0IHNob3VsZFxuICogICBiZSBkcmF3biB0byB0aGUgd2ViR0wgY2FudmFzLiBNYW5hZ2VzIHZlcnRleCBkYXRhIGFuZCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBjbGFzcyBEeW5hbWljR2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBpbnN0YW50aWF0aW9uIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gRHluYW1pY0dlb21ldHJ5KG9wdGlvbnMpIHtcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zcGVjLmR5bmFtaWMgPSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBhdHRyaWJ1dGUgdmFsdWVzIHVzZWQgdG8gZHJhdyB0aGUgRHluYW1pY0dlb21ldHJ5LlxuICpcbiAqIEBjbGFzcyBEeW5hbWljR2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGZsYXR0ZW5lZCBsZW5ndGggb2YgdGhlIHZlcnRleCBwb3NpdGlvbnMgYXR0cmlidXRlXG4gKiBpbiB0aGUgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZlcnRleFBvc2l0aW9ucygpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYnVmZmVyIG9iamVjdCBiYXNlZCBvbiBidWZmZXIgbmFtZS4gVGhyb3dzIGVycm9yXG4gKiBpZiBidWZmZXJOYW1lIGlzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAbWV0aG9kIGdldFZlcnRleEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXJOYW1lIE5hbWUgb2YgdmVydGV4QnVmZmVyIHRvIGJlIHJldHJpZXZlZC5cbiAqIEByZXR1cm4ge09iamVjdH0gdmFsdWUgb2YgYnVmZmVyIHdpdGggY29ycmVzcG9uZGluZyBidWZmZXJOYW1lLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldFZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uIGdldFZlcnRleEJ1ZmZlcihidWZmZXJOYW1lKSB7XG4gICAgaWYgKCEgYnVmZmVyTmFtZSkgdGhyb3cgJ2dldFZlcnRleEJ1ZmZlciByZXF1aXJlcyBhIG5hbWUnO1xuXG4gICAgdmFyIGlkeCA9IHRoaXMuc3BlYy5idWZmZXJOYW1lcy5pbmRleE9mKGJ1ZmZlck5hbWUpO1xuICAgIGlmIChpZHggPT09IC0xKSB0aHJvdyAnYnVmZmVyIGRvZXMgbm90IGV4aXN0JztcbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5idWZmZXJWYWx1ZXNbaWR4XTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgYSB2ZXJ0ZXggYnVmZmVyIHdpdGggZ2l2ZW4gbmFtZSB0byBpbnB1dCB2YWx1ZS4gUmVnaXN0ZXJzIGEgbmV3IFxuICogYnVmZmVyIGlmIG9uZSBkb2VzIG5vdCBleGlzdCB3aXRoIGdpdmVuIG5hbWUuXG4gKiBcbiAqIEBtZXRob2Qgc2V0VmVydGV4QnVmZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyTmFtZSBOYW1lIG9mIHZlcnRleEJ1ZmZlciB0byBiZSBzZXQuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBJbnB1dCBkYXRhIHRvIGZpbGwgdGFyZ2V0IGJ1ZmZlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFZlY3RvciBzaXplIG9mIGlucHV0IGJ1ZmZlciBkYXRhLlxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldFZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uIHNldFZlcnRleEJ1ZmZlcihidWZmZXJOYW1lLCB2YWx1ZSwgc2l6ZSkge1xuICAgIHZhciBpZHggPSB0aGlzLnNwZWMuYnVmZmVyTmFtZXMuaW5kZXhPZihidWZmZXJOYW1lKTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgIGlkeCA9IHRoaXMuc3BlYy5idWZmZXJOYW1lcy5wdXNoKGJ1ZmZlck5hbWUpIC0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnNwZWMuYnVmZmVyVmFsdWVzW2lkeF0gPSB2YWx1ZSB8fCBbXTtcbiAgICB0aGlzLnNwZWMuYnVmZmVyU3BhY2luZ3NbaWR4XSA9IHNpemUgfHwgdGhpcy5ERUZBVUxUX0JVRkZFUl9TSVpFO1xuXG4gICAgaWYgKHRoaXMuc3BlYy5pbnZhbGlkYXRpb25zLmluZGV4T2YoaWR4KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5zcGVjLmludmFsaWRhdGlvbnMucHVzaChpZHgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYW5kIHNldHMgYWxsIGJ1ZmZlcnMgZnJvbSBhbm90aGVyIGdlb21ldHJ5IGluc3RhbmNlLlxuICpcbiAqIEBtZXRob2QgZnJvbUdlb21ldHJ5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGdlb21ldHJ5IEdlb21ldHJ5IGluc3RhbmNlIHRvIGNvcHkgYnVmZmVycyBmcm9tLlxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmZyb21HZW9tZXRyeSA9IGZ1bmN0aW9uIGZyb21HZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHZhciBsZW4gPSBnZW9tZXRyeS5zcGVjLmJ1ZmZlck5hbWVzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2V0VmVydGV4QnVmZmVyKFxuICAgICAgICAgICAgZ2VvbWV0cnkuc3BlYy5idWZmZXJOYW1lc1tpXSxcbiAgICAgICAgICAgIGdlb21ldHJ5LnNwZWMuYnVmZmVyVmFsdWVzW2ldLFxuICAgICAgICAgICAgZ2VvbWV0cnkuc3BlYy5idWZmZXJTcGFjaW5nc1tpXVxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogIFNldCB0aGUgcG9zaXRpb25zIG9mIHRoZSB2ZXJ0aWNlcyBpbiB0aGlzIGdlb21ldHJ5LlxuICogXG4gKiAgQG1ldGhvZCBzZXRWZXJ0ZXhQb3NpdGlvbnNcbiAqICBAcGFyYW0ge0FycmF5fSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHZlcnRleCBwb3NpdGlvbiBidWZmZXJcbiAqICBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuc2V0VmVydGV4UG9zaXRpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVydGV4QnVmZmVyKCdhX3BvcycsIHZhbHVlLCAzKTtcbn07XG5cbi8qKlxuICogIFNldCB0aGUgbm9ybWFscyBvbiB0aGlzIGdlb21ldHJ5LlxuICogXG4gKiAgQG1ldGhvZCBzZXROb3JtYWxzXG4gKiAgQHBhcmFtIHtBcnJheX0gdmFsdWUgVmFsdWUgdG8gc2V0IG5vcm1hbCBidWZmZXIgdG8uXG4gKiAgQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldE5vcm1hbHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWZXJ0ZXhCdWZmZXIoJ2Ffbm9ybWFscycsIHZhbHVlLCAzKTtcbn07XG5cbi8qKlxuICogIFNldCB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBvbiB0aGlzIGdlb21ldHJ5LlxuICogXG4gKiAgQG1ldGhvZCBzZXRUZXh0dXJlQ29vcmRzXG4gKiAgQHBhcmFtIHtBcnJheX0gdmFsdWUgTmV3IHZhbHVlIGZvciB0ZXh0dXJlIGNvb3JkaW5hdGVzIGJ1ZmZlci5cbiAqICBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuc2V0VGV4dHVyZUNvb3JkcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNldFZlcnRleEJ1ZmZlcignYV90ZXhDb29yZCcsIHZhbHVlLCAyKTtcbn07XG5cbi8qKlxuICogIFNldCB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBvbiB0aGlzIGdlb21ldHJ5LlxuICogIEBtZXRob2Qgc2V0VGV4dHVyZUNvb3Jkc1xuICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlIE5ldyB2YWx1ZSBmb3IgaW5kZXggYnVmZmVyXG4gKiAgQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldEluZGljZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWZXJ0ZXhCdWZmZXIoJ2luZGljZXMnLCB2YWx1ZSwgMSk7XG59O1xuXG4vKipcbiAqICBTZXQgdGhlIFdlYkdMIGRyYXdpbmcgcHJpbWl0aXZlIGZvciB0aGlzIGdlb21ldHJ5LlxuICogIEBtZXRob2Qgc2V0RHJhd1R5cGVcbiAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBOZXcgZHJhd2luZyBwcmltaXRpdmUgZm9yIGdlb21ldHJ5XG4gKiAgQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldERyYXdUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5zcGVjLnR5cGUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAncG9zJyB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBtZXRob2QgZ2V0VmVydGV4UG9zaXRpb25zXG4gKiBAcmV0dXJuIHtBcnJheX0gVmVydGV4IGJ1ZmZlci5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5nZXRWZXJ0ZXhQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmVydGV4QnVmZmVyKCdhX3BvcycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAnbm9ybWFsJyB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBtZXRob2QgZ2V0Tm9ybWFsc1xuICogQHJldHVybiB7QXJyYXl9IFZlcnRleCBCdWZmZXIuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuZ2V0Tm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWZXJ0ZXhCdWZmZXIoJ2Ffbm9ybWFscycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAndGV4dHVyZUNvb3JkJyB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBtZXRob2QgZ2V0VGV4dHVyZUNvb3Jkc1xuICogQHJldHVybiB7QXJyYXl9IFZlcnRleCBCdWZmZXIuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuZ2V0VGV4dHVyZUNvb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWZXJ0ZXhCdWZmZXIoJ2FfdGV4Q29vcmQnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY0dlb21ldHJ5O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5SWRzID0gMDtcblxuLyoqXG4gKiBHZW9tZXRyeSBpcyBhIGNvbXBvbmVudCB0aGF0IGRlZmluZXMgdGhlIGRhdGEgdGhhdCBzaG91bGRcbiAqIGJlIGRyYXduIHRvIHRoZSB3ZWJHTCBjYW52YXMuIE1hbmFnZXMgdmVydGV4IGRhdGEgYW5kIGF0dHJpYnV0ZXMuXG4gKlxuICogQGNsYXNzIEdlb21ldHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgSW5zdGFudGlhdGlvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBHZW9tZXRyeShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLkRFRkFVTFRfQlVGRkVSX1NJWkUgPSAzO1xuXG4gICAgdGhpcy5zcGVjID0ge1xuICAgICAgICBpZDogR2VvbWV0cnlJZHMrKyxcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy50eXBlIHx8ICdUUklBTkdMRVMnLFxuICAgICAgICBidWZmZXJOYW1lczogW10sXG4gICAgICAgIGJ1ZmZlclZhbHVlczogW10sXG4gICAgICAgIGJ1ZmZlclNwYWNpbmdzOiBbXSxcbiAgICAgICAgaW52YWxpZGF0aW9uczogW11cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5idWZmZXJzKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLm9wdGlvbnMuYnVmZmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgdGhpcy5zcGVjLmJ1ZmZlck5hbWVzLnB1c2godGhpcy5vcHRpb25zLmJ1ZmZlcnNbaV0ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLnNwZWMuYnVmZmVyVmFsdWVzLnB1c2godGhpcy5vcHRpb25zLmJ1ZmZlcnNbaV0uZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnNwZWMuYnVmZmVyU3BhY2luZ3MucHVzaCh0aGlzLm9wdGlvbnMuYnVmZmVyc1tpXS5zaXplIHx8IHRoaXMuREVGQVVMVF9CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICB0aGlzLnNwZWMuaW52YWxpZGF0aW9ucy5wdXNoKGkrKyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvbWV0cnk7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzInKTtcblxudmFyIG91dHB1dHMgPSBbXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzIoKSxcbiAgICBuZXcgVmVjMigpXG5dO1xuXG4vKipcbiAqIEEgaGVscGVyIG9iamVjdCB1c2VkIHRvIGNhbGN1bGF0ZSBidWZmZXJzIGZvciBjb21wbGljYXRlZCBnZW9tZXRyaWVzLlxuICogVGFpbG9yZWQgZm9yIHRoZSBXZWJHTFJlbmRlcmVyLCB1c2VkIGJ5IG1vc3QgcHJpbWl0aXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY2xhc3MgR2VvbWV0cnlIZWxwZXJcbiAqL1xudmFyIEdlb21ldHJ5SGVscGVyID0ge307XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIHRocm91Z2ggdmVydGljYWwgYW5kIGhvcml6b250YWwgc2xpY2VzXG4gKiBiYXNlZCBvbiBpbnB1dCBkZXRhaWwsIGFuZCBnZW5lcmF0ZXMgdmVydGljZXMgYW5kIGluZGljZXMgZm9yIGVhY2hcbiAqIHN1YmRpdmlzaW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2VuZXJhdGVQYXJhbWV0cmljXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRldGFpbFggQW1vdW50IG9mIHNsaWNlcyB0byBpdGVyYXRlIHRocm91Z2guXG4gKiBAcGFyYW0ge051bWJlcn0gZGV0YWlsWSBBbW91bnQgb2Ygc3RhY2tzIHRvIGl0ZXJhdGUgdGhyb3VnaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB2ZXJ0ZXggcG9zaXRpb25zIGF0IGVhY2ggcG9pbnQuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIHZlcnRpY2VzIGFuZCBpbmRpY2VzLlxuICovXG5HZW9tZXRyeUhlbHBlci5nZW5lcmF0ZVBhcmFtZXRyaWMgPSBmdW5jdGlvbiBnZW5lcmF0ZVBhcmFtZXRyaWMoZGV0YWlsWCwgZGV0YWlsWSwgZnVuYywgd3JhcCkge1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICBpLCB0aGV0YSwgcGhpLCByZXN1bHQsIGo7XG5cbiAgICAvLyBXZSBjYW4gd3JhcCBhcm91bmQgc2xpZ2h0bHkgbW9yZSB0aGFuIG9uY2UgZm9yIHV2IGNvb3JkaW5hdGVzIHRvIGxvb2sgY29ycmVjdC5cblxuICAgIHZhciBYcmFuZ2UgPSB3cmFwID8gTWF0aC5QSSArIChNYXRoLlBJIC8gKGRldGFpbFggLSAxKSkgOiBNYXRoLlBJO1xuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBkZXRhaWxYICsgMTsgaSsrKSB7XG4gICAgICAgIHRoZXRhID0gaSAqIFhyYW5nZSAvIGRldGFpbFg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBkZXRhaWxZOyBqKyspIHtcbiAgICAgICAgICAgIHBoaSA9IGogKiAyLjAgKiBYcmFuZ2UgLyBkZXRhaWxZO1xuICAgICAgICAgICAgZnVuYyh0aGV0YSwgcGhpLCBvdXQpO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChvdXRbMF0sIG91dFsxXSwgb3V0WzJdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gW10sXG4gICAgICAgIHYgPSAwLFxuICAgICAgICBuZXh0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBkZXRhaWxYOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRldGFpbFk7IGorKykge1xuICAgICAgICAgICAgbmV4dCA9IChqICsgMSkgJSBkZXRhaWxZO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHYgKyBqLCB2ICsgaiArIGRldGFpbFksIHYgKyBuZXh0KTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ICsgbmV4dCwgdiArIGogKyBkZXRhaWxZLCB2ICsgbmV4dCArIGRldGFpbFkpO1xuICAgICAgICB9XG4gICAgICAgIHYgKz0gZGV0YWlsWTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgICAgIGluZGljZXM6IGluZGljZXNcbiAgICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgbm9ybWFscyBiZWxvbmdpbmcgdG8gZWFjaCBmYWNlIG9mIGEgZ2VvbWV0cnkuICBcbiAqIEFzc3VtZXMgY2xvY2t3aXNlIGRlY2xhcmF0aW9uIG9mIHZlcnRpY2VzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IGluZGljZXMgSW5kaWNlcyBkZWNsYXJpbmcgZmFjZXMgb2YgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgQXJyYXkgdG8gYmUgZmlsbGVkIGFuZCByZXR1cm5lZC5cbiAqIFxuICogQHJldHVybiB7QXJyYXl9IENhbGN1bGF0ZWQgZmFjZSBub3JtYWxzLlxuICovXG5HZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyA9IGZ1bmN0aW9uIGNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLCBpbmRpY2VzLCBvdXQpIHtcbiAgICB2YXIgbm9ybWFscyA9IG91dCB8fCBbXTtcbiAgICB2YXIgdmVydGV4VGhyZWU7XG4gICAgdmFyIHZlcnRleFR3bztcbiAgICB2YXIgdmVydGV4T25lO1xuICAgIHZhciBpbmRleE9uZTtcbiAgICB2YXIgaW5kZXhUd287XG4gICAgdmFyIGluZGV4VGhyZWU7XG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIG5vcm1hbDtcbiAgICB2YXIgajtcbiAgICB2YXIgbGVuID0gaW5kaWNlcy5sZW5ndGggLyAzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBqID0gaSAqIDM7XG4gICAgICAgIGluZGV4VHdvID0gaW5kaWNlc1tqICsgMF0gKiAzO1xuICAgICAgICBpbmRleE9uZSA9IGluZGljZXNbaiArIDFdICogMztcbiAgICAgICAgaW5kZXhUaHJlZSA9IGluZGljZXNbaiArIDJdICogMztcblxuICAgICAgICBvdXRwdXRzWzBdLnNldCh2ZXJ0aWNlc1tpbmRleE9uZV0sIHZlcnRpY2VzW2luZGV4T25lICsgMV0sIHZlcnRpY2VzW2luZGV4T25lICsgMl0pO1xuICAgICAgICBvdXRwdXRzWzFdLnNldCh2ZXJ0aWNlc1tpbmRleFR3b10sIHZlcnRpY2VzW2luZGV4VHdvICsgMV0sIHZlcnRpY2VzW2luZGV4VHdvICsgMl0pO1xuICAgICAgICBvdXRwdXRzWzJdLnNldCh2ZXJ0aWNlc1tpbmRleFRocmVlXSwgdmVydGljZXNbaW5kZXhUaHJlZSArIDFdLCB2ZXJ0aWNlc1tpbmRleFRocmVlICsgMl0pO1xuXG4gICAgICAgIG5vcm1hbCA9IG91dHB1dHNbMl0uc3VidHJhY3Qob3V0cHV0c1swXSkuY3Jvc3Mob3V0cHV0c1sxXS5zdWJ0cmFjdChvdXRwdXRzWzBdKSk7XG4gICAgICAgIG5vcm1hbCA9IG5vcm1hbC5ub3JtYWxpemUoKS50b0FycmF5KCk7XG5cbiAgICAgICAgbm9ybWFsc1tpbmRleE9uZSArIDBdID0gbm9ybWFsWzBdO1xuICAgICAgICBub3JtYWxzW2luZGV4T25lICsgMV0gPSBub3JtYWxbMV07XG4gICAgICAgIG5vcm1hbHNbaW5kZXhPbmUgKyAyXSA9IG5vcm1hbFsyXTtcblxuICAgICAgICBub3JtYWxzW2luZGV4VHdvICsgMF0gPSBub3JtYWxbMF07XG4gICAgICAgIG5vcm1hbHNbaW5kZXhUd28gKyAxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgbm9ybWFsc1tpbmRleFR3byArIDJdID0gbm9ybWFsWzJdO1xuXG4gICAgICAgIG5vcm1hbHNbaW5kZXhUaHJlZSArIDBdID0gbm9ybWFsWzBdO1xuICAgICAgICBub3JtYWxzW2luZGV4VGhyZWUgKyAxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgbm9ybWFsc1tpbmRleFRocmVlICsgMl0gPSBub3JtYWxbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbHM7XG59O1xuXG4vKipcbiAqIERpdmlkZXMgYWxsIGluc2VydGVkIHRyaWFuZ2xlcyBpbnRvIGZvdXIgc3ViLXRyaWFuZ2xlcy4gQWx0ZXJzIHRoZVxuICogcGFzc2VkIGluIGFycmF5cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN1YmRpdmlkZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGluZGljZXMgSW5kaWNlcyBkZWNsYXJpbmcgZmFjZXMgb2YgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSB0ZXh1dHVyZUNvb3JkcyBUZXh0dXJlIGNvb3JkaW5hdGVzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBcbiAqL1xuR2VvbWV0cnlIZWxwZXIuc3ViZGl2aWRlID0gZnVuY3Rpb24gc3ViZGl2aWRlKGluZGljZXMsIHZlcnRpY2VzLCB0ZXh0dXJlQ29vcmRzKSB7XG4gICAgdmFyIHRyaWFuZ2xlSW5kZXggPSBpbmRpY2VzLmxlbmd0aCAvIDMsXG4gICAgICAgIGFiYyxcbiAgICAgICAgZmFjZSxcbiAgICAgICAgaSwgaiwgaywgcG9zLCB0ZXg7XG5cbiAgICB3aGlsZSAodHJpYW5nbGVJbmRleC0tKSB7XG4gICAgICAgIGZhY2UgPSBpbmRpY2VzLnNsaWNlKHRyaWFuZ2xlSW5kZXggKiAzLCB0cmlhbmdsZUluZGV4ICogMyArIDMpO1xuXG4gICAgICAgIHBvcyA9IGZhY2UubWFwKGZ1bmN0aW9uKHZlcnRJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHZlcnRpY2VzW3ZlcnRJbmRleCAqIDNdLCB2ZXJ0aWNlc1t2ZXJ0SW5kZXggKiAzICsgMV0sIHZlcnRpY2VzW3ZlcnRJbmRleCAqIDMgKyAyXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoLmFwcGx5KHZlcnRpY2VzLCBWZWMzLnNjYWxlKFZlYzMuYWRkKHBvc1swXSwgcG9zWzFdLCBvdXRwdXRzWzBdKSwgMC41LCBvdXRwdXRzWzFdKS50b0FycmF5KCkpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoLmFwcGx5KHZlcnRpY2VzLCBWZWMzLnNjYWxlKFZlYzMuYWRkKHBvc1sxXSwgcG9zWzJdLCBvdXRwdXRzWzBdKSwgMC41LCBvdXRwdXRzWzFdKS50b0FycmF5KCkpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoLmFwcGx5KHZlcnRpY2VzLCBWZWMzLnNjYWxlKFZlYzMuYWRkKHBvc1swXSwgcG9zWzJdLCBvdXRwdXRzWzBdKSwgMC41LCBvdXRwdXRzWzFdKS50b0FycmF5KCkpO1xuXG4gICAgICAgIGlmICh0ZXh0dXJlQ29vcmRzKSB7XG4gICAgICAgICAgICB0ZXggPSBmYWNlLm1hcChmdW5jdGlvbih2ZXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIodGV4dHVyZUNvb3Jkc1t2ZXJ0SW5kZXggKiAyXSwgdGV4dHVyZUNvb3Jkc1t2ZXJ0SW5kZXggKiAyICsgMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZXh0dXJlQ29vcmRzLnB1c2guYXBwbHkodGV4dHVyZUNvb3JkcywgVmVjMi5zY2FsZShWZWMyLmFkZCh0ZXhbMF0sIHRleFsxXSwgb3V0cHV0c1szXSksIDAuNSwgb3V0cHV0c1s0XSkudG9BcnJheSgpKTtcbiAgICAgICAgICAgIHRleHR1cmVDb29yZHMucHVzaC5hcHBseSh0ZXh0dXJlQ29vcmRzLCBWZWMyLnNjYWxlKFZlYzIuYWRkKHRleFsxXSwgdGV4WzJdLCBvdXRwdXRzWzNdKSwgMC41LCBvdXRwdXRzWzRdKS50b0FycmF5KCkpO1xuICAgICAgICAgICAgdGV4dHVyZUNvb3Jkcy5wdXNoLmFwcGx5KHRleHR1cmVDb29yZHMsIFZlYzIuc2NhbGUoVmVjMi5hZGQodGV4WzBdLCB0ZXhbMl0sIG91dHB1dHNbM10pLCAwLjUsIG91dHB1dHNbNF0pLnRvQXJyYXkoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpID0gdmVydGljZXMubGVuZ3RoIC0gMywgaiA9IGkgKyAxLCBrID0gaSArIDI7XG4gICAgICAgIGluZGljZXMucHVzaChpLCBqLCBrKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGZhY2VbMF0sIGksIGspO1xuICAgICAgICBpbmRpY2VzLnB1c2goaSwgZmFjZVsxXSwgaik7XG4gICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRleF0gPSBrO1xuICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kZXggKyAxXSA9IGo7XG4gICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRleCArIDJdID0gZmFjZVsyXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgZHVwbGljYXRlIG9mIHZlcnRpY2VzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGZhY2VzLlxuICogQWx0ZXJzIHRoZSBpbnB1dCB2ZXJ0ZXggYW5kIGluZGV4IGFycmF5cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldFVuaXF1ZUZhY2VzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IGluZGljZXMgSW5kaWNlcyBkZWNsYXJpbmcgZmFjZXMgb2YgZ2VvbWV0cnlcbiAqIFxuICovXG5HZW9tZXRyeUhlbHBlci5nZXRVbmlxdWVGYWNlcyA9IGZ1bmN0aW9uIGdldFVuaXF1ZUZhY2VzKHZlcnRpY2VzLCBpbmRpY2VzKSB7XG4gICAgdmFyIHRyaWFuZ2xlSW5kZXggPSBpbmRpY2VzLmxlbmd0aCAvIDMsXG4gICAgICAgIHJlZ2lzdGVyZWQgPSBbXSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICB3aGlsZSAodHJpYW5nbGVJbmRleC0tKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cbiAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc1t0cmlhbmdsZUluZGV4ICogMyArIGldO1xuXG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW2luZGV4ICogM10sIHZlcnRpY2VzW2luZGV4ICogMyArIDFdLCB2ZXJ0aWNlc1tpbmRleCAqIDMgKyAyXSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGV4ICogMyArIGldID0gdmVydGljZXMubGVuZ3RoIC8gMyAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRGl2aWRlcyBhbGwgaW5zZXJ0ZWQgdHJpYW5nbGVzIGludG8gZm91ciBzdWItdHJpYW5nbGVzIHdoaWxlIG1haW50YWluaW5nXG4gKiBhIHJhZGl1cyBvZiBvbmUuIEFsdGVycyB0aGUgcGFzc2VkIGluIGFycmF5cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN1YmRpdmlkZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIEluZGljZXMgZGVjbGFyaW5nIGZhY2VzIG9mIGdlb21ldHJ5XG4gKiBcbiAqL1xuR2VvbWV0cnlIZWxwZXIuc3ViZGl2aWRlU3BoZXJvaWQgPSBmdW5jdGlvbiBzdWJkaXZpZGVTcGhlcm9pZCh2ZXJ0aWNlcywgaW5kaWNlcykge1xuICAgIHZhciB0cmlhbmdsZUluZGV4ID0gaW5kaWNlcy5sZW5ndGggLyAzLFxuICAgICAgICBhYmMsXG4gICAgICAgIGZhY2UsXG4gICAgICAgIGksIGosIGs7XG5cbiAgICB3aGlsZSAodHJpYW5nbGVJbmRleC0tKSB7XG4gICAgICAgIGZhY2UgPSBpbmRpY2VzLnNsaWNlKHRyaWFuZ2xlSW5kZXggKiAzLCB0cmlhbmdsZUluZGV4ICogMyArIDMpO1xuICAgICAgICBhYmMgPSBmYWNlLm1hcChmdW5jdGlvbih2ZXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh2ZXJ0aWNlc1t2ZXJ0SW5kZXggKiAzXSwgdmVydGljZXNbdmVydEluZGV4ICogMyArIDFdLCB2ZXJ0aWNlc1t2ZXJ0SW5kZXggKiAzICsgMl0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2ZXJ0aWNlcy5wdXNoLmFwcGx5KHZlcnRpY2VzLCBWZWMzLm5vcm1hbGl6ZShWZWMzLmFkZChhYmNbMF0sIGFiY1sxXSwgb3V0cHV0c1swXSksIG91dHB1dHNbMV0pLnRvQXJyYXkoKSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2guYXBwbHkodmVydGljZXMsIFZlYzMubm9ybWFsaXplKFZlYzMuYWRkKGFiY1sxXSwgYWJjWzJdLCBvdXRwdXRzWzBdKSwgb3V0cHV0c1sxXSkudG9BcnJheSgpKTtcbiAgICAgICAgdmVydGljZXMucHVzaC5hcHBseSh2ZXJ0aWNlcywgVmVjMy5ub3JtYWxpemUoVmVjMy5hZGQoYWJjWzBdLCBhYmNbMl0sIG91dHB1dHNbMF0pLCBvdXRwdXRzWzFdKS50b0FycmF5KCkpO1xuXG4gICAgICAgIGkgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzIC0gMywgaiA9IGkgKyAxLCBrID0gaSArIDI7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKGksIGosIGspO1xuICAgICAgICBpbmRpY2VzLnB1c2goZmFjZVswXSwgaSwgayk7XG4gICAgICAgIGluZGljZXMucHVzaChpLCBmYWNlWzFdLCBqKTtcbiAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGV4ICogM10gPSBrO1xuICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kZXggKiAzICsgMV0gPSBqO1xuICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kZXggKiAzICsgMl0gPSBmYWNlWzJdO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGl2aWRlcyBhbGwgaW5zZXJ0ZWQgdHJpYW5nbGVzIGludG8gZm91ciBzdWItdHJpYW5nbGVzIHdoaWxlIG1haW50YWluaW5nXG4gKiBhIHJhZGl1cyBvZiBvbmUuIEFsdGVycyB0aGUgcGFzc2VkIGluIGFycmF5cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldFNwaGVyb2lkTm9ybWFsc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgT3B0aW9uYWwgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggcmVzdWx0aW5nIG5vcm1hbHMuXG4gKiBcbiAqIEByZXR1cm4ge0FycmF5fSBuZXcgbGlzdCBvZiBjYWxjdWxhdGVkIG5vcm1hbHMuXG4gKi9cbkdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkTm9ybWFscyA9IGZ1bmN0aW9uIGdldFNwaGVyb2lkTm9ybWFscyh2ZXJ0aWNlcywgb3V0KSB7XG4gICAgdmFyIG91dCA9IG91dCB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gdmVydGljZXMubGVuZ3RoIC8gMztcbiAgICB2YXIgbm9ybWFsaXplZDtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBub3JtYWxpemVkID0gbmV3IFZlYzMoXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDBdLFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAxXSxcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzICsgMl1cbiAgICAgICAgKS5ub3JtYWxpemUoKS50b0FycmF5KCk7XG5cbiAgICAgICAgb3V0W2kgKiAzICsgMF0gPSBub3JtYWxpemVkWzBdO1xuICAgICAgICBvdXRbaSAqIDMgKyAxXSA9IG5vcm1hbGl6ZWRbMV07XG4gICAgICAgIG91dFtpICogMyArIDJdID0gbm9ybWFsaXplZFsyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgZm9yIHNwaGVyb2lkIHByaW1pdGl2ZXMgYmFzZWQgb25cbiAqIGlucHV0IHZlcnRpY2VzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0U3BoZXJvaWRVVlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgT3B0aW9uYWwgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggcmVzdWx0aW5nIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gKiBcbiAqIEByZXR1cm4ge0FycmF5fSBuZXcgbGlzdCBvZiBjYWxjdWxhdGVkIHRleHR1cmUgY29vcmRpbmF0ZXNcbiAqL1xuR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWRVViA9IGZ1bmN0aW9uIGdldFNwaGVyb2lkVVYodmVydGljZXMsIG91dCkge1xuICAgIHZhciBvdXQgPSBvdXQgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgdmFyIHZlcnRleDtcblxuICAgIHZhciB1diA9IFtdO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZlcnRleCA9IG91dHB1dHNbMF0uc2V0KFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDNdLFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAxXSxcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzICsgMl1cbiAgICAgICAgKVxuICAgICAgICAubm9ybWFsaXplKClcbiAgICAgICAgLnRvQXJyYXkoKTtcblxuICAgICAgICB1dlswXSA9IHRoaXMuZ2V0QXppbXV0aCh2ZXJ0ZXgpICogMC41IC8gTWF0aC5QSSArIDAuNTtcbiAgICAgICAgdXZbMV0gPSB0aGlzLmdldEFsdGl0dWRlKHZlcnRleCkgLyBNYXRoLlBJICsgMC41O1xuXG4gICAgICAgIG91dC5wdXNoLmFwcGx5KG91dCwgdXYpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggYW5kIG5vcm1hbGl6ZXMgYSBsaXN0IG9mIHZlcnRpY2VzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgbm9ybWFsaXplQWxsXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBPcHRpb25hbCBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCByZXN1bHRpbmcgbm9ybWFsaXplZCB2ZWN0b3JzLlxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gbmV3IGxpc3Qgb2Ygbm9ybWFsaXplZCB2ZXJ0aWNlc1xuICovXG5HZW9tZXRyeUhlbHBlci5ub3JtYWxpemVBbGwgPSBmdW5jdGlvbiBub3JtYWxpemVBbGwodmVydGljZXMsIG91dCkge1xuICAgIHZhciBvdXQgPSBvdXQgfHwgW107XG4gICAgdmFyIHZlcnRleDtcbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoIC8gMztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3V0LCBuZXcgVmVjMyh2ZXJ0aWNlc1tpICogM10sIHZlcnRpY2VzW2kgKiAzICsgMV0sIHZlcnRpY2VzW2kgKiAzICsgMl0pLm5vcm1hbGl6ZSgpLnRvQXJyYXkoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHNldCBvZiB2ZXJ0aWNlcyB0byBtb2RlbCBzcGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVZlcnRpY2VzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBPcHRpb25hbCBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBtb2RlbCBzcGFjZSBwb3NpdGlvbiB2ZWN0b3JzLlxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gT3V0cHV0IHZlcnRpY2VzLlxuICovXG5HZW9tZXRyeUhlbHBlci5ub3JtYWxpemVWZXJ0aWNlcyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVZlcnRpY2VzKHZlcnRpY2VzLCBvdXQpIHtcbiAgICB2YXIgb3V0ID0gb3V0IHx8IFtdO1xuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgIHZhciB2ZWN0b3JzID0gW107XG4gICAgdmFyIG1pblg7XG4gICAgdmFyIG1heFg7XG4gICAgdmFyIG1pblk7XG4gICAgdmFyIG1heFk7XG4gICAgdmFyIG1pblo7XG4gICAgdmFyIG1heFo7XG4gICAgdmFyIHY7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHYgPSB2ZWN0b3JzW2ldID0gbmV3IFZlYzMoXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogM10sXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDFdLFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAyXVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtaW5YID09IG51bGwgfHwgdi54IDwgbWluWCkgbWluWCA9IHYueDtcbiAgICAgICAgaWYgKG1heFggPT0gbnVsbCB8fCB2LnggPiBtYXhYKSBtYXhYID0gdi54O1xuXG4gICAgICAgIGlmIChtaW5ZID09IG51bGwgfHwgdi55IDwgbWluWSkgbWluWSA9IHYueTtcbiAgICAgICAgaWYgKG1heFkgPT0gbnVsbCB8fCB2LnkgPiBtYXhZKSBtYXhZID0gdi55O1xuXG4gICAgICAgIGlmIChtaW5aID09IG51bGwgfHwgdi56IDwgbWluWikgbWluWiA9IHYuejtcbiAgICAgICAgaWYgKG1heFogPT0gbnVsbCB8fCB2LnogPiBtYXhaKSBtYXhaID0gdi56O1xuICAgIH07XG5cbiAgICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgVmVjMyhcbiAgICAgICAgZ2V0VHJhbnNsYXRpb25GYWN0b3IobWF4WCwgbWluWCksXG4gICAgICAgIGdldFRyYW5zbGF0aW9uRmFjdG9yKG1heFksIG1pblkpLFxuICAgICAgICBnZXRUcmFuc2xhdGlvbkZhY3RvcihtYXhaLCBtaW5aKVxuICAgICk7XG5cbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihcbiAgICAgICAgZ2V0U2NhbGVGYWN0b3IobWF4WCArIHRyYW5zbGF0aW9uLngsIG1pblggKyB0cmFuc2xhdGlvbi54KSxcbiAgICAgICAgZ2V0U2NhbGVGYWN0b3IobWF4WSArIHRyYW5zbGF0aW9uLnksIG1pblkgKyB0cmFuc2xhdGlvbi55KSxcbiAgICAgICAgZ2V0U2NhbGVGYWN0b3IobWF4WiArIHRyYW5zbGF0aW9uLnosIG1pblogKyB0cmFuc2xhdGlvbi56KVxuICAgICk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2guYXBwbHkob3V0LCB2ZWN0b3JzW2ldLmFkZCh0cmFuc2xhdGlvbikuc2NhbGUoc2NhbGUpLnRvQXJyYXkoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0cmFuc2xhdGlvbiBhbW91bnQgZm9yIGEgZ2l2ZW4gYXhpcyB0byBub3JtYWxpemUgbW9kZWwgY29vcmRpbmF0ZXMuXG4gKlxuICogQG1ldGhvZCBnZXRUcmFuc2xhdGlvbkZhY3RvclxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IE1heGltdW0gcG9zaXRpb24gdmFsdWUgb2YgZ2l2ZW4gYXhpcyBvbiB0aGUgbW9kZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIE1pbmltdW0gcG9zaXRpb24gdmFsdWUgb2YgZ2l2ZW4gYXhpcyBvbiB0aGUgbW9kZWwuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgYnkgd2hpY2ggdGhlIGdpdmVuIGF4aXMgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgZm9yIGFsbCB2ZXJ0aWNlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb25GYWN0b3IobWF4LCBtaW4pIHtcbiAgICByZXR1cm4gLShtaW4gKyAobWF4IC0gbWluKSAvIDIpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgc2NhbGUgYW1vdW50IGZvciBhIGdpdmVuIGF4aXMgdG8gbm9ybWFsaXplIG1vZGVsIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBtZXRob2QgZ2V0U2NhbGVGYWN0b3JcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBNYXhpbXVtIHNjYWxlIHZhbHVlIG9mIGdpdmVuIGF4aXMgb24gdGhlIG1vZGVsLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBNaW5pbXVtIHNjYWxlIHZhbHVlIG9mIGdpdmVuIGF4aXMgb24gdGhlIG1vZGVsLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gTnVtYmVyIGJ5IHdoaWNoIHRoZSBnaXZlbiBheGlzIHNob3VsZCBiZSBzY2FsZWQgZm9yIGFsbCB2ZXJ0aWNlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGVGYWN0b3IobWF4LCBtaW4pIHtcbiAgICByZXR1cm4gMSAvICgobWF4IC0gbWluKSAvIDIpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBhemltdXRoLCBvciBhbmdsZSBhYm92ZSB0aGUgWFkgcGxhbmUsIG9mIGEgZ2l2ZW4gdmVjdG9yLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0QXppbXV0aFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHYgVmVydGV4IHRvIHJldHJlaXZlIGF6aW11dGggZnJvbS5cbiAqIFxuICogQHJldHVybiB7TnVtYmVyfSBBemltdXRoIHZhbHVlIGluIHJhZGlhbnMuIFxuICovXG5HZW9tZXRyeUhlbHBlci5nZXRBemltdXRoID0gZnVuY3Rpb24gYXppbXV0aCh2KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIodlsyXSwgLXZbMF0pO1xufTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgYWx0aXR1ZGUsIG9yIGFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZSwgb2YgYSBnaXZlbiB2ZWN0b3IuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRBbHRpdHVkZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHYgVmVydGV4IHRvIHJldHJlaXZlIGFsdGl0dWRlIGZyb20uXG4gKiBcbiAqIEByZXR1cm4ge051bWJlcn0gQWx0aXR1ZGUgdmFsdWUgaW4gcmFkaWFucy4gXG4gKi9cbkdlb21ldHJ5SGVscGVyLmdldEFsdGl0dWRlID0gZnVuY3Rpb24gYWx0aXR1ZGUodikge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKC12WzFdLCBNYXRoLnNxcnQoKHZbMF0gKiB2WzBdKSArICh2WzJdICogdlsyXSkpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIGluZGljZXMgZnJvbSAndHJpYW5nbGUnIHRvICdsaW5lJyBmb3JtYXQuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCB0cmlhbmdsZXNUb0xpbmVzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaW5kaWNlcyBJbmRpY2VzIG9mIGFsbCBmYWNlcyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBJbmRpY2VzIG9mIGFsbCBmYWNlcyBvbiB0aGUgZ2VvbWV0cnlcbiAqIFxuICogQHJldHVybiB7QXJyYXl9IG5ldyBsaXN0IG9mIGxpbmUtZm9ybWF0dGVkIGluZGljZXNcbiAqL1xuR2VvbWV0cnlIZWxwZXIudHJpYW5nbGVzVG9MaW5lcyA9IGZ1bmN0aW9uIHRyaWFuZ2xlVG9MaW5lcyhpbmRpY2VzLCBvdXQpIHtcbiAgICB2YXIgbnVtVmVjdG9ycyA9IGluZGljZXMubGVuZ3RoIC8gMztcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGZhY2U7XG4gICAgdmFyIGo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVmVjdG9yczsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKGluZGljZXNbaSAqIDMgKyAwXSwgaW5kaWNlc1tpICogMyArIDFdKTtcbiAgICAgICAgb3V0LnB1c2goaW5kaWNlc1tpICogMyArIDFdLCBpbmRpY2VzW2kgKiAzICsgMl0pO1xuICAgICAgICBvdXQucHVzaChpbmRpY2VzW2kgKiAzICsgMl0sIGluZGljZXNbaSAqIDMgKyAwXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyBhIHJldmVyc2Ugb3JkZXIgdHJpYW5nbGUgZm9yIGV2ZXJ5IHRyaWFuZ2xlIGluIHRoZSBtZXNoLiAgQWRkcyBleHRyYSB2ZXJ0aWNlc1xuICogYW5kIGluZGljZXMgdG8gaW5wdXQgYXJyYXlzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkQmFja2ZhY2VUcmlhbmdsZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBYLCBZLCBaIHBvc2l0aW9ucyBvZiBhbGwgdmVydGljZXMgaW4gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIEluZGljZXMgb2YgYWxsIGZhY2VzIG9uIHRoZSBnZW9tZXRyeVxuICovXG5HZW9tZXRyeUhlbHBlci5hZGRCYWNrZmFjZVRyaWFuZ2xlcyA9IGZ1bmN0aW9uIGFkZEJhY2tmYWNlVHJpYW5nbGVzKHZlcnRpY2VzLCBpbmRpY2VzKSB7XG4gICAgdmFyIG5GYWNlcyA9IGluZGljZXMubGVuZ3RoIC8gMztcbiAgICBcbiAgICB2YXIgbWF4SW5kZXggPSAwO1xuICAgIHZhciBpID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgaWYgKGluZGljZXNbaV0gPiBtYXhJbmRleCkgbWF4SW5kZXggPSBpbmRpY2VzW2ldO1xuXG4gICAgbWF4SW5kZXgrKztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkZhY2VzOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4T25lID0gaW5kaWNlc1tpICogM10sXG4gICAgICAgICAgICBpbmRleFR3byA9IGluZGljZXNbaSAqIDMgKyAxXSxcbiAgICAgICAgICAgIGluZGV4VGhyZWUgPSBpbmRpY2VzW2kgKiAzICsgMl07XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4T25lICsgbWF4SW5kZXgsIGluZGV4VGhyZWUgKyBtYXhJbmRleCwgaW5kZXhUd28gKyBtYXhJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0aW5nIGluc3RlYWQgb2YgLnNsaWNlKCkgaGVyZSB0byBhdm9pZCBtYXggY2FsbCBzdGFjayBpc3N1ZS5cblxuICAgIHZhciBuVmVydHMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuVmVydHM7IGkrKykge1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW2ldKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb21ldHJ5SGVscGVyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxvYWRVUkwgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2xvYWRVUkwnKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4vR2VvbWV0cnlIZWxwZXInKTtcblxuLypcbiAqIEEgc2luZ2xldG9uIG9iamVjdCB0aGF0IHRha2VzIHRoYXQgbWFrZXMgcmVxdWVzdHNcbiAqIGZvciBPQkogZmlsZXMgYW5kIHJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRhIGFzXG4gKiBhbiBhcmd1bWVudCB0byBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjbGFzcyBPQkpMb2FkZXJcbiAqL1xuXG52YXIgT0JKTG9hZGVyID0ge1xuICAgIGNhY2hlZDoge30sXG4gICAgcmVxdWVzdHM6IHt9LFxuICAgIGZvcm1hdFRleHQ6IGZvcm1hdFxufTtcblxuLypcbiAqIFRha2VzIGEgcGF0aCB0byBkZXNpcmVkIG9iaiBmaWxlIGFuZCBtYWtlcyBhbiBYTUxIdHRwIHJlcXVlc3RcbiAqIGlmIHRoZSByZXNvdXJjZSBpcyBub3QgY2FjaGVkLiBTZXRzIHVwIHRoZSAnb25yZXNwb25zZScgZnVuY3Rpb25cbiAqIGFzIGEgY2FsbGJhY2sgZm9yIGZvcm1hdHRpbmcgYW5kIGNhbGxiYWNrIGludm9jYXRpb24uXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgb2YgZGVzaXJlZCBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIEZ1bmN0aW9uIHRvIGJlIGZpcmVkIHVwb24gc3VjY2Vzc2Z1bCBmb3JtYXR0aW5nIG9mIG9ialxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBoYXNoIHRvIHRoYXQgY2FuIGFmZmVjdCB0aGUgb3V0cHV0IG9mIHRoZSBPQkpcbiAqIHZlcnRpY2VzLlxuICovXG5PQkpMb2FkZXIubG9hZCA9IGZ1bmN0aW9uIGxvYWQodXJsLCBjYiwgb3B0aW9ucykge1xuICAgIGlmICghIHRoaXMuY2FjaGVkW3VybF0pIHtcbiAgICAgICAgaWYoISB0aGlzLnJlcXVlc3RzW3VybF0pIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNbdXJsXSA9IFtjYl07XG4gICAgICAgICAgICBsb2FkVVJMKFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB0aGlzLl9vbnN1Y2Nlc3MuYmluZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNbdXJsXS5wdXNoKGNiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKHRoaXMuY2FjaGVkW3VybF0pO1xuICAgIH1cbn07XG5cbi8qXG4gKiBGaXJlZCBvbiByZXNwb25zZSBmcm9tIHNlcnZlciBmb3IgT0JKIGFzc2V0LiAgRm9ybWF0cyB0aGVcbiAqIHJldHVybmVkIHN0cmluZyBhbmQgc3RvcmVzIHRoZSBidWZmZXIgZGF0YSBpbiBjYWNoZS5cbiAqIEludm9rZXMgYWxsIHF1ZXVlZCBjYWxsYmFja3MgYmVmb3JlIGNsZWFyaW5nIHRoZW0uXG4gKlxuICogQG1ldGhvZCBfb25zdWNjZXNzXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBVUkwgb2YgcmVxdWVzdGVkIG9ialxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBkZXRlcm1pbmluZyB3aGV0aGVyIG9yIG5vdCB0byBtYW51YWxseSBjYWxjdWxhdGUgbm9ybWFsc1xuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgb2YgdGhlIHNlcnZlciByZXNwb25zZVxuICovXG5PQkpMb2FkZXIuX29uc3VjY2VzcyA9IGZ1bmN0aW9uIF9vbnN1Y2Nlc3ModXJsLCBvcHRpb25zLCB0ZXh0KSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBmb3JtYXQuY2FsbCh0aGlzLCB0ZXh0LCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLmNhY2hlZFt1cmxdID0gYnVmZmVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZXF1ZXN0c1t1cmxdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdHNbdXJsXVtpXShidWZmZXJzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3RzW3VybF0gPSBudWxsO1xufTtcblxuLypcbiAqIFRha2VzIHJhdyBzdHJpbmcgZm9ybWF0IG9mIG9iaiBhbmQgY29udmVydHMgaXQgdG8gYSBqYXZhc2NyaXB0XG4gKiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBidWZmZXJzIG5lZWRlZCB0byBkcmF3IHRoZSBnZW9tZXRyeS5cbiAqXG4gKiBAbWV0aG9kIGZvcm1hdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3IG9iaiBkYXRhIGluIHRleHQgZm9ybWF0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIGRldGVybWluaW5nIHdoZXRoZXIgb3Igbm90IHRvIG1hbnVhbGx5IGNhbGN1bGF0ZSBub3JtYWxzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB2ZXJ0ZXggYnVmZmVyIGRhdGFcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KHRleHQsIG9wdGlvbnMpIHtcbiAgICB0ZXh0ID0gc2FuaXRpemUodGV4dCk7XG5cbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgIHZhciBmYWNlVGV4Q29vcmRzID0gW107XG4gICAgdmFyIGZhY2VWZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBmYWNlTm9ybWFscyA9IFtdO1xuXG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICB2YXIgdGV4Q29vcmRzID0gW107XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG5cbiAgICB2YXIgaTEsIGkyLCBpMywgaTQ7XG4gICAgdmFyIHNwbGl0O1xuICAgIHZhciBsaW5lO1xuXG4gICAgdmFyIGxlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBzcGxpdCA9IGxpbmVzW2ldLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgLy8gSGFuZGxlIHZlcnRleCBwb3NpdGlvbnNcblxuICAgICAgICBpZiAobGluZS5pbmRleE9mKCd2ICcpICE9PSAtMSkge1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChbXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsyXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHRleHR1cmUgY29vcmRpbmF0ZXNcblxuICAgICAgICBlbHNlIGlmKGxpbmUuaW5kZXhPZigndnQgJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0ZXhDb29yZHMucHVzaChbXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsyXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHZlcnRleCBub3JtYWxzXG5cbiAgICAgICAgZWxzZSBpZiAobGluZS5pbmRleE9mKCd2biAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsyXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGZhY2VcblxuICAgICAgICBlbHNlIGlmIChsaW5lLmluZGV4T2YoJ2YgJykgIT09IC0xKSB7XG5cbiAgICAgICAgICAgIC8vIFZlcnRleCwgTm9ybWFsXG5cbiAgICAgICAgICAgIGlmIChzcGxpdFsxXS5pbmRleE9mKCcvLycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGkxID0gc3BsaXRbMV0uc3BsaXQoJy8vJyk7XG4gICAgICAgICAgICAgICAgaTIgPSBzcGxpdFsyXS5zcGxpdCgnLy8nKTtcbiAgICAgICAgICAgICAgICBpMyA9IHNwbGl0WzNdLnNwbGl0KCcvLycpO1xuXG4gICAgICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzBdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTJbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1swXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMlsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzFdKSAtIDFcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBxdWFkXG5cbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRbNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaTQgPSBzcGxpdFs0XS5zcGxpdCgnLy8nKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMVswXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1swXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpNFswXSkgLSAxXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBmYWNlTm9ybWFscy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTRbMl0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZlcnRleCwgVGV4Q29vcmQsIE5vcm1hbFxuXG4gICAgICAgICAgICBlbHNlIGlmIChzcGxpdFsxXS5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaTEgPSBzcGxpdFsxXS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGkyID0gc3BsaXRbMl0uc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBpMyA9IHNwbGl0WzNdLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgICAgICBmYWNlVmVydGljZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMlswXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzBdKSAtIDFcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBmYWNlVGV4Q29vcmRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTJbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1sxXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMlsyXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzJdKSAtIDFcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBRdWFkXG5cbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRbNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaTQgPSBzcGxpdFs0XS5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTRbMF0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZVRleENvb3Jkcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTRbMV0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGk0WzJdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWZXJ0ZXhcblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZmFjZVRleENvb3Jkcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZhY2VOb3JtYWxzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUXVhZFxuXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0WzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbNF0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZVRleENvb3Jkcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbNF0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzNdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzRdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlVmVydGljZXMoXG4gICAgICAgIHZlcnRpY2VzLFxuICAgICAgICBub3JtYWxzLFxuICAgICAgICB0ZXhDb29yZHMsXG4gICAgICAgIGZhY2VWZXJ0aWNlcyxcbiAgICAgICAgZmFjZU5vcm1hbHMsXG4gICAgICAgIGZhY2VUZXhDb29yZHNcbiAgICApO1xuXG5cbiAgICBjYWNoZWQudmVydGljZXMgPSBmbGF0dGVuKGNhY2hlZC52ZXJ0aWNlcyk7XG4gICAgY2FjaGVkLm5vcm1hbHMgPSBmbGF0dGVuKGNhY2hlZC5ub3JtYWxzKTtcbiAgICBjYWNoZWQudGV4Q29vcmRzID0gZmxhdHRlbihjYWNoZWQudGV4Q29vcmRzKTtcbiAgICBjYWNoZWQuaW5kaWNlcyA9IGZsYXR0ZW4oY2FjaGVkLmluZGljZXMpO1xuXG4gICAgaWYgKG9wdGlvbnMubm9ybWFsaXplKSB7XG4gICAgICAgIGNhY2hlZC52ZXJ0aWNlcyA9IEdlb21ldHJ5SGVscGVyLm5vcm1hbGl6ZVZlcnRpY2VzKFxuICAgICAgICAgICAgY2FjaGVkLnZlcnRpY2VzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY29tcHV0ZU5vcm1hbHMpIHtcbiAgICAgICAgY2FjaGVkLm5vcm1hbHMgPSBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyhcbiAgICAgICAgICAgIGNhY2hlZC52ZXJ0aWNlcyxcbiAgICAgICAgICAgIGNhY2hlZC5pbmRpY2VzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IGNhY2hlZC52ZXJ0aWNlcyxcbiAgICAgICAgbm9ybWFsczogY2FjaGVkLm5vcm1hbHMsXG4gICAgICAgIHRleHR1cmVDb29yZHM6IGNhY2hlZC50ZXhDb29yZHMsXG4gICAgICAgIGluZGljZXM6IGNhY2hlZC5pbmRpY2VzXG4gICAgfTtcbn1cblxuLypcbiAqIFJlcGxhY2VzIGFsbCBkb3VibGUgc3BhY2VzIHdpdGggc2luZ2xlIHNwYWNlcyBhbmQgcmVtb3Zlc1xuICogYWxsIHRyYWlsaW5nIHNwYWNlcyBmcm9tIGxpbmVzIG9mIGEgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBtZXRob2Qgc2FuaXRpemVcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgU3RyaW5nIHRvIGJlIHNhbml0aXplZC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHNhbml0aXplZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8gKyg/PSApL2csJycpLnJlcGxhY2UoL1xccyskL2csICcnKTtcbn1cblxuLypcbiAqIFRha2VzIGEgZ2l2ZW4gcG9vbCBvZiBhdHRyaWJ1dGVzIGFuZCBmYWNlIGRlZmluaXRpb25zXG4gKiBhbmQgcmVtb3ZlcyBhbGwgZHVwbGljYXRlIHZlcnRpY2VzLlxuICpcbiAqIEBtZXRob2QgY2FjaGVWZXJ0aWNlc1xuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2IFBvb2wgb2YgdmVydGljZXMgdXNlZCBpbiBmYWNlIGRlY2xhcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IG4gUG9vbCBvZiBub3JtYWxzIHVzZWQgaW4gZmFjZSBkZWNsYXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSB0IFBvb2wgb2YgdGV4dHVyZUNvb3JkcyB1c2VkIGluIGZhY2UgZGVjbGFyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheX0gZnYgVmVydGV4IHBvc2l0aW9ucyBhdCBlYWNoIGZhY2UgaW4gdGhlIE9CSi5cbiAqIEBwYXJhbSB7QXJyYXl9IGZuIE5vcm1hbHMgYXQgZWFjaCBmYWNlIGluIHRoZSBPQkouXG4gKiBAcGFyYW0ge0FycmF5fSBmdCBUZXh0dXJlIGNvb3JkaW5hdGVzIGF0IGVhY2ggZmFjZSBpbiB0aGUgT0JKLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZlcnRpY2VzLCB0ZXh0dXJlQ29vcmRpbmF0ZXMgYW5kXG4gKiBub3JtYWxzIG9mIHRoZSBPQkouXG4gKi9cbmZ1bmN0aW9uIGNhY2hlVmVydGljZXModiwgbiwgdCwgZnYsIGZuLCBmdCkge1xuICAgIHZhciBvdXROb3JtYWxzID0gW107XG4gICAgdmFyIG91dFBvcyA9IFtdO1xuICAgIHZhciBvdXRUZXhDb29yZCA9IFtdO1xuICAgIHZhciBvdXRJbmRpY2VzID0gW107XG5cbiAgICB2YXIgdmVydGV4Q2FjaGUgPSB7fTtcblxuICAgIHZhciBwb3NpdGlvbkluZGV4O1xuICAgIHZhciBub3JtYWxJbmRleDtcbiAgICB2YXIgdGV4Q29vcmRJbmRleDtcblxuICAgIHZhciBjdXJyZW50SW5kZXggPSAwO1xuICAgIHZhciBmdkxlbmd0aCA9IGZ2Lmxlbmd0aDtcbiAgICB2YXIgZm5MZW5ndGggPSBmbi5sZW5ndGg7XG4gICAgdmFyIGZ0TGVuZ3RoID0gZnQubGVuZ3RoO1xuICAgIHZhciBmYWNlTGVuZ3RoO1xuICAgIHZhciBpbmRleDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnZMZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRJbmRpY2VzW2ldID0gW107XG4gICAgICAgIGZhY2VMZW5ndGggPSBmdltpXS5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmYWNlTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChmdExlbmd0aCkgdGV4Q29vcmRJbmRleCA9IGZ0W2ldW2pdO1xuICAgICAgICAgICAgaWYgKGZuTGVuZ3RoKSBub3JtYWxJbmRleCAgID0gZm5baV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW5kZXggPSBmdltpXVtqXTtcblxuICAgICAgICAgICAgaW5kZXggPSB2ZXJ0ZXhDYWNoZVtwb3NpdGlvbkluZGV4ICsgJywnICsgbm9ybWFsSW5kZXggKyAnLCcgKyB0ZXhDb29yZEluZGV4XTtcblxuICAgICAgICAgICAgaWYoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gY3VycmVudEluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFBvcy5wdXNoKHZbcG9zaXRpb25JbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChmbkxlbmd0aCkgb3V0Tm9ybWFscy5wdXNoKG5bbm9ybWFsSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoZnRMZW5ndGgpIG91dFRleENvb3JkLnB1c2godFt0ZXhDb29yZEluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhDYWNoZVtwb3NpdGlvbkluZGV4ICsgJywnICsgbm9ybWFsSW5kZXggKyAnLCcgKyB0ZXhDb29yZEluZGV4XSA9IGluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXRJbmRpY2VzW2ldLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IG91dFBvcyxcbiAgICAgICAgbm9ybWFsczogb3V0Tm9ybWFscyxcbiAgICAgICAgdGV4Q29vcmRzOiBvdXRUZXhDb29yZCxcbiAgICAgICAgaW5kaWNlczogb3V0SW5kaWNlc1xuICAgIH07XG59XG5cbi8qXG4gKiBGbGF0dGVucyBhbiBhcnJheSBvZiBhcnJheXMuIE5vdCByZWN1cnNpdmUuIEFzc3VtZXNcbiAqIGFsbCBjaGlsZHJlbiBhcmUgYXJyYXlzLlxuICpcbiAqIEBtZXRob2QgZmxhdHRlblxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgSW5wdXQgYXJyYXkgdG8gYmUgZmxhdHRlbmVkLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBGbGF0dGVuZWQgdmVyc2lvbiBvZiBpbnB1dCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoLmFwcGx5KG91dCwgYXJyW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9CSkxvYWRlcjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJveDogcmVxdWlyZSgnLi9wcmltaXRpdmVzL0JveCcpLFxuICAgIENpcmNsZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL0NpcmNsZScpLFxuICAgIEN5bGluZGVyOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvQ3lsaW5kZXInKSxcbiAgICBHZW9kZXNpY1NwaGVyZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL0dlb2Rlc2ljU3BoZXJlJyksXG4gICAgSWNvc2FoZWRyb246IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9JY29zYWhlZHJvbicpLFxuICAgIFBhcmFtZXRyaWNDb25lOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvUGFyYW1ldHJpY0NvbmUnKSxcbiAgICBQbGFuZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL1BsYW5lJyksXG4gICAgU3BoZXJlOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvU3BoZXJlJyksXG4gICAgVGV0cmFoZWRyb246IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9UZXRyYWhlZHJvbicpLFxuICAgIFRvcnVzOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvVG9ydXMnKSxcbiAgICBUcmlhbmdsZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL1RyaWFuZ2xlJyksXG4gICAgR2VvbWV0cnlIZWxwZXI6IHJlcXVpcmUoJy4vR2VvbWV0cnlIZWxwZXInKSxcbiAgICBEeW5hbWljR2VvbWV0cnk6IHJlcXVpcmUoJy4vRHluYW1pY0dlb21ldHJ5JyksXG4gICAgR2VvbWV0cnk6IHJlcXVpcmUoJy4vR2VvbWV0cnknKSxcbiAgICBPQkpMb2FkZXI6IHJlcXVpcmUoJy4vT0JKTG9hZGVyJyksXG59OyIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG5cbmZ1bmN0aW9uIHBpY2tPY3RhbnQoaSkge1xuICAgIHJldHVybiBbKGkgJiAxKSAqIDIgLSAxLCAoaSAmIDIpIC0gMSwgKGkgJiA0KSAvIDIgLSAxXTtcbn1cblxudmFyIGJveERhdGEgPSBbXG4gICAgWzAsIDQsIDIsIDYsIC0xLCAwLCAwXSwgXG4gICAgWzEsIDMsIDUsIDcsICsxLCAwLCAwXSxcbiAgICBbMCwgMSwgNCwgNSwgMCwgLTEsIDBdLFxuICAgIFsyLCA2LCAzLCA3LCAwLCArMSwgMF0sXG4gICAgWzAsIDIsIDEsIDMsIDAsIDAsIC0xXSxcbiAgICBbNCwgNSwgNiwgNywgMCwgMCwgKzFdXG5dO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBCb3hHZW9tZXRyeVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBCb3hHZW9tZXRyeShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgdmVydGljZXMgICAgICA9IFtdO1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gW107XG4gICAgdmFyIG5vcm1hbHMgICAgICAgPSBbXTtcbiAgICB2YXIgaW5kaWNlcyAgICAgICA9IFtdO1xuXG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIGQ7XG4gICAgdmFyIHY7XG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYm94RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhID0gYm94RGF0YVtpXSwgdiA9IGkgKiA0O1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBkID0gZGF0YVtqXTtcbiAgICAgICAgICAgIHZhciBvY3RhbnQgPSBwaWNrT2N0YW50KGQpO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChvY3RhbnRbMF0sIG9jdGFudFsxXSwgb2N0YW50WzJdKTtcbiAgICAgICAgICAgIHRleHR1cmVDb29yZHMucHVzaChqICYgMSwgKGogJiAyKSAvIDIpO1xuICAgICAgICAgICAgbm9ybWFscy5wdXNoKGRhdGFbNF0sIGRhdGFbNV0sIGRhdGFbNl0pO1xuICAgICAgICB9XG4gICAgICAgIGluZGljZXMucHVzaCh2LCB2ICsgMSwgdiArIDIpO1xuICAgICAgICBpbmRpY2VzLnB1c2godiArIDIsIHYgKyAxLCB2ICsgMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCb3hHZW9tZXRyeTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gQ2lyY2xlIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyAgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZXRhaWwgICA9IG9wdGlvbnMuZGV0YWlsIHx8IDMwO1xuICAgIHZhciBidWZmZXJzICA9IGdldENpcmNsZUJ1ZmZlcnMoZGV0YWlsLCB0cnVlKTtcblxuICAgIGlmIChvcHRpb25zLmJhY2tmYWNlICE9PSBmYWxzZSkge1xuICAgICAgICBHZW9tZXRyeUhlbHBlci5hZGRCYWNrZmFjZVRyaWFuZ2xlcyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gZ2V0Q2lyY2xlVGV4Q29vcmRzKGJ1ZmZlcnMudmVydGljZXMpO1xuICAgIHZhciBub3JtYWxzID0gR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHMoYnVmZmVycy52ZXJ0aWNlcywgYnVmZmVycy5pbmRpY2VzKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3BvcycsIGRhdGE6IGJ1ZmZlcnMudmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogYnVmZmVycy5pbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDaXJjbGVUZXhDb29yZHMgKHZlcnRpY2VzKSB7XG4gICAgdmFyIHRleHR1cmVDb29yZHMgPSBbXTtcbiAgICB2YXIgbkZhY2VzID0gdmVydGljZXMubGVuZ3RoIC8gMztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkZhY2VzOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1tpICogM10sXG4gICAgICAgICAgICB5ID0gdmVydGljZXNbaSAqIDMgKyAxXTtcblxuICAgICAgICB0ZXh0dXJlQ29vcmRzLnB1c2goMC41ICsgeCAqIDAuNSwgMC41ICsgLXkgKiAwLjUpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlQ29vcmRzO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgYWxsIHZlcnRleCBwb3NpdGlvbnMsIHRleHR1cmVcbiAqIGNvb3JkaW5hdGVzIGFuZCBub3JtYWxzIG9mIHRoZSBjaXJjbGUgcHJpbWl0aXZlLlxuICpcbiAqIEBtZXRob2QgZ2V0QnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXRhaWwgQW1vdW50IG9mIGRldGFpbCB0aGF0IGRldGVybWluZXMgaG93IG1hbnlcbiAqIHZlcnRpY2VzIGFyZSBjcmVhdGVkIGFuZCB3aGVyZSB0aGV5IGFyZSBwbGFjZWRcbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBnZXRDaXJjbGVCdWZmZXJzKGRldGFpbCkge1xuICAgIHZhciB2ZXJ0aWNlcyA9IFswLCAwLCAwXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgdGhldGE7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRldGFpbCArIDE7IGkrKykge1xuICAgICAgICB0aGV0YSA9IGkgLyBkZXRhaWwgKiBNYXRoLlBJICogMjtcblxuICAgICAgICB4ID0gTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5ID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgIHZlcnRpY2VzLnB1c2goeCwgeSwgMCk7XG5cbiAgICAgICAgaWYgKGkgPiAwKSBpbmRpY2VzLnB1c2goMCwgY291bnRlciwgKytjb3VudGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgICAgIGluZGljZXM6IGluZGljZXNcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY3JlYXRlcyBhIG5ldyBnZW9tZXRyeSBpbnN0YW5jZSBhbmQgc2V0c1xuICogaXRzIHZlcnRleCBwb3NpdGlvbnMsIHRleHR1cmUgY29vcmRpbmF0ZXMsIG5vcm1hbHMsXG4gKiBhbmQgaW5kaWNlcyB0byBiYXNlZCBvbiB0aGUgcHJpbWl0aXZlLlxuICpcbiAqIEBjbGFzcyBDeWxpbmRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVkXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gQ3lsaW5kZXIgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHJhZGl1cyAgID0gb3B0aW9ucy5yYWRpdXMgfHwgMTtcbiAgICB2YXIgZGV0YWlsICAgPSBvcHRpb25zLmRldGFpbCB8fCAxNTtcbiAgICB2YXIgYnVmZmVycztcblxuICAgIGJ1ZmZlcnMgPSBHZW9tZXRyeUhlbHBlci5nZW5lcmF0ZVBhcmFtZXRyaWMoXG4gICAgICAgIGRldGFpbCxcbiAgICAgICAgZGV0YWlsLFxuICAgICAgICBDeWxpbmRlci5nZW5lcmF0b3IuYmluZChudWxsLCByYWRpdXMpXG4gICAgKTtcblxuICAgIGlmIChvcHRpb25zLmJhY2tmYWNlICE9PSBmYWxzZSkge1xuICAgICAgICBHZW9tZXRyeUhlbHBlci5hZGRCYWNrZmFjZVRyaWFuZ2xlcyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3BvcycsIGRhdGE6IGJ1ZmZlcnMudmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Q29vcmQnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5nZXRTcGhlcm9pZFVWKGJ1ZmZlcnMudmVydGljZXMpLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbHMnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogYnVmZmVycy5pbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgaW4gaXRlcmF0aXZlIGNvbnN0cnVjdGlvbiBvZiBwYXJhbWV0cmljIHByaW1pdGl2ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdlbmVyYXRvclxuICogQHBhcmFtIHtOdW1iZXJ9IHIgQ3lsaW5kZXIgcmFkaXVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHUgTG9uZ2l0dWRhbCBwcm9ncmVzcyBmcm9tIDAgdG8gUEkuXG4gKiBAcGFyYW0ge051bWJlcn0gdiBMYXRpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSB4LCB5IGFuZCB6IGNvb3JkaW5hdGUgb2YgZ2VvbWV0cnkuXG4gKi9cbkN5bGluZGVyLmdlbmVyYXRvciA9IGZ1bmN0aW9uIGdlbmVyYXRvcihyLCB1LCB2LCBwb3MpIHtcbiAgICBwb3NbMV0gPSByICogTWF0aC5zaW4odik7XG4gICAgcG9zWzBdID0gciAqIE1hdGguY29zKHYpO1xuICAgIHBvc1syXSA9IHIgKiAoLTEgKyB1IC8gTWF0aC5QSSAqIDIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDeWxpbmRlcjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBHZW9kZXNpY1NwaGVyZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBHZW9kZXNpY1NwaGVyZSAob3B0aW9ucykge1xuICAgIHZhciB0ID0gKDEgKyBNYXRoLnNxcnQoNSkpICogMC41O1xuXG4gICAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAgICAtIDEsICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcbiAgICAgICAgIDAsIC0gMSwgLXQsICAgIDAsICAxLCAtdCwgICAgMCwgLSAxLCAgIHQsICAgIDAsICAxLCAgIHQsXG4gICAgICAgICB0LCAgMCwgICAxLCAgICB0LCAgMCwgLTEsICAgLSB0LCAgMCwgICAxLCAgIC0gdCwgIDAsIC0xXG4gICAgXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgICAgMCwgIDUsIDExLCAgICAwLCAgMSwgIDUsICAgIDAsICA3LCAgMSwgICAgMCwgMTAsICA3LCAgICAwLCAxMSwgMTAsXG4gICAgICAgIDEsICA5LCAgNSwgICAgNSwgIDQsIDExLCAgICAxMSwgMiwgMTAsICAgMTAsICA2LCAgNywgICAgNywgIDgsICAxLFxuICAgICAgICAzLCAgNCwgIDksICAgIDMsICAyLCAgNCwgICAgMywgIDYsICAyLCAgICAzLCAgOCwgIDYsICAgIDMsICA5LCAgOCxcbiAgICAgICAgNCwgIDUsICA5LCAgICAyLCAxMSwgIDQsICAgIDYsIDEwLCAgMiwgICAgOCwgIDcsICA2LCAgICA5LCAgMSwgIDhcbiAgICBdO1xuXG4gICAgdmVydGljZXMgPSBHZW9tZXRyeUhlbHBlci5ub3JtYWxpemVBbGwodmVydGljZXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbCAgPSBvcHRpb25zLmRldGFpbCB8fCAzO1xuXG4gICAgd2hpbGUoLS1kZXRhaWwpIEdlb21ldHJ5SGVscGVyLnN1YmRpdmlkZVNwaGVyb2lkKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICBHZW9tZXRyeUhlbHBlci5nZXRVbmlxdWVGYWNlcyh2ZXJ0aWNlcywgaW5kaWNlcyk7XG5cbiAgICB2YXIgbm9ybWFscyAgICAgICA9IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICB2YXIgdGV4dHVyZUNvb3JkcyA9IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYodmVydGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHZW9kZXNpY1NwaGVyZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBJY29zYWhlZHJvblxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBJY29zYWhlZHJvbigpIHtcbiAgICB2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAgICAtIDEsICAgdCwgIDAsICAgIDEsICB0LCAgMCwgICAtIDEsIC0gdCwgIDAsICAgIDEsIC0gdCwgIDAsXG4gICAgICAgICAgMCwgLSAxLCAtdCwgICAgMCwgIDEsIC10LCAgICAgMCwgLSAxLCAgdCwgICAgMCwgICAxLCAgdCxcbiAgICAgICAgICB0LCAgIDAsICAxLCAgICB0LCAgMCwgLTEsICAgLSB0LCAgIDAsICAxLCAgLSB0LCAgIDAsIC0xXG4gICAgXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgICAgMCwgIDUsIDExLCAgICAwLCAgMSwgIDUsICAgIDAsICA3LCAgMSwgICAgMCwgMTAsICA3LCAgICAwLCAxMSwgMTAsXG4gICAgICAgIDEsICA5LCAgNSwgICAgNSwgIDQsIDExLCAgICAxMSwgMiwgMTAsICAgMTAsICA2LCAgNywgICAgNywgIDgsICAxLFxuICAgICAgICAzLCAgNCwgIDksICAgIDMsICAyLCAgNCwgICAgMywgIDYsICAyLCAgICAzLCAgOCwgIDYsICAgIDMsICA5LCAgOCxcbiAgICAgICAgNCwgIDUsICA5LCAgICAyLCAxMSwgIDQsICAgIDYsIDEwLCAgMiwgICAgOCwgIDcsICA2LCAgICA5LCAgMSwgIDhcbiAgICBdO1xuXG4gICAgR2VvbWV0cnlIZWxwZXIuZ2V0VW5pcXVlRmFjZXModmVydGljZXMsIGluZGljZXMpO1xuXG4gICAgdmFyIG5vcm1hbHMgICAgICAgPSBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyh2ZXJ0aWNlcywgaW5kaWNlcyk7XG4gICAgdmFyIHRleHR1cmVDb29yZHMgPSBHZW9tZXRyeUhlbHBlci5nZXRTcGhlcm9pZFVWKHZlcnRpY2VzKTtcblxuICAgIHZlcnRpY2VzICAgICAgPSBHZW9tZXRyeUhlbHBlci5ub3JtYWxpemVBbGwodmVydGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJY29zYWhlZHJvbjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBQYXJhbWV0cmljQ29uZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBQYXJhbWV0cmljQ29uZSAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGV0YWlsICAgPSBvcHRpb25zLmRldGFpbCB8fCAxNTtcbiAgICB2YXIgcmFkaXVzICAgPSBvcHRpb25zLnJhZGl1cyB8fCAxIC8gTWF0aC5QSTtcblxuICAgIHZhciBidWZmZXJzID0gR2VvbWV0cnlIZWxwZXIuZ2VuZXJhdGVQYXJhbWV0cmljKFxuICAgICAgICBkZXRhaWwsXG4gICAgICAgIGRldGFpbCxcbiAgICAgICAgUGFyYW1ldHJpY0NvbmUuZ2VuZXJhdG9yLmJpbmQobnVsbCwgcmFkaXVzKVxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy5iYWNrZmFjZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgR2VvbWV0cnlIZWxwZXIuYWRkQmFja2ZhY2VUcmlhbmdsZXMoYnVmZmVycy52ZXJ0aWNlcywgYnVmZmVycy5pbmRpY2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnYV9wb3MnLCBkYXRhOiBidWZmZXJzLnZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3RleENvb3JkJywgZGF0YTogR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWRVVihidWZmZXJzLnZlcnRpY2VzKSwgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9ub3JtYWxzJywgZGF0YTogR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHMoYnVmZmVycy52ZXJ0aWNlcywgYnVmZmVycy5pbmRpY2VzKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGJ1ZmZlcnMuaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBmdW5jdGlvbiB1c2VkIGluIGl0ZXJhdGl2ZSBjb25zdHJ1Y3Rpb24gb2YgcGFyYW1ldHJpYyBwcmltaXRpdmUuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSByIENvbmUgUmFkaXVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHUgTG9uZ2l0dWRhbCBwcm9ncmVzcyBmcm9tIDAgdG8gUEkuXG4gKiBAcGFyYW0ge051bWJlcn0gdiBMYXRpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHJldHVybiB7QXJyYXl9IHgsIHkgYW5kIHogY29vcmRpbmF0ZSBvZiBnZW9tZXRyeS5cbiAqL1xuXG5QYXJhbWV0cmljQ29uZS5nZW5lcmF0b3IgPSBmdW5jdGlvbiBnZW5lcmF0b3IociwgdSwgdiwgcG9zKSB7XG4gICAgcG9zWzBdID0gLXIgKiB1ICogTWF0aC5jb3Modik7XG4gICAgcG9zWzFdID0gciAqIHUgKiBNYXRoLnNpbih2KTtcbiAgICBwb3NbMl0gPSAtdSAvIChNYXRoLlBJIC8gMikgKyAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbWV0cmljQ29uZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBQbGFuZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBQbGFuZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbFggPSBvcHRpb25zLmRldGFpbFggfHwgb3B0aW9ucy5kZXRhaWwgfHwgMTtcbiAgICB2YXIgZGV0YWlsWSA9IG9wdGlvbnMuZGV0YWlsWSB8fCBvcHRpb25zLmRldGFpbCB8fCAxO1xuXG4gICAgdmFyIHZlcnRpY2VzICAgICAgPSBbXTtcbiAgICB2YXIgdGV4dHVyZUNvb3JkcyA9IFtdO1xuICAgIHZhciBub3JtYWxzICAgICAgID0gW107XG4gICAgdmFyIGluZGljZXMgICAgICAgPSBbXTtcblxuICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IGRldGFpbFk7IHkrKykge1xuICAgICAgICB2YXIgdCA9IHkgLyBkZXRhaWxZO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBkZXRhaWxYOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBzID0geCAvIGRldGFpbFg7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKDIuICogKHMgLSAuNSksIDIgKiAodCAtIC41KSwgMCk7XG4gICAgICAgICAgICB0ZXh0dXJlQ29vcmRzLnB1c2gocywgMSAtIHQpO1xuICAgICAgICAgICAgaWYgKHggPCBkZXRhaWxYICYmIHkgPCBkZXRhaWxZKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB4ICsgeSAqIChkZXRhaWxYICsgMSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGksIGkgKyAxLCBpICsgZGV0YWlsWCArIDEpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpICsgZGV0YWlsWCArIDEsIGkgKyAxLCBpICsgZGV0YWlsWCArIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYmFja2ZhY2UgIT09IGZhbHNlKSB7XG4gICAgICAgIEdlb21ldHJ5SGVscGVyLmFkZEJhY2tmYWNlVHJpYW5nbGVzKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGR1cGxpY2F0ZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFzIHdlbGxcblxuICAgICAgICB2YXIgbGVuID0gdGV4dHVyZUNvb3Jkcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHRleHR1cmVDb29yZHMucHVzaCh0ZXh0dXJlQ29vcmRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFscyA9IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLCBpbmRpY2VzKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3BvcycsIGRhdGE6IHZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3RleENvb3JkJywgZGF0YTogdGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9ub3JtYWxzJywgZGF0YTogbm9ybWFscyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGluZGljZXMsIHNpemU6IDEgfVxuICAgICAgICBdXG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIFBhcmFtZXRyaWNTcGhlcmVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gUGFyYW1ldHJpY1NwaGVyZSAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZXRhaWwgPSBvcHRpb25zLmRldGFpbCB8fCAxMDtcbiAgICB2YXIgZGV0YWlsWCA9IG9wdGlvbnMuZGV0YWlsWCB8fCBkZXRhaWw7ICAgIFxuICAgIHZhciBkZXRhaWxZID0gb3B0aW9ucy5kZXRhaWxZIHx8IGRldGFpbDtcblxuICAgIHZhciBidWZmZXJzID0gR2VvbWV0cnlIZWxwZXIuZ2VuZXJhdGVQYXJhbWV0cmljKFxuICAgICAgICBkZXRhaWxYLFxuICAgICAgICBkZXRhaWxZLFxuICAgICAgICBQYXJhbWV0cmljU3BoZXJlLmdlbmVyYXRvcixcbiAgICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBHZW9tZXRyeUhlbHBlci5nZXRVbmlxdWVGYWNlcyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zJywgZGF0YTogYnVmZmVycy52ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV90ZXhDb29yZCcsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYoYnVmZmVycy52ZXJ0aWNlcyksIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffbm9ybWFscycsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkTm9ybWFscyhidWZmZXJzLnZlcnRpY2VzKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGJ1ZmZlcnMuaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIGluIGl0ZXJhdGl2ZSBjb25zdHJ1Y3Rpb24gb2YgcGFyYW1ldHJpYyBwcmltaXRpdmUuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB1IExvbmdpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHBhcmFtIHtOdW1iZXJ9IHYgTGF0aXR1ZGFsIHByb2dyZXNzIGZyb20gMCB0byBQSS5cbiAqIEByZXR1cm4ge0FycmF5fSB4LCB5IGFuZCB6IGNvb3JkaW5hdGVzIG9mIGdlb21ldHJ5XG4gKi9cblBhcmFtZXRyaWNTcGhlcmUuZ2VuZXJhdG9yID0gZnVuY3Rpb24gZ2VuZXJhdG9yKHUsIHYsIHBvcykge1xuICAgIHZhciB4ID0gTWF0aC5zaW4odSkgKiBNYXRoLmNvcyh2KTtcbiAgICB2YXIgeSA9IE1hdGguY29zKHUpO1xuICAgIHZhciB6ID0gLU1hdGguc2luKHUpICogTWF0aC5zaW4odik7XG5cbiAgICBwb3NbMF0gPSB4O1xuICAgIHBvc1sxXSA9IHk7XG4gICAgcG9zWzJdID0gejtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyYW1ldHJpY1NwaGVyZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIGN1c3RvbSBidWZmZXJzIGFuZCBwYXNzZXMgdGhlbSB0b1xuICogYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAqXG4gKiBAY2xhc3MgVGV0cmFoZWRyb25cbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gVGV0cmFoZWRyb24ob3B0aW9ucykge1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gW107XG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICB2YXIgZGV0YWlsO1xuICAgIHZhciBpO1xuICAgIHZhciB0ID0gTWF0aC5zcXJ0KDMpO1xuICAgIFxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgLy8gQmFjayBcbiAgICAgICAgIDEsIC0xLCAtMSAvIHQsXG4gICAgICAgIC0xLCAtMSwgLTEgLyB0LFxuICAgICAgICAgMCwgIDEsICAwLFxuICAgICAgICBcbiAgICAgICAgLy8gUmlnaHRcbiAgICAgICAgIDAsICAxLCAgMCxcbiAgICAgICAgIDAsIC0xLCB0IC0gMSAvIHQsXG4gICAgICAgICAxLCAtMSwgLTEgLyB0LFxuXG4gICAgICAgIC8vIExlZnRcbiAgICAgICAgIDAsICAxLCAgMCxcbiAgICAgICAgLTEsIC0xLCAtMSAvIHQsXG4gICAgICAgICAwLCAtMSwgIHQgLSAxIC8gdCxcblxuICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgIDAsIC0xLCAgdCAtIDEgLyB0LFxuICAgICAgICAtMSwgLTEsIC0xIC8gdCxcbiAgICAgICAgIDEsIC0xLCAtMSAvIHQsXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAwLCAxLCAyLFxuICAgICAgICAzLCA0LCA1LFxuICAgICAgICA2LCA3LCA4LFxuICAgICAgICA5LCAxMCwgMTEsXG4gICAgXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgdGV4dHVyZUNvb3Jkcy5wdXNoKFxuICAgICAgICAgICAgMC4wLCAwLjAsXG4gICAgICAgICAgICAwLjUsIDEuMCxcbiAgICAgICAgICAgIDEuMCwgMC4wXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyAgICAgICA9IG9wdGlvbnMgfHwge307XG5cbiAgICB3aGlsZSgtLWRldGFpbCkgR2VvbWV0cnlIZWxwZXIuc3ViZGl2aWRlKGluZGljZXMsIHZlcnRpY2VzLCB0ZXh0dXJlQ29vcmRzKTtcbiAgICBub3JtYWxzICAgICAgID0gR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHModmVydGljZXMsIGluZGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXRyYWhlZHJvbjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBUb3J1c1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5cbmZ1bmN0aW9uIFRvcnVzKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyAgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZXRhaWwgICA9IG9wdGlvbnMuZGV0YWlsIHx8IDMwO1xuICAgIHZhciBob2xlUmFkaXVzID0gb3B0aW9ucy5ob2xlUmFkaXVzIHx8IDAuODA7XG4gICAgdmFyIHR1YmVSYWRpdXMgPSBvcHRpb25zLnR1YmVSYWRpdXMgfHwgMC4yMDtcblxuICAgIHZhciBidWZmZXJzID0gR2VvbWV0cnlIZWxwZXIuZ2VuZXJhdGVQYXJhbWV0cmljKFxuICAgICAgICBkZXRhaWwsXG4gICAgICAgIGRldGFpbCxcbiAgICAgICAgVG9ydXMuZ2VuZXJhdG9yLmJpbmQobnVsbCwgaG9sZVJhZGl1cywgdHViZVJhZGl1cylcbiAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zJywgZGF0YTogYnVmZmVycy52ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV90ZXhDb29yZCcsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYoYnVmZmVycy52ZXJ0aWNlcyksIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffbm9ybWFscycsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKGJ1ZmZlcnMudmVydGljZXMsIGJ1ZmZlcnMuaW5kaWNlcykgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2luZGljZXMnLCBkYXRhOiBidWZmZXJzLmluZGljZXMsIHNpemU6IDEgfVxuICAgICAgICBdXG4gICAgfSk7XG59XG5cbi8qKlxuICogZnVuY3Rpb24gdXNlZCBpbiBpdGVyYXRpdmUgY29uc3RydWN0aW9uIG9mIHBhcmFtZXRyaWMgcHJpbWl0aXZlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2VuZXJhdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gYyBSYWRpdXMgb2YgaW5uZXIgaG9sZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFJhZGl1cyBvZiB0dWJlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHUgTG9uZ2l0dWRhbCBwcm9ncmVzcyBmcm9tIDAgdG8gUEkuXG4gKiBAcGFyYW0ge051bWJlcn0gdiBMYXRpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHJldHVybiB7QXJyYXl9IHgsIHkgYW5kIHogY29vcmRpbmF0ZSBvZiB0aGUgdmVydGV4LlxuICovXG5Ub3J1cy5nZW5lcmF0b3IgPSBmdW5jdGlvbiBnZW5lcmF0b3IoYywgYSwgdSwgdiwgcG9zKSB7XG4gICAgcG9zWzBdID0gKGMgKyBhICogTWF0aC5jb3MoMiAqIHYpKSAqIE1hdGguc2luKDIgKiB1KTtcbiAgICBwb3NbMV0gPSAtKGMgKyBhICogTWF0aC5jb3MoMiAqIHYpKSAqIE1hdGguY29zKDIgKiB1KTtcbiAgICBwb3NbMl0gPSBhICogTWF0aC5zaW4oMiAqIHYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRvcnVzO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIFRyaWFuZ2xlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIFRyaWFuZ2xlIChvcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGV0YWlsICAgPSBvcHRpb25zLmRldGFpbCB8fCAxO1xuICAgIHZhciBub3JtYWxzICA9IFtdO1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gW1xuICAgICAgICAwLjAsIDAuMCxcbiAgICAgICAgMC41LCAxLjAsXG4gICAgICAgIDEuMCwgMC4wXG4gICAgXTtcbiAgICB2YXIgaW5kaWNlcyAgPSBbXG4gICAgICAgIDAsIDEsIDJcbiAgICBdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgLTEsIC0xLCAwLFxuICAgICAgICAgMCwgIDEsIDAsXG4gICAgICAgICAxLCAtMSwgMFxuICAgIF07XG5cbiAgICB3aGlsZSgtLWRldGFpbCkgR2VvbWV0cnlIZWxwZXIuc3ViZGl2aWRlKGluZGljZXMsIHZlcnRpY2VzLCB0ZXh0dXJlQ29vcmRzKTtcblxuICAgIGlmIChvcHRpb25zLmJhY2tmYWNlICE9PSBmYWxzZSkge1xuICAgICAgICBHZW9tZXRyeUhlbHBlci5hZGRCYWNrZmFjZVRyaWFuZ2xlcyh2ZXJ0aWNlcywgaW5kaWNlcyk7XG4gICAgfVxuXG4gICAgbm9ybWFscyA9IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLCBpbmRpY2VzKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3BvcycsIGRhdGE6IHZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3RleENvb3JkJywgZGF0YTogdGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9ub3JtYWxzJywgZGF0YTogbm9ybWFscyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGluZGljZXMsIHNpemU6IDEgfVxuICAgICAgICBdXG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbiBcbid1c2Ugc3RyaWN0JztcblxudmFyIFRleHR1cmVSZWdpc3RyeSA9IHJlcXVpcmUoJy4vVGV4dHVyZVJlZ2lzdHJ5Jyk7XG5cbnZhciBleHByZXNzaW9ucyA9IHt9O1xuXG52YXIgc25pcHBldHMgPSB7XG5cbiAgICAvKiBBYnMgLSBUaGUgYWJzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHgsIGkuZS4geCB3aGVuIHggaXMgcG9zaXRpdmUgb3IgemVybyBhbmQgLXggZm9yIG5lZ2F0aXZlIHguIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiBJbiBjYXNlIG9mIGEgZmxvYXQgdmVjdG9yIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS5cbiAgICAgKi9cblxuICAgIGFiczoge2dsc2w6ICdhYnMoJTEpOycsIG91dHB1dDogeyA0OiA0LCAzOiAzLCAyOiAyLCAxOiAxIH19LFxuICAgIC8qIFNpZ24gLSBUaGUgc2lnbiBmdW5jdGlvbiByZXR1cm5zIDEuMCB3aGVuIHggaXMgcG9zaXRpdmUsIDAuMCB3aGVuIHggaXMgemVybyBhbmQgLTEuMCB3aGVuIHggaXMgbmVnYXRpdmUuIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiBJbiBjYXNlIG9mIGEgZmxvYXQgdmVjdG9yIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIHNpZ246IHtnbHNsOiAnc2lnbiglMSk7Jywgb3V0cHV0OiB7IDQ6IDQsIDM6IDMsIDI6IDIsIDE6IDEgfX0sXG5cbiAgICAvKiBGbG9vciAtIFRoZSBmbG9vciBmdW5jdGlvbiByZXR1cm5zIHRoZSBsYXJnZXN0IGludGVnZXIgbnVtYmVyIHRoYXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB4LiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBmbG9vcjoge2dsc2w6ICdmbG9vciglMSk7Jywgb3V0cHV0OiB7IDQ6IDQsIDM6IDMsIDI6IDIsIDE6IDEgfX0sXG5cbiAgICAvKiBDZWlsaW5nIC0gVGhlIGNlaWxpbmcgZnVuY3Rpb24gcmV0dXJucyB0aGUgc21hbGxlc3QgbnVtYmVyIHRoYXQgaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHguIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiBJbiBjYXNlIG9mIGEgZmxvYXQgdmVjdG9yIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIGNlaWxpbmc6IHtnbHNsOiAnY2VpbCglMSk7Jywgb3V0cHV0OiB7IDQ6IDQsIDM6IDMsIDI6IDIsIDE6IDEgfX0sXG5cbiAgICAvKiBUaGUgbW9kIGV4cHJlc3Npb24gcmV0dXJucyB0aGUgcmVtYWluZWQgb2YgdGhlIGRpdmlzaW9uIG9wZXJhdGlvbiBvZiB0aGUgdHdvIGlucHV0cy4gKi9cblxuICAgIG1vZDoge2dsc2w6ICdtb2QoJTEsICUyKTsnfSxcblxuICAgIC8qIE1pbiAtIFRoZSBtaW4gZnVuY3Rpb24gcmV0dXJucyB0aGUgc21hbGxlciBvZiB0aGUgdHdvIGFyZ3VtZW50cy4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIG1pbjoge2dsc2w6ICdtaW4oJTEsICUyKTsnLCBvdXRwdXQ6IHsgNDogNCwgMzogMywgMjogMiwgMTogMSB9fSxcblxuICAgIC8qIE1heCAtIFRoZSBtYXggZnVuY3Rpb24gcmV0dXJucyB0aGUgbGFyZ2VyIG9mIHRoZSB0d28gYXJndW1lbnRzLiBUaGUgaW5wdXQgcGFyYW1ldGVycyBjYW4gYmUgZmxvYXRpbmcgc2NhbGFycyBvciBmbG9hdCB2ZWN0b3JzLiBJbiBjYXNlIG9mIGZsb2F0IHZlY3RvcnMgdGhlIG9wZXJhdGlvbiBpcyBkb25lIGNvbXBvbmVudC13aXNlLiAqL1xuXG4gICAgbWF4OiB7Z2xzbDogJ21heCglMSwgJTIpOycsIG91dHB1dDogeyA0OiA0LCAzOiAzLCAyOiAyLCAxOiAxIH19LFxuXG4gICAgLyogQ2xhbXAgLSBUaGUgY2xhbXAgZnVuY3Rpb24gcmV0dXJucyB4IGlmIGl0IGlzIGxhcmdlciB0aGFuIG1pblZhbCBhbmQgc21hbGxlciB0aGFuIG1heFZhbC4gSW4gY2FzZSB4IGlzIHNtYWxsZXIgdGhhbiBtaW5WYWwsIG1pblZhbCBpcyByZXR1cm5lZC4gSWYgeCBpcyBsYXJnZXIgdGhhbiBtYXhWYWwsIG1heFZhbCBpcyByZXR1cm5lZC4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIGNsYW1wOiB7Z2xzbDogJ2NsYW1wKCUxLCAlMiwgJTMpOycsIG91dHB1dDogeyAnNCwxLDEnOiA0LCAnMywxLDEnOiAzLCAnMiwxLDEnOiAyLCAnMSwxLDEnOiAxIH19LFxuXG4gICAgLyogTWl4IC0gVGhlIG1peCBmdW5jdGlvbiByZXR1cm5zIHRoZSBsaW5lYXIgYmxlbmQgb2YgeCBhbmQgeSwgaS5lLiB0aGUgcHJvZHVjdCBvZiB4IGFuZCAoMSAtIGEpIHBsdXMgdGhlIHByb2R1Y3Qgb2YgeSBhbmQgYS4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIG1peDoge2dsc2w6ICdtaXgoJTEsICUyLCAlMyk7Jywgb3V0cHV0OiB7ICc0LDQsMSc6IDQsICczLDMsMSc6IDMsICcyLDIsMSc6IDIsICcxLDEsMSc6IDEgfX0sXG5cbiAgICAvKiBTdGVwIC0gVGhlIHN0ZXAgZnVuY3Rpb24gcmV0dXJucyAwLjAgaWYgeCBpcyBzbWFsbGVyIHRoZW4gZWRnZSBhbmQgb3RoZXJ3aXNlIDEuMC4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIHN0ZXA6IHtnbHNsOiAnc3RlcCglMSwgJTIsICUzKTsnLCBvdXRwdXQ6IHsgJzEsMSc6IDEsICcxLDInOiAyLCAnMSwzJzogMywgJzEsNCc6IDQgfX0sXG5cbiAgICAvKiBTbW9vdGhzdGVwIC0gVGhlIHNtb290aHN0ZXAgZnVuY3Rpb24gcmV0dXJucyAwLjAgaWYgeCBpcyBzbWFsbGVyIHRoZW4gZWRnZTAgYW5kIDEuMCBpZiB4IGlzIGxhcmdlciB0aGFuIGVkZ2UxLiBPdGhlcndpc2UgdGhlIHJldHVybiB2YWx1ZSBpcyBpbnRlcnBvbGF0ZWQgYmV0d2VlbiAwLjAgYW5kIDEuMCB1c2luZyBIZXJtaXRlIHBvbHlub21pcmFscy4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIHNtb290aHN0ZXA6IHtnbHNsOiAnc21vb3Roc3RlcCglMSk7Jywgb3V0cHV0OiB7ICcxLDEsMSc6MSwgJzIsMiwyJzoyLCAnMywzLDMnOjMsICc0LDQsNCc6NCB9fSxcblxuXG4gICAgLyogZnJhZ0Nvb3JkIC0gVGhlIGZyYWdDb29yZCBmdW5jdGlvbiByZXR1cm5zIHRoZSBmcmFnbWVudCdzIHBvc2l0aW9uIGluIHNjcmVlbnNwYWNlLiAqL1xuXG4gICAgZnJhZ0Nvb3JkOiB7Z2xzbDogJ2dsX0ZyYWdDb2xvcjsnLCBvdXRwdXQ6IDQgfSxcblxuICAgIC8qIFNpbiAtIFRoZSBzaW4gZnVuY3Rpb24gcmV0dXJucyB0aGUgc2luZSBvZiBhbiBhbmdsZSBpbiByYWRpYW5zLiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgc2luZSBpcyBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZm9yIGV2ZXJ5IGNvbXBvbmVudC4gKi9cblxuXG4gICAgc2luOiB7Z2xzbDogJ3NpbiglMSk7Jywgb3V0cHV0OiB7JzEnOjEsICcyJzoyLCAnMyc6MywgJzQnOjR9fSxcblxuICAgIC8qIENvcyAtIFRoZSBjb3MgZnVuY3Rpb24gcmV0dXJucyB0aGUgY29zaW5lIG9mIGFuIGFuZ2xlIGluIHJhZGlhbnMuIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiAqL1xuXG4gICAgY29zOiB7Z2xzbDogJ2NvcyglMSk7Jywgb3V0cHV0OiB7JzEnOjEsICcyJzoyLCAnMyc6MywgJzQnOjR9fSxcblxuICAgIC8qIFBvdyAtIFRoZSBwb3dlciBmdW5jdGlvbiByZXR1cm5zIHggcmFpc2VkIHRvIHRoZSBwb3dlciBvZiB5LiBUaGUgaW5wdXQgcGFyYW1ldGVycyBjYW4gYmUgZmxvYXRpbmcgc2NhbGFycyBvciBmbG9hdCB2ZWN0b3JzLiBJbiBjYXNlIG9mIGZsb2F0IHZlY3RvcnMgdGhlIG9wZXJhdGlvbiBpcyBkb25lIGNvbXBvbmVudC13aXNlLiAqL1xuXG4gICAgcG93OiB7Z2xzbDogJ3BvdyglMSwgJTIpOycsIG91dHB1dDogeycxLDEnOjEsICcyLDInOjIsICczLDMnOjMsICcxLDQnOjR9fSxcblxuICAgIC8qIFNxcnQgLSBUaGUgc3FydCBmdW5jdGlvbiByZXR1cm5zIHRoZSBzcXVhcmUgcm9vdCBvZiB4LiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBzcXJ0OiB7Z2xzbDogJ3NxcnQoJTEpOycsIG91dHB1dDogeycxLDEnOjEsICcyLDInOjIsICczLDMnOjMsICcxLDQnOjR9fSxcblxuICAgIC8qIHRpbWUgLSBUaGUgdGltZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBlbGFwc2VkIHRpbWUgaW4gdGhlIHVuaXggZXBvY2ggaW4gbWlsbGlzZWNvbmRzLiovXG5cbiAgICB0aW1lOiB7Z2xzbDogJ3RpbWU7Jywgb3V0cHV0OiAxfSxcblxuICAgIC8qIFRoZSBBZGQgZnVuY3Rpb24gdGFrZXMgdHdvIGlucHV0cywgYWRkcyB0aGVtIHRvZ2V0aGVyIGFuZCBvdXRwdXRzIHRoZSByZXN1bHQuIFRoaXMgYWRkaXRpb24gb3BlcmF0aW9uIGlzIHBlcmZvcm1lZCBvbiBhIHBlciBjaGFubmVsIGJhc2lzLCBtZWFuaW5nIHRoYXQgdGhlIGlucHV0cycgUiBjaGFubmVscyBnZXQgYWRkZWQsIEcgY2hhbm5lbHMgZ2V0IGFkZGVkLCBCIGNoYW5uZWxzIGdldCBhZGRlZCwgZXRjLiBCb3RoIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIHVubGVzcyBvbmUgb2YgdGhlbSBpcyBhIHNpbmdsZSBDb25zdGFudCB2YWx1ZS4gQ29uc3RhbnRzIGNhbiBiZSBhZGRlZCB0byBhIHZlY3RvciB3aXRoIGFueSBudW1iZXIgb2YgaW5wdXRzLiAqL1xuXG4gICAgYWRkOiB7Z2xzbDogJyUxICsgJTI7Jywgb3V0cHV0OiAgeycxLDEnOjEsICcyLDInOjIsICczLDMnOjMsICc0LDQnOjQsICcyLDEnOjIsICczLDEnOjMsICc0LDEnOjR9fSxcblxuICAgIC8qIFRoZSBzdWJ0cmFjdCBmdW5jdGlvbiB0YWtlcyB0d28gaW5wdXRzLCBzdWJ0cmFjdHMgdGhlIGZpcnN0IGZyb20gdGhlIHNlY29uZCwgIGFuZCBvdXRwdXRzIHRoZSByZXN1bHQuIFRoaXMgYWRkaXRpb24gb3BlcmF0aW9uIGlzIHBlcmZvcm1lZCBvbiBhIHBlciBjaGFubmVsIGJhc2lzLCBtZWFuaW5nIHRoYXQgdGhlIGlucHV0cycgUiBjaGFubmVscyBnZXQgc3VidHJhY3RlZCwgRyBjaGFubmVscyBnZXQgc3VidHJhY3RlZCwgQiBjaGFubmVscyBnZXQgc3VidHJhY3RlZCwgZXRjLiBCb3RoIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIHVubGVzcyBvbmUgb2YgdGhlbSBpcyBhIHNpbmdsZSBDb25zdGFudCB2YWx1ZS4gQ29uc3RhbnRzIGNhbiBiZSBhZGRlZCB0byBhIHZlY3RvciB3aXRoIGFueSBudW1iZXIgb2YgaW5wdXRzLiAqL1xuXG4gICAgc3VidHJhY3Q6IHtnbHNsOiAnJTEgLSAlMjsnLCBvdXRwdXQ6IHsnMSwxJzoxLCAnMiwyJzoyLCAnMywzJzozLCAnNCw0Jzo0LCAnMiwxJzoyLCAnMywxJzozLCAnNCwxJzo0fX0sXG5cbiAgICAvKiBUaGUgQWRkIGZ1bmN0aW9uIHRha2VzIHR3byBpbnB1dHMsIGFkZHMgdGhlbSB0b2dldGhlciBhbmQgb3V0cHV0cyB0aGUgcmVzdWx0LiBUaGlzIGFkZGl0aW9uIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgb24gYSBwZXIgY2hhbm5lbCBiYXNpcywgbWVhbmluZyB0aGF0IHRoZSBpbnB1dHMnIFIgY2hhbm5lbHMgZ2V0IGFkZGVkLCBHIGNoYW5uZWxzIGdldCBhZGRlZCwgQiBjaGFubmVscyBnZXQgYWRkZWQsIGV0Yy4gQm90aCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyB1bmxlc3Mgb25lIG9mIHRoZW0gaXMgYSBzaW5nbGUgQ29uc3RhbnQgdmFsdWUuIENvbnN0YW50cyBjYW4gYmUgYWRkZWQgdG8gYSB2ZWN0b3Igd2l0aCBhbnkgbnVtYmVyIG9mIGlucHV0cy4gKi9cblxuICAgIG11bHRpcGx5OiB7Z2xzbDogJyUxICogJTI7Jywgb3V0cHV0OiB7JzEsMSc6MSwgJzIsMic6MiwgJzMsMyc6MywgJzQsNCc6NCwgJzIsMSc6MiwgJzMsMSc6MywgJzQsMSc6NH19LFxuXG4gICAgLyogVGhlIG5vcm1hbCBmdW5jdGlvbiByZXR1cm5zIHRoZSAzLWRpbWVuc2lvbmFsIHN1cmZhY2Ugbm9ybWFsLCB3aGljaCBpcyBhIHZlY3RvciB0aGF0IGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHRhbmdlbnQgcGxhbmUgYXQgdGhhdCBwb2ludC4qL1xuXG4gICAgbm9ybWFsOiB7IGdsc2w6ICd2ZWM0KCh2X25vcm1hbCArIDEuMCkgKiAwLjUsIDEuMCk7Jywgb3V0cHV0OiA0IH0sXG5cbiAgICAvKiBUaGUgdXYgZnVuY3Rpb24gcmV0dXJucyB0aGUgMi1kaW1lbnNpb25hbCB2ZWN0b3IgdGhhdCBtYXBzIHRoZSBvYmplY3QncyAzLWRpbWVuc2lvbmFsIHZlcnRpY2VzIHRvIGEgMkQgcGxhbmUuICovXG5cbiAgICB1djoge2dsc2w6J3ZfdGV4dHVyZUNvb3JkaW5hdGU7Jywgb3V0cHV0OiAyfSxcblxuICAgIC8qIFRoZSBtZXNoIHBvc2l0aW9uIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIGZyYWdtZW50J3MgcG9zaXRpb24gaW4gd29ybGQtc3BhY2UuICAqL1xuXG4gICAgbWVzaFBvc2l0aW9uOiB7Z2xzbDonKHZfcG9zaXRpb24gKyAxLjApICogMC41OycsIG91dHB1dDogM30sXG5cblxuICAgIG5vcm1hbGl6ZToge2dsc2w6ICdub3JtYWxpemUoJTEpJywgb3V0cHV0OiB7MTogMSwgMjogMiwgMzogMywgNDogNH19LFxuXG5cbiAgICBkb3Q6IHtnbHNsOiAnZG90KCUxLCAlMik7Jywgb3V0cHV0OiB7JzEsMSc6IDEsJzIsMic6MSwgJzMsMyc6IDEsICc0LDQnOjEgfX0sXG5cbiAgICAvKiBUaGUgaW1hZ2UgZnVuY3Rpb24gZmV0Y2hlcyB0aGUgbW9kZWwncyAqL1xuXG4gICAgaW1hZ2U6IHtnbHNsOid0ZXh0dXJlMkQoJFRFWFRVUkUsIHZfdGV4dHVyZUNvb3JkaW5hdGUpOycsIG91dHB1dDogNCB9LFxuXG5cbiAgICAvKiBUaGUgY29uc3RhbnQgZnVuY3Rpb24gcmV0dXJucyBhIHN0YXRpYyB2YWx1ZSB3aGljaCBpcyBkZWZpbmVkIGF0IGNvbXBpbGUtdGltZSB0aGF0IGNhbm5vdCBiZSBjaGFuZ2VkIGR5bmFtaWNhbGx5LiovXG5cbiAgICBjb25zdGFudDoge2dsc2w6ICclMTsnfSxcblxuICAgIC8qIFRoZSBQYXJhbWV0ZXIgZXhwcmVzc2lvbiBoYXMgdmFsdWVzIHRoYXQgY2FuIGJlIG1vZGlmaWVkIChkeW5hbWljYWxseSBkdXJpbmcgcnVudGltZSBpbiBzb21lIGNhc2VzKSBpbiBhIE1hdGVyaWFsSW5zdGFuY2Ugb2YgdGhlIGJhc2UgbWF0ZXJpYWwgY29udGFpbmluZyB0aGUgcGFyYW1ldGVyLiBUaGVzZSBleHByZXNzaW9ucyBzaG91bGQgYmUgZ2l2ZW4gdW5pcXVlIG5hbWVzLCB2aWEgdGhlIFBhcmFtZXRlciBOYW1lIHByb3BlcnR5LCB0byBiZSB1c2VkIHdoZW4gaWRlbnRpZnlpbmcgdGhlIHNwZWNpZmljIHBhcmFtZXRlciBpbiB0aGUgTWF0ZXJpYWxJbnN0YW5jZS4gSWYgdHdvIHBhcmFtZXRlcnMgb2YgdGhlIHNhbWUgdHlwZSBoYXZlIHRoZSBzYW1lIG5hbWUgaW4gdGhlIHNhbWUgbWF0ZXJpYWwsIHRoZXkgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIHRoZSBzYW1lIHBhcmFtZXRlci4gQ2hhbmdpbmcgdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgaW4gdGhlIE1hdGVyaWFsSW5zdGFuY2Ugd291bGQgY2hhbmdlIHRoZSB2YWx1ZSBvZiBib3RoIHRoZSBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgaW4gdGhlIG1hdGVyaWFsLiBBIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwYXJhbWV0ZXIgd2lsbCBhbHNvIGJlIHNldCBpbiB0aGUgYmFzZSBtYXRlcmlhbC4gVGhpcyB3aWxsIGJlIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIGluIHRoZSBNYXRlcmlhbEluc3RhbmNlIHVubGVzcyBpdCBpcyBvdmVycmlkZGVuIGFuZCBtb2RpZmllZCB0aGVyZS4gKi9cblxuICAgIHBhcmFtZXRlcjoge3VuaWZvcm1zOiB7cGFyYW1ldGVyOiAxfSwgZ2xzbDogJ3BhcmFtZXRlcjsnfSxcbiAgICB2ZWMzOiB7Z2xzbDogJ3ZlYzMoJTEpOycsIG91dHB1dDogM30sXG4gICAgdmVjMjoge2dsc2w6ICd2ZWMyKCUxKTsnLCBvdXRwdXQ6IDJ9XG59O1xuXG5leHByZXNzaW9ucy5yZWdpc3RlckV4cHJlc3Npb24gPSBmdW5jdGlvbiByZWdpc3RlckV4cHJlc3Npb24obmFtZSwgc2NoZW1hKSB7XG4gICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uIChpbnB1dHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRlcmlhbChuYW1lLCBzY2hlbWEsIGlucHV0cywgb3B0aW9ucyk7XG4gICAgfTtcbn07XG5cbmZvciAodmFyIHNuaXBwZXROYW1lIGluIHNuaXBwZXRzKSB7XG4gICAgZXhwcmVzc2lvbnMucmVnaXN0ZXJFeHByZXNzaW9uKHNuaXBwZXROYW1lLCBzbmlwcGV0c1tzbmlwcGV0TmFtZV0pO1xufVxuXG4vKipcbiAqIE1hdGVyaWFsIGlzIGEgcHVibGljIGNsYXNzIHRoYXQgY29tcG9zZXMgYSBtYXRlcmlhbC1ncmFwaCBvdXQgb2YgZXhwcmVzc2lvbnNcbiAqXG4gKlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdG9uIG9mIG5hc2NlbnQgZXhwcmVzc2lvbiB3aXRoIHNoYWRlciBjb2RlLCBpbnB1dHMgYW5kIHVuaWZvcm1zXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IG9mIE1hdGVyaWFsIGV4cHJlc3Npb25zLCBpbWFnZXMsIG9yIGNvbnN0YW50XG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIG9mIHVuaWZvcm0gZGF0YSBvZiBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNFxuICovXG5cbmZ1bmN0aW9uIE1hdGVyaWFsKG5hbWUsIGNodW5rLCBpbnB1dHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzID8gKEFycmF5LmlzQXJyYXkoaW5wdXRzKSA/IGlucHV0cyA6IFtpbnB1dHNdKTogW107XG4gICAgdGhpcy51bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXMgfHwge307XG4gICAgdGhpcy52YXJ5aW5ncyA9IG9wdGlvbnMudmFyeWluZ3M7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzO1xuXG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBvcHRpb25zLnRleHR1cmUuX19pc0FUZXh0dXJlX18gPyBvcHRpb25zLnRleHR1cmUgOiBUZXh0dXJlUmVnaXN0cnkucmVnaXN0ZXIobnVsbCwgb3B0aW9ucy50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pZCA9IE1hdGVyaWFsLmlkKys7XG5cbiAgICB0aGlzLmludmFsaWRhdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9faXNBTWF0ZXJpYWxfXyA9IHRydWU7XG59XG5cbk1hdGVyaWFsLmlkID0gMjtcblxuTWF0ZXJpYWwucHJvdG90eXBlLnNldFVuaWZvcm0gPSBmdW5jdGlvbiBzZXRVbmlmb3JtKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgdGhpcy5pbnZhbGlkYXRpb25zLnB1c2gobmFtZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cHJlc3Npb25zO1xuZXhwcmVzc2lvbnMuTWF0ZXJpYWwgPSBNYXRlcmlhbDtcblxuZXhwcmVzc2lvbnMuVGV4dHVyZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBjb25zb2xlLmVycm9yKCdUZXh0dXJlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBydW4gaW5zaWRlIG9mIGEgd29ya2VyJyk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zLmltYWdlKFtdLCB7IHRleHR1cmU6IHNvdXJjZSB9KTtcbn07XG5cbmV4cHJlc3Npb25zLkN1c3RvbSA9IGZ1bmN0aW9uIChzY2hlbWEsIGlucHV0cywgdW5pZm9ybXMpIHtcbiAgICByZXR1cm4gbmV3IE1hdGVyaWFsKCdjdXN0b20nLCB7Z2xzbDogc2NoZW1hLCBvdXRwdXQ6IDEsIHVuaWZvcm1zOiB1bmlmb3JtcyB8fCB7fX0gLCBpbnB1dHMpO1xufTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBBIHNpbmdsZXRvbiBvYmplY3QgdGhhdCBob2xkcyB0ZXh0dXJlIGluc3RhbmNlcyBpbiBhIHJlZ2lzdHJ5IHdoaWNoXG4gKiBjYW4gYmUgYWNjZXNzZWQgYnkga2V5LiAgQWxsb3dzIGZvciB0ZXh0dXJlIHNoYXJpbmcgYW5kIGVhc3kgcmVmZXJlbmNpbmcuXG4gKlxuICogQHN0YXRpY1xuICogQGNsYXNzIFRleHR1cmVSZWdpc3RyeVxuICovXG52YXIgVGV4dHVyZVJlZ2lzdHJ5ID0ge1xuXHRyZWdpc3RyeToge30sXG5cdHRleHR1cmVJZHM6IDFcbn07XG5cbi8qXG4gKiBSZWdpc3RlcnMgYSBuZXcgVGV4dHVyZSBvYmplY3Qgd2l0aCBhIHVuaXF1ZSBpZCBhbmQgaW5wdXQgcGFyYW1ldGVycyB0byBiZVxuICogaGFuZGxlZCBieSB0aGUgV2ViR0xSZW5kZXJlci4gIElmIG5vIGFjY2Vzc29yIGlzIGlucHV0IHRoZSB0ZXh0dXJlIHdpbGwgYmUgXG4gKiBjcmVhdGVkIGJ1dCBub3Qgc3RvcmUgaW4gdGhlIHJlZ2lzdHJ5LlxuICpcbiAqIEBtZXRob2QgcmVnaXN0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXNzb3IgS2V5IHVzZWQgdG8gbGF0ZXIgYWNjZXNzIHRoZSB0ZXh0dXJlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXkgfCBTdHJpbmd9IGRhdGEgRGF0YSB0byBiZSB1c2VkIGluIHRoZSBXZWJHTFJlbmRlcmVyIHRvXG4gKiBnZW5lcmF0ZSB0ZXh0dXJlIGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgcmVuZGVyaW5nIG9mIHRoZVxuICogV2ViR0wgdGV4dHVyZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ld2x5IGdlbmVyYXRlZCB0ZXh0dXJlIG9iamVjdC5cbiAqL1xuVGV4dHVyZVJlZ2lzdHJ5LnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoYWNjZXNzb3IsIGRhdGEsIG9wdGlvbnMpIHtcblx0aWYgKGFjY2Vzc29yKSByZXR1cm4gKHRoaXMucmVnaXN0cnlbYWNjZXNzb3JdID0geyBpZDogdGhpcy50ZXh0dXJlSWRzKyssIF9faXNBVGV4dHVyZV9fOiB0cnVlLCBkYXRhOiBkYXRhLCBvcHRpb25zOiBvcHRpb25zIH0pO1xuXHRlbHNlIHJldHVybiB7IGlkOiB0aGlzLnRleHR1cmVJZHMrKywgZGF0YTogZGF0YSwgX19pc0FUZXh0dXJlX186IHRydWUsIG9wdGlvbnM6IG9wdGlvbnMgfTtcbn07XG5cbi8qXG4gKiBSZXRyZWl2ZXMgdGhlIHRleHR1cmUgb2JqZWN0IGZyb20gcmVnaXN0cnkuICBUaHJvd3MgaWYgbm8gdGV4dHVyZSBpc1xuICogZm91bmQgYXQgZ2l2ZW4ga2V5LlxuICpcbiAqIEBtZXRob2QgZ2V0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2Vzc29yIEtleSBvZiBhIGRlc2lyZWQgdGV4dHVyZSBpbiB0aGUgcmVnaXN0cnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBEZXNpcmVkIHRleHR1cmUgb2JqZWN0LlxuICovXG5UZXh0dXJlUmVnaXN0cnkuZ2V0ID0gZnVuY3Rpb24gZ2V0KGFjY2Vzc29yKSB7XG5cdGlmICghdGhpcy5yZWdpc3RyeVthY2Nlc3Nvcl0pIHtcblx0XHR0aHJvdyAnVGV4dHVyZSBcIicgKyBhY2Nlc3NvciArICdcIiBub3QgZm91bmQhJztcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5yZWdpc3RyeVthY2Nlc3Nvcl07XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZVJlZ2lzdHJ5O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0ZXJpYWw6IHJlcXVpcmUoJy4vTWF0ZXJpYWwnKSxcbiAgICBUZXh0dXJlUmVnaXN0cnk6IHJlcXVpcmUoJy4vVGV4dHVyZVJlZ2lzdHJ5Jylcbn07IiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3dlYmdsLWdlb21ldHJpZXMnKTtcblxuLyoqXG4gKiBUaGUgTWVzaCBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nIHRoZSBBUEkgZm9yIGhvd1xuICogYSBSZW5kZXJOb2RlIHdpbGwgaW50ZXJhY3Qgd2l0aCB0aGUgV2ViR0wgQVBJIGJ5IGFkZGluZ1xuICogYSBzZXQgb2YgY29tbWFuZHMgdG8gdGhlIHJlbmRlcmVyLlxuICpcbiAqIEBjbGFzcyBNZXNoXG4gKiBAY29uc3RydWN0b3JcbiAqIEByZW5kZXJhYmxlXG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkXG4gKiBAcGFyYW0ge29iamVjdH0gT3B0aW9ucyBPcHRpb25hbCBwYXJhbXMgZm9yIGNvbmZpZ3VyaW5nIE1lc2hcbiAqL1xuZnVuY3Rpb24gTWVzaCAobm9kZSwgb3B0aW9ucykge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2NoYW5nZVF1ZXVlID0gW107XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5faW5EcmF3ID0gZmFsc2U7XG4gICAgdGhpcy52YWx1ZSA9IHtcbiAgICAgICAgZHJhd09wdGlvbnM6IHt9LFxuICAgICAgICBjb2xvcjogbnVsbCxcbiAgICAgICAgZXhwcmVzc2lvbnM6IHt9LFxuICAgICAgICBnZW9tZXRyeTogbnVsbCxcbiAgICAgICAgZmxhdFNoYWRpbmc6IG51bGwsXG4gICAgICAgIGdsb3NzaW5lc3M6IG51bGwsXG4gICAgICAgIGJhc2VDb2xvcjogWzAsIDAsIDAsIDFdLFxuICAgICAgICBwb3NpdGlvbk9mZnNldDogbnVsbCxcbiAgICAgICAgbm9ybWFsczogbnVsbCxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHRoaXMuc2V0RHJhd09wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbn1cblxuLyoqXG4gKiBQYXNzIGN1c3RvbSBvcHRpb25zIHRvIE1lc2gsIHN1Y2ggYXMgYSAzIGVsZW1lbnQgbWFwXG4gKiB3aGljaCBkaXNwbGFjZXMgdGhlIHBvc2l0aW9uIG9mIGVhY2ggdmVydGV4IGluIHdvcmxkIHNwYWNlLlxuICpcbiAqIEBtZXRob2Qgc2V0RHJhd09wdGlvbnNcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uc1xuICogQGNoYWluYWJsZVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXREcmF3T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMgKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9TRVRfRFJBV19PUFRJT05TJyk7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtZXNoJ3MgY3VzdG9tIG9wdGlvbnMuXG4gKlxuICogQG1ldGhvZCBnZXREcmF3T3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gT3B0aW9uc1xuICovXG5NZXNoLnByb3RvdHlwZS5nZXREcmF3T3B0aW9ucyA9IGZ1bmN0aW9uIGdldERyYXdPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5kcmF3T3B0aW9ucztcbn07XG5cbi8qKlxuICogQXNzaWducyBhIGdlb21ldHJ5IHRvIGJlIHVzZWQgZm9yIHRoaXMgbWVzaC4gIFdpbGwgY3JlYXRlIG5ldyBHZW9tZXRyeVxuICogZnJvbSBwcmltdGl2ZXMgaWYgaW5wdXQgaXMgYSBzdHJpbmcuICBRdWV1ZXMgdGhlIHNldCBjb21tYW5kIGZvciB0aGlzIFxuICogZ2VvbWV0cnkgYW5kIGxvb2tzIGZvciBidWZmZXJzIHRvIHNlbmQgdG8gdGhlIHJlbmRlcmVyIHRvIHVwZGF0ZSBnZW9tZXRyeS5cbiAqXG4gKiBAbWV0aG9kIHNldEdlb21ldHJ5XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNoXG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyBWYXJpb3VzIGNvbmZpZ3VyYXRpb25zIGZvciBnZW9tZXRyaWVzLlxuICogQGNoYWluYWJsZVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIHNldEdlb21ldHJ5IChnZW9tZXRyeSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZ2VvbWV0cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghR2VvbWV0cnlbZ2VvbWV0cnldKSB0aHJvdyAnSW52YWxpZCBnZW9tZXRyeTogXCInICsgZ2VvbWV0cnkgKyAnXCIuJztcbiAgICAgICAgZWxzZSBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeVtnZW9tZXRyeV0ob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmFsdWUuZ2VvbWV0cnkgIT09IGdlb21ldHJ5IHx8IHRoaXMuX2luRHJhdykge1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX1NFVF9HRU9NRVRSWScpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChnZW9tZXRyeS5zcGVjLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goZ2VvbWV0cnkuc3BlYy50eXBlKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goZ2VvbWV0cnkuc3BlYy5keW5hbWljKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIHRoaXMudmFsdWUuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX25vZGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy52YWx1ZS5nZW9tZXRyeS5zcGVjLmludmFsaWRhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5pbnZhbGlkYXRpb25zLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX0JVRkZFUl9EQVRBJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCh0aGlzLnZhbHVlLmdlb21ldHJ5LnNwZWMuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2godGhpcy52YWx1ZS5nZW9tZXRyeS5zcGVjLmJ1ZmZlck5hbWVzW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5idWZmZXJWYWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2godGhpcy52YWx1ZS5nZW9tZXRyeS5zcGVjLmJ1ZmZlclNwYWNpbmdzW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5keW5hbWljKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGdlb21ldHJ5IG9mIGEgbWVzaC5cbiAqXG4gKiBAbWV0aG9kIGdldEdlb21ldHJ5XG4gKiBAcmV0dXJucyB7R2VvbWV0cnl9IGdlb21ldHJ5IEdlb21ldHJ5IG9mIG1lc2hcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZ2VvbWV0cnk7XG59O1xuXG4vKipcbiogQ2hhbmdlcyB0aGUgY29sb3Igb2YgTWVzaCwgcGFzc2luZyBlaXRoZXIgYSBtYXRlcmlhbCBleHByZXNzaW9uIG9yXG4qIGNvbG9yIHVzaW5nIHRoZSAnQ29sb3InIHV0aWxpdHkgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIHNldEJhc2VDb2xvclxuKiBAcGFyYW0ge09iamVjdHxDb2xvcn0gTWF0ZXJpYWwsIGltYWdlLCB2ZWMzLCBvciBDb2xvciBpbnN0YW5jZVxuKiBAY2hhaW5hYmxlXG4qL1xuTWVzaC5wcm90b3R5cGUuc2V0QmFzZUNvbG9yID0gZnVuY3Rpb24gc2V0QmFzZUNvbG9yIChjb2xvcikge1xuICAgIHZhciB1bmlmb3JtVmFsdWU7XG5cbiAgICBpZiAoY29sb3IuX19pc0FNYXRlcmlhbF9fKSB7XG4gICAgICAgIHRoaXMudmFsdWUuY29sb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmJhc2VDb2xvciA9IGNvbG9yO1xuICAgICAgICB1bmlmb3JtVmFsdWUgPSBjb2xvcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sb3IuZ2V0Tm9ybWFsaXplZFJHQikge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmJhc2VDb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdmFyIHZhbHVlID0gY29sb3IuZ2V0Tm9ybWFsaXplZFJHQigpO1xuICAgICAgICB0aGlzLnZhbHVlLmJhc2VDb2xvclswXSA9IHZhbHVlWzBdO1xuICAgICAgICB0aGlzLnZhbHVlLmJhc2VDb2xvclsxXSA9IHZhbHVlWzFdO1xuICAgICAgICB0aGlzLnZhbHVlLmJhc2VDb2xvclsyXSA9IHZhbHVlWzJdO1xuXG4gICAgICAgIHVuaWZvcm1WYWx1ZSA9IHRoaXMudmFsdWUuYmFzZUNvbG9yO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuXG4gICAgICAgIC8vIElmIGEgbWF0ZXJpYWwgZXhwcmVzc2lvblxuXG4gICAgICAgIGlmIChjb2xvci5fX2lzQU1hdGVyaWFsX18pIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ01BVEVSSUFMX0lOUFVUJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIGNvbG9yIGNvbXBvbmVudFxuXG4gICAgICAgIGVsc2UgaWYgKGNvbG9yLmdldE5vcm1hbGl6ZWRSR0IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX1VOSUZPUk1TJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCd1X2Jhc2VDb2xvcicpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHVuaWZvcm1WYWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZWl0aGVyIHRoZSBtYXRlcmlhbCBleHByZXNzaW9uIG9yIHRoZSBjb2xvciBpbnN0YW5jZSBvZiBNZXNoLlxuICpcbiAqIEBtZXRob2QgZ2V0QmFzZUNvbG9yXG4gKiBAcmV0dXJucyB7TWF0ZXJpYWxFeHByZXNzfENvbG9yfVxuICovXG5NZXNoLnByb3RvdHlwZS5nZXRCYXNlQ29sb3IgPSBmdW5jdGlvbiBnZXRCYXNlQ29sb3IgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmJhc2VDb2xvciB8fCB0aGlzLnZhbHVlLmNvbG9yO1xufTtcblxuLyoqXG4gKiBDaGFuZ2Ugd2hldGhlciB0aGUgTWVzaCBpcyBhZmZlY3RlZCBieSBsaWdodC4gRGVmYXVsdCBpcyB0cnVlLlxuICpcbiAqIEBtZXRob2Qgc2V0RmxhdFNoYWRpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gQm9vbGVhblxuICogQGNoYWluYWJsZVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXRGbGF0U2hhZGluZyA9IGZ1bmN0aW9uIHNldEZsYXRTaGFkaW5nIChib29sKSB7XG4gICAgaWYgKHRoaXMuX2luRHJhdyB8fCB0aGlzLnZhbHVlLmZsYXRTaGFkaW5nICE9PSBib29sKSB7XG4gICAgICAgIHRoaXMudmFsdWUuZmxhdFNoYWRpbmcgPSBib29sO1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX1VOSUZPUk1TJyk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCd1X2ZsYXRTaGFkaW5nJyk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKGJvb2wgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBmb3Igd2hldGhlciBNZXNoIGlzIGFmZmVjdGVkIGJ5IGxpZ2h0LlxuICpcbiAqIEBtZXRob2QgZ2V0RmxhdFNoYWRpbmdcbiAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuXG4gKi9cbk1lc2gucHJvdG90eXBlLmdldEZsYXRTaGFkaW5nID0gZnVuY3Rpb24gZ2V0RmxhdFNoYWRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmZsYXRTaGFkaW5nO1xufTtcblxuXG4vKipcbiAqIERlZmluZXMgYSAzLWVsZW1lbnQgbWFwIHdoaWNoIGlzIHVzZWQgdG8gcHJvdmlkZSBzaWduaWZpY2FudCBwaHlzaWNhbFxuICogZGV0YWlsIHRvIHRoZSBzdXJmYWNlIGJ5IHBlcnR1cmJpbmcgdGhlIGZhY2luZyBkaXJlY3Rpb24gb2YgZWFjaCBpbmRpdmlkdWFsXG4gKiBwaXhlbC5cbiAqXG4gKiBAbWV0aG9kIG5vcm1hbFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBNYXRlcmlhbCwgSW1hZ2Ugb3IgdmVjM1xuICogQHJldHVybiB7RWxlbWVudH0gY3VycmVudCBNZXNoXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldE5vcm1hbHMgPSBmdW5jdGlvbiBzZXROb3JtYWxzIChtYXRlcmlhbEV4cHJlc3Npb24pIHtcbiAgICBpZiAobWF0ZXJpYWxFeHByZXNzaW9uLl9faXNBTWF0ZXJpYWxfXykge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLm5vcm1hbHMgPSBtYXRlcmlhbEV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2gobWF0ZXJpYWxFeHByZXNzaW9uLl9faXNBTWF0ZXJpYWxfXyA/ICdNQVRFUklBTF9JTlBVVCcgOiAnVU5JRk9STV9JTlBVVCcpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCd1X25vcm1hbHMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChtYXRlcmlhbEV4cHJlc3Npb24pO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBOb3JtYWxzIGV4cHJlc3Npb24gb2YgTWVzaFxuICpcbiAqIEBtZXRob2QgZ2V0Tm9ybWFsc1xuICogQHJldHVybnMgVGhlIG5vcm1hbHMgZXhwcmVzc2lvbiBmb3IgTWVzaFxuICovXG5NZXNoLnByb3RvdHlwZS5nZXROb3JtYWxzID0gZnVuY3Rpb24gZ2V0Tm9ybWFscyAobWF0ZXJpYWxFeHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMubm9ybWFscztcbn07XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgZ2xvc3NpbmVzcyBvZiB0aGUgbWVzaCBmcm9tIGVpdGhlciBhIG1hdGVyaWFsIGV4cHJlc3Npb24gb3IgYVxuICogc2NhbGFyIHZhbHVlXG4gKlxuICogQG1ldGhvZCBzZXRHbG9zc2luZXNzXG4gKiBAcGFyYW0ge01hdGVyaWFsRXhwcmVzc2lvbnxDb2xvcn0gQWNjZXB0cyBlaXRoZXIgYSBtYXRlcmlhbCBleHByZXNzaW9uIG9yIENvbG9yIGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gT3B0aW9uYWwgdmFsdWUgZm9yIGNoYW5naW5nIHRoZSBzdHJlbmd0aCBvZiB0aGUgZ2xvc3NpbmVzc1xuICogQGNoYWluYWJsZVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXRHbG9zc2luZXNzID0gZnVuY3Rpb24gc2V0R2xvc3NpbmVzcyhnbG9zc2luZXNzLCBzdHJlbmd0aCkge1xuICAgIGlmIChnbG9zc2luZXNzLl9faXNBTWF0ZXJpYWxfXykge1xuICAgICAgICB0aGlzLnZhbHVlLmdsb3NzaW5lc3MgPSBbbnVsbCwgbnVsbF07XG4gICAgICAgIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMuZ2xvc3NpbmVzcyA9IGdsb3NzaW5lc3M7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdsb3NzaW5lc3MuZ2V0Tm9ybWFsaXplZFJHQikge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmdsb3NzaW5lc3MgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlLmdsb3NzaW5lc3MgPSBbZ2xvc3NpbmVzcywgc3RyZW5ndGggfHwgMjBdO1xuICAgICAgICBnbG9zc2luZXNzID0gZ2xvc3NpbmVzcyA/IGdsb3NzaW5lc3MuZ2V0Tm9ybWFsaXplZFJHQigpIDogWzAsIDAsIDBdO1xuICAgICAgICBnbG9zc2luZXNzLnB1c2goc3RyZW5ndGggfHwgMjApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKGdsb3NzaW5lc3MuX19pc0FNYXRlcmlhbF9fID8gJ01BVEVSSUFMX0lOUFVUJyA6ICdHTF9VTklGT1JNUycpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCd1X2dsb3NzaW5lc3MnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChnbG9zc2luZXNzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgbWF0ZXJpYWwgZXhwcmVzc2lvbiBvciBzY2FsYXIgdmFsdWUgZm9yIGdsb3NzaW5lc3MuXG4gKlxuICogQG1ldGhvZCBnZXRHbG9zc2luZXNzXG4gKiBAcmV0dXJucyB7TWF0ZXJpYWxFeHByZXNzfE51bWJlcn1cbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0R2xvc3NpbmVzcyA9IGZ1bmN0aW9uIGdldEdsb3NzaW5lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMuZ2xvc3NpbmVzcyB8fCB0aGlzLnZhbHVlLmdsb3NzaW5lc3M7XG59O1xuXG4vKipcbiAqIERlZmluZXMgMyBlbGVtZW50IG1hcCB3aGljaCBkaXNwbGFjZXMgdGhlIHBvc2l0aW9uIG9mIGVhY2ggdmVydGV4IGluIHdvcmxkXG4gKiBzcGFjZS5cbiAqXG4gKiBAbWV0aG9kIHNldFBvc2l0aW9uT2Zmc2V0XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtNYXRlcmlhbEV4cHJlc3Npb258QXJyYXl9XG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uYWwgdHdlZW5pbmcgcGFyYW1ldGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDYWxsYmFja1xuICogQGNoYWluYWJsZVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXRQb3NpdGlvbk9mZnNldCA9IGZ1bmN0aW9uIHBvc2l0aW9uT2Zmc2V0KG1hdGVyaWFsRXhwcmVzc2lvbikge1xuICAgIHZhciB1bmlmb3JtVmFsdWU7XG5cbiAgICBpZiAobWF0ZXJpYWxFeHByZXNzaW9uLl9faXNBTWF0ZXJpYWxfXykge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0ID0gbWF0ZXJpYWxFeHByZXNzaW9uO1xuICAgICAgICB1bmlmb3JtVmFsdWUgPSBtYXRlcmlhbEV4cHJlc3Npb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZS5wb3NpdGlvbk9mZnNldCA9IG1hdGVyaWFsRXhwcmVzc2lvbjtcbiAgICAgICAgdW5pZm9ybVZhbHVlID0gdGhpcy52YWx1ZS5wb3NpdGlvbk9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChtYXRlcmlhbEV4cHJlc3Npb24uX19pc0FNYXRlcmlhbF9fID8gJ01BVEVSSUFMX0lOUFVUJyA6ICdHTF9VTklGT1JNUycpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCd1X3Bvc2l0aW9uT2Zmc2V0Jyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2godW5pZm9ybVZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBwb3NpdGlvbiBvZmZzZXQuXG4gKlxuICogQG1ldGhvZCBnZXRQb3NpdGlvbk9mZnNldFxuICogQHJldHVybnMge01hdGVyaWFsRXhwcmVzc3xOdW1iZXJ9XG4gKi9cbk1lc2gucHJvdG90eXBlLmdldFBvc2l0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0UG9zaXRpb25PZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0IHx8IHRoaXMudmFsdWUucG9zaXRpb25PZmZzZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWVzaCdzIGN1c3RvbSBvcHRpb25zLlxuICpcbiAqIEBtZXRob2QgZ2V0RHJhd09wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9wdGlvbnNcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIGdldE1hdGVyaWFsRXhwcmVzc2lvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmV4cHJlc3Npb25zO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5fcHVzaEludmFsaWRhdGlvbnMgPSBmdW5jdGlvbiBwdXNoSW52YWxpZGF0aW9ucyAoZXhwcmVzc2lvbk5hbWUpIHtcbiAgICB2YXIgdW5pZm9ybUtleTtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudmFsdWUuZXhwcmVzc2lvbnNbZXhwcmVzc2lvbk5hbWVdO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBpID0gZXhwcmVzc2lvbi5pbnZhbGlkYXRpb25zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdW5pZm9ybUtleSA9IGV4cHJlc3Npb24uaW52YWxpZGF0aW9ucy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKCdHTF9VTklGT1JNUycpO1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodW5pZm9ybUtleSk7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChleHByZXNzaW9uLnVuaWZvcm1zW3VuaWZvcm1LZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuKiBTZW5kcyBkcmF3IGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlclxuKlxuKiBAcHJpdmF0ZVxuKiBAbWV0aG9kIG9uVXBkYXRlXG4qL1xuTWVzaC5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZSgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fY2hhbmdlUXVldWU7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZCgnV0lUSCcpO1xuICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZChub2RlLmdldExvY2F0aW9uKCkpO1xuXG4gICAgICAgIC8vIElmIGFueSBpbnZhbGlkYXRpb25zIGV4aXN0LCBwdXNoIHRoZW0gaW50byB0aGUgcXVldWVcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuY29sb3IgJiYgdGhpcy52YWx1ZS5jb2xvci5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKCd1X2Jhc2VDb2xvcicpO1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy52YWx1ZS5jb2xvci5nZXROb3JtYWxpemVkUkdCKCkpO1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWUuZ2xvc3NpbmVzcyAmJiB0aGlzLnZhbHVlLmdsb3NzaW5lc3NbMF0gJiYgdGhpcy52YWx1ZS5nbG9zc2luZXNzWzBdLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKCdHTF9VTklGT1JNUycpO1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ3VfZ2xvc3NpbmVzcycpO1xuICAgICAgICAgICAgdmFyIGdsb3NzaW5lc3MgPSB0aGlzLnZhbHVlLmdsb3NzaW5lc3NbMF0uZ2V0Tm9ybWFsaXplZFJHQigpO1xuICAgICAgICAgICAgZ2xvc3NpbmVzcy5wdXNoKHRoaXMudmFsdWUuZ2xvc3NpbmVzc1sxXSk7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChnbG9zc2luZXNzKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcy5faWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYW55IGludmFsaWRhdGlvbnMgZXhpc3QsIHB1c2ggdGhlbSBpbnRvIHRoZSBxdWV1ZVxuICAgICAgICB0aGlzLl9wdXNoSW52YWxpZGF0aW9ucygnYmFzZUNvbG9yJyk7XG4gICAgICAgIHRoaXMuX3B1c2hJbnZhbGlkYXRpb25zKCdwb3NpdGlvbk9mZnNldCcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKHF1ZXVlW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfVxuXG59O1xuXG5NZXNoLnByb3RvdHlwZS5vbk1vdW50ID0gZnVuY3Rpb24gb25Nb3VudCAobm9kZSwgaWQpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9pZCA9IGlkO1xuXG4gICAgdGhpcy5kcmF3KCk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5vbkRpc21vdW50ID0gZnVuY3Rpb24gb25EaXNtb3VudCAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9SRU1PVkVfTUVTSCcpO1xuXG4gICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuTWVzaC5wcm90b3R5cGUub25TaG93ID0gZnVuY3Rpb24gb25TaG93ICgpIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9NRVNIX1ZJU0lCSUxJVFknLCB0cnVlKTtcblxuICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbk1lc2gucHJvdG90eXBlLm9uSGlkZSA9IGZ1bmN0aW9uIG9uSGlkZSAoKSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfTUVTSF9WSVNJQklMSVRZJywgZmFsc2UpO1xuXG4gICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBSZWNlaXZlcyB0cmFuc2Zvcm0gY2hhbmdlIHVwZGF0ZXMgZnJvbSB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiBvblRyYW5zZm9ybUNoYW5nZSAodHJhbnNmb3JtKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX1VOSUZPUk1TJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ3VfdHJhbnNmb3JtJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2godHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIFJlY2VpdmVzIHNpemUgY2hhbmdlIHVwZGF0ZXMgZnJvbSB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUub25TaXplQ2hhbmdlID0gZnVuY3Rpb24gb25TaXplQ2hhbmdlIChzaXplKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX1VOSUZPUk1TJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ3Vfc2l6ZScpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHNpemUpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgb3BhY2l0eSBjaGFuZ2UgdXBkYXRlcyBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5vbk9wYWNpdHlDaGFuZ2UgPSBmdW5jdGlvbiBvbk9wYWNpdHlDaGFuZ2UgKG9wYWNpdHkpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgndV9vcGFjaXR5Jyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2gob3BhY2l0eSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuTWVzaC5wcm90b3R5cGUub25BZGRVSUV2ZW50ID0gZnVuY3Rpb24gb25BZGRVSUV2ZW50IChVSUV2ZW50KSB7XG4gICAgLy9UT0RPXG59O1xuXG5NZXNoLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZSA9IGZ1bmN0aW9uIF9yZXF1ZXN0VXBkYXRlICgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuTWVzaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLm9uVHJhbnNmb3JtQ2hhbmdlKHRoaXMuX25vZGUuZ2V0VHJhbnNmb3JtKCkpO1xuICAgIHRoaXMub25TaXplQ2hhbmdlKHRoaXMuX25vZGUuZ2V0U2l6ZSgpKTtcbiAgICB0aGlzLm9uT3BhY2l0eUNoYW5nZSh0aGlzLl9ub2RlLmdldE9wYWNpdHkoKSk7XG4gICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIGRyYXcgKCkge1xuICAgIHRoaXMuX2luRHJhdyA9IHRydWU7XG5cbiAgICB0aGlzLmluaXQoKTtcblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICAgIGlmICh2YWx1ZS5nZW9tZXRyeSAhPSBudWxsKSB0aGlzLnNldEdlb21ldHJ5KHZhbHVlLmdlb21ldHJ5KTtcbiAgICBpZiAodmFsdWUuY29sb3IgIT0gbnVsbCkgdGhpcy5zZXRCYXNlQ29sb3IodmFsdWUuY29sb3IpO1xuICAgIGlmICh2YWx1ZS5nbG9zc2luZXNzICE9IG51bGwpIHRoaXMuc2V0R2xvc3NpbmVzcy5hcHBseSh0aGlzLCB2YWx1ZS5nbG9zc2luZXNzKTtcbiAgICBpZiAodmFsdWUuZHJhd09wdGlvbnMgIT0gbnVsbCkgdGhpcy5zZXREcmF3T3B0aW9ucyh2YWx1ZS5kcmF3T3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlLmZsYXRTaGFkaW5nICE9IG51bGwpIHRoaXMuc2V0RmxhdFNoYWRpbmcodmFsdWUuZmxhdFNoYWRpbmcpO1xuXG4gICAgaWYgKHZhbHVlLmV4cHJlc3Npb25zLm5vcm1hbHMgIT0gbnVsbCkgdGhpcy5zZXROb3JtYWxzKHZhbHVlLmV4cHJlc3Npb25zLm5vcm1hbHMpO1xuICAgIGlmICh2YWx1ZS5leHByZXNzaW9ucy5iYXNlQ29sb3IgIT0gbnVsbCkgdGhpcy5zZXRCYXNlQ29sb3IodmFsdWUuZXhwcmVzc2lvbnMuYmFzZUNvbG9yKTtcbiAgICBpZiAodmFsdWUuZXhwcmVzc2lvbnMuZ2xvc3NpbmVzcyAhPSBudWxsKSB0aGlzLnNldEdsb3NzaW5lc3ModmFsdWUuZXhwcmVzc2lvbnMuZ2xvc3NpbmVzcyk7XG4gICAgaWYgKHZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0ICE9IG51bGwpIHRoaXMuc2V0UG9zaXRpb25PZmZzZXQodmFsdWUuZXhwcmVzc2lvbnMucG9zaXRpb25PZmZzZXQpO1xuXG4gICAgdGhpcy5faW5EcmF3ID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc2g7IiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWVzaDogcmVxdWlyZSgnLi9NZXNoJyksXG4gICAgUG9pbnRMaWdodDogcmVxdWlyZSgnLi9saWdodHMvUG9pbnRMaWdodCcpLFxuICAgIEFtYmllbnRMaWdodDogcmVxdWlyZSgnLi9saWdodHMvQW1iaWVudExpZ2h0JyksXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpZ2h0ID0gcmVxdWlyZSgnLi9MaWdodCcpO1xuXG4vKipcbiAqIEFtYmllbnRMaWdodCBleHRlbmRzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIExpZ2h0LiBJdCBzZXRzIHRoZSBhbWJpZW5jZSBpblxuICogdGhlIHNjZW5lLiBBbWJpZW5jZSBpcyBhIGxpZ2h0IHNvdXJjZSB0aGF0IGVtaXRzIGxpZ2h0IGluIHRoZSBlbnRpcmVcbiAqIHNjZW5lLCBldmVubHkuXG4gKlxuICogQGNsYXNzIEFtYmllbnRMaWdodFxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkXG4gKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlXG4gKi9cbmZ1bmN0aW9uIEFtYmllbnRMaWdodChub2RlKSB7XG4gICAgTGlnaHQuY2FsbCh0aGlzLCBub2RlKTtcbiAgICB0aGlzLmNvbW1hbmRzLmNvbG9yID0gJ0dMX0FNQklFTlRfTElHSFQnO1xufVxuXG4vKipcbiogUmV0dXJucyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgQ2xhc3M6ICdBbWJpZW50TGlnaHQnXG4qXG4qIEBtZXRob2QgdG9TdHJpbmdcbiogQHJldHVybiB7c3RyaW5nfSBkZWZpbml0aW9uXG4qL1xuQW1iaWVudExpZ2h0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQW1iaWVudExpZ2h0Jztcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBMaWdodCBjb25zdHJ1Y3RvclxuICovXG5BbWJpZW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaWdodC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgQW1iaWVudExpZ2h0IGFzIHRoZSBjb25zdHJ1Y3RvclxuICovXG5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW1iaWVudExpZ2h0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFtYmllbnRMaWdodDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIGJsdWVwcmludCBmb3IgYWxsIGxpZ2h0IGNvbXBvbmVudHMgZm9yIGluaGVyaXRpbmcgY29tbW9uIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQGNsYXNzIExpZ2h0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgY29udHJvbGxpbmcgbm9kZVxuICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZVxuICovXG5mdW5jdGlvbiBMaWdodChub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2NvbG9yO1xuICAgIHRoaXMuY29tbWFuZHMgPSB7IGNvbG9yOiAnR0xfTElHSFRfQ09MT1InIH07XG59XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBDbGFzczogJ0xpZ2h0J1xuKlxuKiBAbWV0aG9kIHRvU3RyaW5nXG4qIEByZXR1cm4ge1N0cmluZ30gZGVmaW5pdGlvblxuKi9cbkxpZ2h0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnTGlnaHQnO1xufTtcblxuLyoqXG4qIENoYW5nZXMgdGhlIGNvbG9yIG9mIHRoZSBsaWdodCwgdXNpbmcgdGhlICdDb2xvcicgdXRpbGl0eSBjb21wb25lbnQuXG4qXG4qIEBtZXRob2Qgc2V0Q29sb3JcbiogQHBhcmFtIHtDb2xvcn0gQ29sb3IgaW5zdGFuY2VcbiogQGNoYWluYWJsZVxuKi9cbkxpZ2h0LnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uIHNldENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvci5nZXROb3JtYWxpemVkUkdCKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMucXVldWUucHVzaCh0aGlzLmNvbW1hbmRzLmNvbG9yKTtcbiAgICB2YXIgcmdiID0gdGhpcy5fY29sb3IuZ2V0Tm9ybWFsaXplZFJHQigpO1xuICAgIHRoaXMucXVldWUucHVzaChyZ2JbMF0pO1xuICAgIHRoaXMucXVldWUucHVzaChyZ2JbMV0pO1xuICAgIHRoaXMucXVldWUucHVzaChyZ2JbMl0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGN1cnJlbnQgY29sb3IuXG5cbiogQG1ldGhvZCBnZXRDb2xvclxuKiBAcmV0dXJucyB7Q29sb3J9IENvbG9yLlxuKi9cbkxpZ2h0LnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbn07XG5cbi8qKlxuKiBTZW5kcyBkcmF3IGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlclxuKlxuKiBAcHJpdmF0ZVxuKiBAbWV0aG9kIG9uVXBkYXRlXG4qL1xuTGlnaHQucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLl9ub2RlLmdldExvY2F0aW9uKCk7XG5cbiAgICB0aGlzLl9ub2RlXG4gICAgICAgIC5zZW5kRHJhd0NvbW1hbmQoJ1dJVEgnKVxuICAgICAgICAuc2VuZERyYXdDb21tYW5kKHBhdGgpO1xuXG4gICAgdmFyIGkgPSB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMucXVldWUuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbG9yICYmIHRoaXMuX2NvbG9yLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5jb21tYW5kcy5jb2xvcik7XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLl9jb2xvci5nZXROb3JtYWxpemVkUkdCKCk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHJnYlswXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHJnYlsxXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHJnYlsyXSk7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcy5faWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpZ2h0ID0gcmVxdWlyZSgnLi9MaWdodCcpO1xuXG4vKipcbiAqIFBvaW50TGlnaHQgZXh0ZW5kcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBMaWdodC4gUG9pbnRMaWdodCBpcyBhIGxpZ2h0IHNvdXJjZVxuICogdGhhdCBlbWl0cyBsaWdodCBpbiBhbGwgZGlyZWN0aW9ucyBmcm9tIGEgcG9pbnQgaW4gc3BhY2UuXG4gKlxuICogQGNsYXNzIFBvaW50TGlnaHRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZFxuICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZVxuICovXG5mdW5jdGlvbiBQb2ludExpZ2h0KG5vZGUpIHtcbiAgICBMaWdodC5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIHRoaXMuY29tbWFuZHMucG9zaXRpb24gPSAnR0xfTElHSFRfUE9TSVRJT04nO1xuICAgIHRoaXMub25UcmFuc2Zvcm1DaGFuZ2Uobm9kZS5nZXRUcmFuc2Zvcm0oKSk7XG59XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBDbGFzczogJ1BvaW50TGlnaHQnXG4qXG4qIEBtZXRob2QgdG9TdHJpbmdcbiogQHJldHVybiB7c3RyaW5nfSBkZWZpbml0aW9uXG4qL1xuUG9pbnRMaWdodC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1BvaW50TGlnaHQnO1xufTtcblxuLyoqXG4gKiBFeHRlbmRzIExpZ2h0IGNvbnN0cnVjdG9yXG4gKi9cblBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaWdodC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgUG9pbnRMaWdodCBhcyB0aGUgY29uc3RydWN0b3JcbiAqL1xuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0O1xuXG4vKipcbiAqIFJlY2VpdmVzIHRyYW5zZm9ybSBjaGFuZ2UgdXBkYXRlcyBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5Qb2ludExpZ2h0LnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHJhbnNmb3JtQ2hhbmdlICh0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucXVldWUucHVzaCh0aGlzLmNvbW1hbmRzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnF1ZXVlLnB1c2godHJhbnNmb3JtWzEyXSk7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHRyYW5zZm9ybVsxM10pO1xuICAgIHRoaXMucXVldWUucHVzaCh0cmFuc2Zvcm1bMTRdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRMaWdodDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQnVmZmVyIGlzIGEgcHJpdmF0ZSBjbGFzcyB0aGF0IHdyYXBzIHRoZSB2ZXJ0ZXggZGF0YSB0aGF0IGRlZmluZXNcbiAqIHRoZSB0aGUgcG9pbnRzIG9mIHRoZSB0cmlhbmdsZXMgdGhhdCB3ZWJnbCBkcmF3cy4gRWFjaCBidWZmZXIgXG4gKiBtYXBzIHRvIG9uZSBhdHRyaWJ1dGUgb2YgYSBtZXNoLlxuICogXG4gKiBAY2xhc3MgQnVmZmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldCBUaGUgYmluZCB0YXJnZXQgb2YgdGhlIGJ1ZmZlciB0byB1cGRhdGU6IEFSUkFZX0JVRkZFUiBvciBFTEVNRU5UX0FSUkFZX0JVRkZFUlxuICogQHBhcmFtIHtPYmplY3R9IHR5cGUgQXJyYXkgdHlwZSB0byBiZSB1c2VkIGluIGNhbGxzIHRvIGdsLmJ1ZmZlckRhdGEuXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dH0gZ2wgVGhlIFdlYkdMIGNvbnRleHQgdGhhdCB0aGUgYnVmZmVyIGlzIGhvc3RlZCBieS5cbiAqIFxuICovXG5mdW5jdGlvbiBCdWZmZXIodGFyZ2V0LCB0eXBlLCBnbCkge1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuZ2wgPSBnbDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgV2ViR0wgYnVmZmVyIGlmIG9uZSBkb2VzIG5vdCB5ZXQgZXhpc3QgYW5kIGJpbmRzIHRoZSBidWZmZXIgdG9cbiAqIHRvIHRoZSBjb250ZXh0LiAgUnVucyBidWZmZXJEYXRhIHdpdGggYXBwcm9wcmlhdGUgZGF0YS5cbiAqIFxuICogQG1ldGhvZCBzdWJEYXRhXG4gKiBcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5zdWJEYXRhID0gZnVuY3Rpb24gc3ViRGF0YSgpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBkYXRhID0gW107XG5cbiAgICAvLyB0byBwcmV2ZW50IGFnYWluc3QgbWF4aW11bSBjYWxsLXN0YWNrIGlzc3VlLlxuICAgIGZvciAodmFyIGkgPSAwLCBjaHVuayA9IDEwMDAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSBjaHVuaylcbiAgICAgICAgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoZGF0YSwgdGhpcy5kYXRhLnNsaWNlKGksIGkgKyBjaHVuaykpO1xuXG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlciB8fCBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YSh0aGlzLnRhcmdldCwgbmV3IHRoaXMudHlwZShkYXRhKSwgZ2wuU1RBVElDX0RSQVcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSU5ESUNFUyA9ICdpbmRpY2VzJztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vQnVmZmVyJyk7XG5cbi8qKlxuICogQnVmZmVyUmVnaXN0cnkgaXMgYSBjbGFzcyB0aGF0IG1hbmFnZXMgYWxsb2NhdGlvbiBvZiBidWZmZXJzIHRvXG4gKiBpbnB1dCBnZW9tZXRyaWVzLlxuICogXG4gKiBAY2xhc3MgQnVmZmVyUmVnaXN0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dH0gY29udGV4dCBXZWJHTCBkcmF3aW5nIGNvbnRleHQgdG8gYmUgcGFzc2VkIHRvIGJ1ZmZlcnMuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlZ2lzdHJ5KGNvbnRleHQpIHtcbiAgICB0aGlzLmdsID0gY29udGV4dDtcblxuICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLl9keW5hbWljQnVmZmVycyA9IFtdO1xuICAgIHRoaXMuX3N0YXRpY0J1ZmZlcnMgPSBbXTtcbiAgICBcbiAgICB0aGlzLl9hcnJheUJ1ZmZlck1heCA9IDMwMDAwO1xuICAgIHRoaXMuX2VsZW1lbnRCdWZmZXJNYXggPSAzMDAwMDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbmQgZmlsbHMgYWxsIHRoZSB2ZXJ0ZXggZGF0YSBpbnRvIHdlYmdsIGJ1ZmZlcnMuICBXaWxsIHJldXNlIGJ1ZmZlcnMgaWZcbiAqIHBvc3NpYmxlLiAgUG9wdWxhdGVzIHJlZ2lzdHJ5IHdpdGggdGhlIG5hbWUgb2YgdGhlIGJ1ZmZlciwgdGhlIFdlYkdMIGJ1ZmZlclxuICogb2JqZWN0LCBzcGFjaW5nIG9mIHRoZSBhdHRyaWJ1dGUsIHRoZSBhdHRyaWJ1dGUncyBvZmZzZXQgd2l0aGluIHRoZSBidWZmZXIsIFxuICogYW5kIGZpbmFsbHkgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLiAgVGhpcyBpbmZvcm1hdGlvbiBpcyBsYXRlciBhY2Nlc3NlZCBieVxuICogdGhlIHJvb3QgdG8gZHJhdyB0aGUgYnVmZmVycy5cbiAqXG4gKiBAbWV0aG9kIGFsbG9jYXRlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGdlb21ldHJ5SWQgSWQgb2YgdGhlIGdlb21ldHJ5IGluc3RhbmNlIHRoYXQgaG9sZHMgdGhlIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBLZXkgb2YgdGhlIGlucHV0IGJ1ZmZlciBpbiB0aGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBGbGF0IGFycmF5IGNvbnRhaW5pbmcgaW5wdXQgZGF0YSBmb3IgYnVmZmVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYWNpbmcgVGhlIHNwYWNpbmcsIG9yIGl0ZW1TaXplLCBvZiB0aGUgaW5wdXQgYnVmZmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBkeW5hbWljIEJvb2xlYW4gZGVub3Rpbmcgd2hldGhlciBhIGdlb21ldHJ5IGlzIGR5bmFtaWMgb3Igc3RhdGljLlxuICovXG5CdWZmZXJSZWdpc3RyeS5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZShnZW9tZXRyeUlkLCBuYW1lLCB2YWx1ZSwgc3BhY2luZywgZHluYW1pYykge1xuICAgIHZhciB2ZXJ0ZXhCdWZmZXJzID0gdGhpcy5yZWdpc3RyeVtnZW9tZXRyeUlkXSB8fCAodGhpcy5yZWdpc3RyeVtnZW9tZXRyeUlkXSA9IHsga2V5czogW10sIHZhbHVlczogW10sIHNwYWNpbmc6IFtdLCBvZmZzZXQ6IFtdLCBsZW5ndGg6IFtdIH0pO1xuXG4gICAgdmFyIGogPSB2ZXJ0ZXhCdWZmZXJzLmtleXMuaW5kZXhPZihuYW1lKTtcbiAgICB2YXIgaXNJbmRleCA9IG5hbWUgPT09IElORElDRVM7XG4gICAgdmFyIGJ1ZmZlckZvdW5kID0gZmFsc2U7XG4gICAgdmFyIG5ld09mZnNldDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgbGVuZ3RoO1xuICAgIHZhciBidWZmZXI7XG4gICAgdmFyIGs7XG5cbiAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgaiA9IHZlcnRleEJ1ZmZlcnMua2V5cy5sZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IGlzSW5kZXggPyB2YWx1ZS5sZW5ndGggOiBNYXRoLmZsb29yKHZhbHVlLmxlbmd0aCAvIHNwYWNpbmcpO1xuXG4gICAgICAgIGlmICghZHluYW1pYykge1xuXG4gICAgICAgICAgICAvLyBVc2UgYSBwcmV2aW91c2x5IGNyZWF0ZWQgYnVmZmVyIGlmIGF2YWlsYWJsZS5cblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHRoaXMuX3N0YXRpY0J1ZmZlcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmRleCA9PT0gdGhpcy5fc3RhdGljQnVmZmVyc1trXS5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09mZnNldCA9IHRoaXMuX3N0YXRpY0J1ZmZlcnNba10ub2Zmc2V0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCFpc0luZGV4ICYmIG5ld09mZnNldCA8IHRoaXMuX2FycmF5QnVmZmVyTWF4KSB8fCAoaXNJbmRleCAmJiBuZXdPZmZzZXQgPCB0aGlzLl9lbGVtZW50QnVmZmVyTWF4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5fc3RhdGljQnVmZmVyc1trXS5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9zdGF0aWNCdWZmZXJzW2tdLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRpY0J1ZmZlcnNba10ub2Zmc2V0ICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RhdGljIGJ1ZmZlciBpbiBub25lIHdlcmUgZm91bmQuXG5cbiAgICAgICAgICAgIGlmICghYnVmZmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKFxuICAgICAgICAgICAgICAgICAgICBpc0luZGV4ID8gdGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IHRoaXMuZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgICAgICAgICAgICAgICBpc0luZGV4ID8gVWludDE2QXJyYXkgOiBGbG9hdDMyQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGljQnVmZmVycy5wdXNoKHsgYnVmZmVyOiBidWZmZXIsIG9mZnNldDogdmFsdWUubGVuZ3RoLCBpc0luZGV4OiBpc0luZGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBGb3IgZHluYW1pYyBnZW9tZXRyaWVzLCBhbHdheXMgY3JlYXRlIG5ldyBidWZmZXIuXG5cbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoXG4gICAgICAgICAgICAgICAgaXNJbmRleCA/IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiB0aGlzLmdsLkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICBpc0luZGV4ID8gVWludDE2QXJyYXkgOiBGbG9hdDMyQXJyYXksXG4gICAgICAgICAgICAgICAgdGhpcy5nbFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0J1ZmZlcnMucHVzaCh7IGJ1ZmZlcjogYnVmZmVyLCBvZmZzZXQ6IHZhbHVlLmxlbmd0aCwgaXNJbmRleDogaXNJbmRleCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVnaXN0cnkgZm9yIHRoZSBzcGVjIHdpdGggYnVmZmVyIGluZm9ybWF0aW9uLlxuXG4gICAgICAgIHZlcnRleEJ1ZmZlcnMua2V5cy5wdXNoKG5hbWUpO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLnZhbHVlcy5wdXNoKGJ1ZmZlcik7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnMuc3BhY2luZy5wdXNoKHNwYWNpbmcpO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLm9mZnNldC5wdXNoKG9mZnNldCk7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnMubGVuZ3RoLnB1c2gobGVuZ3RoKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgdmVydGV4QnVmZmVycy52YWx1ZXNbal0uZGF0YVtvZmZzZXQgKyBrXSA9IHZhbHVlW2tdO1xuICAgIH1cbiAgICB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tqXS5zdWJEYXRhKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlZ2lzdHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBUYWtlcyB0aGUgb3JpZ2luYWwgcmVuZGVyaW5nIGNvbnRleHRzJyBjb21waWxlciBmdW5jdGlvblxuICogYW5kIGF1Z21lbnRzIGl0IHdpdGggYWRkZWQgZnVuY3Rpb25hbGl0eSBmb3IgcGFyc2luZyBhbmRcbiAqIGRpc3BsYXlpbmcgZXJyb3JzLlxuICpcbiAqIEBtZXRob2QgZGVidWdcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGVidWcoKSB7XG4gICAgcmV0dXJuIF9hdWdtZW50RnVuY3Rpb24oXG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcixcbiAgICAgICAgZnVuY3Rpb24oc2hhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gdGhpcy5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U2hhZGVyU291cmNlKHNoYWRlcik7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NFcnJvcnMoZXJyb3JzLCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn07XG5cbi8vIFRha2VzIGEgZnVuY3Rpb24sIGtlZXBzIHRoZSByZWZlcmVuY2UgYW5kIHJlcGxhY2VzIGl0IGJ5IGEgY2xvc3VyZSB0aGF0XG4vLyBleGVjdXRlcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYW5kIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cblxuZnVuY3Rpb24gX2F1Z21lbnRGdW5jdGlvbihmdW5jLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlcyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuXG4vLyBQYXJzZXMgZXJyb3JzIGFuZCBmYWlsZWQgc291cmNlIGNvZGUgZnJvbSBzaGFkZXJzIGluIG9yZGVyXG4vLyB0byBidWlsZCBkaXNwbGF5YWJsZSBlcnJvciBibG9ja3MuXG4vLyBJbnNwaXJlZCBieSBKYXVtZSBTYW5jaGV6IEVsaWFzLlxuXG5mdW5jdGlvbiBfcHJvY2Vzc0Vycm9ycyhlcnJvcnMsIHNvdXJjZSkge1xuXG4gICAgdmFyIGNzcyA9ICdib2R5LGh0bWx7YmFja2dyb3VuZDojZTNlM2UzO2ZvbnQtZmFtaWx5Om1vbmFjbyxtb25vc3BhY2U7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS43ZW19JyArXG4gICAgICAgICAgICAgICcjc2hhZGVyUmVwb3J0e2xlZnQ6MDt0b3A6MDtyaWdodDowO2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjEwMDA7Y29sb3I6JyArXG4gICAgICAgICAgICAgICcjMjIyO3BhZGRpbmc6MTVweDt3aGl0ZS1zcGFjZTpub3JtYWw7bGlzdC1zdHlsZS10eXBlOm5vbmU7bWFyZ2luOjUwcHggYXV0bzttYXgtd2lkdGg6MTIwMHB4fScgK1xuICAgICAgICAgICAgICAnI3NoYWRlclJlcG9ydCBsaXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7bWFyZ2luOjEzcHggMDtib3gtc2hhZG93OjAgMXB4IDJweCByZ2JhKDAsMCwwLC4xNSk7JyArXG4gICAgICAgICAgICAgICdwYWRkaW5nOjIwcHggMzBweDtib3JkZXItcmFkaXVzOjJweDtib3JkZXItbGVmdDoyMHB4IHNvbGlkICNlMDExMTF9c3Bhbntjb2xvcjojZTAxMTExOycgK1xuICAgICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTtmb250LXdlaWdodDo3MDB9I3NoYWRlclJlcG9ydCBsaSBwe3BhZGRpbmc6MDttYXJnaW46MH0nICtcbiAgICAgICAgICAgICAgJyNzaGFkZXJSZXBvcnQgbGk6bnRoLWNoaWxkKGV2ZW4pe2JhY2tncm91bmQtY29sb3I6I2Y0ZjRmNH0nICtcbiAgICAgICAgICAgICAgJyNzaGFkZXJSZXBvcnQgbGkgcDpmaXJzdC1jaGlsZHttYXJnaW4tYm90dG9tOjEwcHg7Y29sb3I6IzY2Nn0nO1xuXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsKTtcbiAgICBlbC50ZXh0Q29udGVudCA9IGNzcztcblxuICAgIHZhciByZXBvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIHJlcG9ydC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3NoYWRlclJlcG9ydCcpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVwb3J0KTtcblxuICAgIHZhciByZSA9IC9FUlJPUjogW1xcZF0rOihbXFxkXSspOiAoLispL2dtaTtcbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuXG4gICAgdmFyIG07XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyhlcnJvcnMpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtLmluZGV4ID09PSByZS5sYXN0SW5kZXgpIHJlLmxhc3RJbmRleCsrO1xuICAgICAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICB2YXIgY29kZSA9ICc8cD48c3Bhbj5FUlJPUjwvc3Bhbj4gXCInICsgbVsyXSArICdcIiBpbiBsaW5lICcgKyBtWzFdICsgJzwvcD4nO1xuICAgICAgICBjb2RlICs9ICc8cD48Yj4nICsgbGluZXNbbVsxXSAtIDFdLnJlcGxhY2UoL15bIFxcdF0rL2csICcnKSArICc8L2I+PC9wPic7XG4gICAgICAgIGxpLmlubmVySFRNTCA9IGNvZGU7XG4gICAgICAgIHJlcG9ydC5hcHBlbmRDaGlsZChsaSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNsb25lID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2Nsb25lJyk7XG52YXIga2V5VmFsdWVUb0FycmF5cyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9rZXlWYWx1ZVRvQXJyYXlzJyk7XG5cbnZhciB2ZXJ0ZXhXcmFwcGVyID0gcmVxdWlyZSgnLi4vd2ViZ2wtc2hhZGVycycpLnZlcnRleDtcbnZhciBmcmFnbWVudFdyYXBwZXIgPSByZXF1aXJlKCcuLi93ZWJnbC1zaGFkZXJzJykuZnJhZ21lbnQ7XG52YXIgRGVidWcgPSByZXF1aXJlKCcuL0RlYnVnJyk7XG5cbnZhciBWRVJURVhfU0hBREVSID0gMzU2MzM7XG52YXIgRlJBR01FTlRfU0hBREVSID0gMzU2MzI7XG52YXIgaWRlbnRpdHlNYXRyaXggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG5cbnZhciBoZWFkZXIgPSAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuJztcblxudmFyIFRZUEVTID0ge1xuICAgIHVuZGVmaW5lZDogJ2Zsb2F0ICcsXG4gICAgMTogJ2Zsb2F0ICcsXG4gICAgMjogJ3ZlYzIgJyxcbiAgICAzOiAndmVjMyAnLFxuICAgIDQ6ICd2ZWM0ICcsXG4gICAgMTY6ICdtYXQ0ICdcbn07XG5cbnZhciBpbnB1dFR5cGVzID0ge1xuICAgIHVfYmFzZUNvbG9yOiAndmVjNCcsXG4gICAgdV9ub3JtYWxzOiAndmVydCcsXG4gICAgdV9nbG9zc2luZXNzOiAndmVjNCcsXG4gICAgdV9wb3NpdGlvbk9mZnNldDogJ3ZlcnQnXG59O1xuXG52YXIgbWFza3MgPSAge1xuICAgIHZlcnQ6IDEsXG4gICAgdmVjMzogMixcbiAgICB2ZWM0OiA0LFxuICAgIGZsb2F0OiA4XG59O1xuXG4vKipcbiAqIFVuaWZvcm0ga2V5cyBhbmQgdmFsdWVzXG4gKi9cbnZhciB1bmlmb3JtcyA9IGtleVZhbHVlVG9BcnJheXMoe1xuICAgIHVfcGVyc3BlY3RpdmU6IGlkZW50aXR5TWF0cml4LFxuICAgIHVfdmlldzogaWRlbnRpdHlNYXRyaXgsXG4gICAgdV9yZXNvbHV0aW9uOiBbMCwgMCwgMF0sXG4gICAgdV90cmFuc2Zvcm06IGlkZW50aXR5TWF0cml4LFxuICAgIHVfc2l6ZTogWzEsIDEsIDFdLFxuICAgIHVfdGltZTogMCxcbiAgICB1X29wYWNpdHk6IDEsXG4gICAgdV9tZXRhbG5lc3M6IDAsXG4gICAgdV9nbG9zc2luZXNzOiBbMCwgMCwgMCwgMF0sXG4gICAgdV9iYXNlQ29sb3I6IFsxLCAxLCAxLCAxXSxcbiAgICB1X25vcm1hbHM6IFsxLCAxLCAxXSxcbiAgICB1X3Bvc2l0aW9uT2Zmc2V0OiBbMCwgMCwgMF0sXG4gICAgdV9saWdodFBvc2l0aW9uOiBpZGVudGl0eU1hdHJpeCxcbiAgICB1X2xpZ2h0Q29sb3I6IGlkZW50aXR5TWF0cml4LFxuICAgIHVfYW1iaWVudExpZ2h0OiBbMCwgMCwgMF0sXG4gICAgdV9mbGF0U2hhZGluZzogMCxcbiAgICB1X251bUxpZ2h0czogMFxufSk7XG5cbi8qKlxuICogQXR0cmlidXRlcyBrZXlzIGFuZCB2YWx1ZXNcbiAqL1xudmFyIGF0dHJpYnV0ZXMgPSBrZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICBhX3BvczogWzAsIDAsIDBdLFxuICAgIGFfdGV4Q29vcmQ6IFswLCAwXSxcbiAgICBhX25vcm1hbHM6IFswLCAwLCAwXVxufSk7XG5cbi8qKlxuICogVmFyeWluZ3Mga2V5cyBhbmQgdmFsdWVzXG4gKi9cbnZhciB2YXJ5aW5ncyA9IGtleVZhbHVlVG9BcnJheXMoe1xuICAgIHZfdGV4dHVyZUNvb3JkaW5hdGU6IFswLCAwXSxcbiAgICB2X25vcm1hbDogWzAsIDAsIDBdLFxuICAgIHZfcG9zaXRpb246IFswLCAwLCAwXSxcbiAgICB2X2V5ZVZlY3RvcjogWzAsIDAsIDBdXG59KTtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgaGFuZGxlcyBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgV2ViR0wgc2hhZGVyIHByb2dyYW1cbiAqIHVzZWQgYnkgYSBzcGVjaWZpYyBjb250ZXh0LiAgSXQgbWFuYWdlcyBjcmVhdGlvbiBvZiB0aGUgc2hhZGVyIHByb2dyYW1cbiAqIGFuZCB0aGUgYXR0YWNoZWQgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLiAgSXQgaXMgYWxzbyBpbiBjaGFyZ2Ugb2ZcbiAqIHBhc3NpbmcgYWxsIHVuaWZvcm1zIHRvIHRoZSBXZWJHTENvbnRleHQuXG4gKlxuICogQGNsYXNzIFByb2dyYW1cbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7V2ViR0xfQ29udGV4dH0gZ2wgQ29udGV4dCB0byBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gKi9cbmZ1bmN0aW9uIFByb2dyYW0oZ2wsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy50ZXh0dXJlU2xvdHMgPSAxO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnJlZ2lzdGVyZWRNYXRlcmlhbHMgPSB7fTtcbiAgICB0aGlzLmZsYWdnZWRVbmlmb3JtcyA9IFtdO1xuICAgIHRoaXMuY2FjaGVkVW5pZm9ybXMgID0ge307XG4gICAgdGhpcy51bmlmb3JtVHlwZXMgPSBbXTtcblxuICAgIHRoaXMuZGVmaW5pdGlvblZlYzQgPSBbXTtcbiAgICB0aGlzLmRlZmluaXRpb25WZWMzID0gW107XG4gICAgdGhpcy5kZWZpbml0aW9uRmxvYXQgPSBbXTtcbiAgICB0aGlzLmFwcGxpY2F0aW9uVmVjMyA9IFtdO1xuICAgIHRoaXMuYXBwbGljYXRpb25WZWM0ID0gW107XG4gICAgdGhpcy5hcHBsaWNhdGlvbkZsb2F0ID0gW107XG4gICAgdGhpcy5hcHBsaWNhdGlvblZlcnQgPSBbXTtcbiAgICB0aGlzLmRlZmluaXRpb25WZXJ0ID0gW107XG5cbiAgICB0aGlzLnJlc2V0UHJvZ3JhbSgpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIG1hdGVyaWFsIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCB0b1xuICogdGhlIHNoYWRlciBwcm9ncmFtLlxuICpcbiAqIEBtZXRob2QgcmVnaXN0ZXJNYXRlcmlhbFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGFyZ2V0IGlucHV0IG9mIG1hdGVyaWFsLlxuICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsIENvbXBpbGVkIG1hdGVyaWFsIG9iamVjdCBiZWluZyB2ZXJpZmllZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgcHJvZ3JhbS5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUucmVnaXN0ZXJNYXRlcmlhbCA9IGZ1bmN0aW9uIHJlZ2lzdGVyTWF0ZXJpYWwobmFtZSwgbWF0ZXJpYWwpIHtcbiAgICB2YXIgY29tcGlsZWQgPSBtYXRlcmlhbDtcbiAgICB2YXIgdHlwZSA9IGlucHV0VHlwZXNbbmFtZV07XG4gICAgdmFyIG1hc2sgPSBtYXNrc1t0eXBlXTtcblxuICAgIGlmICgodGhpcy5yZWdpc3RlcmVkTWF0ZXJpYWxzW21hdGVyaWFsLl9pZF0gJiBtYXNrKSA9PT0gbWFzaykgcmV0dXJuO1xuXG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gY29tcGlsZWQudW5pZm9ybXMpIHtcbiAgICAgICAgaWYgKHVuaWZvcm1zLmtleXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHVuaWZvcm1zLmtleXMucHVzaChrKTtcbiAgICAgICAgICAgIHVuaWZvcm1zLnZhbHVlcy5wdXNoKGNvbXBpbGVkLnVuaWZvcm1zW2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoayBpbiBjb21waWxlZC52YXJ5aW5ncykge1xuICAgICAgICBpZiAodmFyeWluZ3Mua2V5cy5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICAgICAgdmFyeWluZ3Mua2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgdmFyeWluZ3MudmFsdWVzLnB1c2goY29tcGlsZWQudmFyeWluZ3Nba10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrIGluIGNvbXBpbGVkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMua2V5cy5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5rZXlzLnB1c2goayk7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnZhbHVlcy5wdXNoKGNvbXBpbGVkLmF0dHJpYnV0ZXNba10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZWdpc3RlcmVkTWF0ZXJpYWxzW21hdGVyaWFsLl9pZF0gfD0gbWFzaztcblxuICAgIGlmICh0eXBlID09PSAnZmxvYXQnKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbkZsb2F0LnB1c2gobWF0ZXJpYWwuZGVmaW5lcyk7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbkZsb2F0LnB1c2goJ2Zsb2F0IGZhXycgKyBtYXRlcmlhbC5faWQgKyAnKCkge1xcbiAnICArIGNvbXBpbGVkLmdsc2wgKyAnIFxcbn0nKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbkZsb2F0LnB1c2goJ2lmIChpbnQoYWJzKElEKSkgPT0gJyArIG1hdGVyaWFsLl9pZCArICcpIHJldHVybiBmYV8nICsgbWF0ZXJpYWwuX2lkICArICcoKTsnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3ZlYzMnKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlYzMucHVzaChtYXRlcmlhbC5kZWZpbmVzKTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uVmVjMy5wdXNoKCd2ZWMzIGZhXycgKyBtYXRlcmlhbC5faWQgKyAnKCkge1xcbiAnICArIGNvbXBpbGVkLmdsc2wgKyAnIFxcbn0nKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvblZlYzMucHVzaCgnaWYgKGludChhYnMoSUQueCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCArICcoKTsnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3ZlYzQnKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlYzQucHVzaChtYXRlcmlhbC5kZWZpbmVzKTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uVmVjNC5wdXNoKCd2ZWM0IGZhXycgKyBtYXRlcmlhbC5faWQgKyAnKCkge1xcbiAnICArIGNvbXBpbGVkLmdsc2wgKyAnIFxcbn0nKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvblZlYzQucHVzaCgnaWYgKGludChhYnMoSUQueCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCArICcoKTsnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3ZlcnQnKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlcnQucHVzaChtYXRlcmlhbC5kZWZpbmVzKTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uVmVydC5wdXNoKCd2ZWMzIGZhXycgKyBtYXRlcmlhbC5faWQgKyAnKCkge1xcbiAnICArIGNvbXBpbGVkLmdsc2wgKyAnIFxcbn0nKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvblZlcnQucHVzaCgnaWYgKGludChhYnMoSUQueCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCArICcoKTsnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNldFByb2dyYW0oKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIGFsbCBjYWNoZWQgdW5pZm9ybXMgYW5kIGF0dHJpYnV0ZSBsb2NhdGlvbnMuICBBc3NlbWJsZXNcbiAqIG5ldyBmcmFnbWVudCBhbmQgdmVydGV4IHNoYWRlcnMgYW5kIGJhc2VkIG9uIG1hdGVyaWFsIGZyb21cbiAqIGN1cnJlbnRseSByZWdpc3RlcmVkIG1hdGVyaWFscy4gIEF0dGFjaGVzIHNhaWQgc2hhZGVycyB0byBuZXdcbiAqIHNoYWRlciBwcm9ncmFtIGFuZCB1cG9uIHN1Y2Nlc3MgbGlua3MgcHJvZ3JhbSB0byB0aGUgV2ViR0xcbiAqIGNvbnRleHQuXG4gKlxuICogQG1ldGhvZCByZXNldFByb2dyYW1cbiAqXG4gKiBAcmV0dXJuIHtQcm9ncmFtfSBDdXJyZW50IHByb2dyYW0uXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLnJlc2V0UHJvZ3JhbSA9IGZ1bmN0aW9uIHJlc2V0UHJvZ3JhbSgpIHtcbiAgICB2YXIgdmVydGV4SGVhZGVyID0gW2hlYWRlcl07XG4gICAgdmFyIGZyYWdtZW50SGVhZGVyID0gW2hlYWRlcl07XG5cbiAgICB2YXIgZnJhZ21lbnRTb3VyY2U7XG4gICAgdmFyIHZlcnRleFNvdXJjZTtcbiAgICB2YXIgcHJvZ3JhbTtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgICA9IFtdO1xuICAgIHRoaXMuYXR0cmlidXRlTG9jYXRpb25zID0ge307XG5cbiAgICB0aGlzLnVuaWZvcm1UeXBlcyA9IHt9O1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lcyA9IGNsb25lKGF0dHJpYnV0ZXMua2V5cyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVWYWx1ZXMgPSBjbG9uZShhdHRyaWJ1dGVzLnZhbHVlcyk7XG5cbiAgICB0aGlzLnZhcnlpbmdOYW1lcyA9IGNsb25lKHZhcnlpbmdzLmtleXMpO1xuICAgIHRoaXMudmFyeWluZ1ZhbHVlcyA9IGNsb25lKHZhcnlpbmdzLnZhbHVlcyk7XG5cbiAgICB0aGlzLnVuaWZvcm1OYW1lcyA9IGNsb25lKHVuaWZvcm1zLmtleXMpO1xuICAgIHRoaXMudW5pZm9ybVZhbHVlcyA9IGNsb25lKHVuaWZvcm1zLnZhbHVlcyk7XG5cbiAgICB0aGlzLmZsYWdnZWRVbmlmb3JtcyA9IFtdO1xuICAgIHRoaXMuY2FjaGVkVW5pZm9ybXMgPSB7fTtcblxuICAgIGZyYWdtZW50SGVhZGVyLnB1c2goJ3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZXNbN107XFxuJyk7XG5cbiAgICBpZiAodGhpcy5hcHBsaWNhdGlvblZlcnQubGVuZ3RoKSB7XG4gICAgICAgIHZlcnRleEhlYWRlci5wdXNoKCd1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVzWzddO1xcbicpO1xuICAgIH1cblxuICAgIGZvcihpID0gMDsgaSA8IHRoaXMudW5pZm9ybU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnVuaWZvcm1OYW1lc1tpXSwgdmFsdWUgPSB0aGlzLnVuaWZvcm1WYWx1ZXNbaV07XG4gICAgICAgIHZlcnRleEhlYWRlci5wdXNoKCd1bmlmb3JtICcgKyBUWVBFU1t2YWx1ZS5sZW5ndGhdICsgbmFtZSArICc7XFxuJyk7XG4gICAgICAgIGZyYWdtZW50SGVhZGVyLnB1c2goJ3VuaWZvcm0gJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gKyBuYW1lICsgJztcXG4nKTtcbiAgICB9XG5cbiAgICBmb3IoaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLmF0dHJpYnV0ZU5hbWVzW2ldLCB2YWx1ZSA9IHRoaXMuYXR0cmlidXRlVmFsdWVzW2ldO1xuICAgICAgICB2ZXJ0ZXhIZWFkZXIucHVzaCgnYXR0cmlidXRlICcgKyBUWVBFU1t2YWx1ZS5sZW5ndGhdICsgbmFtZSArICc7XFxuJyk7XG4gICAgfVxuXG4gICAgZm9yKGkgPSAwOyBpIDwgdGhpcy52YXJ5aW5nTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHRoaXMudmFyeWluZ05hbWVzW2ldLCB2YWx1ZSA9IHRoaXMudmFyeWluZ1ZhbHVlc1tpXTtcbiAgICAgICAgdmVydGV4SGVhZGVyLnB1c2goJ3ZhcnlpbmcgJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gICsgbmFtZSArICc7XFxuJyk7XG4gICAgICAgIGZyYWdtZW50SGVhZGVyLnB1c2goJ3ZhcnlpbmcgJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gKyBuYW1lICsgJztcXG4nKTtcbiAgICB9XG5cbiAgICB2ZXJ0ZXhTb3VyY2UgPSB2ZXJ0ZXhIZWFkZXIuam9pbignJykgKyB2ZXJ0ZXhXcmFwcGVyXG4gICAgICAgIC5yZXBsYWNlKCcjdmVydF9kZWZpbml0aW9ucycsIHRoaXMuZGVmaW5pdGlvblZlcnQuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjdmVydF9hcHBsaWNhdGlvbnMnLCB0aGlzLmFwcGxpY2F0aW9uVmVydC5qb2luKCdcXG4nKSk7XG5cbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50SGVhZGVyLmpvaW4oJycpICsgZnJhZ21lbnRXcmFwcGVyXG4gICAgICAgIC5yZXBsYWNlKCcjdmVjM19kZWZpbml0aW9ucycsIHRoaXMuZGVmaW5pdGlvblZlYzMuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjdmVjM19hcHBsaWNhdGlvbnMnLCB0aGlzLmFwcGxpY2F0aW9uVmVjMy5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyN2ZWM0X2RlZmluaXRpb25zJywgdGhpcy5kZWZpbml0aW9uVmVjNC5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyN2ZWM0X2FwcGxpY2F0aW9ucycsIHRoaXMuYXBwbGljYXRpb25WZWM0LmpvaW4oJ1xcbicpKVxuICAgICAgICAucmVwbGFjZSgnI2Zsb2F0X2RlZmluaXRpb25zJywgdGhpcy5kZWZpbml0aW9uRmxvYXQuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjZmxvYXRfYXBwbGljYXRpb25zJywgdGhpcy5hcHBsaWNhdGlvbkZsb2F0LmpvaW4oJ1xcbicpKTtcblxuICAgIHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKFxuICAgICAgICBwcm9ncmFtLFxuICAgICAgICB0aGlzLmNvbXBpbGVTaGFkZXIodGhpcy5nbC5jcmVhdGVTaGFkZXIoVkVSVEVYX1NIQURFUiksIHZlcnRleFNvdXJjZSlcbiAgICApO1xuXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIoXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLmdsLmNyZWF0ZVNoYWRlcihGUkFHTUVOVF9TSEFERVIpLCBmcmFnbWVudFNvdXJjZSlcbiAgICApO1xuXG4gICAgdGhpcy5nbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIGlmICghIHRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdsaW5rIGVycm9yOiAnICsgdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFVuaWZvcm1zKHRoaXMudW5pZm9ybU5hbWVzLCB0aGlzLnVuaWZvcm1WYWx1ZXMpO1xuXG4gICAgdmFyIHRleHR1cmVMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3VfdGV4dHVyZXNbMF0nKTtcbiAgICB0aGlzLmdsLnVuaWZvcm0xaXYodGV4dHVyZUxvY2F0aW9uLCBbMCwgMSwgMiwgMywgNCwgNSwgNl0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgdW5pZm9ybSB2YWx1ZSBhZ2FpbnN0XG4gKiB0aGUgY2FjaGVkIHZhbHVlIHN0b3JlZCBvbiB0aGUgUHJvZ3JhbSBjbGFzcy4gIFVwZGF0ZXMgYW5kXG4gKiBjcmVhdGVzIG5ldyBlbnRyaWVzIGluIHRoZSBjYWNoZSB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kIHVuaWZvcm1Jc0NhY2hlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXROYW1lIEtleSBvZiB1bmlmb3JtIHNwZWMgYmVpbmcgZXZhbHVhdGVkLlxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IHZhbHVlIFZhbHVlIG9mIHVuaWZvcm0gc3BlYyBiZWluZyBldmFsdWF0ZWQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gVmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB1bmlmb3JtIGJlaW5nIHNldFxuICogaXMgY2FjaGVkLlxuICovXG5Qcm9ncmFtLnByb3RvdHlwZS51bmlmb3JtSXNDYWNoZWQgPSBmdW5jdGlvbih0YXJnZXROYW1lLCB2YWx1ZSkge1xuICAgIGlmKHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFVuaWZvcm1zW3RhcmdldE5hbWVdID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFVuaWZvcm1zW3RhcmdldE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmKHZhbHVlW2ldICE9PSB0aGlzLmNhY2hlZFVuaWZvcm1zW3RhcmdldE5hbWVdW2ldKSB7XG4gICAgICAgICAgICAgICAgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZShpLS0pIHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV1baV0gPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlIGlmICh0aGlzLmNhY2hlZFVuaWZvcm1zW3RhcmdldE5hbWVdICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhY2hlZFVuaWZvcm1zW3RhcmdldE5hbWVdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhbGwgcGFzc2luZyBvZiB1bmlmb3JtcyB0byBXZWJHTCBkcmF3aW5nIGNvbnRleHQuICBUaGlzXG4gKiBmdW5jdGlvbiB3aWxsIGZpbmQgdGhlIHVuaWZvcm0gbG9jYXRpb24gYW5kIHRoZW4sIGJhc2VkIG9uXG4gKiBhIHR5cGUgaW5mZXJyZWQgZnJvbSB0aGUgamF2YXNjcmlwdCB2YWx1ZSBvZiB0aGUgdW5pZm9ybSwgaXQgd2lsbCBjYWxsXG4gKiB0aGUgYXBwcm9wcmlhdGUgZnVuY3Rpb24gdG8gcGFzcyB0aGUgdW5pZm9ybSB0byBXZWJHTC4gIEZpbmFsbHksXG4gKiBzZXRVbmlmb3JtcyB3aWxsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgcGFzc2VkIGluIHNoYWRlckNodW5rcyAoaWYgYW55KVxuICogYW5kIHNldCB0aGUgYXBwcm9wcmlhdGUgdW5pZm9ybXMgdG8gc3BlY2lmeSB3aGljaCBjaHVua3MgdG8gdXNlLlxuICpcbiAqIEBtZXRob2Qgc2V0VW5pZm9ybXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB1bmlmb3JtTmFtZXMgQXJyYXkgY29udGFpbmluZyB0aGUga2V5cyBvZiBhbGwgdW5pZm9ybXMgdG8gYmUgc2V0LlxuICogQHBhcmFtIHtBcnJheX0gdW5pZm9ybVZhbHVlIEFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiBhbGwgdW5pZm9ybXMgdG8gYmUgc2V0LlxuICpcbiAqIEByZXR1cm4ge1Byb2dyYW19IEN1cnJlbnQgcHJvZ3JhbS5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUuc2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAodW5pZm9ybU5hbWVzLCB1bmlmb3JtVmFsdWUpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBsb2NhdGlvbjtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgaTtcblxuICAgIGlmICghdGhpcy5wcm9ncmFtKSByZXR1cm47XG5cbiAgICBsZW4gPSB1bmlmb3JtTmFtZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBuYW1lID0gdW5pZm9ybU5hbWVzW2ldO1xuICAgICAgICB2YWx1ZSA9IHVuaWZvcm1WYWx1ZVtpXTtcblxuICAgICAgICAvLyBSZXRyZWl2ZSB0aGUgY2FjaGVkIGxvY2F0aW9uIG9mIHRoZSB1bmlmb3JtLFxuICAgICAgICAvLyByZXF1ZXN0aW5nIGEgbmV3IGxvY2F0aW9uIGZyb20gdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgICAgLy8gaWYgaXQgZG9lcyBub3QgeWV0IGV4aXN0LlxuXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW25hbWVdIHx8IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuICAgICAgICBpZiAoIWxvY2F0aW9uKSBjb250aW51ZTtcblxuICAgICAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbbmFtZV0gPSBsb2NhdGlvbjtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBzZXQgZm9yIHRoZVxuICAgICAgICAvLyBnaXZlbiB1bmlmb3JtLlxuXG4gICAgICAgIGlmICh0aGlzLnVuaWZvcm1Jc0NhY2hlZChuYW1lLCB2YWx1ZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgY29ycmVjdCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgdW5pZm9ybVxuICAgICAgICAvLyB2YWx1ZSB0byBXZWJHTC5cblxuICAgICAgICBpZiAoIXRoaXMudW5pZm9ybVR5cGVzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1UeXBlc1tuYW1lXSA9IHRoaXMuZ2V0VW5pZm9ybVR5cGVGcm9tVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB1bmlmb3JtIHNldHRlciBmdW5jdGlvbiBvbiBXZWJHTCBjb250ZXh0IHdpdGggY29ycmVjdCB2YWx1ZVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy51bmlmb3JtVHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm00ZnYnOiAgZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0zZnYnOiAgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0yZnYnOiAgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0xZnYnOiAgZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0xZicgOiAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndW5pZm9ybU1hdHJpeDNmdic6IGdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndW5pZm9ybU1hdHJpeDRmdic6IGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluZmVycyB1bmlmb3JtIHNldHRlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlIFdlYkdMIGNvbnRleHQsIGJhc2VkXG4gKiBvbiBhbiBpbnB1dCB2YWx1ZS5cbiAqXG4gKiBAbWV0aG9kIGdldFVuaWZvcm1UeXBlRnJvbVZhbHVlXG4gKlxuICogQHBhcmFtIHtOdW1iZXIgfCBBcnJheX0gdmFsdWUgVmFsdWUgZnJvbSB3aGljaCB1bmlmb3JtIHR5cGUgaXMgaW5mZXJyZWQuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHVuaWZvcm0gZnVuY3Rpb24gZm9yIGdpdmVuIHZhbHVlLlxuICovXG5Qcm9ncmFtLnByb3RvdHlwZS5nZXRVbmlmb3JtVHlwZUZyb21WYWx1ZSA9IGZ1bmN0aW9uIGdldFVuaWZvcm1UeXBlRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICByZXR1cm4gJ3VuaWZvcm0xZnYnO1xuICAgICAgICAgICAgY2FzZSAyOiAgcmV0dXJuICd1bmlmb3JtMmZ2JztcbiAgICAgICAgICAgIGNhc2UgMzogIHJldHVybiAndW5pZm9ybTNmdic7XG4gICAgICAgICAgICBjYXNlIDQ6ICByZXR1cm4gJ3VuaWZvcm00ZnYnO1xuICAgICAgICAgICAgY2FzZSA5OiAgcmV0dXJuICd1bmlmb3JtTWF0cml4M2Z2JztcbiAgICAgICAgICAgIGNhc2UgMTY6IHJldHVybiAndW5pZm9ybU1hdHJpeDRmdic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSAmJiBpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICd1bmlmb3JtMWYnO1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyAnY2FudCBsb2FkIHVuaWZvcm0gXCInICsgbmFtZSArICdcIiB3aXRoIHZhbHVlOicgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgc2hhZGVyIHNvdXJjZSB0byBzaGFkZXIgYW5kIGNvbXBpbGVzIHRoZSBpbnB1dCBzaGFkZXIuICBDaGVja3NcbiAqIGNvbXBpbGUgc3RhdHVzIGFuZCBsb2dzIGVycm9yIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kIGNvbXBpbGVTaGFkZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2hhZGVyIFByb2dyYW0gdG8gYmUgY29tcGlsZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIFNvdXJjZSB0byBiZSB1c2VkIGluIHRoZSBzaGFkZXIuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDb21waWxlZCBzaGFkZXIuXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLmNvbXBpbGVTaGFkZXIgPSBmdW5jdGlvbiBjb21waWxlU2hhZGVyKHNoYWRlciwgc291cmNlKSB7XG4gICAgdmFyIGkgPSAxO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIgPSBEZWJ1Zy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignY29tcGlsZSBlcnJvcjogJyArIHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignMTogJyArIHNvdXJjZS5yZXBsYWNlKC9cXG4vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1xcbicgKyAoaSs9MSkgKyAnOiAnOyB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZ3JhbTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGV4dHVyZSBpcyBhIHByaXZhdGUgY2xhc3MgdGhhdCBzdG9yZXMgaW1hZ2UgZGF0YVxuICogdG8gYmUgYWNjZXNzZWQgZnJvbSBhIHNoYWRlciBvciB1c2VkIGFzIGEgcmVuZGVyIHRhcmdldC5cbiAqXG4gKiBAY2xhc3MgVGV4dHVyZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmUoZ2wsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmlkID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDA7XG4gICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCAwO1xuICAgIHRoaXMubWlwbWFwID0gb3B0aW9ucy5taXBtYXA7XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCAnUkdCQSc7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8ICdVTlNJR05FRF9CWVRFJztcbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICB0aGlzLmJpbmQoKTtcblxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcblxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbFtvcHRpb25zLm1hZ0ZpbHRlcl0gfHwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW29wdGlvbnMubWluRmlsdGVyXSB8fCBnbC5ORUFSRVNUKTtcblxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsW29wdGlvbnMud3JhcFNdIHx8IGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsW29wdGlvbnMud3JhcFRdIHx8IGdsLkNMQU1QX1RPX0VER0UpO1xufVxuXG4vKipcbiAqIEJpbmRzIHRoaXMgdGV4dHVyZSBhcyB0aGUgc2VsZWN0ZWQgdGFyZ2V0LlxuICpcbiAqIEBtZXRob2QgYmluZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCB0ZXh0dXJlIGluc3RhbmNlLlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5pZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVyYXNlcyB0aGUgdGV4dHVyZSBkYXRhIGluIHRoZSBnaXZlbiB0ZXh0dXJlIHNsb3QuXG4gKlxuICogQG1ldGhvZCB1bmJpbmRcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgdGV4dHVyZSBpbnN0YW5jZS5cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGltYWdlIGRhdGEgaW4gdGhlIHRleHR1cmUgd2l0aCB0aGUgZ2l2ZW4gaW1hZ2UuXG4gKlxuICogQG1ldGhvZCBzZXRJbWFnZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltZyBUaGUgaW1hZ2Ugb2JqZWN0IHRvIHVwbG9hZCBwaXhlbCBkYXRhIGZyb20uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHRleHR1cmUgaW5zdGFuY2UuXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnNldEltYWdlID0gZnVuY3Rpb24gc2V0SW1hZ2UoaW1nKSB7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbFt0aGlzLmZvcm1hdF0sIHRoaXMuZ2xbdGhpcy5mb3JtYXRdLCB0aGlzLmdsW3RoaXMudHlwZV0sIGltZyk7XG4gICAgaWYgKHRoaXMubWlwbWFwKSB0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuZ2wuVEVYVFVSRV8yRCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBpbWFnZSBkYXRhIGluIHRoZSB0ZXh0dXJlIHdpdGggYW4gYXJyYXkgb2YgYXJiaXRyYXJ5IGRhdGEuXG4gKlxuICogQG1ldGhvZCBzZXRBcnJheVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGlucHV0IEFycmF5IHRvIGJlIHNldCBhcyBkYXRhIHRvIHRleHR1cmUuIFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCB0ZXh0dXJlIGluc3RhbmNlLlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5zZXRBcnJheSA9IGZ1bmN0aW9uIHNldEFycmF5KGlucHV0KSB7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbFt0aGlzLmZvcm1hdF0sIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCB0aGlzLmdsW3RoaXMuZm9ybWF0XSwgdGhpcy5nbFt0aGlzLnR5cGVdLCBpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIER1bXBzIHRoZSByZ2ItcGl4ZWwgY29udGVudHMgb2YgYSB0ZXh0dXJlIGludG8gYW4gYXJyYXkgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICpcbiAqIEBtZXRob2QgcmVhZEJhY2tcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geC1vZmZzZXQgYmV0d2VlbiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBzbmFwc2hvdFxuICogQHBhcmFtIHtOdW1iZXJ9IHktb2Zmc2V0IGJldHdlZW4gdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgc25hcHNob3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB4LWRlcHRoIG9mIHRoZSBzbmFwc2hvdFxuICogQHBhcmFtIHtOdW1iZXJ9IHktZGVwdGggb2YgdGhlIHNuYXBzaG90XG4gKiBcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgcGl4ZWxzIGNvbnRhaW5lZCBpbiB0aGUgc25hcHNob3QuXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnJlYWRCYWNrID0gZnVuY3Rpb24gcmVhZEJhY2soeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIHBpeGVscztcbiAgICB4ID0geCB8fCAwO1xuICAgIHkgPSB5IHx8IDA7XG4gICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodDtcbiAgICB2YXIgZmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5pZCwgMCk7XG4gICAgaWYgKGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICAgIHBpeGVscyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpeGVscztcbn07XG5cbi8qXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYm90aCBpbnB1dCB2YWx1ZXMgYXJlIHBvd2VyLW9mLXR3byBudW1iZXJzLlxuICpcbiAqIEBtZXRob2QgaXNQb3dlck9mVHdvXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBOdW1iZXIgcmVwcmVzZW50aW5nIHRleHR1cmUgd2lkdGguXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IE51bWJlciByZXByZXNlbnRpbmcgdGV4dHVyZSBoZWlnaHQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBkZW5vdGluZyB3aGV0aGVyIHRoZSBpbnB1dCBkaW1lbnNpb25zXG4gKiBhcmUgYm90aCBwb3dlci1vZi10d28gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28od2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiAod2lkdGggJiB3aWR0aCAtIDEpID09PSAwIFxuICAgICAgICAmJiAoaGVpZ2h0ICYgaGVpZ2h0IC0gMSkgPT09IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcbnZhciBjcmVhdGVDaGVja2VyYm9hcmQgPSByZXF1aXJlKCcuL2NyZWF0ZUNoZWNrZXJib2FyZCcpO1xuXG4vKipcbiAqIEhhbmRsZXMgbG9hZGluZywgYmluZGluZywgYW5kIHJlc2FtcGxpbmcgb2YgdGV4dHVyZXMgZm9yIFdlYkdMUmVuZGVyZXIuXG4gKlxuICogQGNsYXNzIFRleHR1cmVNYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1dlYkdMX0NvbnRleHR9IGdsIENvbnRleHQgdXNlZCB0byBjcmVhdGUgYW5kIGJpbmQgdGV4dHVyZXMuXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmVNYW5hZ2VyKGdsKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICAgIHRoaXMuX25lZWRzUmVzYW1wbGUgPSBbXTtcblxuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmUgPSAwO1xuICAgIHRoaXMuX2JvdW5kVGV4dHVyZSA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5fY2hlY2tlcmJvYXJkID0gY3JlYXRlQ2hlY2tlcmJvYXJkKCk7XG5cbiAgICB0aGlzLmdsID0gZ2w7XG59XG5cbi8qKlxuICogVXBkYXRlIGZ1bmN0aW9uIHVzZWQgYnkgV2ViR0xSZW5kZXJlciB0byBxdWV1ZSByZXNhbXBsZXMgb24gXG4gKiByZWdpc3RlcmVkIHRleHR1cmVzLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGltZSBpbiBtaWxsaXNlY29uZHMgYWNjb3JkaW5nIHRvIHRoZSBjb21wb3NpdG9yLlxuICovXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHRpbWUpIHtcbiAgICB2YXIgcmVnaXN0cnlMZW5ndGggPSB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVnaXN0cnlMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMucmVnaXN0cnlbaV07XG5cbiAgICAgICAgaWYgKHRleHR1cmUgJiYgdGV4dHVyZS5pc0xvYWRlZCAmJiB0ZXh0dXJlLnJlc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlLmxhc3RSZXNhbXBsZSB8fCB0aW1lIC0gdGV4dHVyZS5sYXN0UmVzYW1wbGUgPiB0ZXh0dXJlLnJlc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbmVlZHNSZXNhbXBsZVt0ZXh0dXJlLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1Jlc2FtcGxlW3RleHR1cmUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5sYXN0UmVzYW1wbGUgPSB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNwZWMgYW5kIGNyZWF0ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIGdpdmVuIHRleHR1cmUgZGF0YS5cbiAqIEhhbmRsZXMgbG9hZGluZyBhc3NldHMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2QgcmVnaXN0ZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgT2JqZWN0IGNvbnRhaW5pbmcgdGV4dHVyZSBpZCwgdGV4dHVyZSBkYXRhXG4gKiBhbmQgb3B0aW9ucyB1c2VkIHRvIGRyYXcgdGV4dHVyZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzbG90IFRleHR1cmUgc2xvdCB0byBiaW5kIGdlbmVyYXRlZCB0ZXh0dXJlIHRvLlxuICovXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihpbnB1dCwgc2xvdCkge1xuICAgIHZhciBzb3VyY2UgPSBpbnB1dC5kYXRhO1xuICAgIHZhciB0ZXh0dXJlSWQgPSBpbnB1dC5pZDtcbiAgICB2YXIgb3B0aW9ucyA9IGlucHV0Lm9wdGlvbnMgfHwge307XG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnJlZ2lzdHJ5W3RleHR1cmVJZF07XG4gICAgdmFyIHNwZWM7XG5cbiAgICBpZiAoIXRleHR1cmUpIHtcblxuICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgb3B0aW9ucyk7XG4gICAgICAgIHRleHR1cmUuc2V0SW1hZ2UodGhpcy5fY2hlY2tlcmJvYXJkKTtcblxuICAgICAgICAvLyBBZGQgdGV4dHVyZSB0byByZWdpc3RyeVxuXG4gICAgICAgIHNwZWMgPSB0aGlzLnJlZ2lzdHJ5W3RleHR1cmVJZF0gPSB7XG4gICAgICAgICAgICByZXNhbXBsZVJhdGU6IG9wdGlvbnMucmVzYW1wbGVSYXRlIHx8IG51bGwsXG4gICAgICAgICAgICBsYXN0UmVzYW1wbGU6IG51bGwsXG4gICAgICAgICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBpZDogdGV4dHVyZUlkLFxuICAgICAgICAgICAgc2xvdDogc2xvdFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEhhbmRsZSBhcnJheVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZUlkKTtcbiAgICAgICAgICAgIHRleHR1cmUuc2V0QXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgIHNwZWMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHZpZGVvXG5cbiAgICAgICAgZWxzZSBpZiAod2luZG93ICYmIHNvdXJjZSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZUlkKTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnNldEltYWdlKHNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICBzcGVjLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzcGVjLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgaW1hZ2UgdXJsXG5cbiAgICAgICAgZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGxvYWRJbWFnZShzb3VyY2UsIGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKHRleHR1cmVJZCk7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5zZXRJbWFnZShpbWcpO1xuXG4gICAgICAgICAgICAgICAgc3BlYy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3BlYy5zb3VyY2UgPSBpbWc7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmVJZDtcbn07XG5cbi8qKlxuICogTG9hZHMgYW4gaW1hZ2UgZnJvbSBhIHN0cmluZyBvciBJbWFnZSBvYmplY3QgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBsb2FkSW1hZ2VcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmd9IGltZyBUaGUgaW5wdXQgaW1hZ2UgZGF0YSB0byBsb2FkIGFzIGFuIGFzc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGZpcmVkIHdoZW5cbiAqIHRoZSBpbWFnZSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEltYWdlIG9iamVjdCBiZWluZyBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGxvYWRJbWFnZSAoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGltYWdlID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBuZXcgSW1hZ2UoKSA6IGlucHV0KSB8fCB7fTtcbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblxuICAgIGlmICghaW1hZ2Uuc3JjKSBpbWFnZS5zcmMgPSBpbnB1dDtcbiAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKGltYWdlKTsgfTtcbiAgICBlbHNlIGNhbGxiYWNrKGltYWdlKTtcblxuICAgIHJldHVybiBpbWFnZTtcbn1cblxuLyoqXG4gKiBTZXRzIGFjdGl2ZSB0ZXh0dXJlIHNsb3QgYW5kIGJpbmRzIHRhcmdldCB0ZXh0dXJlLiAgQWxzbyBoYW5kbGVzIFxuICogcmVzYW1wbGluZyB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kIGJpbmRUZXh0dXJlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIElkZW50aWZpZXIgdXNlZCB0byByZXRyZWl2ZSB0ZXh0dXJlIHNwZWMuXG4gKi9cblRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5iaW5kVGV4dHVyZSA9IGZ1bmN0aW9uIGJpbmRUZXh0dXJlKGlkKSB7XG4gICAgdmFyIHNwZWMgPSB0aGlzLnJlZ2lzdHJ5W2lkXTtcblxuICAgIGlmICh0aGlzLl9hY3RpdmVUZXh0dXJlICE9PSBzcGVjLnNsb3QpIHtcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyBzcGVjLnNsb3QpO1xuICAgICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlID0gc3BlYy5zbG90O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib3VuZFRleHR1cmUgIT09IGlkKSB7XG4gICAgICAgIHRoaXMuX2JvdW5kVGV4dHVyZSA9IGlkO1xuICAgICAgICBzcGVjLnRleHR1cmUuYmluZCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc1Jlc2FtcGxlW3NwZWMuaWRdKSB7XG5cbiAgICAgICAgLy8gVE9ETzogQWNjb3VudCBmb3IgcmVzYW1wbGluZyBvZiBhcnJheXMuXG5cbiAgICAgICAgc3BlYy50ZXh0dXJlLnNldEltYWdlKHNwZWMuc291cmNlKTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZXNhbXBsZVtzcGVjLmlkXSA9IGZhbHNlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZU1hbmFnZXI7IiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcbnZhciBQcm9ncmFtID0gcmVxdWlyZSgnLi9Qcm9ncmFtJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9CdWZmZXInKTtcbnZhciBCdWZmZXJSZWdpc3RyeSA9IHJlcXVpcmUoJy4vQnVmZmVyUmVnaXN0cnknKTtcbnZhciBQbGFuZSA9IHJlcXVpcmUoJy4uL3dlYmdsLWdlb21ldHJpZXMvcHJpbWl0aXZlcy9QbGFuZScpO1xudmFyIHNvcnRlciA9IHJlcXVpcmUoJy4vcmFkaXhTb3J0Jyk7XG52YXIga2V5VmFsdWVUb0FycmF5cyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9rZXlWYWx1ZVRvQXJyYXlzJyk7XG52YXIgVGV4dHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuL1RleHR1cmVNYW5hZ2VyJyk7XG52YXIgY29tcGlsZU1hdGVyaWFsID0gcmVxdWlyZSgnLi9jb21waWxlTWF0ZXJpYWwnKTtcblxudmFyIGlkZW50aXR5ID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG52YXIgZ2xvYmFsVW5pZm9ybXMgPSBrZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICAndV9udW1MaWdodHMnOiAwLFxuICAgICd1X2FtYmllbnRMaWdodCc6IG5ldyBBcnJheSgzKSxcbiAgICAndV9saWdodFBvc2l0aW9uJzogbmV3IEFycmF5KDMpLFxuICAgICd1X2xpZ2h0Q29sb3InOiBuZXcgQXJyYXkoMyksXG4gICAgJ3VfcGVyc3BlY3RpdmUnOiBuZXcgQXJyYXkoMTYpLFxuICAgICd1X3RpbWUnOiAwLFxuICAgICd1X3ZpZXcnOiBuZXcgQXJyYXkoMTYpXG59KTtcblxuLyoqXG4gKiBXZWJHTFJlbmRlcmVyIGlzIGEgcHJpdmF0ZSBjbGFzcyB0aGF0IG1hbmFnZXMgYWxsIGludGVyYWN0aW9ucyB3aXRoIHRoZSBXZWJHTFxuICogQVBJLiAgRWFjaCBmcmFtZSBpdCByZWNlaXZlcyBjb21tYW5kcyBmcm9tIHRoZSBjb21wb3NpdG9yIGFuZCB1cGRhdGVzIGl0c1xuICogcmVnaXN0cmllcyBhY2NvcmRpbmdseS4gIFN1YnNlcXVlbnRseSwgdGhlIGRyYXcgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCB0aGVcbiAqIFdlYkdMUmVuZGVyZXIgaXNzdWVzIGRyYXcgY2FsbHMgZm9yIGFsbCBtZXNoZXMgaW4gaXRzIHJlZ2lzdHJ5LlxuICpcbiAqIEBjbGFzcyBXZWJHTFJlbmRlcmVyXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNhbnZhcyAgICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBHTCB3aWxsIHBhaW50IGl0c2VsZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb250by5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciAgIENvbXBvc2l0b3IgdXNlZCBmb3IgcXVlcnlpbmcgdGhlIHRpbWUgZnJvbS5cbiAqXG4gKi9cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIoY2FudmFzLCBjb21wb3NpdG9yKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jb21wb3NpdG9yID0gY29tcG9zaXRvcjtcbiAgICBcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jb25zdHJ1Y3Rvci5ERUZBVUxUX1NUWUxFUykge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZVtrZXldID0gdGhpcy5jb25zdHJ1Y3Rvci5ERUZBVUxUX1NUWUxFU1trZXldO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2wgPSB0aGlzLmdldFdlYkdMQ29udGV4dCh0aGlzLmNhbnZhcyk7XG5cbiAgICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgZ2wucG9seWdvbk9mZnNldCgwLjEsIDAuMSk7XG4gICAgZ2wuZW5hYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuXG4gICAgdGhpcy5tZXNoUmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLm1lc2hSZWdpc3RyeUtleXMgPSBbXTtcblxuICAgIHRoaXMuY3V0b3V0UmVnaXN0cnkgPSB7fTtcbiAgICBcbiAgICB0aGlzLmN1dG91dFJlZ2lzdHJ5S2V5cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTGlnaHRzXG4gICAgICovXG4gICAgdGhpcy5udW1MaWdodHMgPSAwO1xuICAgIHRoaXMuYW1iaWVudExpZ2h0Q29sb3IgPSBbMCwgMCwgMF07XG4gICAgdGhpcy5saWdodFJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5saWdodFJlZ2lzdHJ5S2V5cyA9IFtdO1xuICAgIHRoaXMubGlnaHRQb3NpdGlvbnMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgdGhpcy5saWdodENvbG9ycyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcblxuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIoZ2wpO1xuICAgIHRoaXMudGV4Q2FjaGUgPSB7fTtcbiAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5ID0gbmV3IEJ1ZmZlclJlZ2lzdHJ5KGdsKTtcbiAgICB0aGlzLnByb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwgeyBkZWJ1ZzogdHJ1ZSB9KTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIGJvdW5kQXJyYXlCdWZmZXI6IG51bGwsXG4gICAgICAgIGJvdW5kRWxlbWVudEJ1ZmZlcjogbnVsbCxcbiAgICAgICAgbGFzdERyYXduOiBudWxsLFxuICAgICAgICBlbmFibGVkQXR0cmlidXRlczoge30sXG4gICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzS2V5czogW11cbiAgICB9O1xuXG4gICAgdGhpcy5yZXNvbHV0aW9uTmFtZSA9IFsndV9yZXNvbHV0aW9uJ107XG4gICAgdGhpcy5yZXNvbHV0aW9uVmFsdWVzID0gW107XG5cbiAgICB0aGlzLmNhY2hlZFNpemUgPSBbXTtcblxuICAgIC8qXG4gICAgVGhlIHByb2plY3Rpb25UcmFuc2Zvcm0gaGFzIHNvbWUgY29uc3RhbnQgY29tcG9uZW50cywgaS5lLiB0aGUgeiBzY2FsZSwgYW5kIHRoZSB4IGFuZCB5IHRyYW5zbGF0aW9uLlxuXG4gICAgVGhlIHogc2NhbGUga2VlcHMgdGhlIGZpbmFsIHogcG9zaXRpb24gb2YgYW55IHZlcnRleCB3aXRoaW4gdGhlIGNsaXAncyBkb21haW4gYnkgc2NhbGluZyBpdCBieSBhblxuICAgIGFyYml0cmFyaWx5IHNtYWxsIGNvZWZmaWNpZW50LiBUaGlzIGhhcyB0aGUgYWR2YW50YWdlIG9mIGJlaW5nIGEgdXNlZnVsIGRlZmF1bHQgaW4gdGhlIGV2ZW50IG9mIHRoZVxuICAgIHVzZXIgZm9yZ29pbmcgYSBuZWFyIGFuZCBmYXIgcGxhbmUsIGFuIGFsaWVuIGNvbnZlbnRpb24gaW4gZG9tIHNwYWNlIGFzIGluIERPTSBvdmVybGFwcGluZyBpc1xuICAgIGNvbmR1Y3RlZCB2aWEgcGFpbnRlcidzIGFsZ29yaXRobS5cblxuICAgIFRoZSB4IGFuZCB5IHRyYW5zbGF0aW9uIHRyYW5zZm9ybXMgdGhlIHdvcmxkIHNwYWNlIG9yaWdpbiB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXG5cbiAgICBUaGUgZmluYWwgY29tcG9uZW50ICh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm1bMTVdKSBpcyBpbml0aWFsaXplZCBhcyAxIGJlY2F1c2UgY2VydGFpbiBwcm9qZWN0aW9uIG1vZGVscyxcbiAgICBlLmcuIHRoZSBXQzMgc3BlY2lmaWVkIG1vZGVsLCBrZWVwIHRoZSBYWSBwbGFuZSBhcyB0aGUgcHJvamVjdGlvbiBoeXBlcnBsYW5lLlxuICAgICovXG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIC0wLjAwMDAwMSwgMCwgLTEsIDEsIDAsIDFdO1xuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgaGFja1xuXG4gICAgdmFyIGN1dG91dCA9IHRoaXMuY3V0b3V0R2VvbWV0cnkgPSBuZXcgUGxhbmUoKTtcblxuICAgIHRoaXMuYnVmZmVyUmVnaXN0cnkuYWxsb2NhdGUoY3V0b3V0LnNwZWMuaWQsICdhX3BvcycsIGN1dG91dC5zcGVjLmJ1ZmZlclZhbHVlc1swXSwgMyk7XG4gICAgdGhpcy5idWZmZXJSZWdpc3RyeS5hbGxvY2F0ZShjdXRvdXQuc3BlYy5pZCwgJ2FfdGV4Q29vcmQnLCBjdXRvdXQuc3BlYy5idWZmZXJWYWx1ZXNbMV0sIDIpO1xuICAgIHRoaXMuYnVmZmVyUmVnaXN0cnkuYWxsb2NhdGUoY3V0b3V0LnNwZWMuaWQsICdhX25vcm1hbHMnLCBjdXRvdXQuc3BlYy5idWZmZXJWYWx1ZXNbMl0sIDMpO1xuICAgIHRoaXMuYnVmZmVyUmVnaXN0cnkuYWxsb2NhdGUoY3V0b3V0LnNwZWMuaWQsICdpbmRpY2VzJywgY3V0b3V0LnNwZWMuYnVmZmVyVmFsdWVzWzNdLCAxKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXRyZWl2ZSB0aGUgV2ViR0xSZW5kZXJlciBjb250ZXh0IHVzaW5nIHNldmVyYWxcbiAqIGFjY2Vzc29ycy4gIEZvciBicm93c2VyIGNvbXBhdGFiaWxpdHkuICBUaHJvd3Mgb24gZXJyb3IuXG4gKlxuICogQG1ldGhvZCBnZXRXZWJHTENvbnRleHRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2FudmFzIENhbnZhcyBlbGVtZW50IGZyb20gd2hpY2ggdGhlIGNvbnRleHQgaXMgcmV0cmVpdmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gV2ViR0xDb250ZXh0IG9mIGNhbnZhcyBlbGVtZW50LlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRXZWJHTENvbnRleHQgPSBmdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzKSB7XG4gICAgdmFyIG5hbWVzID0gWyd3ZWJnbCcsICdleHBlcmltZW50YWwtd2ViZ2wnLCAnd2Via2l0LTNkJywgJ21vei13ZWJnbCddO1xuICAgIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQobmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0OiAnICsgZXJyb3IucHJvdG90eXBlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0ID8gY29udGV4dCA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbmV3IGJhc2Ugc3BlYyB0byB0aGUgbGlnaHQgcmVnaXN0cnkgYXQgYSBnaXZlbiBwYXRoLlxuICpcbiAqIEBtZXRob2QgY3JlYXRlTGlnaHRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIG5ldyBsaWdodCBpbiBsaWdodFJlZ2lzdHJ5LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gTmV3bHkgY3JlYXRlZCBsaWdodCBzcGVjLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVMaWdodCA9IGZ1bmN0aW9uIGNyZWF0ZUxpZ2h0KHBhdGgpIHtcbiAgICB0aGlzLm51bUxpZ2h0cysrO1xuICAgIHRoaXMubGlnaHRSZWdpc3RyeUtleXMucHVzaChwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5saWdodFJlZ2lzdHJ5W3BhdGhdID0ge1xuICAgICAgICBjb2xvcjogWzAsIDAsIDBdLFxuICAgICAgICBwb3NpdGlvbjogWzAsIDAsIDBdXG4gICAgfTtcbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBiYXNlIHNwZWMgdG8gdGhlIG1lc2ggcmVnaXN0cnkgYXQgYSBnaXZlbiBwYXRoLlxuICpcbiAqIEBtZXRob2QgY3JlYXRlTWVzaFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiBuZXcgbWVzaCBpbiBtZXNoUmVnaXN0cnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXdseSBjcmVhdGVkIG1lc2ggc3BlYy5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IGZ1bmN0aW9uIGNyZWF0ZU1lc2gocGF0aCkge1xuICAgIHRoaXMubWVzaFJlZ2lzdHJ5S2V5cy5wdXNoKHBhdGgpO1xuXG4gICAgdmFyIHVuaWZvcm1zID0ga2V5VmFsdWVUb0FycmF5cyh7XG4gICAgICAgIHVfb3BhY2l0eTogMSxcbiAgICAgICAgdV90cmFuc2Zvcm06IGlkZW50aXR5LFxuICAgICAgICB1X3NpemU6IFswLCAwLCAwXSxcbiAgICAgICAgdV9iYXNlQ29sb3I6IFswLjUsIDAuNSwgMC41LCAxXSxcbiAgICAgICAgdV9wb3NpdGlvbk9mZnNldDogWzAsIDAsIDBdLFxuICAgICAgICB1X25vcm1hbHM6IFswLCAwLCAwXSxcbiAgICAgICAgdV9mbGF0U2hhZGluZzogMCxcbiAgICAgICAgdV9nbG9zc2luZXNzOiBbMCwgMCwgMCwgMF1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gPSB7XG4gICAgICAgIGRlcHRoOiBudWxsLFxuICAgICAgICB1bmlmb3JtS2V5czogdW5pZm9ybXMua2V5cyxcbiAgICAgICAgdW5pZm9ybVZhbHVlczogdW5pZm9ybXMudmFsdWVzLFxuICAgICAgICBidWZmZXJzOiB7fSxcbiAgICAgICAgZ2VvbWV0cnk6IG51bGwsXG4gICAgICAgIGRyYXdUeXBlOiBudWxsLFxuICAgICAgICB0ZXh0dXJlczogW10sXG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICB9O1xufTtcblxuLyoqXG4gKiBTZXRzIGZsYWcgb24gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGRvIHNraXAgZHJhdyBwaGFzZSBmb3JcbiAqIGN1dG91dCBtZXNoIGF0IGdpdmVuIHBhdGguIFxuICpcbiAqIEBtZXRob2Qgc2V0Q3V0b3V0U3RhdGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHVzZWQgYXMgaWQgb2YgdGFyZ2V0IGN1dG91dCBtZXNoLlxuICogQHBhcmFtIHtCb29sZWFufSB1c2VzQ3V0b3V0IEluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgYSBcbiAqIGN1dG91dCBtZXNoLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRDdXRvdXRTdGF0ZSA9IGZ1bmN0aW9uIHNldEN1dG91dFN0YXRlKHBhdGgsIHVzZXNDdXRvdXQpIHtcbiAgICB2YXIgY3V0b3V0ID0gdGhpcy5nZXRPclNldEN1dG91dChwYXRoKTtcblxuICAgIGN1dG91dC52aXNpYmxlID0gdXNlc0N1dG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBvciByZXRyZWl2ZXMgY3V0b3V0XG4gKlxuICogQG1ldGhvZCBnZXRPclNldEN1dG91dFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiB0YXJnZXQgY3V0b3V0IG1lc2guXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXdseSBjcmVhdGVkIGN1dG91dCBzcGVjLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRPclNldEN1dG91dCA9IGZ1bmN0aW9uIGdldE9yU2V0Q3V0b3V0KHBhdGgpIHtcbiAgICB2YXIgZ2VvbWV0cnk7XG5cbiAgICBpZiAodGhpcy5jdXRvdXRSZWdpc3RyeVtwYXRoXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXRvdXRSZWdpc3RyeVtwYXRoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IGtleVZhbHVlVG9BcnJheXMoe1xuICAgICAgICAgICAgdV9vcGFjaXR5OiAwLFxuICAgICAgICAgICAgdV90cmFuc2Zvcm06IGlkZW50aXR5LnNsaWNlKCksXG4gICAgICAgICAgICB1X3NpemU6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHVfb3JpZ2luOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICB1X2Jhc2VDb2xvcjogWzAsIDAsIDAsIDFdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY3V0b3V0UmVnaXN0cnlLZXlzLnB1c2gocGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3V0b3V0UmVnaXN0cnlbcGF0aF0gPSB7XG4gICAgICAgICAgICB1bmlmb3JtS2V5czogdW5pZm9ybXMua2V5cyxcbiAgICAgICAgICAgIHVuaWZvcm1WYWx1ZXM6IHVuaWZvcm1zLnZhbHVlcyxcbiAgICAgICAgICAgIGdlb21ldHJ5OiB0aGlzLmN1dG91dEdlb21ldHJ5LnNwZWMuaWQsXG4gICAgICAgICAgICBkcmF3VHlwZTogdGhpcy5jdXRvdXRHZW9tZXRyeS5zcGVjLnR5cGUsXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIGZsYWcgb24gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGRvIHNraXAgZHJhdyBwaGFzZSBmb3JcbiAqIG1lc2ggYXQgZ2l2ZW4gcGF0aC4gXG4gKlxuICogQG1ldGhvZCBzZXRNZXNoVmlzaWJpbGl0eVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiB0YXJnZXQgbWVzaC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJpbGl0eSBJbmRpY2F0ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGFyZ2V0IG1lc2guXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldE1lc2hWaXNpYmlsaXR5ID0gZnVuY3Rpb24gc2V0TWVzaFZpc2liaWxpdHkocGF0aCwgdmlzaWJpbGl0eSkge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuICAgIFxuICAgIG1lc2gudmlzaWJsZSA9IHZpc2liaWxpdHk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBtZXNoIGZyb20gdGhlIG1lc2hSZWdpc3RyeS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZU1lc2hcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHVzZWQgYXMgaWQgb2YgdGFyZ2V0IG1lc2guXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZU1lc2ggPSBmdW5jdGlvbiByZW1vdmVNZXNoKHBhdGgpIHtcbiAgICB2YXIga2V5TG9jYXRpb24gPSB0aGlzLm1lc2hSZWdpc3RyeUtleXMuaW5kZXhPZihwYXRoKTtcbiAgICB0aGlzLm1lc2hSZWdpc3RyeUtleXMuc3BsaWNlKGtleUxvY2F0aW9uLCAxKTtcbiAgICB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSA9IG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgb3IgcmV0cmVpdmVzIGN1dG91dFxuICpcbiAqIEBtZXRob2Qgc2V0Q3V0b3V0VW5pZm9ybVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgY3V0b3V0IGluIGN1dG91dCByZWdpc3RyeS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB1bmlmb3JtTG9jYXRpb24gaWRlbnRpZmllciB1c2VkIHRvIHVwbG9hZCB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWUgb2YgdW5pZm9ybSBkYXRhXG4gKlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRDdXRvdXRVbmlmb3JtID0gZnVuY3Rpb24gc2V0Q3V0b3V0VW5pZm9ybShwYXRoLCB1bmlmb3JtTmFtZSwgdW5pZm9ybVZhbHVlKSB7XG4gICAgdmFyIGN1dG91dCA9IHRoaXMuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG5cbiAgICB2YXIgaW5kZXggPSBjdXRvdXQudW5pZm9ybUtleXMuaW5kZXhPZih1bmlmb3JtTmFtZSk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh1bmlmb3JtVmFsdWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB1bmlmb3JtVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGN1dG91dC51bmlmb3JtVmFsdWVzW2luZGV4XVtpXSA9IHVuaWZvcm1WYWx1ZVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3V0b3V0LnVuaWZvcm1WYWx1ZXNbaW5kZXhdID0gdW5pZm9ybVZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogRWRpdHMgdGhlIG9wdGlvbnMgZmllbGQgb24gYSBtZXNoXG4gKlxuICogQG1ldGhvZCBzZXRNZXNoT3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgdGFyZ2V0IG1lc2guXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIG9mIGRyYXcgb3B0aW9ucyBmb3IgbWVzaFxuICpcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0TWVzaE9wdGlvbnMgPSBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG5cbiAgICBtZXNoLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjb2xvciBvZiB0aGUgZml4ZWQgaW50ZW5zaXR5IGxpZ2h0aW5nIGluIHRoZSBzY2VuZVxuICpcbiAqIEBtZXRob2Qgc2V0QW1iaWVudExpZ2h0Q29sb3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB1c2VkIGFzIGlkIG9mIGxpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gcmVkIGNoYW5uZWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBncmVlbiBjaGFubmVsXG4gKiBAcGFyYW0ge051bWJlcn0gYmx1ZSBjaGFubmVsXG4gKlxuKiovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRBbWJpZW50TGlnaHRDb2xvciA9IGZ1bmN0aW9uIHNldEFtYmllbnRMaWdodENvbG9yKHBhdGgsIHIsIGcsIGIpIHtcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yWzBdID0gcjtcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yWzFdID0gZztcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yWzJdID0gYjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGxpZ2h0IGluIHRoZSBzY2VuZVxuICpcbiAqIEBtZXRob2Qgc2V0TGlnaHRQb3NpdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHVzZWQgYXMgaWQgb2YgbGlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHogcG9zaXRpb25cbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldExpZ2h0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRMaWdodFBvc2l0aW9uKHBhdGgsIHgsIHksIHopIHtcbiAgICB2YXIgbGlnaHQgPSB0aGlzLmxpZ2h0UmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVMaWdodChwYXRoKTtcblxuICAgIGxpZ2h0LnBvc2l0aW9uWzBdID0geDtcbiAgICBsaWdodC5wb3NpdGlvblsxXSA9IHk7XG4gICAgbGlnaHQucG9zaXRpb25bMl0gPSB6O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjb2xvciBvZiBhIGR5bmFtaWMgaW50ZW5zaXR5IGxpZ2h0aW5nIGluIHRoZSBzY2VuZVxuICpcbiAqIEBtZXRob2Qgc2V0TGlnaHRDb2xvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHVzZWQgYXMgaWQgb2YgbGlnaHQgaW4gbGlnaHQgUmVnaXN0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0gcmVkIGNoYW5uZWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBncmVlbiBjaGFubmVsXG4gKiBAcGFyYW0ge051bWJlcn0gYmx1ZSBjaGFubmVsXG4gKlxuKiovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRMaWdodENvbG9yID0gZnVuY3Rpb24gc2V0TGlnaHRDb2xvcihwYXRoLCByLCBnLCBiKSB7XG4gICAgdmFyIGxpZ2h0ID0gdGhpcy5saWdodFJlZ2lzdHJ5W3BhdGhdIHx8IHRoaXMuY3JlYXRlTGlnaHQocGF0aCk7XG5cbiAgICBsaWdodC5jb2xvclswXSA9IHI7XG4gICAgbGlnaHQuY29sb3JbMV0gPSBnO1xuICAgIGxpZ2h0LmNvbG9yWzJdID0gYjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcGlsZXMgbWF0ZXJpYWwgc3BlYyBpbnRvIHByb2dyYW0gc2hhZGVyXG4gKlxuICogQG1ldGhvZCBoYW5kbGVNYXRlcmlhSW5wdXRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIGN1dG91dCBpbiBjdXRvdXQgcmVnaXN0cnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gd2hpY2ggcmVuZGVyaW5nIGlucHV0IHRoZSBtYXRlcmlhbCBpcyBib3VuZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsIHNwZWNcbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZU1hdGVyaWFsSW5wdXQgPSBmdW5jdGlvbiBoYW5kbGVNYXRlcmlhbElucHV0KHBhdGgsIG5hbWUsIG1hdGVyaWFsKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG4gICAgdmFyIG1hdGVyaWFsID0gY29tcGlsZU1hdGVyaWFsKG1hdGVyaWFsLCBtZXNoLnRleHR1cmVzLmxlbmd0aCk7XG5cbiAgICAvLyBTZXQgdW5pZm9ybXMgdG8gZW5hYmxlIHRleHR1cmUhXG5cbiAgICBtZXNoLnVuaWZvcm1WYWx1ZXNbbWVzaC51bmlmb3JtS2V5cy5pbmRleE9mKG5hbWUpXVswXSA9IC1tYXRlcmlhbC5faWQ7XG5cbiAgICAvLyBSZWdpc3RlciB0ZXh0dXJlcyFcblxuICAgIHZhciBpID0gbWF0ZXJpYWwudGV4dHVyZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbWVzaC50ZXh0dXJlcy5wdXNoKFxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5yZWdpc3RlcihtYXRlcmlhbC50ZXh0dXJlc1tpXSwgbWVzaC50ZXh0dXJlcy5sZW5ndGggKyBpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIG1hdGVyaWFsIVxuXG4gICAgdGhpcy5wcm9ncmFtLnJlZ2lzdGVyTWF0ZXJpYWwobmFtZSwgbWF0ZXJpYWwpO1xuXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU2l6ZSgpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBnZW9tZXRyeSBkYXRhIG9mIGEgbWVzaFxuICpcbiAqIEBtZXRob2Qgc2V0R2VvbWV0cnlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIGN1dG91dCBpbiBjdXRvdXQgcmVnaXN0cnkuXG4gKiBAcGFyYW0ge09iamVjdH0gR2VvbWV0cnkgb2JqZWN0IGNvbnRhaW5pbmcgdmVydGV4IGRhdGEgdG8gYmUgZHJhd25cbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmltaXRpdmUgaWRlbnRpZmllclxuICogQHBhcmFtIHtCb29sZWFufSB3aWxsIHRoZSBnZW9tZXRyeSBkYXRhIGNoYW5nZT9cbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24gc2V0R2VvbWV0cnkocGF0aCwgZ2VvbWV0cnksIGRyYXdUeXBlLCBkeW5hbWljKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG5cbiAgICBtZXNoLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgbWVzaC5kcmF3VHlwZSA9IGRyYXdUeXBlO1xuICAgIG1lc2guZHluYW1pYyA9IGR5bmFtaWM7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBsb2FkcyBhIG5ldyB2YWx1ZSBmb3IgdGhlIHVuaWZvcm0gZGF0YSB3aGVuIHRoZSBtZXNoIGlzIGJlaW5nIGRyYXduXG4gKlxuICogQG1ldGhvZCBzZXRNZXNoVW5pZm9ybVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgbWVzaCBpbiBtZXNoIHJlZ2lzdHJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pZm9ybUxvY2F0aW9uIGlkZW50aWZpZXIgdXNlZCB0byB1cGxvYWQgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIG9mIHVuaWZvcm0gZGF0YVxuICpcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0TWVzaFVuaWZvcm0gPSBmdW5jdGlvbiBzZXRNZXNoVW5pZm9ybShwYXRoLCB1bmlmb3JtTmFtZSwgdW5pZm9ybVZhbHVlKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG5cbiAgICB2YXIgaW5kZXggPSBtZXNoLnVuaWZvcm1LZXlzLmluZGV4T2YodW5pZm9ybU5hbWUpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBtZXNoLnVuaWZvcm1LZXlzLnB1c2godW5pZm9ybU5hbWUpO1xuICAgICAgICBtZXNoLnVuaWZvcm1WYWx1ZXMucHVzaCh1bmlmb3JtVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWVzaC51bmlmb3JtVmFsdWVzW2luZGV4XSA9IHVuaWZvcm1WYWx1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyaWdnZXJzIHRoZSAnZHJhdycgcGhhc2Ugb2YgdGhlIFdlYkdMUmVuZGVyZXIuICBJdGVyYXRlcyB0aHJvdWdoIHJlZ2lzdHJpZXNcbiAqIHRvIHNldCB1bmlmb3Jtcywgc2V0IGF0dHJpYnV0ZXMgYW5kIGlzc3VlIGRyYXcgY29tbWFuZHMgZm9yIHJlbmRlcmFibGVzLlxuICpcbiAqIEBtZXRob2QgYnVmZmVyRGF0YVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgbWVzaCBpbiBtZXNoIHJlZ2lzdHJ5XG4gKiBAcGFyYW0ge051bWJlcn0gSWQgb2YgZ2VvbWV0cnkgaW4gZ2VvbWV0cnkgcmVnaXN0cnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBBdHRyaWJ1dGUgbG9jYXRpb24gbmFtZVxuICogQHBhcmFtIHtBcnJheX0gVmVydGV4IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdmVydGV4XG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmJ1ZmZlckRhdGEgPSBmdW5jdGlvbiBidWZmZXJEYXRhKHBhdGgsIGdlb21ldHJ5SWQsIGJ1ZmZlck5hbWUsIGJ1ZmZlclZhbHVlLCBidWZmZXJTcGFjaW5nLCBpc0R5bmFtaWMpIHtcbiAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LmFsbG9jYXRlKGdlb21ldHJ5SWQsIGJ1ZmZlck5hbWUsIGJ1ZmZlclZhbHVlLCBidWZmZXJTcGFjaW5nLCBpc0R5bmFtaWMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRyaWdnZXJzIHRoZSAnZHJhdycgcGhhc2Ugb2YgdGhlIFdlYkdMUmVuZGVyZXIuICBJdGVyYXRlcyB0aHJvdWdoIHJlZ2lzdHJpZXNcbiAqIHRvIHNldCB1bmlmb3Jtcywgc2V0IGF0dHJpYnV0ZXMgYW5kIGlzc3VlIGRyYXcgY29tbWFuZHMgZm9yIHJlbmRlcmFibGVzLlxuICpcbiAqIEBtZXRob2QgZHJhd1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJTdGF0ZSBQYXJhbWV0ZXJzIHByb3ZpZGVkIGJ5IHRoZSBjb21wb3NpdG9yLCB0aGF0XG4gKiBhZmZlY3QgdGhlIHJlbmRlcmluZyBvZiBhbGwgcmVuZGVyYWJsZXMuXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBkcmF3KHJlbmRlclN0YXRlKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLmNvbXBvc2l0b3IuZ2V0VGltZSgpO1xuICAgIFxuICAgIHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUIHwgdGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnVwZGF0ZSh0aW1lKTtcbiAgICBcbiAgICB0aGlzLm1lc2hSZWdpc3RyeUtleXMgPSBzb3J0ZXIodGhpcy5tZXNoUmVnaXN0cnlLZXlzLCB0aGlzLm1lc2hSZWdpc3RyeSk7XG5cbiAgICB0aGlzLnNldEdsb2JhbFVuaWZvcm1zKHJlbmRlclN0YXRlKTtcbiAgICB0aGlzLmRyYXdDdXRvdXRzKCk7XG4gICAgdGhpcy5kcmF3TWVzaGVzKCk7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggYW5kIGRyYXdzIGFsbCByZWdpc3RlcmVkIG1lc2hlcy4gIFRoaXMgaW5jbHVkZXNcbiAqIGJpbmRpbmcgdGV4dHVyZXMsIGhhbmRsaW5nIGRyYXcgb3B0aW9ucywgc2V0dGluZyBtZXNoIHVuaWZvcm1zXG4gKiBhbmQgZHJhd2luZyBtZXNoIGJ1ZmZlcnMuXG4gKlxuICogQG1ldGhvZCBkcmF3TWVzaGVzXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmRyYXdNZXNoZXMgPSBmdW5jdGlvbiBkcmF3TWVzaGVzKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGJ1ZmZlcnM7XG4gICAgdmFyIG1lc2g7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tZXNoUmVnaXN0cnlLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVt0aGlzLm1lc2hSZWdpc3RyeUtleXNbaV1dO1xuICAgICAgICBidWZmZXJzID0gdGhpcy5idWZmZXJSZWdpc3RyeS5yZWdpc3RyeVttZXNoLmdlb21ldHJ5XTtcblxuICAgICAgICBpZiAoIW1lc2gudmlzaWJsZSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKG1lc2gudW5pZm9ybVZhbHVlc1swXSA8IDEpIHtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKHRydWUpO1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJ1ZmZlcnMpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBqID0gbWVzaC50ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqLS0pIHRoaXMudGV4dHVyZU1hbmFnZXIuYmluZFRleHR1cmUobWVzaC50ZXh0dXJlc1tqXSk7XG4gICAgICAgIFxuICAgICAgICBpZiAobWVzaC5vcHRpb25zKSB0aGlzLmhhbmRsZU9wdGlvbnMobWVzaC5vcHRpb25zLCBtZXNoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtcyhtZXNoLnVuaWZvcm1LZXlzLCBtZXNoLnVuaWZvcm1WYWx1ZXMpO1xuICAgICAgICB0aGlzLmRyYXdCdWZmZXJzKGJ1ZmZlcnMsIG1lc2guZHJhd1R5cGUsIG1lc2guZ2VvbWV0cnkpO1xuXG4gICAgICAgIGlmIChtZXNoLm9wdGlvbnMpIHRoaXMucmVzZXRPcHRpb25zKG1lc2gub3B0aW9ucyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGFuZCBkcmF3cyBhbGwgcmVnaXN0ZXJlZCBjdXRvdXQgbWVzaGVzLiAgQmxlbmRpbmcgXG4gKiBpcyBkaXNhYmxlZCwgY3V0b3V0IHVuaWZvcm1zIGFyZSBzZXQgYW5kIGZpbmFsbHkgYnVmZmVycyBhcmUgZHJhd24uXG4gKlxuICogQG1ldGhvZCBkcmF3Q3V0b3V0c1xuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q3V0b3V0cyA9IGZ1bmN0aW9uIGRyYXdDdXRvdXRzKCkge1xuICAgIHZhciBjdXRvdXQ7XG4gICAgdmFyIGJ1ZmZlcnM7XG4gICAgdmFyIGxlbiA9IHRoaXMuY3V0b3V0UmVnaXN0cnlLZXlzLmxlbmd0aDtcblxuICAgIGlmIChsZW4pIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjdXRvdXQgPSB0aGlzLmN1dG91dFJlZ2lzdHJ5W3RoaXMuY3V0b3V0UmVnaXN0cnlLZXlzW2ldXTtcbiAgICAgICAgYnVmZmVycyA9IHRoaXMuYnVmZmVyUmVnaXN0cnkucmVnaXN0cnlbY3V0b3V0Lmdlb21ldHJ5XTtcblxuICAgICAgICBpZiAoIWN1dG91dC52aXNpYmxlKSBjb250aW51ZTtcblxuICAgICAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXMoY3V0b3V0LnVuaWZvcm1LZXlzLCBjdXRvdXQudW5pZm9ybVZhbHVlcyk7XG4gICAgICAgIHRoaXMuZHJhd0J1ZmZlcnMoYnVmZmVycywgY3V0b3V0LmRyYXdUeXBlLCBjdXRvdXQuZ2VvbWV0cnkpO1xuICAgIH1cblxuICAgIGlmIChsZW4pIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkJMRU5EKTtcbn07XG5cbi8qKlxuICogU2V0cyB1bmlmb3JtcyB0byBiZSBzaGFyZWQgYnkgYWxsIG1lc2hlcy5cbiAqXG4gKiBAbWV0aG9kIHNldEdsb2JhbFVuaWZvcm1zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlbmRlclN0YXRlIERyYXcgc3RhdGUgb3B0aW9ucyBwYXNzZWQgZG93biBmcm9tIGNvbXBvc2l0b3IuXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldEdsb2JhbFVuaWZvcm1zID0gZnVuY3Rpb24gc2V0R2xvYmFsVW5pZm9ybXMocmVuZGVyU3RhdGUpIHtcbiAgICB2YXIgbGlnaHQ7XG4gICAgdmFyIHN0cmlkZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxpZ2h0UmVnaXN0cnlLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpZ2h0ID0gdGhpcy5saWdodFJlZ2lzdHJ5W3RoaXMubGlnaHRSZWdpc3RyeUtleXNbaV1dO1xuICAgICAgICBzdHJpZGUgPSBpICogNDtcblxuICAgICAgICAvLyBCdWlsZCB0aGUgbGlnaHQgcG9zaXRpb25zJyA0eDQgbWF0cml4XG5cbiAgICAgICAgdGhpcy5saWdodFBvc2l0aW9uc1swICsgc3RyaWRlXSA9IGxpZ2h0LnBvc2l0aW9uWzBdO1xuICAgICAgICB0aGlzLmxpZ2h0UG9zaXRpb25zWzEgKyBzdHJpZGVdID0gbGlnaHQucG9zaXRpb25bMV07XG4gICAgICAgIHRoaXMubGlnaHRQb3NpdGlvbnNbMiArIHN0cmlkZV0gPSBsaWdodC5wb3NpdGlvblsyXTtcblxuICAgICAgICAvLyBCdWlsZCB0aGUgbGlnaHQgY29sb3JzJyA0eDQgbWF0cml4XG5cbiAgICAgICAgdGhpcy5saWdodENvbG9yc1swICsgc3RyaWRlXSA9IGxpZ2h0LmNvbG9yWzBdO1xuICAgICAgICB0aGlzLmxpZ2h0Q29sb3JzWzEgKyBzdHJpZGVdID0gbGlnaHQuY29sb3JbMV07XG4gICAgICAgIHRoaXMubGlnaHRDb2xvcnNbMiArIHN0cmlkZV0gPSBsaWdodC5jb2xvclsyXTtcbiAgICB9XG5cbiAgICBnbG9iYWxVbmlmb3Jtcy52YWx1ZXNbMF0gPSB0aGlzLm51bUxpZ2h0cztcbiAgICBnbG9iYWxVbmlmb3Jtcy52YWx1ZXNbMV0gPSB0aGlzLmFtYmllbnRMaWdodENvbG9yO1xuICAgIGdsb2JhbFVuaWZvcm1zLnZhbHVlc1syXSA9IHRoaXMubGlnaHRQb3NpdGlvbnM7XG4gICAgZ2xvYmFsVW5pZm9ybXMudmFsdWVzWzNdID0gdGhpcy5saWdodENvbG9ycztcblxuICAgIC8qXG4gICAgICogU2V0IHRpbWUgYW5kIHByb2plY3Rpb24gdW5pZm9ybXNcbiAgICAgKiBwcm9qZWN0aW5nIHdvcmxkIHNwYWNlIGludG8gYSAyZCBwbGFuZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2FudmFzLlxuICAgICAqIFRoZSB4IGFuZCB5IHNjYWxlICh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm1bMF0gYW5kIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybVs1XSByZXNwZWN0aXZlbHkpXG4gICAgICogY29udmVydCB0aGUgcHJvamVjdGVkIGdlb21ldHJ5IGJhY2sgaW50byBjbGlwc3BhY2UuXG4gICAgICogVGhlIHBlcnBlY3RpdmUgZGl2aWRlICh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm1bMTFdKSwgYWRkcyB0aGUgeiB2YWx1ZSBvZiB0aGUgcG9pbnRcbiAgICAgKiBtdWx0aXBsaWVkIGJ5IHRoZSBwZXJzcGVjdGl2ZSBkaXZpZGUgdG8gdGhlIHcgdmFsdWUgb2YgdGhlIHBvaW50LiBJbiB0aGUgcHJvY2Vzc1xuICAgICAqIG9mIGNvbnZlcnRpbmcgZnJvbSBob21vZ2Vub3VzIGNvb3JkaW5hdGVzIHRvIE5EQyAobm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMpXG4gICAgICogdGhlIHggYW5kIHkgdmFsdWVzIG9mIHRoZSBwb2ludCBhcmUgZGl2aWRlZCBieSB3LCB3aGljaCBpbXBsZW1lbnRzIHBlcnNwZWN0aXZlLlxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtWzBdID0gMSAvICh0aGlzLmNhY2hlZFNpemVbMF0gKiAwLjUpO1xuICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybVs1XSA9IC0xIC8gKHRoaXMuY2FjaGVkU2l6ZVsxXSAqIDAuNSk7XG4gICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtWzExXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzExXTtcblxuICAgIGdsb2JhbFVuaWZvcm1zLnZhbHVlc1s0XSA9IHRoaXMucHJvamVjdGlvblRyYW5zZm9ybTtcbiAgICBnbG9iYWxVbmlmb3Jtcy52YWx1ZXNbNV0gPSB0aGlzLmNvbXBvc2l0b3IuZ2V0VGltZSgpICogMC4wMDE7XG4gICAgZ2xvYmFsVW5pZm9ybXMudmFsdWVzWzZdID0gcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybTtcblxuICAgIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtcyhnbG9iYWxVbmlmb3Jtcy5rZXlzLCBnbG9iYWxVbmlmb3Jtcy52YWx1ZXMpO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGUgYnVmZmVycyBhbmQgaXNzdWVzIHRoZSBkcmF3IGNvbW1hbmQgZm9yIGEgZ2VvbWV0cnkuXG4gKlxuICogQG1ldGhvZCBkcmF3QnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2ZXJ0ZXhCdWZmZXJzIEFsbCBidWZmZXJzIHVzZWQgdG8gZHJhdyB0aGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0gbW9kZSBFbnVtZXJhdG9yIGRlZmluaW5nIHdoYXQgcHJpbWl0aXZlIHRvIGRyYXdcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBJRCBvZiBnZW9tZXRyeSBiZWluZyBkcmF3bi5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiBkcmF3QnVmZmVycyh2ZXJ0ZXhCdWZmZXJzLCBtb2RlLCBpZCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIGF0dHJpYnV0ZTtcbiAgICB2YXIgbG9jYXRpb247XG4gICAgdmFyIHNwYWNpbmc7XG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgYnVmZmVyO1xuICAgIHZhciBpdGVyO1xuICAgIHZhciBqO1xuXG4gICAgaXRlciA9IHZlcnRleEJ1ZmZlcnMua2V5cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyOyBpKyspIHtcbiAgICAgICAgYXR0cmlidXRlID0gdmVydGV4QnVmZmVycy5rZXlzW2ldO1xuXG4gICAgICAgIC8vIERvIG5vdCBzZXQgdmVydGV4QXR0cmliUG9pbnRlciBpZiBpbmRleCBidWZmZXIuXG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PT0gJ2luZGljZXMnKSB7XG4gICAgICAgICAgICBqID0gaTsgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRyZWl2ZSB0aGUgYXR0cmlidXRlIGxvY2F0aW9uIGFuZCBtYWtlIHN1cmUgaXQgaXMgZW5hYmxlZC5cblxuICAgICAgICBsb2NhdGlvbiA9IHRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0cmlidXRlXTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT09IC0xKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLnByb2dyYW0sIGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0uYXR0cmlidXRlTG9jYXRpb25zW2F0dHJpYnV0ZV0gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzS2V5cy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRyZWl2ZSBidWZmZXIgaW5mb3JtYXRpb24gdXNlZCB0byBzZXQgYXR0cmlidXRlIHBvaW50ZXIuXG5cbiAgICAgICAgYnVmZmVyID0gdmVydGV4QnVmZmVycy52YWx1ZXNbaV07XG4gICAgICAgIHNwYWNpbmcgPSB2ZXJ0ZXhCdWZmZXJzLnNwYWNpbmdbaV07XG4gICAgICAgIG9mZnNldCA9IHZlcnRleEJ1ZmZlcnMub2Zmc2V0W2ldO1xuICAgICAgICBsZW5ndGggPSB2ZXJ0ZXhCdWZmZXJzLmxlbmd0aFtpXTtcblxuICAgICAgICAvLyBTa2lwIGJpbmRCdWZmZXIgaWYgYnVmZmVyIGlzIGN1cnJlbnRseSBib3VuZC5cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5ib3VuZEFycmF5QnVmZmVyICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnRhcmdldCwgYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmJvdW5kQXJyYXlCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5sYXN0RHJhd24gIT09IGlkKSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBzcGFjaW5nLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDQgKiBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSBhbnkgYXR0cmlidXRlcyB0aGF0IG5vdCBjdXJyZW50bHkgYmVpbmcgdXNlZC5cblxuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzS2V5c1tpXTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNba2V5XSAmJiB2ZXJ0ZXhCdWZmZXJzLmtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNba2V5XSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzW2tleV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZW5ndGgpIHtcblxuICAgICAgICAvLyBJZiBpbmRleCBidWZmZXIsIHVzZSBkcmF3RWxlbWVudHMuXG5cbiAgICAgICAgaWYgKGogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnVmZmVyID0gdmVydGV4QnVmZmVycy52YWx1ZXNbal07XG4gICAgICAgICAgICBvZmZzZXQgPSB2ZXJ0ZXhCdWZmZXJzLm9mZnNldFtqXTtcbiAgICAgICAgICAgIHNwYWNpbmcgPSB2ZXJ0ZXhCdWZmZXJzLnNwYWNpbmdbal07XG4gICAgICAgICAgICBsZW5ndGggPSB2ZXJ0ZXhCdWZmZXJzLmxlbmd0aFtqXTtcblxuICAgICAgICAgICAgLy8gU2tpcCBiaW5kQnVmZmVyIGlmIGJ1ZmZlciBpcyBjdXJyZW50bHkgYm91bmQuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmJvdW5kRWxlbWVudEJ1ZmZlciAhPT0gYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudGFyZ2V0LCBidWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmJvdW5kRWxlbWVudEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsW21vZGVdLCBsZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAyICogb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2xbbW9kZV0sIDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmxhc3REcmF3biA9IGlkO1xufTtcblxuLyoqXG4gKiBXcmFwcyBkcmF3IG1ldGhvZHMgaW4gYm91bmQgZnJhbWUgYnVmZmVyXG4gKlxuICogQG1ldGhvZCByZW5kZXJPZmZzY3JlZW5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgcmVuZGVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBzZXR1cCBhbmQgYmVmb3JlIGNsZWFudXAuXG4gKiBAcGFyYW0ge0FycmF5fSBzaXplIFNpemUgb2YgZnJhbWVidWZmZXIgYmVpbmcgZHJhd24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dHVyZSBMb2NhdGlvbiB3aGVyZSB0aGUgcmVuZGVyIGRhdGEgaXMgc3RvcmVkLlxuICovXG5mdW5jdGlvbiByZW5kZXJPZmZzY3JlZW4oY2FsbGJhY2ssIHNpemUsIHRleHR1cmUpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIGZyYW1lYnVmZmVyICA9IHRoaXMuZnJhbWVidWZmZXIgPyB0aGlzLmZyYW1lYnVmZmVyIDogdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdmFyIHJlbmRlcmJ1ZmZlciA9IHRoaXMucmVuZGVyYnVmZmVyID8gdGhpcy5yZW5kZXJidWZmZXIgOiB0aGlzLnJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlcik7XG5cbiAgICBpZiAoc2l6ZVswXSAhPSByZW5kZXJidWZmZXIud2lkdGggfHwgc2l6ZVsxXSAhPSByZW5kZXJidWZmZXIuaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmJ1ZmZlci53aWR0aCA9IHNpemVbMF07XG4gICAgICAgIHJlbmRlcmJ1ZmZlci5oZWlnaHQgPSBzaXplWzFdO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHNpemVbMF0sIHNpemVbMV0pO1xuICAgIH1cblxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5pZCwgMCk7XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyKTtcblxuICAgIGlmICh0aGlzLmRlYnVnKSBjaGVja0ZyYW1lQnVmZmVyU3RhdHVzKGdsKTtcblxuICAgIGNhbGxiYWNrLmNhbGwodGhpcyk7XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbn07XG5cbi8qKlxuICogRGlhZ25vc2VzIHRoZSBmYWlsZWQgaW50aWFsaXphdGlvbiBvZiBhbiBGQk8uXG4gKlxuICogQG1ldGhvZCBjaGVja0ZyYW1lQnVmZmVyU3RhdHVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoZSBXZWJHTENvbnRleHQgdGhhdCBvd25zIHRoaXMgRkJPLlxuICovXG5mdW5jdGlvbiBjaGVja0ZyYW1lQnVmZmVyU3RhdHVzKGdsKSB7XG4gICAgdmFyIHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXCIpOyBicmVhaztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIik7IGJyZWFrO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCIpOyBicmVhaztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3coXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBcIiArIHN0YXR1cyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHBhcmVudCBjYW52YXMsIHNldHMgdGhlIHZpZXdwb3J0IHNpemUgb25cbiAqIHRoZSBXZWJHTCBjb250ZXh0IGFuZCB1cGRhdGVzIHRoZSByZXNvbHV0aW9uIHVuaWZvcm0gZm9yIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAqIFNpemUgaXMgcmV0cmVpdmVkIGZyb20gdGhlIGNvbnRhaW5lciBvYmplY3Qgb2YgdGhlIHJlbmRlcmVyLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlU2l6ZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHdpZHRoLCBoZWlnaHQgYW5kIGRlcHRoIG9mIGNhbnZhc1xuICpcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkU2l6ZVswXSA9IHNpemVbMF07XG4gICAgICAgIHRoaXMuY2FjaGVkU2l6ZVsxXSA9IHNpemVbMV07XG4gICAgICAgIHRoaXMuY2FjaGVkU2l6ZVsyXSA9IChzaXplWzBdID4gc2l6ZVsxXSkgPyBzaXplWzBdIDogc2l6ZVsxXTtcbiAgICB9XG5cbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FjaGVkU2l6ZVswXSwgdGhpcy5jYWNoZWRTaXplWzFdKTtcblxuICAgIHRoaXMucmVzb2x1dGlvblZhbHVlc1swXSA9IHRoaXMuY2FjaGVkU2l6ZTtcbiAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXModGhpcy5yZXNvbHV0aW9uTmFtZSwgdGhpcy5yZXNvbHV0aW9uVmFsdWVzKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgV2ViR0wgZHJhd2luZyBjb250ZXh0IGJhc2VkIG9uIGN1c3RvbSBwYXJhbWV0ZXJzXG4gKiBkZWZpbmVkIG9uIGEgbWVzaC5cbiAqXG4gKiBAbWV0aG9kIGhhbmRsZU9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBEcmF3IHN0YXRlIG9wdGlvbnMgdG8gYmUgc2V0IHRvIHRoZSBjb250ZXh0LlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVPcHRpb25zID0gZnVuY3Rpb24gaGFuZGxlT3B0aW9ucyhvcHRpb25zLCBtZXNoKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBpZiAoIW9wdGlvbnMpIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zLnNpZGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIHRoaXMuZ2wuY3VsbEZhY2UodGhpcy5nbC5GUk9OVCk7XG4gICAgICAgIHRoaXMuZHJhd0J1ZmZlcnModGhpcy5idWZmZXJSZWdpc3RyeS5yZWdpc3RyeVttZXNoLmdlb21ldHJ5XSwgbWVzaC5kcmF3VHlwZSwgbWVzaC5nZW9tZXRyeSk7XG4gICAgICAgIHRoaXMuZ2wuY3VsbEZhY2UodGhpcy5nbC5CQUNLKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ibGVuZGluZykgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbiAgICBpZiAob3B0aW9ucy5zaWRlID09PSAnYmFjaycpIGdsLmN1bGxGYWNlKGdsLkZST05UKTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgV2ViR0wgZHJhd2luZyBjb250ZXh0IHRvIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBtZXRob2QgcmVzZXRPcHRpb25zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgRHJhdyBzdGF0ZSBvcHRpb25zIHRvIGJlIHNldCB0byB0aGUgY29udGV4dC5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzZXRPcHRpb25zID0gZnVuY3Rpb24gcmVzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGlmICghb3B0aW9ucykgcmV0dXJuO1xuICAgIGlmIChvcHRpb25zLmJsZW5kaW5nKSBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICBpZiAob3B0aW9ucy5zaWRlID09PSAnYmFjaycpIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xufTtcblxuV2ViR0xSZW5kZXJlci5ERUZBVUxUX1NUWUxFUyA9IHtcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAxLFxuICAgIHRvcDogJzBweCcsXG4gICAgbGVmdDogJzBweCdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR0xSZW5kZXJlcjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZXMgPSB7XG4gICAgMTogJ2Zsb2F0ICcsXG4gICAgMjogJ3ZlYzIgJyxcbiAgICAzOiAndmVjMyAnLFxuICAgIDQ6ICd2ZWM0ICdcbn07XG5cbi8qKlxuICogVHJhdmVyc2VzIG1hdGVyaWFsIHRvIGNyZWF0ZSBhIHN0cmluZyBvZiBnbHNsIGNvZGUgdG8gYmUgYXBwbGllZCBpblxuICogdGhlIHZlcnRleCBvciBmcmFnbWVudCBzaGFkZXIuXG4gKlxuICogQG1ldGhvZCBfY29tcGlsZVxuICogQHByb3RlY3RlZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbCBNYXRlcmlhbCB0byBiZSBjb21waWxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0dXJlU2xvdCBOZXh0IGF2YWlsYWJsZSB0ZXh0dXJlIHNsb3QgZm9yIE1lc2guXG4gKlxuICovXG5mdW5jdGlvbiBjb21waWxlTWF0ZXJpYWwobWF0ZXJpYWwsIHRleHR1cmVTbG90KSB7XG4gICAgdmFyIGdsc2wgPSAnJztcbiAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICB2YXIgdmFyeWluZ3MgPSB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBkZWZpbmVzID0gW107XG4gICAgdmFyIHRleHR1cmVzID0gW107XG5cbiAgICBfdHJhdmVyc2UobWF0ZXJpYWwsIGZ1bmN0aW9uIChub2RlLCBkZXB0aCkge1xuICAgICAgICBpZiAoISBub2RlLmNodW5rKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW19nZXRPdXRwdXRMZW5ndGgobm9kZSldO1xuICAgICAgICB2YXIgbGFiZWwgPSBfbWFrZUxhYmVsKG5vZGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gX3Byb2Nlc3NHTFNMKG5vZGUuY2h1bmsuZ2xzbCwgbm9kZS5pbnB1dHMsIHRleHR1cmVzLmxlbmd0aCArIHRleHR1cmVTbG90KTtcblxuICAgICAgICBnbHNsICs9IHR5cGUgKyBsYWJlbCArICcgPSAnICsgb3V0cHV0ICsgJ1xcbiAnO1xuXG4gICAgICAgIGlmIChub2RlLnVuaWZvcm1zKSBfZXh0ZW5kKHVuaWZvcm1zLCBub2RlLnVuaWZvcm1zKTtcbiAgICAgICAgaWYgKG5vZGUudmFyeWluZ3MpIF9leHRlbmQodmFyeWluZ3MsIG5vZGUudmFyeWluZ3MpO1xuICAgICAgICBpZiAobm9kZS5hdHRyaWJ1dGVzKSBfZXh0ZW5kKGF0dHJpYnV0ZXMsIG5vZGUuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChub2RlLmNodW5rLmRlZmluZXMpIGRlZmluZXMucHVzaChub2RlLmNodW5rLmRlZmluZXMpO1xuICAgICAgICBpZiAobm9kZS50ZXh0dXJlKSB0ZXh0dXJlcy5wdXNoKG5vZGUudGV4dHVyZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBfaWQ6IG1hdGVyaWFsLl9pZCxcbiAgICAgICAgZ2xzbDogZ2xzbCArICdyZXR1cm4gJyArIF9tYWtlTGFiZWwobWF0ZXJpYWwpICsgJzsnLFxuICAgICAgICBkZWZpbmVzOiBkZWZpbmVzLmpvaW4oJ1xcbicpLFxuICAgICAgICB1bmlmb3JtczogdW5pZm9ybXMsXG4gICAgICAgIHZhcnlpbmdzOiB2YXJ5aW5ncyxcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgdGV4dHVyZXM6IHRleHR1cmVzXG4gICAgfTtcbn1cblxuLy8gUmVjdXJzaXZlbHkgaXRlcmF0ZXMgb3ZlciBhIG1hdGVyaWFsJ3MgaW5wdXRzLCBpbnZva2luZyBhIGdpdmVuIGNhbGxiYWNrXG4vLyB3aXRoIHRoZSBjdXJyZW50IG1hdGVyaWFsXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShtYXRlcmlhbCwgY2FsbGJhY2spIHtcblx0dmFyIGlucHV0cyA9IG1hdGVyaWFsLmlucHV0cztcbiAgICB2YXIgbGVuID0gaW5wdXRzICYmIGlucHV0cy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IC0xO1xuICAgIHZhciBzYXZlO1xuXG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSBzYXZlID0gX3RyYXZlcnNlKGlucHV0c1tpZHhdLCBjYWxsYmFjayk7XG5cbiAgICBjYWxsYmFjayhtYXRlcmlhbCk7XG5cbiAgICByZXR1cm4gbWF0ZXJpYWw7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIGluZmVyIGxlbmd0aCBvZiB0aGUgb3V0cHV0XG4vLyBmcm9tIGEgZ2l2ZW4gbWF0ZXJpYWwgbm9kZS5cblxuZnVuY3Rpb24gX2dldE91dHB1dExlbmd0aChub2RlKSB7XG5cbiAgICAvLyBIYW5kbGUgY29uc3RhbnQgdmFsdWVzXG5cbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSByZXR1cm4gMTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIG5vZGUubGVuZ3RoO1xuXG4gICAgLy8gSGFuZGxlIG1hdGVyaWFsc1xuICAgIFxuICAgIHZhciBvdXRwdXQgPSBub2RlLmNodW5rLm91dHB1dDtcbiAgICBpZiAodHlwZW9mIG91dHB1dCA9PT0gJ251bWJlcicpIHJldHVybiBvdXRwdXQ7XG5cbiAgICAvLyBIYW5kbGUgcG9seW1vcnBoaWMgb3V0cHV0XG5cbiAgICB2YXIga2V5ID0gbm9kZS5pbnB1dHMubWFwKGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkgeyByZXR1cm4gX2dldE91dHB1dExlbmd0aChub2RlKTsgfSkuam9pbignLCcpO1xuICAgIHJldHVybiBvdXRwdXRba2V5XTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJ1biByZXBsYWNlIGlucHV0cyBhbmQgdGV4dHVyZSB0YWdzIHdpdGhcbi8vIGNvcnJlY3QgZ2xzbC5cblxuZnVuY3Rpb24gX3Byb2Nlc3NHTFNMKHN0ciwgaW5wdXRzLCB0ZXh0dXJlU2xvdCkge1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnJlcGxhY2UoLyVcXGQvZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFrZUxhYmVsKGlucHV0c1tzWzFdLTFdKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlcGxhY2UoL1xcJFRFWFRVUkUvLCAndV90ZXh0dXJlc1snICsgdGV4dHVyZVNsb3QgKyAnXScpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgZ2xzbCBkZWZpbml0aW9uIG9mIHRoZSBcbi8vIGlucHV0IG1hdGVyaWFsIG5vZGUuXG5cbmZ1bmN0aW9uIF9tYWtlTGFiZWwgKG4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuKSkgcmV0dXJuIGFycmF5VG9WZWMobik7XG4gICAgaWYgKHR5cGVvZiBuID09ICdvYmplY3QnKSByZXR1cm4gJ2ZhXycgKyAobi5faWQpO1xuICAgIGVsc2UgcmV0dXJuIG4udG9GaXhlZCg2KTtcbn1cblxuLy8gSGVscGVyIHRvIGNvcHkgdGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IG9udG8gYW5vdGhlciBvYmplY3QuXG5cbmZ1bmN0aW9uIF9leHRlbmQgKGEsIGIpIHtcblx0Zm9yICh2YXIgayBpbiBiKSBhW2tdID0gYltrXTtcbn1cblxuLy8gSGVscGVyIHRvIGNyZWF0ZSBnbHNsIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiBhIGphdmFzY3JpcHQgYXJyYXkuXG5cbmZ1bmN0aW9uIF9hcnJheVRvVmVjKGFycmF5KSB7XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gJ3ZlYycgKyBsZW4gKyAnKCcgKyBhcnJheS5qb2luKCcsJykgICsgJyknO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVNYXRlcmlhbDsiLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBHZW5lcmF0ZXMgYSBjaGVja2VyYm9hcmQgcGF0dGVybiB0byBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgdGV4dHVyZSB3aGlsZSBhblxuLy8gaW1hZ2UgbG9hZHMgb3ZlciB0aGUgbmV0d29yay5cblxuZnVuY3Rpb24gY3JlYXRlQ2hlY2tlckJvYXJkKCkge1xuICAgIHZhciBjb250ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IGNvbnRleHQuY2FudmFzLmhlaWdodCA9IDEyODtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNvbnRleHQuY2FudmFzLmhlaWdodDsgeSArPSAxNikge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNvbnRleHQuY2FudmFzLndpZHRoOyB4ICs9IDE2KSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICh4IF4geSkgJiAxNiA/ICcjRkZGJyA6ICcjREREJztcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgMTYsIDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY29udGV4dC5jYW52YXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2hlY2tlckJvYXJkO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQnVmZmVyOiByZXF1aXJlKCcuL0J1ZmZlcicpLFxuICAgIEJ1ZmZlclJlZ2lzdHJ5OiByZXF1aXJlKCcuL0J1ZmZlclJlZ2lzdHJ5JyksXG4gICAgY3JlYXRlQ2hlY2tlcmJvYXJkOiByZXF1aXJlKCcuL2NyZWF0ZUNoZWNrZXJib2FyZCcpLFxuICAgIFByb2dyYW06IHJlcXVpcmUoJy4vUHJvZ3JhbScpLFxuICAgIFdlYkdMUmVuZGVyZXI6IHJlcXVpcmUoJy4vV2ViR0xSZW5kZXJlcicpLFxuICAgIFRleHR1cmU6IHJlcXVpcmUoJy4vVGV4dHVyZScpXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYWRpeEJpdHMgPSAxMSxcbiAgICBtYXhSYWRpeCA9IDEgPDwgKHJhZGl4Qml0cyksXG4gICAgcmFkaXhNYXNrID0gbWF4UmFkaXggLSAxLFxuICAgIGJ1Y2tldHMgPSBuZXcgQXJyYXkobWF4UmFkaXggKiBNYXRoLmNlaWwoNjQgLyByYWRpeEJpdHMpKSxcbiAgICBtc2JNYXNrID0gMSA8PCAoKDMyIC0gMSkgJSByYWRpeEJpdHMpLFxuICAgIGxhc3RNYXNrID0gKG1zYk1hc2sgPDwgMSkgLSAxLFxuICAgIHBhc3NDb3VudCA9ICgoMzIgLyByYWRpeEJpdHMpICsgMC45OTk5OTk5OTk5OTk5OTkpIHwgMCxcbiAgICBtYXhPZmZzZXQgPSBtYXhSYWRpeCAqIChwYXNzQ291bnQgLSAxKSxcbiAgICBub3JtYWxpemVyID0gTWF0aC5wb3coMjAsIDYpO1xuXG52YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xudmFyIGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbnZhciBpbnRWaWV3ID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcblxuZnVuY3Rpb24gY29tcChsaXN0LCByZWdpc3RyeSwgaSkge1xuICAgIHZhciBrZXkgPSBsaXN0W2ldO1xuICAgIHZhciBpdGVtID0gcmVnaXN0cnlba2V5XTtcbiAgICByZXR1cm4gKGl0ZW0uZGVwdGggPyBpdGVtLmRlcHRoIDogcmVnaXN0cnlba2V5XS51bmlmb3JtVmFsdWVzWzFdWzE0XSkgKyBub3JtYWxpemVyO1xufVxuXG5mdW5jdGlvbiBtdXRhdG9yKGxpc3QsIHJlZ2lzdHJ5LCBpLCB2YWx1ZSkge1xuICAgIHZhciBrZXkgPSBsaXN0W2ldO1xuICAgIHJlZ2lzdHJ5W2tleV0uZGVwdGggPSBpbnRUb0Zsb2F0KHZhbHVlKSAtIG5vcm1hbGl6ZXI7XG4gICAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGNsZWFuKGxpc3QsIHJlZ2lzdHJ5LCBpKSB7XG4gICAgcmVnaXN0cnlbbGlzdFtpXV0uZGVwdGggPSBudWxsO1xufVxuXG5mdW5jdGlvbiBmbG9hdFRvSW50KGspIHtcbiAgICBmbG9hdFZpZXdbMF0gPSBrO1xuICAgIHJldHVybiBpbnRWaWV3WzBdO1xufVxuXG5mdW5jdGlvbiBpbnRUb0Zsb2F0KGspIHtcbiAgICBpbnRWaWV3WzBdID0gaztcbiAgICByZXR1cm4gZmxvYXRWaWV3WzBdO1xufVxuXG5mdW5jdGlvbiBzb3J0KGxpc3QsIHJlZ2lzdHJ5KSB7XG4gICAgdmFyIHBhc3MgPSAwO1xuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIHZhciBpLCBqLCBrLCBuLCBkaXYsIG9mZnNldCwgc3dhcCwgaWQsIHN1bSwgdHN1bSwgc2l6ZTtcblxuICAgIHBhc3NDb3VudCA9ICgoMzIgLyByYWRpeEJpdHMpICsgMC45OTk5OTk5OTk5OTk5OTkpIHwgMDtcblxuICAgIGZvciAoaSA9IDAsIG4gPSBtYXhSYWRpeCAqIHBhc3NDb3VudDsgaSA8IG47IGkrKykgYnVja2V0c1tpXSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZGl2ID0gZmxvYXRUb0ludChjb21wKGxpc3QsIHJlZ2lzdHJ5LCBpKSk7XG4gICAgICAgIGRpdiBePSBkaXYgPj4gMzEgfCAweDgwMDAwMDAwO1xuICAgICAgICBmb3IgKGogPSAwLCBrID0gMDsgaiA8IG1heE9mZnNldDsgaiArPSBtYXhSYWRpeCwgayArPSByYWRpeEJpdHMpIHtcbiAgICAgICAgICAgIGJ1Y2tldHNbaiArIChkaXYgPj4+IGsgJiByYWRpeE1hc2spXSsrO1xuICAgICAgICB9XG4gICAgICAgIGJ1Y2tldHNbaiArIChkaXYgPj4+IGsgJiBsYXN0TWFzayldKys7XG4gICAgfVxuXG4gICAgZm9yIChqID0gMDsgaiA8PSBtYXhPZmZzZXQ7IGogKz0gbWF4UmFkaXgpIHtcbiAgICAgICAgZm9yIChpZCA9IGosIHN1bSA9IDA7IGlkIDwgaiArIG1heFJhZGl4OyBpZCsrKSB7XG4gICAgICAgICAgICB0c3VtID0gYnVja2V0c1tpZF0gKyBzdW07XG4gICAgICAgICAgICBidWNrZXRzW2lkXSA9IHN1bSAtIDE7XG4gICAgICAgICAgICBzdW0gPSB0c3VtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgtLXBhc3NDb3VudCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICAgICAgb3V0WysrYnVja2V0c1tkaXYgJiByYWRpeE1hc2tdXSA9IG11dGF0b3IobGlzdCwgcmVnaXN0cnksIGksIGRpdiBePSBkaXYgPj4gMzEgfCAweDgwMDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBzd2FwID0gb3V0LCBvdXQgPSBsaXN0LCBsaXN0ID0gc3dhcDtcbiAgICAgICAgd2hpbGUgKCsrcGFzcyA8IHBhc3NDb3VudCkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IGxpc3QubGVuZ3RoLCBvZmZzZXQgPSBwYXNzICogbWF4UmFkaXgsIHNpemUgPSBwYXNzICogcmFkaXhCaXRzOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGl2ID0gZmxvYXRUb0ludChjb21wKGxpc3QsIHJlZ2lzdHJ5LCBpKSk7XG4gICAgICAgICAgICAgICAgb3V0WysrYnVja2V0c1tvZmZzZXQgKyAoZGl2ID4+PiBzaXplICYgcmFkaXhNYXNrKV1dID0gbGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3YXAgPSBvdXQsIG91dCA9IGxpc3QsIGxpc3QgPSBzd2FwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbiA9IGxpc3QubGVuZ3RoLCBvZmZzZXQgPSBwYXNzICogbWF4UmFkaXgsIHNpemUgPSBwYXNzICogcmFkaXhCaXRzOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICBvdXRbKytidWNrZXRzW29mZnNldCArIChkaXYgPj4+IHNpemUgJiBsYXN0TWFzayldXSA9IG11dGF0b3IobGlzdCwgcmVnaXN0cnksIGksIGRpdiBeICh+ZGl2ID4+IDMxIHwgMHg4MDAwMDAwMCkpO1xuICAgICAgICBjbGVhbihsaXN0LCByZWdpc3RyeSwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBnbHNsaWZ5ID0gcmVxdWlyZShcImdsc2xpZnlcIik7XG52YXIgc2hhZGVycyA9IHJlcXVpcmUoXCJnbHNsaWZ5L3NpbXBsZS1hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5tYXQzIGFfeF9nZXROb3JtYWxNYXRyaXgoaW4gbWF0NCB0KSB7XFxuICBtYXQzIG1hdE5vcm07XFxuICBtYXQ0IGEgPSB0O1xcbiAgZmxvYXQgYTAwID0gYVswXVswXSwgYTAxID0gYVswXVsxXSwgYTAyID0gYVswXVsyXSwgYTAzID0gYVswXVszXSwgYTEwID0gYVsxXVswXSwgYTExID0gYVsxXVsxXSwgYTEyID0gYVsxXVsyXSwgYTEzID0gYVsxXVszXSwgYTIwID0gYVsyXVswXSwgYTIxID0gYVsyXVsxXSwgYTIyID0gYVsyXVsyXSwgYTIzID0gYVsyXVszXSwgYTMwID0gYVszXVswXSwgYTMxID0gYVszXVsxXSwgYTMyID0gYVszXVsyXSwgYTMzID0gYVszXVszXSwgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCwgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMiwgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCwgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMiwgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xcbiAgZGV0ID0gMS4wIC8gZGV0O1xcbiAgbWF0Tm9ybVswXVswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xcbiAgbWF0Tm9ybVswXVsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xcbiAgbWF0Tm9ybVswXVsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xcbiAgbWF0Tm9ybVsxXVswXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xcbiAgbWF0Tm9ybVsxXVsxXSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xcbiAgbWF0Tm9ybVsxXVsyXSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xcbiAgbWF0Tm9ybVsyXVswXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xcbiAgbWF0Tm9ybVsyXVsxXSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xcbiAgbWF0Tm9ybVsyXVsyXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xcbiAgcmV0dXJuIG1hdE5vcm07XFxufVxcbmZsb2F0IGJfeF9pbnZlcnNlKGZsb2F0IG0pIHtcXG4gIHJldHVybiAxLjAgLyBtO1xcbn1cXG5tYXQyIGJfeF9pbnZlcnNlKG1hdDIgbSkge1xcbiAgcmV0dXJuIG1hdDIobVsxXVsxXSwgLW1bMF1bMV0sIC1tWzFdWzBdLCBtWzBdWzBdKSAvIChtWzBdWzBdICogbVsxXVsxXSAtIG1bMF1bMV0gKiBtWzFdWzBdKTtcXG59XFxubWF0MyBiX3hfaW52ZXJzZShtYXQzIG0pIHtcXG4gIGZsb2F0IGEwMCA9IG1bMF1bMF0sIGEwMSA9IG1bMF1bMV0sIGEwMiA9IG1bMF1bMl07XFxuICBmbG9hdCBhMTAgPSBtWzFdWzBdLCBhMTEgPSBtWzFdWzFdLCBhMTIgPSBtWzFdWzJdO1xcbiAgZmxvYXQgYTIwID0gbVsyXVswXSwgYTIxID0gbVsyXVsxXSwgYTIyID0gbVsyXVsyXTtcXG4gIGZsb2F0IGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcXG4gIGZsb2F0IGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XFxuICBmbG9hdCBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7XFxuICBmbG9hdCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XFxuICByZXR1cm4gbWF0MyhiMDEsICgtYTIyICogYTAxICsgYTAyICogYTIxKSwgKGExMiAqIGEwMSAtIGEwMiAqIGExMSksIGIxMSwgKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCksICgtYTEyICogYTAwICsgYTAyICogYTEwKSwgYjIxLCAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCksIChhMTEgKiBhMDAgLSBhMDEgKiBhMTApKSAvIGRldDtcXG59XFxubWF0NCBiX3hfaW52ZXJzZShtYXQ0IG0pIHtcXG4gIGZsb2F0IGEwMCA9IG1bMF1bMF0sIGEwMSA9IG1bMF1bMV0sIGEwMiA9IG1bMF1bMl0sIGEwMyA9IG1bMF1bM10sIGExMCA9IG1bMV1bMF0sIGExMSA9IG1bMV1bMV0sIGExMiA9IG1bMV1bMl0sIGExMyA9IG1bMV1bM10sIGEyMCA9IG1bMl1bMF0sIGEyMSA9IG1bMl1bMV0sIGEyMiA9IG1bMl1bMl0sIGEyMyA9IG1bMl1bM10sIGEzMCA9IG1bM11bMF0sIGEzMSA9IG1bM11bMV0sIGEzMiA9IG1bM11bMl0sIGEzMyA9IG1bM11bM10sIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCwgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSwgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCwgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSwgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcXG4gIHJldHVybiBtYXQ0KGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSwgYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5LCBhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMsIGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMywgYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3LCBhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcsIGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSwgYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxLCBhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYsIGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNiwgYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwLCBhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDAsIGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNiwgYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2LCBhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDAsIGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgLyBkZXQ7XFxufVxcbmZsb2F0IGNfeF90cmFuc3Bvc2UoZmxvYXQgbSkge1xcbiAgcmV0dXJuIG07XFxufVxcbm1hdDIgY194X3RyYW5zcG9zZShtYXQyIG0pIHtcXG4gIHJldHVybiBtYXQyKG1bMF1bMF0sIG1bMV1bMF0sIG1bMF1bMV0sIG1bMV1bMV0pO1xcbn1cXG5tYXQzIGNfeF90cmFuc3Bvc2UobWF0MyBtKSB7XFxuICByZXR1cm4gbWF0MyhtWzBdWzBdLCBtWzFdWzBdLCBtWzJdWzBdLCBtWzBdWzFdLCBtWzFdWzFdLCBtWzJdWzFdLCBtWzBdWzJdLCBtWzFdWzJdLCBtWzJdWzJdKTtcXG59XFxubWF0NCBjX3hfdHJhbnNwb3NlKG1hdDQgbSkge1xcbiAgcmV0dXJuIG1hdDQobVswXVswXSwgbVsxXVswXSwgbVsyXVswXSwgbVszXVswXSwgbVswXVsxXSwgbVsxXVsxXSwgbVsyXVsxXSwgbVszXVsxXSwgbVswXVsyXSwgbVsxXVsyXSwgbVsyXVsyXSwgbVszXVsyXSwgbVswXVszXSwgbVsxXVszXSwgbVsyXVszXSwgbVszXVszXSk7XFxufVxcbnZlYzQgYXBwbHlUcmFuc2Zvcm0odmVjNCBwb3MpIHtcXG4gIG1hdDQgTVZNYXRyaXggPSB1X3ZpZXcgKiB1X3RyYW5zZm9ybTtcXG4gIHBvcy54ICs9IDEuMDtcXG4gIHBvcy55IC09IDEuMDtcXG4gIHBvcy54eXogKj0gdV9zaXplICogMC41O1xcbiAgcG9zLnkgKj0gLTEuMDtcXG4gIHZfcG9zaXRpb24gPSAoTVZNYXRyaXggKiBwb3MpLnh5ejtcXG4gIHZfZXllVmVjdG9yID0gKHVfcmVzb2x1dGlvbiAqIDAuNSkgLSB2X3Bvc2l0aW9uO1xcbiAgcG9zID0gdV9wZXJzcGVjdGl2ZSAqIE1WTWF0cml4ICogcG9zO1xcbiAgcmV0dXJuIHBvcztcXG59XFxuI3ZlcnRfZGVmaW5pdGlvbnNcXG5cXG52ZWMzIGNhbGN1bGF0ZU9mZnNldCh2ZWMzIElEKSB7XFxuICBcXG4gICN2ZXJ0X2FwcGxpY2F0aW9uc1xcbiAgcmV0dXJuIHZlYzMoMC4wKTtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdl90ZXh0dXJlQ29vcmRpbmF0ZSA9IGFfdGV4Q29vcmQ7XFxuICB2ZWMzIGludmVydGVkTm9ybWFscyA9IGFfbm9ybWFscyArICh1X25vcm1hbHMueCA8IDAuMCA/IGNhbGN1bGF0ZU9mZnNldCh1X25vcm1hbHMpICogMi4wIC0gMS4wIDogdmVjMygwLjApKTtcXG4gIGludmVydGVkTm9ybWFscy55ICo9IC0xLjA7XFxuICB2X25vcm1hbCA9IGNfeF90cmFuc3Bvc2UobWF0MyhiX3hfaW52ZXJzZSh1X3RyYW5zZm9ybSkpKSAqIGludmVydGVkTm9ybWFscztcXG4gIHZlYzMgb2Zmc2V0UG9zID0gYV9wb3MgKyBjYWxjdWxhdGVPZmZzZXQodV9wb3NpdGlvbk9mZnNldCk7XFxuICBnbF9Qb3NpdGlvbiA9IGFwcGx5VHJhbnNmb3JtKHZlYzQob2Zmc2V0UG9zLCAxLjApKTtcXG59XCIsIFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4jZmxvYXRfZGVmaW5pdGlvbnNcXG5cXG5mbG9hdCBhX3hfYXBwbHlNYXRlcmlhbChmbG9hdCBJRCkge1xcbiAgXFxuICAjZmxvYXRfYXBwbGljYXRpb25zXFxuICByZXR1cm4gMS47XFxufVxcbiN2ZWMzX2RlZmluaXRpb25zXFxuXFxudmVjMyBhX3hfYXBwbHlNYXRlcmlhbCh2ZWMzIElEKSB7XFxuICBcXG4gICN2ZWMzX2FwcGxpY2F0aW9uc1xcbiAgcmV0dXJuIHZlYzMoMCk7XFxufVxcbiN2ZWM0X2RlZmluaXRpb25zXFxuXFxudmVjNCBhX3hfYXBwbHlNYXRlcmlhbCh2ZWM0IElEKSB7XFxuICBcXG4gICN2ZWM0X2FwcGxpY2F0aW9uc1xcbiAgcmV0dXJuIHZlYzQoMCk7XFxufVxcbnZlYzQgYl94X2FwcGx5TGlnaHQoaW4gdmVjNCBiYXNlQ29sb3IsIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWM0IGdsb3NzaW5lc3MpIHtcXG4gIGludCBudW1MaWdodHMgPSBpbnQodV9udW1MaWdodHMpO1xcbiAgdmVjMyBhbWJpZW50Q29sb3IgPSB1X2FtYmllbnRMaWdodCAqIGJhc2VDb2xvci5yZ2I7XFxuICB2ZWMzIGV5ZVZlY3RvciA9IG5vcm1hbGl6ZSh2X2V5ZVZlY3Rvcik7XFxuICB2ZWMzIGRpZmZ1c2UgPSB2ZWMzKDAuMCk7XFxuICBib29sIGhhc0dsb3NzaW5lc3MgPSBnbG9zc2luZXNzLmEgPiAwLjA7XFxuICBib29sIGhhc1NwZWN1bGFyQ29sb3IgPSBsZW5ndGgoZ2xvc3NpbmVzcy5yZ2IpID4gMC4wO1xcbiAgZm9yKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xcbiAgICBpZihpID49IG51bUxpZ2h0cylcXG4gICAgICBicmVhaztcXG4gICAgdmVjMyBsaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZSh1X2xpZ2h0UG9zaXRpb25baV0ueHl6IC0gdl9wb3NpdGlvbik7XFxuICAgIGZsb2F0IGxhbWJlcnRpYW4gPSBtYXgoZG90KGxpZ2h0RGlyZWN0aW9uLCBub3JtYWwpLCAwLjApO1xcbiAgICBpZihsYW1iZXJ0aWFuID4gMC4wKSB7XFxuICAgICAgZGlmZnVzZSArPSB1X2xpZ2h0Q29sb3JbaV0ucmdiICogYmFzZUNvbG9yLnJnYiAqIGxhbWJlcnRpYW47XFxuICAgICAgaWYoaGFzR2xvc3NpbmVzcykge1xcbiAgICAgICAgdmVjMyBoYWxmVmVjdG9yID0gbm9ybWFsaXplKGxpZ2h0RGlyZWN0aW9uICsgZXllVmVjdG9yKTtcXG4gICAgICAgIGZsb2F0IHNwZWN1bGFyV2VpZ2h0ID0gcG93KG1heChkb3QoaGFsZlZlY3Rvciwgbm9ybWFsKSwgMC4wKSwgZ2xvc3NpbmVzcy5hKTtcXG4gICAgICAgIHZlYzMgc3BlY3VsYXJDb2xvciA9IGhhc1NwZWN1bGFyQ29sb3IgPyBnbG9zc2luZXNzLnJnYiA6IHVfbGlnaHRDb2xvcltpXS5yZ2I7XFxuICAgICAgICBkaWZmdXNlICs9IHNwZWN1bGFyQ29sb3IgKiBzcGVjdWxhcldlaWdodCAqIGxhbWJlcnRpYW47XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdmVjNChhbWJpZW50Q29sb3IgKyBkaWZmdXNlLCBiYXNlQ29sb3IuYSk7XFxufVxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgbWF0ZXJpYWwgPSB1X2Jhc2VDb2xvci5yID49IDAuMCA/IHVfYmFzZUNvbG9yIDogYV94X2FwcGx5TWF0ZXJpYWwodV9iYXNlQ29sb3IpO1xcbiAgYm9vbCBsaWdodHNFbmFibGVkID0gKHVfZmxhdFNoYWRpbmcgPT0gMC4wKSAmJiAodV9udW1MaWdodHMgPiAwLjAgfHwgbGVuZ3RoKHVfYW1iaWVudExpZ2h0KSA+IDAuMCk7XFxuICB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSh2X25vcm1hbCk7XFxuICB2ZWM0IGdsb3NzaW5lc3MgPSB1X2dsb3NzaW5lc3MueCA8IDAuMCA/IGFfeF9hcHBseU1hdGVyaWFsKHVfZ2xvc3NpbmVzcykgOiB1X2dsb3NzaW5lc3M7XFxuICB2ZWM0IGNvbG9yID0gbGlnaHRzRW5hYmxlZCA/IGJfeF9hcHBseUxpZ2h0KG1hdGVyaWFsLCBub3JtYWxpemUodl9ub3JtYWwpLCBnbG9zc2luZXNzKSA6IG1hdGVyaWFsO1xcbiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuICBnbF9GcmFnQ29sb3IuYSAqPSB1X29wYWNpdHk7XFxufVwiLCBbXSwgW10pO1xubW9kdWxlLmV4cG9ydHMgPSBzaGFkZXJzOyIsIid1c2Ugc3RyaWN0JztcbmxldCBmYW1vdXMgPSByZXF1aXJlKCdmYW1vdXMnKTtcblxuZmFtb3VzLmRvbVJlbmRlcmVycyA9IHJlcXVpcmUoJ2ZhbW91cy9kb20tcmVuZGVyZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFtb3VzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG53aW5kb3cuRmFtb3VzUGxhdGZvcm0gPSByZXF1aXJlKCdmYW1vdXMtY3JlYXRpdmUvc2NhZmZvbGRpbmcvRmFtb3VzUGxhdGZvcm0nKTtcbiJdfQ==
